/home/ec2-user/git/cover/contracts/CoverEchidnaPool.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './CoverPoolFactory.sol';
   5 |     | import './utils/CoverPoolManager.sol';
   6 |     | import './test/Token20.sol';
   7 |     | import './utils/PositionERC1155.sol';
   8 |     | import './interfaces/structs/CoverPoolStructs.sol';
   9 |     | import './libraries/math/ConstantProduct.sol';
  10 |     | import './libraries/pool/MintCall.sol';
  11 |     | import './libraries/pool/BurnCall.sol';
  12 |     | import './test/UniswapV3FactoryMock.sol';
  13 |     | import './libraries/sources/UniswapV3Source.sol';
  14 |     | 
  15 |     | //TODO: make sure no assertions fail
  16 |     | //TODO: add the ability to change the TWAP randomly
  17 |     | 
  18 |     | // Fuzz CoverPool functionality
  19 | *r  | contract CoverEchidnaPool {
  20 |     | 
  21 |     |     event PassedMint();
  22 |     |     event PassedBurn();
  23 |     |     event Prices(uint160 price0, uint160 price1);
  24 |     |     event LiquidityGlobal(uint128 liqBefore, uint128 liqAfter);
  25 |     |     event Liquidity(uint128 liq0Before, uint128 liq1Before, uint128 liq0After, uint128 liq1After);
  26 |     |     event PositionTicks(int24 lower, int24 upper);
  27 |     |     event BurnTicks(int24 lower, int24 upper, bool positionExists);
  28 |     |     event LiquidityMinted(uint256 amount, uint256 tokenAmount, bool zeroForOne);
  29 |     |     event PositionCreated(bool isCreated);
  30 |     |     event AmountInDeltaMaxMinus(uint128 beforeDelta, uint128 afterDelta);
  31 |     |     event AmountOutDeltaMaxMinus(uint128 beforeDelta, uint128 afterDelta);
  32 |     |     event LiquidityDeltaAndDeltaMaxMinus(int128 delta, uint128 abs);
  33 |     |     event Deployed(address contractAddress);
  34 |     | 
  35 | *   |     int16 private constant tickSpread = 20;
  36 | *   |     int16 private constant MAX_TICK_JUMP = 200; // i.e. 10 * tickSpread
  37 | *   |     int24 private constant MAX_TICK = 887260;
  38 | *   |     int24 private constant MIN_TICK = -MAX_TICK;
  39 |     |     address private immutable poolImpl;
  40 |     |     address private immutable tokenImpl;
  41 |     |     address private immutable poolMock;
  42 |     |     address private immutable poolFactoryMock;
  43 |     |     address private immutable twapSource;
  44 |     |     CoverPoolFactory private immutable factory;
  45 |     |     CoverPoolManager private immutable manager;
  46 |     |     CoverPool private immutable pool;
  47 |     |     PositionERC1155 private immutable token;
  48 |     |     Token20 private immutable token0;
  49 |     |     Token20 private immutable token1;
  50 |     |     Token20 private immutable tokenIn;
  51 |     |     Token20 private immutable tokenOut;
  52 |     |     Position[] private positions;
  53 |     | 
  54 |     |     struct LiquidityDeltaValues {
  55 |     |         int128 liquidityDeltaLowerBefore;
  56 |     |         int128 liquidityDeltaUpperBefore;
  57 |     |         int128 liquidityDeltaLowerAfter;
  58 |     |         int128 liquidityDeltaUpperAfter;
  59 |     |     }
  60 |     | 
  61 |     |     struct PoolValues {
  62 |     |         uint160 price0Before;
  63 |     |         uint128 liquidity0Before;
  64 |     |         uint160 price1Before;
  65 |     |         uint128 liquidity1Before;
  66 |     |         uint160 price0After;
  67 |     |         uint128 liquidity0After;
  68 |     |         uint160 price1After;
  69 |     |         uint128 liquidity1After;
  70 |     | 
  71 |     |         uint128 liquidityGlobalBefore;
  72 |     |         uint128 liquidityGlobalAfter;
  73 |     | 
  74 |     |         int24 latestTickBefore;
  75 |     |         int24 latestTickAfter;
  76 |     | 
  77 |     |         // CoverPoolStructs.PoolState pool0Before;
  78 |     |         // CoverPoolStructs.PoolState pool1Before;
  79 |     |         // CoverPoolStructs.GlobalState stateBefore;
  80 |     |         // CoverPoolStructs.GlobalState stateAfter;
  81 |     | 
  82 |     |         // CoverPoolStructs.Tick tickLowerBefore;
  83 |     |         // CoverPoolStructs.Tick tickUpperBefore;
  84 |     |         // CoverPoolStructs.Tick tickLowerAfter;
  85 |     |         // CoverPoolStructs.Tick tickUpperAfter;
  86 |     | 
  87 |     |         uint128 amountInDeltaMaxMinusUpperBefore;
  88 |     |         uint128 amountInDeltaMaxMinusLowerBefore;
  89 |     |         uint128 amountInDeltaMaxMinusUpperAfter;
  90 |     |         uint128 amountInDeltaMaxMinusLowerAfter;
  91 |     | 
  92 |     |         uint128 amountOutDeltaMaxMinusUpperBefore;
  93 |     |         uint128 amountOutDeltaMaxMinusLowerBefore;
  94 |     |         uint128 amountOutDeltaMaxMinusUpperAfter;
  95 |     |         uint128 amountOutDeltaMaxMinusLowerAfter;
  96 |     | 
  97 |     |         uint160 price0;
  98 |     |         uint160 price1;
  99 |     | 
 100 |     |         uint32 positionIdNextBefore;
 101 |     |         uint32 positionIdNextAfter;
 102 |     |     }
 103 |     | 
 104 |     |     struct SwapCallbackData {
 105 |     |         address sender;
 106 |     |     }
 107 |     | 
 108 |     |     struct Position {
 109 |     |         address owner;
 110 |     |         uint32 positionId;
 111 |     |         int24 lower;
 112 |     |         int24 upper;
 113 |     |         bool zeroForOne;
 114 |     |     }
 115 |     | 
 116 |     |     struct PoolStructs {
 117 |     |         CoverPoolStructs.Tick lower;
 118 |     |         CoverPoolStructs.Tick upper;
 119 |     |         CoverPoolStructs.PoolState pool0;
 120 |     |         CoverPoolStructs.PoolState pool1;
 121 |     |         CoverPoolStructs.GlobalState state;
 122 |     |         PoolsharkStructs.CoverImmutables constants;
 123 |     |     }
 124 |     | 
 125 |     |     modifier tickPreconditions(int24 lower, int24 upper) {
 126 | *r  |         require(lower < upper);
 127 | *r  |         require(upper <= MAX_TICK);
 128 | *r  |         require(lower >= MIN_TICK);
 129 | *r  |         require(lower % tickSpread == 0);
 130 | *r  |         require(upper % tickSpread == 0);
 131 |     |         _;
 132 |     |     }
 133 |     | 
 134 |     |     constructor() {
 135 |     |         manager = new CoverPoolManager();
 136 |     |         factory = new CoverPoolFactory(address(manager));
 137 |     |         poolImpl = address(new CoverPool(address(factory)));
 138 |     |         tokenImpl = address(new PositionERC1155(address(factory)));
 139 |     |         tokenIn = new Token20("IN", "IN", 18);
 140 |     |         tokenOut = new Token20("OUT", "OUT", 18);
 141 |     |         (token0, token1) = address(tokenIn) < address(tokenOut) ? (tokenIn, tokenOut) 
 142 |     |                                                                 : (tokenOut, tokenIn);
 143 |     | 
 144 |     |         // mock sources
 145 |     |         poolFactoryMock = address(new UniswapV3FactoryMock(address(tokenIn), address(tokenOut)));
 146 |     |         twapSource = address(new UniswapV3Source(poolFactoryMock));
 147 |     | 
 148 |     |         poolMock = UniswapV3FactoryMock(poolFactoryMock).getPool(address(token0), address(token1), 500);
 149 |     |         emit Deployed(UniswapV3FactoryMock(poolFactoryMock).getPool(address(token0), address(token1), 500));
 150 |     |         UniswapV3PoolMock(poolMock).setObservationCardinality(5, 5);
 151 |     | 
 152 |     |         CoverPoolStructs.VolatilityTier memory volTier = CoverPoolStructs.VolatilityTier({
 153 |     |             minAmountPerAuction: 0,
 154 |     |             auctionLength: 5,
 155 |     |             blockTime: 1000,
 156 |     |             syncFee: 0,
 157 |     |             fillFee: 0,
 158 |     |             minPositionWidth: 1,
 159 |     |             minAmountLowerPriced: true
 160 |     |         });
 161 |     |         
 162 |     |         // add pool type
 163 |     |         manager.enablePoolType(bytes32(uint256(0x1)), poolImpl, tokenImpl, twapSource);
 164 |     |         manager.enableVolatilityTier(bytes32(uint256(0x1)), 500, 20, 5, volTier);
 165 |     |         ICoverPoolFactory.CoverPoolParams memory params;
 166 |     |         params.poolType = bytes32(uint256(0x1));
 167 |     |         params.tokenIn = address(tokenIn);
 168 |     |         params.tokenOut = address(tokenOut);
 169 |     |         params.feeTier = 500;
 170 |     |         params.tickSpread = 20;
 171 |     |         params.twapLength = 5;
 172 |     | 
 173 |     |         // launch pool
 174 |     |         address poolAddr; address poolToken;
 175 |     |         (poolAddr, poolToken) = factory.createCoverPool(params);
 176 |     |         pool = CoverPool(poolAddr);
 177 |     |         token = PositionERC1155(poolToken);
 178 |     |     }
 179 |     | 
 180 | *   |     function mint(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {
 181 |     |         // PRE CONDITIONS
 182 | *   |         mintAndApprove();
 183 | *   |         amount = amount + 1;
 184 |     |         
 185 |     |         // Ensure the newly created position is using different ticks
 186 | *   |         for(uint i = 0; i < positions.length;) {
 187 |     |             if(positions[i].owner == msg.sender && positions[i].lower == lower && positions[i].upper == upper && positions[i].zeroForOne == zeroForOne) {
 188 |     |                 revert("Position already exists");
 189 |     |             }
 190 |     |             unchecked {
 191 |     |                 ++i;
 192 |     |             }
 193 |     |         }
 194 |     | 
 195 | *   |         PoolValues memory poolValues;
 196 | *   |         PoolStructs memory poolStructs;
 197 | *   |         LiquidityDeltaValues memory values;
 198 |     |         
 199 |     |         // storage structs
 200 | *   |         poolStructs.pool0 = getPoolState(true);
 201 | *   |         poolStructs.pool1 = getPoolState(false);
 202 | *   |         poolStructs.state = getGlobalState();
 203 | *   |         poolStructs.lower = getTick(lower);
 204 | *   |         poolStructs.upper = getTick(upper);
 205 |     | 
 206 |     |         // pool price and liquidity
 207 | *   |         poolValues.price0Before = poolStructs.pool0.price;
 208 | *   |         poolValues.liquidity0Before = poolStructs.pool0.liquidity;
 209 | *   |         poolValues.price1Before = poolStructs.pool1.price;
 210 | *   |         poolValues.liquidity1Before = poolStructs.pool1.liquidity;
 211 | *   |         poolValues.liquidityGlobalBefore = poolStructs.state.liquidityGlobal;
 212 |     | 
 213 |     |         // tick values
 214 | *   |         values.liquidityDeltaLowerBefore = poolStructs.lower.liquidityDelta;
 215 | *   |         values.liquidityDeltaUpperBefore = poolStructs.upper.liquidityDelta;
 216 | *   |         poolValues.amountInDeltaMaxMinusLowerBefore = poolStructs.lower.amountInDeltaMaxMinus;
 217 | *   |         poolValues.amountInDeltaMaxMinusUpperBefore = poolStructs.upper.amountInDeltaMaxMinus;
 218 | *   |         poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;
 219 | *   |         poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;
 220 |     | 
 221 | *   |         ICoverPool.MintParams memory params;
 222 | *   |         params.to = msg.sender;
 223 | *   |         params.amount = amount;
 224 | *   |         params.positionId = 0;
 225 | *   |         params.lower = lower;
 226 | *   |         params.upper = upper;
 227 | *   |         params.zeroForOne = zeroForOne;
 228 |     | 
 229 |     |         // Get the ticks the position will be minted with rather than what was passed directly by fuzzer
 230 |     |         // This is so the we can properly compare before and after mint states of particular ticks.
 231 | *   |         bool posCreated;
 232 | *   |         (lower, upper, posCreated) = pool.getResizedTicksForMint(params);
 233 |     |         //TODO: amount can change as well here so we should change this functionality or account for the change
 234 | *   |         emit PositionTicks(lower, upper);
 235 | *   |         emit PositionCreated(posCreated);
 236 |     | 
 237 |     |         // ACTION 
 238 | *r  |         pool.mint(params);
 239 | *   |         if (posCreated) positions.push(Position(msg.sender, poolValues.positionIdNextBefore, lower, upper, zeroForOne));
 240 |     | 
 241 |     |         // storage structs
 242 | *   |         poolStructs.pool0 = getPoolState(true);
 243 | *   |         poolStructs.pool1 = getPoolState(false);
 244 | *   |         poolStructs.state = getGlobalState();
 245 | *   |         poolStructs.lower = getTick(lower);
 246 | *   |         poolStructs.upper = getTick(upper);
 247 |     | 
 248 |     |         // pool price and liquidity
 249 | *   |         poolValues.price0After = poolStructs.pool0.price;
 250 | *   |         poolValues.liquidity0After = poolStructs.pool0.liquidity;
 251 | *   |         poolValues.price1After = poolStructs.pool1.price;
 252 | *   |         poolValues.liquidity1After = poolStructs.pool1.liquidity;
 253 | *   |         poolValues.liquidityGlobalAfter = poolStructs.state.liquidityGlobal;
 254 |     | 
 255 |     |         // lower tick
 256 | *   |         values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;
 257 | *   |         poolValues.amountInDeltaMaxMinusLowerAfter = poolStructs.lower.amountInDeltaMaxMinus;
 258 | *   |         poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;
 259 |     | 
 260 |     |         // upper tick
 261 | *   |         values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;
 262 | *   |         poolValues.amountInDeltaMaxMinusUpperAfter = poolStructs.upper.amountInDeltaMaxMinus;
 263 | *   |         poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;
 264 |     |         
 265 |     |         // POST CONDITIONS
 266 |     | 
 267 |     |         // Ensure prices have not crossed
 268 | *   |         emit Prices(poolValues.price0After, poolValues.price1After);
 269 | *   |         assert(poolValues.price0After <= poolValues.price1After);
 270 |     |         
 271 |     |         // Ensure that amountOutDeltaMaxMinus is incremented when not undercutting
 272 | *   |         if (posCreated) {
 273 |     |             emit PositionTicks(lower, upper);
 274 |     |             // Ensure positions ticks arent crossed
 275 |     |             assert(lower < upper);
 276 |     |             // Ensure minted ticks on proper tick spacing
 277 |     |             assert((lower % tickSpread == 0) && (upper % tickSpread == 0));
 278 |     | 
 279 |     |             // check delta maxes
 280 |     |             if(zeroForOne){
 281 |     |                 emit AmountInDeltaMaxMinus(poolValues.amountInDeltaMaxMinusLowerBefore, poolValues.amountInDeltaMaxMinusLowerAfter);
 282 |     |                 assert(poolValues.amountInDeltaMaxMinusLowerAfter > poolValues.amountInDeltaMaxMinusLowerBefore);
 283 |     |                 emit AmountOutDeltaMaxMinus(poolValues.amountOutDeltaMaxMinusLowerBefore, poolValues.amountOutDeltaMaxMinusLowerAfter);
 284 |     |                 assert(poolValues.amountOutDeltaMaxMinusLowerAfter > poolValues.amountOutDeltaMaxMinusLowerBefore);
 285 |     |             } else {
 286 |     |                 emit AmountInDeltaMaxMinus(poolValues.amountInDeltaMaxMinusUpperBefore, poolValues.amountInDeltaMaxMinusUpperAfter);
 287 |     |                 assert(poolValues.amountInDeltaMaxMinusUpperAfter > poolValues.amountInDeltaMaxMinusUpperBefore);
 288 |     |                 emit AmountOutDeltaMaxMinus(poolValues.amountOutDeltaMaxMinusUpperBefore, poolValues.amountOutDeltaMaxMinusUpperAfter);
 289 |     |                 assert(poolValues.amountOutDeltaMaxMinusUpperAfter > poolValues.amountOutDeltaMaxMinusUpperBefore);
 290 |     |             }
 291 |     |             emit LiquidityGlobal(poolValues.liquidityGlobalBefore, poolValues.liquidityGlobalAfter);
 292 |     |             //emit Liquidity(poolValues.liquidity0Before, poolValues.liquidity1Before, poolValues.liquidity0After, poolValues.liquidity1After);
 293 |     |             // Ensure liquidityGlobal is incremented after mint
 294 |     |             assert(poolValues.liquidityGlobalAfter > poolValues.liquidityGlobalBefore);
 295 |     |         }
 296 |     |         // Ensure pool liquidity is non-zero after mint with no undercuts
 297 |     |         // if (zeroForOne) {
 298 |     |         //     if (poolValues.price0After < poolValues.price0Before) assert(poolValues.liquidity0After > 0);
 299 |     |         // }
 300 |     |         // else {
 301 |     |         //     if (poolValues.price1After > poolValues.price1Before) assert(poolValues.liquidity1After > 0);
 302 |     |         // }
 303 |     |     }
 304 |     | 
 305 | *   |     function mintVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {
 306 |     |         // PRE CONDITIONS
 307 |     |         // check if it's going to sync beforehand
 308 | *   |         mintAndApprove();
 309 | *   |         amount = amount + 1;
 310 |     |         // Ensure the newly created position is using different ticks
 311 | *   |         for(uint i = 0; i < positions.length;) {
 312 |     |             if(positions[i].owner == msg.sender && positions[i].lower == lower && positions[i].upper == upper && positions[i].zeroForOne == zeroForOne) {
 313 |     |                 revert("Position already exists");
 314 |     |             }
 315 |     |             unchecked {
 316 |     |                 ++i;
 317 |     |             }
 318 |     |         }
 319 |     | 
 320 | *   |         PoolValues memory poolValues;
 321 | *   |         PoolStructs memory poolStructs;
 322 | *   |         LiquidityDeltaValues memory values;
 323 |     | 
 324 |     |         // storage structs
 325 | *   |         poolStructs.pool0 = getPoolState(true);
 326 | *   |         poolStructs.pool1 = getPoolState(false);
 327 | *   |         poolStructs.state = getGlobalState();
 328 | *   |         poolStructs.lower = getTick(lower);
 329 | *   |         poolStructs.upper = getTick(upper);
 330 |     | 
 331 |     |         // pool price and liquidity
 332 | *   |         poolValues.price0Before = poolStructs.pool0.price;
 333 | *   |         poolValues.liquidity0Before = poolStructs.pool0.liquidity;
 334 | *   |         poolValues.price1Before = poolStructs.pool1.price;
 335 | *   |         poolValues.liquidity1Before = poolStructs.pool1.liquidity;
 336 | *   |         poolValues.liquidityGlobalBefore = poolStructs.state.liquidityGlobal;
 337 |     | 
 338 |     |         // tick values
 339 | *   |         values.liquidityDeltaLowerBefore = poolStructs.lower.liquidityDelta;
 340 | *   |         values.liquidityDeltaUpperBefore = poolStructs.upper.liquidityDelta;
 341 | *   |         poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;
 342 | *   |         poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;
 343 |     | 
 344 | *   |         ICoverPool.MintParams memory params;
 345 | *   |         params.to = msg.sender;
 346 | *   |         params.amount = amount;
 347 | *   |         params.lower = lower;
 348 | *   |         params.upper = upper;
 349 | *   |         params.zeroForOne = zeroForOne;
 350 |     | 
 351 |     |         // Get the ticks the position will be minted with rather than what was passed directly by fuzzer
 352 |     |         // This is so the we can properly compare before and after mint states of particular ticks.
 353 | *   |         bool posCreated;
 354 | *   |         (lower, upper, posCreated) = pool.getResizedTicksForMint(params);
 355 | *   |         emit PositionTicks(lower, upper);
 356 | *   |         emit PositionCreated(posCreated);
 357 |     | 
 358 |     |         // ACTION 
 359 | *r  |         pool.mint(params);
 360 | *   |         if (posCreated) positions.push(Position(msg.sender, poolValues.positionIdNextBefore, lower, upper, zeroForOne));
 361 |     | 
 362 |     |         // pool price and liquidity
 363 | *   |         poolValues.price0After = poolStructs.pool0.price;
 364 | *   |         poolValues.liquidity0After = poolStructs.pool0.liquidity;
 365 | *   |         poolValues.price1After = poolStructs.pool1.price;
 366 | *   |         poolValues.liquidity1After = poolStructs.pool1.liquidity;
 367 | *   |         poolValues.liquidityGlobalAfter = poolStructs.state.liquidityGlobal;
 368 |     | 
 369 |     |         // tick values
 370 | *   |         values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;
 371 | *   |         values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;
 372 | *   |         poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;
 373 | *   |         poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;
 374 |     | 
 375 |     |         // POST CONDITIONS
 376 |     | 
 377 |     |         // Ensure prices have not crossed
 378 | *   |         emit Prices(poolValues.price0After, poolValues.price1After);
 379 | *   |         assert(poolValues.price0After <= poolValues.price1After);
 380 |     | 
 381 |     |         // Ensure liquidityDelta is always less or equal to amountOutDeltaMaxMinus
 382 | *   |         if(zeroForOne){
 383 | *   |             emit AmountInDeltaMaxMinus(poolValues.amountOutDeltaMaxMinusLowerBefore, poolValues.amountOutDeltaMaxMinusLowerAfter);
 384 | *   |             assert(poolValues.amountOutDeltaMaxMinusLowerAfter >= poolValues.amountOutDeltaMaxMinusLowerBefore);
 385 | *   |             emit AmountOutDeltaMaxMinus(poolValues.amountOutDeltaMaxMinusLowerBefore, poolValues.amountOutDeltaMaxMinusLowerAfter);
 386 | *   |             assert(poolValues.amountOutDeltaMaxMinusLowerAfter >= poolValues.amountOutDeltaMaxMinusLowerBefore);
 387 |     |         } else {
 388 | *   |             emit AmountInDeltaMaxMinus(poolValues.amountOutDeltaMaxMinusUpperBefore, poolValues.amountOutDeltaMaxMinusUpperAfter);
 389 | *   |             assert(poolValues.amountOutDeltaMaxMinusUpperAfter >= poolValues.amountOutDeltaMaxMinusUpperBefore);
 390 | *   |             emit AmountOutDeltaMaxMinus(poolValues.amountOutDeltaMaxMinusUpperBefore, poolValues.amountOutDeltaMaxMinusUpperAfter);
 391 | *   |             assert(poolValues.amountOutDeltaMaxMinusUpperAfter >= poolValues.amountOutDeltaMaxMinusUpperBefore);
 392 |     |         }
 393 |     | 
 394 | *   |         if (posCreated) {
 395 |     |             emit PositionTicks(lower, upper);
 396 |     |             // Ensure positions ticks arent crossed
 397 |     |             assert(lower < upper);
 398 |     |             // Ensure minted ticks on proper tick spacing
 399 |     |             assert((lower % tickSpread == 0) && (upper % tickSpread == 0));
 400 |     |         }
 401 |     |         
 402 | *   |         emit LiquidityGlobal(poolValues.liquidityGlobalBefore, poolValues.liquidityGlobalAfter);
 403 | *   |         emit Liquidity(poolValues.liquidity0Before, poolValues.liquidity1Before, poolValues.liquidity0After, poolValues.liquidity1After);
 404 |     |         
 405 |     |         // Ensure liquidityGlobal is incremented after mint
 406 | *   |         assert(poolValues.liquidityGlobalAfter >= poolValues.liquidityGlobalBefore);
 407 |     | 
 408 |     |         // Ensure pool liquidity is non-zero after mint with no undercuts
 409 |     |         // if (zeroForOne) {
 410 |     |         //     if (poolValues.price0After < poolValues.price0Before) assert(poolValues.liquidity0After > 0);
 411 |     |         // }
 412 |     |         // else {
 413 |     |         //     if (poolValues.price1After > poolValues.price1Before) assert(poolValues.liquidity1After > 0);
 414 |     |         // }
 415 |     |     }
 416 |     | 
 417 | *   |     function swap(uint160 priceLimit, uint128 amount, bool zeroForOne) public {
 418 |     |         // PRE CONDITIONS
 419 | *   |         mintAndApprove();
 420 |     | 
 421 | *   |         CoverPoolStructs.SwapParams memory params;
 422 | *   |         params.to = msg.sender;
 423 | *   |         params.priceLimit = priceLimit;
 424 | *   |         params.amount = amount;
 425 | *   |         params.exactIn = true; // TODO: exactIn always true for now
 426 | *   |         params.zeroForOne = zeroForOne;
 427 | *   |         params.callbackData = abi.encodePacked(address(this));
 428 |     |         
 429 |     |         // ACTION
 430 | *r  |         pool.swap(params);
 431 |     | 
 432 |     |         // POST CONDITIONS
 433 | *   |         CoverPoolStructs.PoolState memory pool0 = getPoolState(true);
 434 | *   |         CoverPoolStructs.PoolState memory pool1 = getPoolState(false);
 435 | *   |         uint160 price0 = pool0.price;
 436 | *   |         uint160 price1 = pool1.price;
 437 |     |         
 438 |     |         // Ensure prices never cross
 439 | *   |         emit Prices(price0, price1);
 440 | *   |         assert(price0 <= price1);
 441 |     |     }
 442 |     | 
 443 | *   |     function syncTick(int24 newLatestTick, bool autoSync) public  {
 444 | *   |         PoolStructs memory poolStructs;
 445 | *   |         poolStructs.state = getGlobalState();
 446 | *   |         poolStructs.constants = pool.immutables();
 447 |     | 
 448 |     |         // gate tick jump
 449 | *   |         if (newLatestTick < poolStructs.state.latestTick - MAX_TICK_JUMP)
 450 | *   |             newLatestTick = poolStructs.state.latestTick - MAX_TICK_JUMP;
 451 | *   |         else if (newLatestTick > poolStructs.state.latestTick + MAX_TICK_JUMP)
 452 | *   |             newLatestTick = poolStructs.state.latestTick + MAX_TICK_JUMP;
 453 |     | 
 454 | *   |         UniswapV3PoolMock(poolMock).setTickCumulatives(
 455 | *   |             newLatestTick * 10,
 456 | *   |             newLatestTick * 8,
 457 | *   |             newLatestTick * 7,
 458 | *   |             newLatestTick * 5
 459 |     |         );
 460 |     | 
 461 | *   |         if (autoSync) {
 462 |     |             // quote of 0 should start at new tick
 463 |     |             //TODO: find new latest tick based on auction depth
 464 | *   |             CoverPoolStructs.SwapParams memory params;
 465 | *   |             params.to = msg.sender;
 466 | *   |             params.priceLimit = 0;
 467 | *   |             params.amount = 0;
 468 | *   |             params.exactIn = true;
 469 | *   |             params.zeroForOne = true;
 470 | *   |             params.callbackData = abi.encodePacked(address(this));
 471 |     |         
 472 |     |             // ACTION
 473 | *   |             pool.swap(params);
 474 |     | 
 475 |     |             // POST CONDITIONS
 476 |     |             //TODO: find new latest tick based on auction depth
 477 |     |             //new latestTick should match
 478 |     |             //if there was liquidity delta on that tick it should be unlocked
 479 |     |             //amountInDelta should be zeroed out if tick moved
 480 | *   |             poolStructs.pool0 = getPoolState(true);
 481 | *   |             poolStructs.pool1 = getPoolState(false);
 482 | *   |             poolStructs.state = getGlobalState();
 483 | *   |             emit Prices(poolStructs.pool0.price, poolStructs.pool1.price);
 484 | *   |             assert(poolStructs.pool0.price <= poolStructs.pool1.price);
 485 |     |         }
 486 |     |     }
 487 |     | 
 488 | *   |     function burn(int24 claimAt, uint256 positionIndex, uint128 burnPercent) public {
 489 |     |         // PRE CONDITIONS
 490 | *   |         positionIndex = positionIndex % positions.length;
 491 |     |         Position memory pos = positions[positionIndex];
 492 |     |         require(claimAt >= pos.lower && claimAt <= pos.upper);
 493 |     |         require(claimAt % tickSpread == 0);
 494 |     |         PoolStructs memory poolStructs;
 495 |     |         PoolValues memory poolValues;
 496 |     | 
 497 |     |         poolStructs.pool0 = getPoolState(true);
 498 |     |         poolStructs.pool1 = getPoolState(false);
 499 |     |         poolStructs.state = getGlobalState();
 500 |     |         poolStructs.lower = getTick(pos.lower);
 501 |     |         poolStructs.upper = getTick(pos.upper);
 502 |     | 
 503 |     |         ICoverPool.BurnParams memory params;
 504 |     |         params.to = pos.owner;
 505 |     |         params.burnPercent = burnPercent == 1e38 ? burnPercent : _between(burnPercent, 1e36, 1e38); //1e38;
 506 |     |         params.positionId = pos.positionId;
 507 |     |         params.claim = claimAt;
 508 |     |         params.zeroForOne = pos.zeroForOne;
 509 |     | 
 510 |     |         poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;
 511 |     |         poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;
 512 |     |         poolValues.liquidityGlobalBefore = poolStructs.state.liquidityGlobal;
 513 |     |         
 514 |     |         emit PositionTicks(pos.lower, pos.upper);
 515 |     |         (int24 lower, int24 upper, bool positionExists) = pool.getResizedTicksForBurn(params);
 516 |     |         emit BurnTicks(lower, upper, positionExists);
 517 |     | 
 518 |     |         // ACTION
 519 |     |         pool.burn(params);
 520 |     |         if (!positionExists) {
 521 |     |             positions[positionIndex] = positions[positions.length - 1];
 522 |     |             delete positions[positions.length - 1];
 523 |     |         }
 524 |     |         else {
 525 |     |             // Update position data in array if not fully burned
 526 |     |             positions[positionIndex] = Position(pos.owner, pos.positionId, lower, upper, pos.zeroForOne);
 527 |     |             // Ensure positions ticks arent crossed
 528 |     |             assert(lower < upper);
 529 |     |             // Ensure minted ticks on proper tick spacing
 530 |     |             assert((lower % tickSpread == 0) && (upper % tickSpread == 0));
 531 |     |         }
 532 |     | 
 533 |     |         poolStructs.pool0 = getPoolState(true);
 534 |     |         poolStructs.pool1 = getPoolState(false);
 535 |     |         poolStructs.state = getGlobalState();
 536 |     |         poolStructs.lower = getTick(pos.lower);
 537 |     |         poolStructs.upper = getTick(pos.upper);
 538 |     | 
 539 |     |         poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;
 540 |     |         poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;
 541 |     |         poolValues.liquidityGlobalAfter = poolStructs.state.liquidityGlobal;
 542 |     | 
 543 |     |         uint160 price0 = poolStructs.pool0.price;
 544 |     |         uint160 price1 = poolStructs.pool1.price;
 545 |     |         
 546 |     |         // POST CONDITIONS
 547 |     | 
 548 |     |         // Ensure prices never cross
 549 |     |         emit Prices(price0, price1);
 550 |     |         assert(price0 <= price1);
 551 |     | 
 552 |     |         // Ensure liquidityGlobal is decremented after burn
 553 |     |         emit LiquidityGlobal(poolValues.liquidityGlobalBefore, poolValues.liquidityGlobalAfter);
 554 |     |         assert((poolValues.liquidityGlobalAfter <= poolValues.liquidityGlobalBefore));
 555 |     |     }
 556 |     | 
 557 | *   |     function claim(int24 claimAt, uint256 positionIndex) public {
 558 |     |         // PRE CONDITIONS
 559 | *   |         positionIndex = positionIndex % positions.length;
 560 |     |         Position memory pos = positions[positionIndex];
 561 |     |         claimAt = pos.lower + (claimAt % (pos.upper - pos.lower));
 562 |     |         require(claimAt % tickSpread == 0);
 563 |     | 
 564 |     |         // PoolValues memory poolValues;
 565 |     |         PoolStructs memory poolStructs;
 566 |     | 
 567 |     |         poolStructs.pool0 = getPoolState(true);
 568 |     |         poolStructs.pool1 = getPoolState(false);
 569 |     |         poolStructs.state = getGlobalState();
 570 |     |         poolStructs.lower = getTick(pos.lower);
 571 |     |         poolStructs.upper = getTick(pos.upper);
 572 |     | 
 573 |     |         ICoverPool.BurnParams memory params;
 574 |     |         params.to = pos.owner;
 575 |     |         params.burnPercent = 0;
 576 |     |         params.positionId = pos.positionId;
 577 |     |         params.claim = claimAt;
 578 |     |         params.zeroForOne = pos.zeroForOne;
 579 |     |         
 580 |     |         emit PositionTicks(pos.lower, pos.upper);
 581 |     |         (int24 lower, int24 upper, bool positionExists) = pool.getResizedTicksForBurn(params);
 582 |     |         emit BurnTicks(lower, upper, positionExists);
 583 |     | 
 584 |     |         // ACTION
 585 |     |         pool.burn(params);
 586 |     |         if (!positionExists) {
 587 |     |             positions[positionIndex] = positions[positions.length - 1];
 588 |     |             delete positions[positions.length - 1];
 589 |     |         }
 590 |     |         else {
 591 |     |             // Update position data in array if not fully burned
 592 |     |             positions[positionIndex] = Position(pos.owner, pos.positionId, lower, upper, pos.zeroForOne);
 593 |     |             // Ensure positions ticks arent crossed
 594 |     |             assert(lower < upper);
 595 |     |             // Ensure minted ticks on proper tick spacing
 596 |     |             assert((lower % tickSpread == 0) && (upper % tickSpread == 0));
 597 |     |         }
 598 |     | 
 599 |     |         // POST CONDITIONS
 600 |     |         poolStructs.pool0 = getPoolState(true);
 601 |     |         poolStructs.pool1 = getPoolState(false);
 602 |     |         poolStructs.state = getGlobalState();
 603 |     |         poolStructs.lower = getTick(pos.lower);
 604 |     |         poolStructs.upper = getTick(pos.upper);
 605 |     | 
 606 |     |         uint160 price0 = poolStructs.pool0.price;
 607 |     |         uint160 price1 = poolStructs.pool1.price;
 608 |     | 
 609 |     |         // Ensure prices never cross
 610 |     |         emit Prices(price0, price1);
 611 |     |         assert(price0 <= price1);
 612 |     |     }
 613 |     | 
 614 | *   |     function mintThenBurnZeroLiquidityChangeVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {
 615 |     |         // PRE CONDITIONS
 616 | *   |         mintAndApprove();
 617 | *   |         PoolValues memory poolValues;
 618 | *   |         PoolStructs memory poolStructs;
 619 | *   |         LiquidityDeltaValues memory values;
 620 |     | 
 621 | *   |         poolStructs.pool0 = getPoolState(true);
 622 | *   |         poolStructs.pool1 = getPoolState(false);
 623 | *   |         poolStructs.state = getGlobalState();
 624 | *   |         poolStructs.lower = getTick(lower);
 625 | *   |         poolStructs.upper = getTick(upper);
 626 |     | 
 627 | *   |         poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;
 628 | *   |         poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;
 629 |     | 
 630 |     |         // ACTION 
 631 | *   |         mintVariable(amount, zeroForOne, lower, upper);
 632 | *   |         emit PassedMint();
 633 | *   |         burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);
 634 |     |         emit PassedBurn();
 635 |     | 
 636 |     |         // POST CONDITIONS
 637 |     |         poolStructs.pool0 = getPoolState(true);
 638 |     |         poolStructs.pool1 = getPoolState(false);
 639 |     |         poolStructs.state = getGlobalState();
 640 |     |         poolStructs.lower = getTick(lower);
 641 |     |         poolStructs.upper = getTick(upper);
 642 |     | 
 643 |     |         values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;
 644 |     |         values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;
 645 |     |         poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;
 646 |     |         poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;
 647 |     | 
 648 |     |         uint160 price0After = poolStructs.pool0.price;
 649 |     |         uint160 price1After = poolStructs.pool1.price;
 650 |     |         poolValues.liquidityGlobalAfter = poolStructs.state.liquidityGlobal;
 651 |     | 
 652 |     |         // POST CONDITIONS
 653 |     | 
 654 |     |         // Ensure prices never cross
 655 |     |         emit Prices(price0After, price1After);
 656 |     |         assert(price0After <= price1After);
 657 |     | 
 658 |     |         // Ensure liquidityGlobal is decremented after burn
 659 |     |         // emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);
 660 |     |         // assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);
 661 |     |     }
 662 |     | 
 663 | *   |     function mintThenBurnZeroLiquidityChange(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {
 664 |     |         // PRE CONDITIONS
 665 | *   |         mintAndApprove();
 666 | *   |         PoolValues memory poolValues;
 667 | *   |         PoolStructs memory poolStructs;
 668 | *   |         LiquidityDeltaValues memory values;
 669 |     | 
 670 | *   |         poolStructs.pool0 = getPoolState(true);
 671 | *   |         poolStructs.pool1 = getPoolState(false);
 672 | *   |         poolStructs.state = getGlobalState();
 673 | *   |         poolStructs.lower = getTick(lower);
 674 | *   |         poolStructs.upper = getTick(upper);
 675 |     | 
 676 | *   |         poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;
 677 | *   |         poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;
 678 |     | 
 679 |     |         // ACTION 
 680 | *   |         mint(amount, zeroForOne, lower, upper);
 681 | *   |         emit PassedMint();
 682 | *   |         burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);
 683 |     |         emit PassedBurn();
 684 |     | 
 685 |     |         poolStructs.pool0 = getPoolState(true);
 686 |     |         poolStructs.pool1 = getPoolState(false);
 687 |     |         poolStructs.state = getGlobalState();
 688 |     |         poolStructs.lower = getTick(lower);
 689 |     |         poolStructs.upper = getTick(upper);
 690 |     | 
 691 |     |         values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;
 692 |     |         values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;
 693 |     |         poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;
 694 |     |         poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;
 695 |     | 
 696 |     |         uint160 price0After = poolStructs.pool0.price;
 697 |     |         uint160 price1After = poolStructs.pool1.price;
 698 |     |         
 699 |     |         // POST CONDITIONS
 700 |     | 
 701 |     |         // Ensure prices never cross
 702 |     |         emit Prices(price0After, price1After);
 703 |     |         assert(price0After <= price1After);
 704 |     | 
 705 |     |         // Ensure liquidityGlobal is decremented after burn
 706 |     |         // emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);
 707 |     |         // assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);
 708 |     |     }
 709 |     | 
 710 | *   |     function mintThenPartialBurnTwiceLiquidityChange(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint128 percent) public tickPreconditions(lower, upper) {
 711 |     |         // PRE CONDITIONS
 712 | *   |         percent = 1 + (percent % (1e38 - 1));
 713 | *   |         mintAndApprove();
 714 | *   |         PoolValues memory poolValues;
 715 | *   |         PoolStructs memory poolStructs;
 716 | *   |         LiquidityDeltaValues memory values;
 717 |     | 
 718 | *   |         poolStructs.pool0 = getPoolState(true);
 719 | *   |         poolStructs.pool1 = getPoolState(false);
 720 | *   |         poolStructs.state = getGlobalState();
 721 | *   |         poolStructs.lower = getTick(lower);
 722 | *   |         poolStructs.upper = getTick(upper);
 723 |     | 
 724 | *   |         poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;
 725 | *   |         poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;
 726 |     | 
 727 |     |         // ACTION 
 728 | *   |         mint(amount, zeroForOne, lower, upper);
 729 | *   |         emit PassedMint();
 730 | *   |         burn(zeroForOne ? lower : upper, positions.length - 1, percent);
 731 |     |         emit PassedBurn();
 732 |     |         burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);
 733 |     |         emit PassedBurn();
 734 |     | 
 735 |     |         poolStructs.pool0 = getPoolState(true);
 736 |     |         poolStructs.pool1 = getPoolState(false);
 737 |     |         poolStructs.state = getGlobalState();
 738 |     |         poolStructs.lower = getTick(lower);
 739 |     |         poolStructs.upper = getTick(upper);
 740 |     | 
 741 |     |         values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;
 742 |     |         values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;
 743 |     |         poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;
 744 |     |         poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;
 745 |     | 
 746 |     |         uint160 price0After = poolStructs.pool0.price;
 747 |     |         uint160 price1After = poolStructs.pool1.price;
 748 |     | 
 749 |     |         // POST CONDITIONS
 750 |     | 
 751 |     |         // Ensure prices never cross
 752 |     |         emit Prices(price0After, price1After);
 753 |     |         assert(price0After <= price1After);
 754 |     | 
 755 |     |         // Ensure liquidityGlobal is decremented after burn
 756 |     |         // emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);
 757 |     |         // assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);
 758 |     |     }
 759 |     | 
 760 | *   |     function mintThenPartialBurnTwiceLiquidityChangeVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint128 percent) public tickPreconditions(lower, upper) {
 761 |     |         // PRE CONDITIONS
 762 | *   |         percent = 1 + (percent % (1e38 - 1));
 763 | *   |         mintAndApprove();
 764 | *   |         PoolValues memory poolValues;
 765 | *   |         PoolStructs memory poolStructs;
 766 | *   |         LiquidityDeltaValues memory values;
 767 |     | 
 768 | *   |         poolStructs.pool0 = getPoolState(true);
 769 | *   |         poolStructs.pool1 = getPoolState(false);
 770 | *   |         poolStructs.state = getGlobalState();
 771 | *   |         poolStructs.lower = getTick(lower);
 772 | *   |         poolStructs.upper = getTick(upper);
 773 |     | 
 774 | *   |         poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;
 775 | *   |         poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;
 776 |     | 
 777 |     |         // ACTION 
 778 | *   |         mintVariable(amount, zeroForOne, lower, upper);
 779 | *   |         emit PassedMint();
 780 | *   |         burn(zeroForOne ? lower : upper, positions.length - 1, percent);
 781 |     |         emit PassedBurn();
 782 |     |         burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);
 783 |     |         emit PassedBurn();
 784 |     | 
 785 |     |         poolStructs.pool0 = getPoolState(true);
 786 |     |         poolStructs.pool1 = getPoolState(false);
 787 |     |         poolStructs.state = getGlobalState();
 788 |     |         poolStructs.lower = getTick(lower);
 789 |     |         poolStructs.upper = getTick(upper);
 790 |     | 
 791 |     |         values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;
 792 |     |         values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;
 793 |     |         poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;
 794 |     |         poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;
 795 |     | 
 796 |     |         uint160 price0After = poolStructs.pool0.price;
 797 |     |         uint160 price1After = poolStructs.pool1.price;
 798 |     |         
 799 |     |         // POST CONDITIONS
 800 |     | 
 801 |     |         // Ensure prices never cross
 802 |     |         emit Prices(price0After, price1After);
 803 |     |         assert(price0After <= price1After);
 804 |     | 
 805 |     |         // Ensure liquidityGlobal is decremented after burn
 806 |     |         // emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);
 807 |     |         // assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);
 808 |     |     }
 809 |     | 
 810 | *   |     function coverPoolSwapCallback(
 811 |     |         int256 amount0Delta,
 812 |     |         int256 amount1Delta,
 813 |     |         bytes calldata data
 814 |     |     ) external {
 815 | *   |         if (amount0Delta < 0) {
 816 | *   |             SafeTransfers.transferInto(address(token0), address(pool), uint256(-amount0Delta));
 817 |     |         } else {
 818 | *   |             SafeTransfers.transferInto(address(token1), address(pool), uint256(-amount1Delta));
 819 |     |         }
 820 |     |         data;
 821 |     |     }
 822 |     | 
 823 | *   |     function mintAndApprove() internal {
 824 | *   |         tokenIn.mint(msg.sender, 100000000000 ether);
 825 | *   |         tokenOut.mint(msg.sender, 100000000000 ether);
 826 | *   |         tokenIn.mint(address(this), 100000000000 ether);
 827 | *   |         tokenOut.mint(address(this), 100000000000 ether);
 828 | *   |         tokenIn.approve(address(pool), type(uint256).max);
 829 | *   |         tokenOut.approve(address(pool), type(uint256).max);
 830 |     |     }
 831 |     | 
 832 |     |     function _between(uint128 val, uint low, uint high) internal pure returns(uint128) {
 833 |     |         return uint128(low + (val % (high-low +1))); 
 834 |     |     }
 835 |     | 
 836 |     |     function liquidityMintedBackcalculates(uint128 amount, bool zeroForOne, int24 lower, int24 upper) tickPreconditions(lower, upper) internal {
 837 |     |         // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation
 838 |     |         amount = amount + 1e5 + 1;
 839 |     |         PoolsharkStructs.CoverImmutables memory immutables = pool.immutables();
 840 |     |         uint256 priceLower = ConstantProduct.getPriceAtTick(lower, immutables);
 841 |     |         uint256 priceUpper = ConstantProduct.getPriceAtTick(upper, immutables);
 842 |     | 
 843 |     |         uint256 liquidityMinted = ConstantProduct.getLiquidityForAmounts(
 844 |     |             priceLower,
 845 |     |             priceUpper,
 846 |     |             zeroForOne ? priceLower : priceUpper,
 847 |     |             zeroForOne ? 0 : uint256(amount),
 848 |     |             zeroForOne ? uint256(amount) : 0
 849 |     |         );
 850 |     | 
 851 |     |         (uint256 token0Amount, uint256 token1Amount) = ConstantProduct.getAmountsForLiquidity(
 852 |     |             priceLower,
 853 |     |             priceUpper,
 854 |     |             zeroForOne ? priceLower : priceUpper,
 855 |     |             liquidityMinted,
 856 |     |             true
 857 |     |         );
 858 |     | 
 859 |     |         if(zeroForOne) {
 860 |     |             emit LiquidityMinted(amount, token0Amount, zeroForOne);
 861 |     |             assert(token0Amount <= amount);
 862 |     |             
 863 |     |         }
 864 |     |         else {
 865 |     |             emit LiquidityMinted(amount, token1Amount, zeroForOne);
 866 |     |             assert(token1Amount <= amount);
 867 |     |         }
 868 |     |     }
 869 |     | 
 870 | *   |     function getTick(
 871 |     |         int24 tickIdx
 872 |     |     ) internal view returns (
 873 | *   |         CoverPoolStructs.Tick memory tick
 874 |     |     ) {
 875 | *   |         (
 876 | *   |             tick.deltas0,
 877 | *   |             tick.deltas1,
 878 | *   |             tick.liquidityDelta,
 879 | *   |             tick.amountInDeltaMaxMinus,
 880 | *   |             tick.amountOutDeltaMaxMinus,
 881 | *   |             tick.amountInDeltaMaxStashed,
 882 | *   |             tick.amountOutDeltaMaxStashed,
 883 | *   |             tick.pool0Stash
 884 | *   |         ) = pool.ticks(tickIdx);
 885 |     |     }
 886 |     | 
 887 | *   |     function getPoolState(
 888 |     |         bool isPool0
 889 |     |     ) internal view returns (
 890 | *   |         CoverPoolStructs.PoolState memory poolState
 891 |     |     ) {
 892 | *   |         (
 893 | *   |             poolState.price,
 894 | *   |             poolState.liquidity,
 895 | *   |             poolState.amountInDelta,
 896 | *   |             poolState.amountInDeltaMaxClaimed,
 897 | *   |             poolState.amountOutDeltaMaxClaimed
 898 | *   |         ) = isPool0 ? pool.pool0()
 899 | *   |                     : pool.pool1();
 900 |     |     }
 901 |     | 
 902 |     | 
 903 | *   |     function getGlobalState(
 904 |     |     ) internal view returns (
 905 | *   |         CoverPoolStructs.GlobalState memory state
 906 |     |     ) {
 907 | *   |         state = pool.getGlobalState();
 908 |     |     }
 909 |     | }

/home/ec2-user/git/cover/contracts/CoverPool.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './interfaces/cover/ICoverPool.sol';
   5 |     | import './interfaces/cover/ICoverPoolManager.sol';
   6 |     | import './base/storage/CoverPoolStorage.sol';
   7 |     | import './base/storage/CoverPoolImmutables.sol';
   8 |     | import './interfaces/structs/PoolsharkStructs.sol';
   9 |     | import './utils/CoverPoolErrors.sol';
  10 |     | import './libraries/Epochs.sol';
  11 |     | import './libraries/pool/SwapCall.sol';
  12 |     | import './libraries/pool/QuoteCall.sol';
  13 |     | import './libraries/pool/MintCall.sol';
  14 |     | import './libraries/pool/BurnCall.sol';
  15 |     | import './libraries/math/ConstantProduct.sol';
  16 |     | import './external/solady/LibClone.sol';
  17 |     | import './external/openzeppelin/security/ReentrancyGuard.sol';
  18 |     | 
  19 |     | /// @notice Poolshark Cover Pool Implementation
  20 | *   | contract CoverPool is
  21 |     |     ICoverPool,
  22 |     |     CoverPoolImmutables,
  23 |     |     ReentrancyGuard
  24 |     | {
  25 |     |     address public immutable factory;
  26 |     |     address public immutable original;
  27 |     | 
  28 |     |     event SimulateMint(bytes b);
  29 |     |     event SimulateMint(bytes4 b);
  30 |     |     event SimulateMint(bool b);
  31 |     | 
  32 |     |     modifier ownerOnly() {
  33 |     |         _onlyOwner();
  34 |     |         _;
  35 |     |     }
  36 |     | 
  37 |     |     modifier canoncialOnly() {
  38 |     |         _onlyCanoncialClones();
  39 |     |         _;
  40 |     |     }
  41 |     | 
  42 |     |     constructor(
  43 |     |         address factory_
  44 |     |     ) {
  45 |     |         original = address(this);
  46 |     |         factory = factory_;
  47 |     |     }
  48 |     | 
  49 |     |     function mint(
  50 |     |         MintParams memory params
  51 |     |     ) external override
  52 |     |         nonReentrant(globalState)
  53 |     |         canoncialOnly
  54 |     |     {
  55 |     |         MintCache memory cache = MintCache({
  56 |     |             state: globalState,
  57 |     |             position: CoverPosition(0,0,0,0,0,0,0),
  58 |     |             constants: immutables(),
  59 |     |             syncFees: SyncFees(0,0),
  60 |     |             liquidityMinted: 0,
  61 |     |             pool0: pool0,
  62 |     |             pool1: pool1
  63 |     |         });
  64 |     |         (
  65 |     |             cache.state,
  66 |     |             cache.syncFees,
  67 |     |             cache.pool0, 
  68 |     |             cache.pool1
  69 |     |         ) = Epochs.syncLatest(
  70 |     |             ticks,
  71 |     |             tickMap,
  72 |     |             cache.pool0,
  73 |     |             cache.pool1,
  74 |     |             cache.state,
  75 |     |             cache.constants
  76 |     |         );
  77 |     |         MintCall.perform(
  78 |     |             params.zeroForOne ? positions0 : positions1,
  79 |     |             ticks,
  80 |     |             tickMap,
  81 |     |             globalState,
  82 |     |             pool0,
  83 |     |             pool1,
  84 |     |             params,
  85 |     |             cache
  86 |     |         );
  87 |     |     }
  88 |     | 
  89 |     |     function burn(
  90 |     |         BurnParams memory params
  91 |     |     ) external override
  92 |     |         nonReentrant(globalState)
  93 |     |         canoncialOnly
  94 |     |     {
  95 |     |         if (params.to == address(0)) revert CollectToZeroAddress();
  96 |     |         BurnCache memory cache = BurnCache({
  97 |     |             state: globalState,
  98 |     |             position: CoverPosition(0,0,0,0,0,0,0),
  99 |     |             constants: immutables(),
 100 |     |             syncFees: SyncFees(0,0),
 101 |     |             pool0: pool0,
 102 |     |             pool1: pool1
 103 |     |         });
 104 |     |         if (params.sync)
 105 |     |             (
 106 |     |                 cache.state,
 107 |     |                 cache.syncFees,
 108 |     |                 cache.pool0,
 109 |     |                 cache.pool1
 110 |     |             ) = Epochs.syncLatest(
 111 |     |                 ticks,
 112 |     |                 tickMap,
 113 |     |                 cache.pool0,
 114 |     |                 cache.pool1,
 115 |     |                 cache.state,
 116 |     |                 cache.constants
 117 |     |         );
 118 |     |         BurnCall.perform(
 119 |     |             params.zeroForOne ? positions0 : positions1,
 120 |     |             ticks,
 121 |     |             tickMap,
 122 |     |             globalState,
 123 |     |             pool0,
 124 |     |             pool1,
 125 |     |             params,
 126 |     |             cache
 127 |     |         );
 128 |     |     }
 129 |     | 
 130 |     |     function swap(
 131 |     |         SwapParams memory params
 132 |     |     ) external override
 133 |     |         nonReentrant(globalState)
 134 |     |         canoncialOnly
 135 |     |     returns (
 136 |     |         int256,
 137 |     |         int256
 138 |     |     ) 
 139 |     |     {
 140 |     |         SwapCache memory cache;
 141 |     |         cache.pool0 = pool0;
 142 |     |         cache.pool1 = pool1;
 143 |     |         cache.state = globalState;
 144 |     |         cache.constants = immutables();
 145 |     |         (
 146 |     |             cache.state,
 147 |     |             cache.syncFees,
 148 |     |             cache.pool0,
 149 |     |             cache.pool1
 150 |     |         ) = Epochs.syncLatest(
 151 |     |             ticks,
 152 |     |             tickMap,
 153 |     |             cache.pool0,
 154 |     |             cache.pool1,
 155 |     |             cache.state,
 156 |     |             immutables()
 157 |     |         );
 158 |     | 
 159 |     |         return SwapCall.perform(
 160 |     |             params,
 161 |     |             cache,
 162 |     |             globalState,
 163 |     |             pool0,
 164 |     |             pool1
 165 |     |         );
 166 |     |     }
 167 |     | 
 168 |     |     function quote(
 169 |     |         QuoteParams memory params
 170 |     |     ) external override returns (
 171 |     |         int256 inAmount,
 172 |     |         int256 outAmount,
 173 |     |         uint256 priceAfter
 174 |     |     ) {
 175 |     |         SwapCache memory cache;
 176 |     |         cache.pool0 = pool0;
 177 |     |         cache.pool1 = pool1;
 178 |     |         cache.state = globalState;
 179 |     |         cache.constants = immutables();
 180 |     |         (
 181 |     |             cache.state,
 182 |     |             cache.syncFees,
 183 |     |             cache.pool0,
 184 |     |             cache.pool1
 185 |     |         ) = Epochs.simulateSync(
 186 |     |             ticks,
 187 |     |             tickMap,
 188 |     |             cache.pool0,
 189 |     |             cache.pool1,
 190 |     |             cache.state,
 191 |     |             cache.constants
 192 |     |         );
 193 |     |         return QuoteCall.perform(params, cache);
 194 |     |     }
 195 |     | 
 196 |     |     function snapshot(
 197 |     |        SnapshotParams memory params 
 198 |     |     ) external view override returns (
 199 |     |         CoverPosition memory
 200 |     |     ) {
 201 |     |         return Positions.snapshot(
 202 |     |             params.zeroForOne ? positions0 : positions1,
 203 |     |             ticks,
 204 |     |             tickMap,
 205 |     |             globalState,
 206 |     |             params.zeroForOne ? pool0 : pool1,
 207 |     |             UpdateParams(
 208 |     |                 params.owner,
 209 |     |                 params.owner,
 210 |     |                 params.burnPercent,
 211 |     |                 params.positionId,
 212 |     |                 0, 0,
 213 |     |                 params.claim,
 214 |     |                 params.zeroForOne
 215 |     |             ),
 216 |     |             immutables()
 217 |     |         );
 218 |     |     }
 219 |     | 
 220 |     |     function fees(
 221 |     |         uint16 syncFee,
 222 |     |         uint16 fillFee,
 223 |     |         bool setFees
 224 |     |     ) external override
 225 |     |         ownerOnly
 226 |     |         nonReentrant(globalState)
 227 |     |         canoncialOnly
 228 |     |     returns (
 229 |     |         uint128 token0Fees,
 230 |     |         uint128 token1Fees
 231 |     |     ) {
 232 |     |         if (setFees) {
 233 |     |             globalState.syncFee = syncFee;
 234 |     |             globalState.fillFee = fillFee;
 235 |     |         }
 236 |     |         token0Fees = globalState.protocolFees.token0;
 237 |     |         token1Fees = globalState.protocolFees.token1;
 238 |     |         address feeTo = ICoverPoolManager(owner()).feeTo();
 239 |     |         globalState.protocolFees.token0 = 0;
 240 |     |         globalState.protocolFees.token1 = 0;
 241 |     |         SafeTransfers.transferOut(feeTo, token0(), token0Fees);
 242 |     |         SafeTransfers.transferOut(feeTo, token1(), token1Fees);
 243 |     |     }
 244 |     | 
 245 |     |      function getResizedTicksForMint(
 246 |     |         MintParams memory params
 247 |     |     ) external returns (int24 lower, int24 upper, bool positionCreated){
 248 |     |         MintCache memory cache;
 249 |     |         {
 250 |     |             cache.state = globalState;
 251 |     |             cache.constants = immutables();
 252 |     |             cache.pool0 = pool0;
 253 |     |             cache.pool1 = pool1;
 254 |     |         }
 255 |     |         (
 256 |     |             cache.state,
 257 |     |             cache.syncFees,
 258 |     |             cache.pool0,
 259 |     |             cache.pool1
 260 |     |         ) = Epochs.simulateSync(
 261 |     |             ticks,
 262 |     |             tickMap,
 263 |     |             cache.pool0,
 264 |     |             cache.pool1,
 265 |     |             cache.state,
 266 |     |             cache.constants
 267 |     |         );
 268 |     |         try MintCall.getResizedTicks(
 269 |     |             params.zeroForOne ? positions0 : positions1,
 270 |     |             ticks,
 271 |     |             tickMap,
 272 |     |             globalState,
 273 |     |             pool0,
 274 |     |             pool1,
 275 |     |             params,
 276 |     |             cache
 277 |     |         ) {
 278 |     |         } catch (bytes memory data) {
 279 |     |             emit SimulateMint(data);
 280 |     |             bytes4 sig;
 281 |     |             assembly {
 282 |     |                 sig := mload(add(data, 0x20))
 283 |     |             }
 284 |     |             
 285 |     |             // SimulateMint error
 286 |     |             if (sig == hex"5cc1f67b") {
 287 |     |                 (, lower, upper, positionCreated) = abi.decode(abi.encodePacked(bytes28(0), data),(bytes32,int24,int24,bool));
 288 |     |             }
 289 |     |             else {
 290 |     |                 lower = -8388608;
 291 |     |                 upper = -8388608;
 292 |     |                 positionCreated = false;
 293 |     |             }
 294 |     |         }
 295 |     |     }
 296 |     | 
 297 |     |     function getResizedTicksForBurn(
 298 |     |         BurnParams memory params
 299 |     |     ) external returns (int24 lower, int24 upper, bool positionExists){
 300 |     |         if (params.to == address(0)) revert CollectToZeroAddress();
 301 |     |         BurnCache memory cache;
 302 |     |         {
 303 |     |             cache.state = globalState;
 304 |     |             cache.constants = immutables();
 305 |     |             cache.pool0 = pool0;
 306 |     |             cache.pool1 = pool1;
 307 |     |         }
 308 |     |         (
 309 |     |             cache.state,
 310 |     |             cache.syncFees,
 311 |     |             cache.pool0,
 312 |     |             cache.pool1
 313 |     |         ) = Epochs.simulateSync(
 314 |     |             ticks,
 315 |     |             tickMap,
 316 |     |             cache.pool0,
 317 |     |             cache.pool1,
 318 |     |             cache.state,
 319 |     |             cache.constants
 320 |     |         );
 321 |     |         try BurnCall.getResizedTicks(
 322 |     |             params.zeroForOne ? positions0 : positions1,
 323 |     |             ticks,
 324 |     |             tickMap,
 325 |     |             globalState,
 326 |     |             pool0,
 327 |     |             pool1,
 328 |     |             params,
 329 |     |             cache
 330 |     |         ) {
 331 |     |         } catch (bytes memory data) {
 332 |     |             bytes4 sig;
 333 |     |             assembly {
 334 |     |                 sig := mload(add(data, 0x20))
 335 |     |             }
 336 |     |             // SimulateBurn error
 337 |     |             if (sig == hex"97dd6e0a") {
 338 |     |                 (, lower, upper, positionExists) = abi.decode(abi.encodePacked(bytes28(0), data),(bytes32,int24,int24,bool));
 339 |     |             }
 340 |     |              else {
 341 |     |                 lower = -8388608;
 342 |     |                 upper = -8388608;
 343 |     |                 positionExists = false;
 344 |     |             }
 345 |     |         }
 346 |     |     }
 347 |     | 
 348 |     |     function getGlobalState() public view returns(
 349 |     |         GlobalState memory
 350 |     |     ) {
 351 |     |         return globalState;
 352 |     |     }
 353 |     | 
 354 |     |     function immutables() public view returns (
 355 |     |         CoverImmutables memory
 356 |     |     ) {
 357 |     |         return CoverImmutables(
 358 |     |             ITwapSource(twapSource()),
 359 |     |             PriceBounds(minPrice(), maxPrice()),
 360 |     |             owner(),
 361 |     |             token0(),
 362 |     |             token1(),
 363 |     |             original,
 364 |     |             poolToken(),
 365 |     |             inputPool(),
 366 |     |             minAmountPerAuction(),
 367 |     |             genesisTime(),
 368 |     |             minPositionWidth(),
 369 |     |             tickSpread(),
 370 |     |             twapLength(),
 371 |     |             auctionLength(),
 372 |     |             blockTime(),
 373 |     |             token0Decimals(),
 374 |     |             token1Decimals(),
 375 |     |             minAmountLowerPriced()
 376 |     |         );
 377 |     |     }
 378 |     | 
 379 |     |     function priceBounds(
 380 |     |         int16 tickSpacing
 381 |     |     ) external pure returns (uint160, uint160) {
 382 |     |         return ConstantProduct.priceBounds(tickSpacing);
 383 |     |     }
 384 |     | 
 385 |     |     function _onlyCanoncialClones() private view {
 386 |     |         // compute pool key
 387 |     |         bytes32 key = keccak256(abi.encode(
 388 |     |                                     token0(),
 389 |     |                                     token1(),
 390 |     |                                     twapSource(),
 391 |     |                                     inputPool(),
 392 |     |                                     tickSpread(),
 393 |     |                                     twapLength()
 394 |     |                                 ));
 395 |     |         
 396 |     |         // compute canonical pool address
 397 |     |         address predictedAddress = LibClone.predictDeterministicAddress(
 398 |     |             original,
 399 |     |             encodeCover(immutables()),
 400 |     |             key,
 401 |     |             factory
 402 |     |         );
 403 |     |         // only allow delegateCall from canonical clones
 404 |     |         if (address(this) != predictedAddress) require(false, 'NoDelegateCall()');
 405 |     |     }
 406 |     | 
 407 |     |         function encodeCover(
 408 |     |         CoverImmutables memory constants
 409 |     |     ) private pure returns (bytes memory) {
 410 |     |         bytes memory value1 = abi.encodePacked(
 411 |     |             constants.owner,
 412 |     |             constants.token0,
 413 |     |             constants.token1,
 414 |     |             constants.source,
 415 |     |             constants.poolToken,
 416 |     |             constants.inputPool,
 417 |     |             constants.bounds.min,
 418 |     |             constants.bounds.max
 419 |     |         );
 420 |     |         bytes memory value2 = abi.encodePacked(
 421 |     |             constants.minAmountPerAuction,
 422 |     |             constants.genesisTime,
 423 |     |             constants.minPositionWidth,
 424 |     |             constants.tickSpread,
 425 |     |             constants.twapLength,
 426 |     |             constants.auctionLength
 427 |     |         );
 428 |     |         bytes memory value3 = abi.encodePacked(
 429 |     |             constants.blockTime,
 430 |     |             constants.token0Decimals,
 431 |     |             constants.token1Decimals,
 432 |     |             constants.minAmountLowerPriced
 433 |     |         );
 434 |     |         return abi.encodePacked(value1, value2, value3);
 435 |     |     }
 436 |     | 
 437 |     |     function _onlyOwner() private view {
 438 |     |         if (msg.sender != owner()) revert OwnerOnly();
 439 |     |     }
 440 |     | }
 441 |     | 

/home/ec2-user/git/cover/contracts/CoverPoolFactory.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './CoverPool.sol';
   5 |     | import './external/solady/LibClone.sol';
   6 |     | import './interfaces/structs/CoverPoolStructs.sol';
   7 |     | import './interfaces/cover/ICoverPoolFactory.sol';
   8 |     | import './base/events/CoverPoolFactoryEvents.sol';
   9 |     | import './utils/CoverPoolErrors.sol';
  10 |     | 
  11 |     | contract CoverPoolFactory is 
  12 |     |     ICoverPoolFactory,
  13 |     |     CoverPoolFactoryEvents,
  14 |     |     CoverPoolFactoryErrors,
  15 |     |     CoverPoolStructs
  16 |     | {
  17 |     |     using LibClone for address;
  18 |     | 
  19 |     |     address immutable public owner;
  20 |     | 
  21 |     |     constructor(
  22 |     |         address _owner
  23 |     |     ) {
  24 |     |         owner = _owner;
  25 |     |     }
  26 |     | 
  27 |     |     function createCoverPool(
  28 |     |         CoverPoolParams memory params
  29 |     |     ) public override returns (
  30 |     |         address pool,
  31 |     |         address poolToken
  32 |     |     ) {
  33 |     |         // validate token pair
  34 |     |         if (params.tokenIn == params.tokenOut || params.tokenIn == address(0) || params.tokenOut == address(0)) {
  35 |     |             revert InvalidTokenAddress();
  36 |     |         }
  37 |     |         CoverImmutables memory constants;
  38 |     |         constants.owner = owner;
  39 |     |         // sort tokens by address
  40 |     |         constants.token0 = params.tokenIn < params.tokenOut ? params.tokenIn : params.tokenOut;
  41 |     |         constants.token1 = params.tokenIn < params.tokenOut ? params.tokenOut : params.tokenIn;
  42 |     | 
  43 |     |         // validate erc20 decimals
  44 |     |         {
  45 |     |             uint8 token0Decimals = ERC20(constants.token0).decimals();
  46 |     |             uint8 token1Decimals = ERC20(constants.token1).decimals();
  47 |     |             if (token0Decimals > 18 || token1Decimals > 18
  48 |     |             || token0Decimals < 6 || token1Decimals < 6) {
  49 |     |                 revert InvalidTokenDecimals();
  50 |     |             }
  51 |     |             constants.token0Decimals = token0Decimals;
  52 |     |             constants.token1Decimals = token1Decimals;
  53 |     |         }
  54 |     |     
  55 |     |         // get twap source
  56 |     |         {
  57 |     |             (
  58 |     |                 address poolImpl,
  59 |     |                 address tokenImpl,
  60 |     |                 address twapSource
  61 |     |             ) = ICoverPoolManager(owner).poolTypes(params.poolType);
  62 |     |             if (poolImpl == address(0) || twapSource == address(0)) revert PoolTypeNotFound();
  63 |     |             constants.poolImpl = poolImpl;
  64 |     |             constants.poolToken = tokenImpl;
  65 |     |             constants.source = ITwapSource(twapSource);
  66 |     |         }
  67 |     |         // get volatility tier config
  68 |     |         {
  69 |     |             VolatilityTier memory config = ICoverPoolManager(owner).volatilityTiers(
  70 |     |                 params.poolType,
  71 |     |                 params.feeTier,
  72 |     |                 params.tickSpread,
  73 |     |                 params.twapLength
  74 |     |             );
  75 |     |             if (config.auctionLength == 0) revert VolatilityTierNotSupported();
  76 |     |             constants.minAmountPerAuction = config.minAmountPerAuction;
  77 |     |             constants.auctionLength = config.auctionLength;
  78 |     |             constants.blockTime = config.blockTime;
  79 |     |             constants.minPositionWidth = config.minPositionWidth;
  80 |     |             constants.minAmountLowerPriced = config.minAmountLowerPriced;
  81 |     |         }
  82 |     |         // record genesis time
  83 |     |         constants.tickSpread = params.tickSpread;
  84 |     |         constants.twapLength = params.twapLength;
  85 |     |         constants.genesisTime   = uint32(block.timestamp);
  86 |     |         // get reference pool
  87 |     |         constants.inputPool  = ITwapSource(constants.source).getPool(constants.token0, constants.token1, params.feeTier);
  88 |     | 
  89 |     |         // generate key for pool
  90 |     |         bytes32 key = keccak256(
  91 |     |             abi.encode(
  92 |     |                 constants.token0,
  93 |     |                 constants.token1,
  94 |     |                 constants.source,
  95 |     |                 constants.inputPool,
  96 |     |                 constants.tickSpread,
  97 |     |                 constants.twapLength
  98 |     |             )
  99 |     |         );
 100 |     |         if (coverPools[key] != address(0)) {
 101 |     |             revert PoolAlreadyExists();
 102 |     |         }
 103 |     | 
 104 |     |         (
 105 |     |             constants.bounds.min,
 106 |     |             constants.bounds.max
 107 |     |         ) = ICoverPool(constants.poolImpl).priceBounds(constants.tickSpread);
 108 |     | 
 109 |     |         // launch pool token
 110 |     |         constants.poolToken = constants.poolToken.cloneDeterministic({
 111 |     |             salt: key,
 112 |     |             data: abi.encodePacked(
 113 |     |                 constants.poolImpl
 114 |     |             )
 115 |     |         });
 116 |     | 
 117 |     |         // launch pool and save address
 118 |     |         pool = constants.poolImpl.cloneDeterministic({
 119 |     |             salt: key,
 120 |     |             data: encodeCover(constants)
 121 |     |         });
 122 |     | 
 123 |     |         poolToken = constants.poolToken;
 124 |     | 
 125 |     |         coverPools[key] = pool;
 126 |     | 
 127 |     |         emit PoolCreated(
 128 |     |             pool,
 129 |     |             constants.inputPool,
 130 |     |             constants.token0,
 131 |     |             constants.token1,
 132 |     |             params.poolType,
 133 |     |             params.feeTier,
 134 |     |             params.tickSpread,
 135 |     |             params.twapLength
 136 |     |         );
 137 |     |     }
 138 |     | 
 139 |     |     function createCoverPoolAndMint(
 140 |     |         CoverPoolParams memory params,
 141 |     |         ICoverPool.MintParams[] memory mintCoverParams
 142 |     |     ) external returns (
 143 |     |         address pool,
 144 |     |         address poolToken
 145 |     |     ) {
 146 |     |         // check if pool exists
 147 |     |         (
 148 |     |             pool,
 149 |     |             poolToken
 150 |     |         ) = getCoverPool(
 151 |     |             params
 152 |     |         );
 153 |     |         // create if pool doesn't exist
 154 |     |         if (pool == address(0)) {
 155 |     |             (
 156 |     |                 pool,
 157 |     |                 poolToken
 158 |     |             ) = createCoverPool(
 159 |     |                 params
 160 |     |             );
 161 |     |         }
 162 |     |         // mint initial cover positions
 163 |     |         for (uint i = 0; i < mintCoverParams.length;) {
 164 |     |             ICoverPool(pool).mint(mintCoverParams[i]);
 165 |     |             unchecked {
 166 |     |                 ++i;
 167 |     |             }
 168 |     |         }
 169 |     |     } 
 170 |     | 
 171 |     |     function getCoverPool(
 172 |     |         CoverPoolParams memory params
 173 |     |     ) public view override returns (
 174 |     |         address pool,
 175 |     |         address poolToken
 176 |     |     ) {
 177 |     |         // set lexographical token address ordering
 178 |     |         address token0 = params.tokenIn < params.tokenOut ? params.tokenIn : params.tokenOut;
 179 |     |         address token1 = params.tokenIn < params.tokenOut ? params.tokenOut : params.tokenIn;
 180 |     | 
 181 |     |         (
 182 |     |             address poolImpl,
 183 |     |             address tokenImpl,
 184 |     |             address source
 185 |     |         ) = ICoverPoolManager(owner).poolTypes(params.poolType);
 186 |     |         address inputPool  = ITwapSource(source).getPool(token0, token1, params.feeTier);
 187 |     | 
 188 |     |         // generate key for pool
 189 |     |         bytes32 key = keccak256(abi.encode(
 190 |     |                                     token0,
 191 |     |                                     token1,
 192 |     |                                     source,
 193 |     |                                     inputPool,
 194 |     |                                     params.tickSpread,
 195 |     |                                     params.twapLength
 196 |     |                                 ));
 197 |     |         
 198 |     |         pool = coverPools[key];
 199 |     | 
 200 |     |         poolToken = LibClone.predictDeterministicAddress(
 201 |     |             tokenImpl,
 202 |     |             abi.encodePacked(
 203 |     |                 poolImpl
 204 |     |             ),
 205 |     |             key,
 206 |     |             address(this)
 207 |     |         );
 208 |     |     }
 209 |     | 
 210 |     |     function encodeCover(
 211 |     |         CoverImmutables memory constants
 212 |     |     ) private pure returns (bytes memory) {
 213 |     |         bytes memory value1 = abi.encodePacked(
 214 |     |             constants.owner,
 215 |     |             constants.token0,
 216 |     |             constants.token1,
 217 |     |             constants.source,
 218 |     |             constants.poolToken,
 219 |     |             constants.inputPool,
 220 |     |             constants.bounds.min,
 221 |     |             constants.bounds.max
 222 |     |         );
 223 |     |         bytes memory value2 = abi.encodePacked(
 224 |     |             constants.minAmountPerAuction,
 225 |     |             constants.genesisTime,
 226 |     |             constants.minPositionWidth,
 227 |     |             constants.tickSpread,
 228 |     |             constants.twapLength,
 229 |     |             constants.auctionLength
 230 |     |         );
 231 |     |         bytes memory value3 = abi.encodePacked(
 232 |     |             constants.blockTime,
 233 |     |             constants.token0Decimals,
 234 |     |             constants.token1Decimals,
 235 |     |             constants.minAmountLowerPriced
 236 |     |         );
 237 |     |         return abi.encodePacked(value1, value2, value3);
 238 |     |     }
 239 |     | }
 240 |     | 

/home/ec2-user/git/cover/contracts/base/events/CoverPoolFactoryEvents.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | abstract contract CoverPoolFactoryEvents {
  5 |     |     event PoolCreated(
  6 |     |         address pool,
  7 |     |         address indexed inputPool,
  8 |     |         address token0,
  9 |     |         address token1,
 10 |     |         bytes32 indexed poolType,
 11 |     |         uint16 fee,
 12 |     |         int16 tickSpread,
 13 |     |         uint16 twapLength
 14 |     |     );
 15 |     | }
 16 |     | 

/home/ec2-user/git/cover/contracts/base/events/CoverPoolManagerEvents.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | abstract contract CoverPoolManagerEvents {
  5 |     |     event FactoryChanged(address indexed previousFactory, address indexed newFactory);
  6 |     |     event VolatilityTierEnabled(
  7 |     |         bytes32 poolType,
  8 |     |         uint16  feeTier,
  9 |     |         int16   tickSpread,
 10 |     |         uint16  twapLength,
 11 |     |         uint128 minAmountPerAuction,
 12 |     |         uint16  auctionLength,
 13 |     |         uint16  blockTime,
 14 |     |         uint16  syncFee,
 15 |     |         uint16  fillFee,
 16 |     |         int16   minPositionWidth,
 17 |     |         bool    minLowerPriced
 18 |     |     );
 19 |     |     event PoolTypeEnabled(
 20 |     |         bytes32 poolType,
 21 |     |         address implAddress,
 22 |     |         address sourceAddress,
 23 |     |         address factoryAddress
 24 |     |     );
 25 |     |     event FeeToTransfer(address indexed previousFeeTo, address indexed newFeeTo);
 26 |     |     event OwnerTransfer(address indexed previousOwner, address indexed newOwner);
 27 |     |     event ProtocolFeesModified(
 28 |     |         address[] modifyPools,
 29 |     |         uint16[] syncFees,
 30 |     |         uint16[] fillFees,
 31 |     |         bool[] setFees,
 32 |     |         uint128[] token0Fees,
 33 |     |         uint128[] token1Fees
 34 |     |     );
 35 |     |     event ProtocolFeesCollected(
 36 |     |         address[] collectPools,
 37 |     |         uint128[] token0Fees,
 38 |     |         uint128[] token1Fees
 39 |     |     );
 40 |     | }

/home/ec2-user/git/cover/contracts/base/storage/CoverPoolFactoryStorage.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | abstract contract CoverPoolFactoryStorage {
  5 |     |     mapping(bytes32 => address) public coverPools;
  6 |     | }
  7 |     | 
  8 |     | 
  9 |     | 
 10 |     | 
 11 |     | 

/home/ec2-user/git/cover/contracts/base/storage/CoverPoolImmutables.sol
  1 |     | // SPDX-License-Identifier: BSD
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import { Clone } from "../../external/solady/Clone.sol";
  5 |     | 
  6 |     | contract CoverPoolImmutables is Clone {
  7 |     |     function owner() public pure returns (address) {
  8 |     |         return _getArgAddress(0);
  9 |     |     }
 10 |     | 
 11 |     |     function token0() public pure returns (address) {
 12 |     |         return _getArgAddress(20);
 13 |     |     }
 14 |     | 
 15 |     |     function token1() public pure returns (address) {
 16 |     |         return _getArgAddress(40);
 17 |     |     }
 18 |     | 
 19 |     |     function twapSource() public pure returns (address) {
 20 |     |         return _getArgAddress(60);
 21 |     |     }
 22 |     | 
 23 |     |     function poolToken() public pure returns (address) {
 24 |     |         return _getArgAddress(80);
 25 |     |     }
 26 |     | 
 27 |     |     function inputPool() public pure returns (address) {
 28 |     |         return _getArgAddress(100);
 29 |     |     }
 30 |     | 
 31 |     |     function minPrice() public pure returns (uint160) {
 32 |     |         return _getArgUint160(120);
 33 |     |     }
 34 |     | 
 35 |     |     function maxPrice() public pure returns (uint160) {
 36 |     |         return _getArgUint160(140);
 37 |     |     }
 38 |     | 
 39 |     |     function minAmountPerAuction() public pure returns (uint128) {
 40 |     |         return _getArgUint128(160);
 41 |     |     }
 42 |     | 
 43 |     |     function genesisTime() public pure returns (uint32) {
 44 |     |         return _getArgUint32(176);
 45 |     |     }
 46 |     | 
 47 |     |     function minPositionWidth() public pure returns (int16) {
 48 |     |         return int16(_getArgUint16(180));
 49 |     |     }
 50 |     | 
 51 |     |     function tickSpread() public pure returns (int16) {
 52 |     |         return int16(_getArgUint16(182));
 53 |     |     }
 54 |     | 
 55 |     |     function twapLength() public pure returns (uint16) {
 56 |     |         return _getArgUint16(184);
 57 |     |     }
 58 |     | 
 59 |     |     function auctionLength() public pure returns (uint16) {
 60 |     |         return _getArgUint16(186);
 61 |     |     }
 62 |     | 
 63 |     |     function blockTime() public pure returns (uint16) {
 64 |     |         return _getArgUint16(188);
 65 |     |     }
 66 |     | 
 67 |     |     function token0Decimals() public pure returns (uint8) {
 68 |     |         return _getArgUint8(190);
 69 |     |     }
 70 |     | 
 71 |     |     function token1Decimals() public pure returns (uint8) {
 72 |     |         return _getArgUint8(191);
 73 |     |     }
 74 |     | 
 75 |     |     function minAmountLowerPriced() public pure returns (bool) {
 76 |     |         return _getArgUint8(192) > 0;
 77 |     |     }
 78 |     | }

/home/ec2-user/git/cover/contracts/base/storage/CoverPoolStorage.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/structs/CoverPoolStructs.sol';
  5 |     | import '../../interfaces/cover/ICoverPoolFactory.sol';
  6 |     | import '../../utils/CoverPoolErrors.sol';
  7 |     | 
  8 |     | abstract contract CoverPoolStorage is CoverPoolStructs, CoverPoolErrors {
  9 |     |     GlobalState public globalState;
 10 |     |     PoolState public pool0; /// @dev pool with token0 liquidity
 11 |     |     PoolState public pool1; /// @dev pool with token1 liquidity
 12 |     |     TickMap public tickMap;
 13 |     |     mapping(int24 => Tick) public ticks; /// @dev price ticks with delta values
 14 |     |     mapping(uint256 => CoverPosition) public positions0; //positions with token0 deposited
 15 |     |     mapping(uint256 => CoverPosition) public positions1; //positions with token1 deposited
 16 |     | }
 17 |     | 

/home/ec2-user/git/cover/contracts/base/storage/PositionERC1155Immutables.sol
  1 |     | // SPDX-License-Identifier: BSD
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import { Clone } from "../../external/solady/Clone.sol";
  5 |     | 
  6 |     | contract PositionERC1155Immutables is Clone {
  7 |     |     function poolImpl() public pure returns (address) {
  8 |     |         return _getArgAddress(0);
  9 |     |     }
 10 |     | }

/home/ec2-user/git/cover/contracts/external/openzeppelin/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20.sol";
   7 |     | import "./extensions/IERC20Metadata.sol";
   8 |     | import "../../utils/Context.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Implementation of the {IERC20} interface.
  12 |     |  *
  13 |     |  * This implementation is agnostic to the way tokens are created. This means
  14 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  15 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  22 |     |  * instead returning `false` on failure. This behavior is nonetheless
  23 |     |  * conventional and does not conflict with the expectations of ERC20
  24 |     |  * applications.
  25 |     |  *
  26 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  27 |     |  * This allows applications to reconstruct the allowance for all accounts just
  28 |     |  * by listening to said events. Other implementations of the EIP may not emit
  29 |     |  * these events, as it isn't required by the specification.
  30 |     |  *
  31 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  32 |     |  * functions have been added to mitigate the well-known issues around setting
  33 |     |  * allowances. See {IERC20-approve}.
  34 |     |  */
  35 |     | contract ERC20 is Context, IERC20, IERC20Metadata {
  36 |     |     mapping(address => uint256) private _balances;
  37 |     | 
  38 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  39 |     | 
  40 |     |     uint256 private _totalSupply;
  41 |     | 
  42 |     |     string private _name;
  43 |     |     string private _symbol;
  44 |     | 
  45 |     |     /**
  46 |     |      * @dev Sets the values for {name} and {symbol}.
  47 |     |      *
  48 |     |      * The default value of {decimals} is 18. To select a different value for
  49 |     |      * {decimals} you should overload it.
  50 |     |      *
  51 |     |      * All two of these values are immutable: they can only be set once during
  52 |     |      * construction.
  53 |     |      */
  54 |     |     constructor(string memory name_, string memory symbol_) {
  55 |     |         _name = name_;
  56 |     |         _symbol = symbol_;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the name of the token.
  61 |     |      */
  62 |     |     function name() public view virtual override returns (string memory) {
  63 |     |         return _name;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  68 |     |      * name.
  69 |     |      */
  70 |     |     function symbol() public view virtual override returns (string memory) {
  71 |     |         return _symbol;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the number of decimals used to get its user representation.
  76 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  77 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  78 |     |      *
  79 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  80 |     |      * Ether and Wei. This is the value {ERC20} uses, unless this function is
  81 |     |      * overridden;
  82 |     |      *
  83 |     |      * NOTE: This information is only used for _display_ purposes: it in
  84 |     |      * no way affects any of the arithmetic of the contract, including
  85 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  86 |     |      */
  87 |     |     function decimals() public view virtual override returns (uint8) {
  88 |     |         return 18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-totalSupply}.
  93 |     |      */
  94 |     |     function totalSupply() public view virtual override returns (uint256) {
  95 |     |         return _totalSupply;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev See {IERC20-balanceOf}.
 100 |     |      */
 101 | *   |     function balanceOf(address account) public view virtual override returns (uint256) {
 102 | *   |         return _balances[account];
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev See {IERC20-transfer}.
 107 |     |      *
 108 |     |      * Requirements:
 109 |     |      *
 110 |     |      * - `to` cannot be the zero address.
 111 |     |      * - the caller must have a balance of at least `amount`.
 112 |     |      */
 113 | *   |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 114 | *   |         address owner = _msgSender();
 115 | *   |         _transfer(owner, to, amount);
 116 | *   |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev See {IERC20-allowance}.
 121 |     |      */
 122 | *   |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 123 | *   |         return _allowances[owner][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-approve}.
 128 |     |      *
 129 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 130 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 131 |     |      *
 132 |     |      * Requirements:
 133 |     |      *
 134 |     |      * - `spender` cannot be the zero address.
 135 |     |      */
 136 | *   |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 137 | *   |         address owner = _msgSender();
 138 | *   |         _approve(owner, spender, amount);
 139 | *   |         return true;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev See {IERC20-transferFrom}.
 144 |     |      *
 145 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 146 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 147 |     |      *
 148 |     |      * NOTE: Does not update the allowance if the current allowance
 149 |     |      * is the maximum `uint256`.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - `from` and `to` cannot be the zero address.
 154 |     |      * - `from` must have a balance of at least `amount`.
 155 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 156 |     |      * `amount`.
 157 |     |      */
 158 | *   |     function transferFrom(
 159 |     |         address from,
 160 |     |         address to,
 161 |     |         uint256 amount
 162 | *   |     ) public virtual override returns (bool) {
 163 | *   |         address spender = _msgSender();
 164 | *   |         _spendAllowance(from, spender, amount);
 165 | *   |         _transfer(from, to, amount);
 166 | *   |         return true;
 167 |     |     }
 168 |     | 
 169 |     |     /**
 170 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 171 |     |      *
 172 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 173 |     |      * problems described in {IERC20-approve}.
 174 |     |      *
 175 |     |      * Emits an {Approval} event indicating the updated allowance.
 176 |     |      *
 177 |     |      * Requirements:
 178 |     |      *
 179 |     |      * - `spender` cannot be the zero address.
 180 |     |      */
 181 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 182 |     |         address owner = _msgSender();
 183 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 184 |     |         return true;
 185 |     |     }
 186 |     | 
 187 |     |     /**
 188 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 189 |     |      *
 190 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 191 |     |      * problems described in {IERC20-approve}.
 192 |     |      *
 193 |     |      * Emits an {Approval} event indicating the updated allowance.
 194 |     |      *
 195 |     |      * Requirements:
 196 |     |      *
 197 |     |      * - `spender` cannot be the zero address.
 198 |     |      * - `spender` must have allowance for the caller of at least
 199 |     |      * `subtractedValue`.
 200 |     |      */
 201 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 202 |     |         address owner = _msgSender();
 203 |     |         uint256 currentAllowance = allowance(owner, spender);
 204 |     |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 205 |     |         unchecked {
 206 |     |             _approve(owner, spender, currentAllowance - subtractedValue);
 207 |     |         }
 208 |     | 
 209 |     |         return true;
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 214 |     |      *
 215 |     |      * This internal function is equivalent to {transfer}, and can be used to
 216 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 217 |     |      *
 218 |     |      * Emits a {Transfer} event.
 219 |     |      *
 220 |     |      * Requirements:
 221 |     |      *
 222 |     |      * - `from` cannot be the zero address.
 223 |     |      * - `to` cannot be the zero address.
 224 |     |      * - `from` must have a balance of at least `amount`.
 225 |     |      */
 226 | *   |     function _transfer(
 227 |     |         address from,
 228 |     |         address to,
 229 |     |         uint256 amount
 230 | *   |     ) internal virtual {
 231 | *   |         require(from != address(0), "ERC20: transfer from the zero address");
 232 | *   |         require(to != address(0), "ERC20: transfer to the zero address");
 233 |     | 
 234 | *   |         _beforeTokenTransfer(from, to, amount);
 235 |     | 
 236 | *   |         uint256 fromBalance = _balances[from];
 237 | *   |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 238 |     |         unchecked {
 239 | *   |             _balances[from] = fromBalance - amount;
 240 |     |         }
 241 | *   |         _balances[to] += amount;
 242 |     | 
 243 | *   |         emit Transfer(from, to, amount);
 244 |     | 
 245 | *   |         _afterTokenTransfer(from, to, amount);
 246 |     |     }
 247 |     | 
 248 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 249 |     |      * the total supply.
 250 |     |      *
 251 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 252 |     |      *
 253 |     |      * Requirements:
 254 |     |      *
 255 |     |      * - `account` cannot be the zero address.
 256 |     |      */
 257 | *   |     function _mint(address account, uint256 amount) internal virtual {
 258 | *   |         require(account != address(0), "ERC20: mint to the zero address");
 259 |     | 
 260 | *   |         _beforeTokenTransfer(address(0), account, amount);
 261 |     | 
 262 | *   |         _totalSupply += amount;
 263 | *   |         _balances[account] += amount;
 264 | *   |         emit Transfer(address(0), account, amount);
 265 |     | 
 266 | *   |         _afterTokenTransfer(address(0), account, amount);
 267 |     |     }
 268 |     | 
 269 |     |     /**
 270 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 271 |     |      * total supply.
 272 |     |      *
 273 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 274 |     |      *
 275 |     |      * Requirements:
 276 |     |      *
 277 |     |      * - `account` cannot be the zero address.
 278 |     |      * - `account` must have at least `amount` tokens.
 279 |     |      */
 280 |     |     function _burn(address account, uint256 amount) internal virtual {
 281 |     |         require(account != address(0), "ERC20: burn from the zero address");
 282 |     | 
 283 |     |         _beforeTokenTransfer(account, address(0), amount);
 284 |     | 
 285 |     |         uint256 accountBalance = _balances[account];
 286 |     |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 287 |     |         unchecked {
 288 |     |             _balances[account] = accountBalance - amount;
 289 |     |         }
 290 |     |         _totalSupply -= amount;
 291 |     | 
 292 |     |         emit Transfer(account, address(0), amount);
 293 |     | 
 294 |     |         _afterTokenTransfer(account, address(0), amount);
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 299 |     |      *
 300 |     |      * This internal function is equivalent to `approve`, and can be used to
 301 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 302 |     |      *
 303 |     |      * Emits an {Approval} event.
 304 |     |      *
 305 |     |      * Requirements:
 306 |     |      *
 307 |     |      * - `owner` cannot be the zero address.
 308 |     |      * - `spender` cannot be the zero address.
 309 |     |      */
 310 | *   |     function _approve(
 311 |     |         address owner,
 312 |     |         address spender,
 313 |     |         uint256 amount
 314 |     |     ) internal virtual {
 315 | *   |         require(owner != address(0), "ERC20: approve from the zero address");
 316 | *   |         require(spender != address(0), "ERC20: approve to the zero address");
 317 |     | 
 318 | *   |         _allowances[owner][spender] = amount;
 319 | *   |         emit Approval(owner, spender, amount);
 320 |     |     }
 321 |     | 
 322 |     |     /**
 323 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 324 |     |      *
 325 |     |      * Does not update the allowance amount in case of infinite allowance.
 326 |     |      * Revert if not enough allowance is available.
 327 |     |      *
 328 |     |      * Might emit an {Approval} event.
 329 |     |      */
 330 | *   |     function _spendAllowance(
 331 |     |         address owner,
 332 |     |         address spender,
 333 |     |         uint256 amount
 334 | *   |     ) internal virtual {
 335 | *   |         uint256 currentAllowance = allowance(owner, spender);
 336 | *   |         if (currentAllowance != type(uint256).max) {
 337 | *   |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 338 |     |             unchecked {
 339 | *   |                 _approve(owner, spender, currentAllowance - amount);
 340 |     |             }
 341 |     |         }
 342 |     |     }
 343 |     | 
 344 |     |     /**
 345 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 346 |     |      * minting and burning.
 347 |     |      *
 348 |     |      * Calling conditions:
 349 |     |      *
 350 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 351 |     |      * will be transferred to `to`.
 352 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 353 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 354 |     |      * - `from` and `to` are never both zero.
 355 |     |      *
 356 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 357 |     |      */
 358 | *   |     function _beforeTokenTransfer(
 359 |     |         address from,
 360 |     |         address to,
 361 |     |         uint256 amount
 362 |     |     ) internal virtual {}
 363 |     | 
 364 |     |     /**
 365 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 366 |     |      * minting and burning.
 367 |     |      *
 368 |     |      * Calling conditions:
 369 |     |      *
 370 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 371 |     |      * has been transferred to `to`.
 372 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 373 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 374 |     |      * - `from` and `to` are never both zero.
 375 |     |      *
 376 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 377 |     |      */
 378 | *   |     function _afterTokenTransfer(
 379 |     |         address from,
 380 |     |         address to,
 381 |     |         uint256 amount
 382 |     |     ) internal virtual {}
 383 |     | }
 384 |     | 

/home/ec2-user/git/cover/contracts/external/openzeppelin/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(
 78 |     |         address from,
 79 |     |         address to,
 80 |     |         uint256 amount
 81 |     |     ) external returns (bool);
 82 |     | }
 83 |     | 

/home/ec2-user/git/cover/contracts/external/openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../ERC20.sol";
  7 |     | import "../../../utils/Context.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev Extension of {ERC20} that allows token holders to destroy both their own
 11 |     |  * tokens and those that they have an allowance for, in a way that can be
 12 |     |  * recognized off-chain (via event analysis).
 13 |     |  */
 14 |     | abstract contract ERC20Burnable is Context, ERC20 {
 15 |     |     /**
 16 |     |      * @dev Destroys `amount` tokens from the caller.
 17 |     |      *
 18 |     |      * See {ERC20-_burn}.
 19 |     |      */
 20 |     |     function burn(uint256 amount) public virtual {
 21 |     |         _burn(_msgSender(), amount);
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Destroys `amount` tokens from `account`, deducting from the caller's
 26 |     |      * allowance.
 27 |     |      *
 28 |     |      * See {ERC20-_burn} and {ERC20-allowance}.
 29 |     |      *
 30 |     |      * Requirements:
 31 |     |      *
 32 |     |      * - the caller must have allowance for ``accounts``'s tokens of at least
 33 |     |      * `amount`.
 34 |     |      */
 35 |     |     function burnFrom(address account, uint256 amount) public virtual {
 36 |     |         _spendAllowance(account, _msgSender(), amount);
 37 |     |         _burn(account, amount);
 38 |     |     }
 39 |     | }
 40 |     | 

/home/ec2-user/git/cover/contracts/external/openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | pragma solidity 0.8.13;
  4 |     | 
  5 |     | import {IERC20} from "../IERC20.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
  9 |     |  */
 10 |     | interface IERC20Metadata is IERC20 {
 11 |     |     /**
 12 |     |      * @dev Returns the name of the token.
 13 |     |      */
 14 |     |     function name() external view returns (string memory);
 15 |     | 
 16 |     |     /**
 17 |     |      * @dev Returns the symbol of the token.
 18 |     |      */
 19 |     |     function symbol() external view returns (string memory);
 20 |     | 
 21 |     |     /**
 22 |     |      * @dev Returns the decimals places of the token.
 23 |     |      */
 24 |     |     function decimals() external view returns (uint8);
 25 |     | }

/home/ec2-user/git/cover/contracts/external/openzeppelin/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 | *   |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | }
 25 |     | 

/home/ec2-user/git/cover/contracts/external/openzeppelin/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/home/ec2-user/git/cover/contracts/external/openzeppelin/security/ReentrancyGuard.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)
   3 |     | 
   4 |     | pragma solidity 0.8.13;
   5 |     | 
   6 |     | import '../../../base/storage/CoverPoolStorage.sol';
   7 |     | import '../../../interfaces/cover/ICoverPool.sol';
   8 |     | import '../../../interfaces/structs/CoverPoolStructs.sol';
   9 |     | import '../../../libraries/Ticks.sol';
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
  13 |     |  *
  14 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
  15 |     |  * available, which can be applied to functions to make sure there are no nested
  16 |     |  * (reentrant) calls to them.
  17 |     |  *
  18 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
  19 |     |  * `nonReentrant` may not call one another. This can be worked around by making
  20 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
  21 |     |  * points to them.
  22 |     |  *
  23 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
  24 |     |  * to protect against it, check out our blog post
  25 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
  26 |     |  */
  27 |     | abstract contract ReentrancyGuard is CoverPoolStructs, CoverPoolStorage {
  28 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
  29 |     |     // word because each write operation emits an extra SLOAD to first read the
  30 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
  31 |     |     // back. This is the compiler's defense against contract upgrades and
  32 |     |     // pointer aliasing, and it cannot be disabled.
  33 |     | 
  34 |     |     // The values being non-zero value makes deployment a bit more expensive,
  35 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
  36 |     |     // amount. Since refunds are capped to a percentage of the total
  37 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
  38 |     |     // increase the likelihood of the full refund coming into effect.
  39 |     |     uint8 private constant _UNINITIALIZED = 0;
  40 |     |     uint8 private constant _NOT_ENTERED = 1;
  41 |     |     uint8 private constant _ENTERED = 2;
  42 |     | 
  43 |     |     /**
  44 |     |      * @dev Unauthorized reentrant call.
  45 |     |      */
  46 |     |     error ReentrancyGuardReentrantCall();
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Unauthorized read-only reentrant call.
  50 |     |      */
  51 |     |     error ReentrancyGuardReadOnlyReentrantCall();
  52 |     | 
  53 |     |     /**
  54 |     |      * @dev Reentrant state invalid.
  55 |     |      */
  56 |     |     error ReentrancyGuardInvalidState();
  57 |     | 
  58 |     |     /**
  59 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
  60 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
  61 |     |      * function is not supported. It is possible to prevent this from happening
  62 |     |      * by making the `nonReentrant` function external, and making it call a
  63 |     |      * `private` function that does the actual work.
  64 |     |      */
  65 |     |     modifier nonReentrant(GlobalState storage state) {
  66 |     |         _nonReentrantBefore(state);
  67 |     |         _;
  68 |     |         _nonReentrantAfter(state);
  69 |     |     }
  70 |     | 
  71 |     |     function _nonReentrantBefore(GlobalState storage state) private {
  72 |     |         // On the first call to nonReentrant, _status will be _NOT_ENTERED
  73 |     |         if (state.unlocked == _ENTERED) {
  74 |     |             // pool has been reentered
  75 |     |             revert ReentrancyGuardReentrantCall();
  76 |     |         } else if (state.unlocked == _UNINITIALIZED) {
  77 |     |             // pool has not been initialized
  78 |     |             Ticks.initialize(tickMap, pool0, pool1, globalState, ICoverPool(address(this)).immutables());
  79 |     |             if (state.unlocked == 0) revert WaitUntilTwapLengthSufficient();
  80 |     |         } else if (state.unlocked != _NOT_ENTERED) {
  81 |     |             // unexpected state
  82 |     |             revert ReentrancyGuardInvalidState();
  83 |     |         }
  84 |     |         // Any calls to nonReentrant after this point will fail
  85 |     |         state.unlocked = _ENTERED;
  86 |     |     }
  87 |     | 
  88 |     |     function _nonReentrantAfter(GlobalState storage state) private {
  89 |     |         if (state.unlocked != _ENTERED) revert ReentrancyGuardInvalidState();
  90 |     |         // By storing the original value once again, a refund is triggered (see
  91 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
  92 |     |         state.unlocked = _NOT_ENTERED;
  93 |     |     }
  94 |     | 
  95 |     |     /**
  96 |     |      * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
  97 |     |      * `nonReentrant` function in the call stack.
  98 |     |      */
  99 |     |     function _reentrancyGuardEntered(GlobalState storage state) internal view returns (bool) {
 100 |     |         return state.unlocked == _ENTERED;
 101 |     |     }
 102 |     | }

/home/ec2-user/git/cover/contracts/external/solady/Clone.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /// @notice Class with helper read functions for clone with immutable args.
   5 |     | /// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Clone.sol)
   6 |     | /// @author Adapted from clones with immutable args by zefram.eth, Saw-mon & Natalie
   7 |     | /// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)
   8 |     | abstract contract Clone {
   9 |     |     /// @dev Reads an immutable arg with type bytes.
  10 |     |     function _getArgBytes(uint256 argOffset, uint256 length)
  11 |     |         internal
  12 |     |         pure
  13 |     |         returns (bytes memory arg)
  14 |     |     {
  15 |     |         uint256 offset = _getImmutableArgsOffset();
  16 |     |         /// @solidity memory-safe-assembly
  17 |     |         assembly {
  18 |     |             arg := mload(0x40)
  19 |     |             mstore(arg, length) // Store the length.
  20 |     |             calldatacopy(add(arg, 0x20), add(offset, argOffset), length)
  21 |     |             let o := add(add(arg, 0x20), length)
  22 |     |             mstore(o, 0) // Zeroize the slot after the bytes.
  23 |     |             mstore(0x40, add(o, 0x20)) // Allocate the memory.
  24 |     |         }
  25 |     |     }
  26 |     | 
  27 |     |     /// @dev Reads an immutable arg with type address.
  28 |     |     function _getArgAddress(uint256 argOffset) internal pure returns (address arg) {
  29 |     |         uint256 offset = _getImmutableArgsOffset();
  30 |     |         /// @solidity memory-safe-assembly
  31 |     |         assembly {
  32 |     |             arg := shr(96, calldataload(add(offset, argOffset)))
  33 |     |         }
  34 |     |     }
  35 |     | 
  36 |     |     /// @dev Reads a uint256 array stored in the immutable args.
  37 |     |     function _getArgUint256Array(uint256 argOffset, uint256 length)
  38 |     |         internal
  39 |     |         pure
  40 |     |         returns (uint256[] memory arg)
  41 |     |     {
  42 |     |         uint256 offset = _getImmutableArgsOffset();
  43 |     |         /// @solidity memory-safe-assembly
  44 |     |         assembly {
  45 |     |             arg := mload(0x40)
  46 |     |             mstore(arg, length) // Store the length.
  47 |     |             calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))
  48 |     |             mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 |     |     /// @dev Reads a bytes32 array stored in the immutable args.
  53 |     |     function _getArgBytes32Array(uint256 argOffset, uint256 length)
  54 |     |         internal
  55 |     |         pure
  56 |     |         returns (bytes32[] memory arg)
  57 |     |     {
  58 |     |         uint256 offset = _getImmutableArgsOffset();
  59 |     |         /// @solidity memory-safe-assembly
  60 |     |         assembly {
  61 |     |             arg := mload(0x40)
  62 |     |             mstore(arg, length) // Store the length.
  63 |     |             calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))
  64 |     |             mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.
  65 |     |         }
  66 |     |     }
  67 |     | 
  68 |     |     /// @dev Reads an immutable arg with type bytes32.
  69 |     |     function _getArgBytes32(uint256 argOffset) internal pure returns (bytes32 arg) {
  70 |     |         uint256 offset = _getImmutableArgsOffset();
  71 |     |         /// @solidity memory-safe-assembly
  72 |     |         assembly {
  73 |     |             arg := calldataload(add(offset, argOffset))
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /// @dev Reads an immutable arg with type uint256.
  78 |     |     function _getArgUint256(uint256 argOffset) internal pure returns (uint256 arg) {
  79 |     |         uint256 offset = _getImmutableArgsOffset();
  80 |     |         /// @solidity memory-safe-assembly
  81 |     |         assembly {
  82 |     |             arg := calldataload(add(offset, argOffset))
  83 |     |         }
  84 |     |     }
  85 |     | 
  86 |     |     /// @dev Reads an immutable arg with type uint248.
  87 |     |     function _getArgUint248(uint256 argOffset) internal pure returns (uint248 arg) {
  88 |     |         uint256 offset = _getImmutableArgsOffset();
  89 |     |         /// @solidity memory-safe-assembly
  90 |     |         assembly {
  91 |     |             arg := shr(8, calldataload(add(offset, argOffset)))
  92 |     |         }
  93 |     |     }
  94 |     | 
  95 |     |     /// @dev Reads an immutable arg with type uint240.
  96 |     |     function _getArgUint240(uint256 argOffset) internal pure returns (uint240 arg) {
  97 |     |         uint256 offset = _getImmutableArgsOffset();
  98 |     |         /// @solidity memory-safe-assembly
  99 |     |         assembly {
 100 |     |             arg := shr(16, calldataload(add(offset, argOffset)))
 101 |     |         }
 102 |     |     }
 103 |     | 
 104 |     |     /// @dev Reads an immutable arg with type uint232.
 105 |     |     function _getArgUint232(uint256 argOffset) internal pure returns (uint232 arg) {
 106 |     |         uint256 offset = _getImmutableArgsOffset();
 107 |     |         /// @solidity memory-safe-assembly
 108 |     |         assembly {
 109 |     |             arg := shr(24, calldataload(add(offset, argOffset)))
 110 |     |         }
 111 |     |     }
 112 |     | 
 113 |     |     /// @dev Reads an immutable arg with type uint224.
 114 |     |     function _getArgUint224(uint256 argOffset) internal pure returns (uint224 arg) {
 115 |     |         uint256 offset = _getImmutableArgsOffset();
 116 |     |         /// @solidity memory-safe-assembly
 117 |     |         assembly {
 118 |     |             arg := shr(0x20, calldataload(add(offset, argOffset)))
 119 |     |         }
 120 |     |     }
 121 |     | 
 122 |     |     /// @dev Reads an immutable arg with type uint216.
 123 |     |     function _getArgUint216(uint256 argOffset) internal pure returns (uint216 arg) {
 124 |     |         uint256 offset = _getImmutableArgsOffset();
 125 |     |         /// @solidity memory-safe-assembly
 126 |     |         assembly {
 127 |     |             arg := shr(40, calldataload(add(offset, argOffset)))
 128 |     |         }
 129 |     |     }
 130 |     | 
 131 |     |     /// @dev Reads an immutable arg with type uint208.
 132 |     |     function _getArgUint208(uint256 argOffset) internal pure returns (uint208 arg) {
 133 |     |         uint256 offset = _getImmutableArgsOffset();
 134 |     |         /// @solidity memory-safe-assembly
 135 |     |         assembly {
 136 |     |             arg := shr(48, calldataload(add(offset, argOffset)))
 137 |     |         }
 138 |     |     }
 139 |     | 
 140 |     |     /// @dev Reads an immutable arg with type uint200.
 141 |     |     function _getArgUint200(uint256 argOffset) internal pure returns (uint200 arg) {
 142 |     |         uint256 offset = _getImmutableArgsOffset();
 143 |     |         /// @solidity memory-safe-assembly
 144 |     |         assembly {
 145 |     |             arg := shr(56, calldataload(add(offset, argOffset)))
 146 |     |         }
 147 |     |     }
 148 |     | 
 149 |     |     /// @dev Reads an immutable arg with type uint192.
 150 |     |     function _getArgUint192(uint256 argOffset) internal pure returns (uint192 arg) {
 151 |     |         uint256 offset = _getImmutableArgsOffset();
 152 |     |         /// @solidity memory-safe-assembly
 153 |     |         assembly {
 154 |     |             arg := shr(64, calldataload(add(offset, argOffset)))
 155 |     |         }
 156 |     |     }
 157 |     | 
 158 |     |     /// @dev Reads an immutable arg with type uint184.
 159 |     |     function _getArgUint184(uint256 argOffset) internal pure returns (uint184 arg) {
 160 |     |         uint256 offset = _getImmutableArgsOffset();
 161 |     |         /// @solidity memory-safe-assembly
 162 |     |         assembly {
 163 |     |             arg := shr(72, calldataload(add(offset, argOffset)))
 164 |     |         }
 165 |     |     }
 166 |     | 
 167 |     |     /// @dev Reads an immutable arg with type uint176.
 168 |     |     function _getArgUint176(uint256 argOffset) internal pure returns (uint176 arg) {
 169 |     |         uint256 offset = _getImmutableArgsOffset();
 170 |     |         /// @solidity memory-safe-assembly
 171 |     |         assembly {
 172 |     |             arg := shr(80, calldataload(add(offset, argOffset)))
 173 |     |         }
 174 |     |     }
 175 |     | 
 176 |     |     /// @dev Reads an immutable arg with type uint168.
 177 |     |     function _getArgUint168(uint256 argOffset) internal pure returns (uint168 arg) {
 178 |     |         uint256 offset = _getImmutableArgsOffset();
 179 |     |         /// @solidity memory-safe-assembly
 180 |     |         assembly {
 181 |     |             arg := shr(88, calldataload(add(offset, argOffset)))
 182 |     |         }
 183 |     |     }
 184 |     | 
 185 |     |     /// @dev Reads an immutable arg with type uint160.
 186 |     |     function _getArgUint160(uint256 argOffset) internal pure returns (uint160 arg) {
 187 |     |         uint256 offset = _getImmutableArgsOffset();
 188 |     |         /// @solidity memory-safe-assembly
 189 |     |         assembly {
 190 |     |             arg := shr(96, calldataload(add(offset, argOffset)))
 191 |     |         }
 192 |     |     }
 193 |     | 
 194 |     |     /// @dev Reads an immutable arg with type uint152.
 195 |     |     function _getArgUint152(uint256 argOffset) internal pure returns (uint152 arg) {
 196 |     |         uint256 offset = _getImmutableArgsOffset();
 197 |     |         /// @solidity memory-safe-assembly
 198 |     |         assembly {
 199 |     |             arg := shr(104, calldataload(add(offset, argOffset)))
 200 |     |         }
 201 |     |     }
 202 |     | 
 203 |     |     /// @dev Reads an immutable arg with type uint144.
 204 |     |     function _getArgUint144(uint256 argOffset) internal pure returns (uint144 arg) {
 205 |     |         uint256 offset = _getImmutableArgsOffset();
 206 |     |         /// @solidity memory-safe-assembly
 207 |     |         assembly {
 208 |     |             arg := shr(112, calldataload(add(offset, argOffset)))
 209 |     |         }
 210 |     |     }
 211 |     | 
 212 |     |     /// @dev Reads an immutable arg with type uint136.
 213 |     |     function _getArgUint136(uint256 argOffset) internal pure returns (uint136 arg) {
 214 |     |         uint256 offset = _getImmutableArgsOffset();
 215 |     |         /// @solidity memory-safe-assembly
 216 |     |         assembly {
 217 |     |             arg := shr(120, calldataload(add(offset, argOffset)))
 218 |     |         }
 219 |     |     }
 220 |     | 
 221 |     |     /// @dev Reads an immutable arg with type uint128.
 222 |     |     function _getArgUint128(uint256 argOffset) internal pure returns (uint128 arg) {
 223 |     |         uint256 offset = _getImmutableArgsOffset();
 224 |     |         /// @solidity memory-safe-assembly
 225 |     |         assembly {
 226 |     |             arg := shr(128, calldataload(add(offset, argOffset)))
 227 |     |         }
 228 |     |     }
 229 |     | 
 230 |     |     /// @dev Reads an immutable arg with type uint120.
 231 |     |     function _getArgUint120(uint256 argOffset) internal pure returns (uint120 arg) {
 232 |     |         uint256 offset = _getImmutableArgsOffset();
 233 |     |         /// @solidity memory-safe-assembly
 234 |     |         assembly {
 235 |     |             arg := shr(136, calldataload(add(offset, argOffset)))
 236 |     |         }
 237 |     |     }
 238 |     | 
 239 |     |     /// @dev Reads an immutable arg with type uint112.
 240 |     |     function _getArgUint112(uint256 argOffset) internal pure returns (uint112 arg) {
 241 |     |         uint256 offset = _getImmutableArgsOffset();
 242 |     |         /// @solidity memory-safe-assembly
 243 |     |         assembly {
 244 |     |             arg := shr(144, calldataload(add(offset, argOffset)))
 245 |     |         }
 246 |     |     }
 247 |     | 
 248 |     |     /// @dev Reads an immutable arg with type uint104.
 249 |     |     function _getArgUint104(uint256 argOffset) internal pure returns (uint104 arg) {
 250 |     |         uint256 offset = _getImmutableArgsOffset();
 251 |     |         /// @solidity memory-safe-assembly
 252 |     |         assembly {
 253 |     |             arg := shr(152, calldataload(add(offset, argOffset)))
 254 |     |         }
 255 |     |     }
 256 |     | 
 257 |     |     /// @dev Reads an immutable arg with type uint96.
 258 |     |     function _getArgUint96(uint256 argOffset) internal pure returns (uint96 arg) {
 259 |     |         uint256 offset = _getImmutableArgsOffset();
 260 |     |         /// @solidity memory-safe-assembly
 261 |     |         assembly {
 262 |     |             arg := shr(160, calldataload(add(offset, argOffset)))
 263 |     |         }
 264 |     |     }
 265 |     | 
 266 |     |     /// @dev Reads an immutable arg with type uint88.
 267 |     |     function _getArgUint88(uint256 argOffset) internal pure returns (uint88 arg) {
 268 |     |         uint256 offset = _getImmutableArgsOffset();
 269 |     |         /// @solidity memory-safe-assembly
 270 |     |         assembly {
 271 |     |             arg := shr(168, calldataload(add(offset, argOffset)))
 272 |     |         }
 273 |     |     }
 274 |     | 
 275 |     |     /// @dev Reads an immutable arg with type uint80.
 276 |     |     function _getArgUint80(uint256 argOffset) internal pure returns (uint80 arg) {
 277 |     |         uint256 offset = _getImmutableArgsOffset();
 278 |     |         /// @solidity memory-safe-assembly
 279 |     |         assembly {
 280 |     |             arg := shr(176, calldataload(add(offset, argOffset)))
 281 |     |         }
 282 |     |     }
 283 |     | 
 284 |     |     /// @dev Reads an immutable arg with type uint72.
 285 |     |     function _getArgUint72(uint256 argOffset) internal pure returns (uint72 arg) {
 286 |     |         uint256 offset = _getImmutableArgsOffset();
 287 |     |         /// @solidity memory-safe-assembly
 288 |     |         assembly {
 289 |     |             arg := shr(184, calldataload(add(offset, argOffset)))
 290 |     |         }
 291 |     |     }
 292 |     | 
 293 |     |     /// @dev Reads an immutable arg with type uint64.
 294 |     |     function _getArgUint64(uint256 argOffset) internal pure returns (uint64 arg) {
 295 |     |         uint256 offset = _getImmutableArgsOffset();
 296 |     |         /// @solidity memory-safe-assembly
 297 |     |         assembly {
 298 |     |             arg := shr(192, calldataload(add(offset, argOffset)))
 299 |     |         }
 300 |     |     }
 301 |     | 
 302 |     |     /// @dev Reads an immutable arg with type uint56.
 303 |     |     function _getArgUint56(uint256 argOffset) internal pure returns (uint56 arg) {
 304 |     |         uint256 offset = _getImmutableArgsOffset();
 305 |     |         /// @solidity memory-safe-assembly
 306 |     |         assembly {
 307 |     |             arg := shr(200, calldataload(add(offset, argOffset)))
 308 |     |         }
 309 |     |     }
 310 |     | 
 311 |     |     /// @dev Reads an immutable arg with type uint48.
 312 |     |     function _getArgUint48(uint256 argOffset) internal pure returns (uint48 arg) {
 313 |     |         uint256 offset = _getImmutableArgsOffset();
 314 |     |         /// @solidity memory-safe-assembly
 315 |     |         assembly {
 316 |     |             arg := shr(208, calldataload(add(offset, argOffset)))
 317 |     |         }
 318 |     |     }
 319 |     | 
 320 |     |     /// @dev Reads an immutable arg with type uint40.
 321 |     |     function _getArgUint40(uint256 argOffset) internal pure returns (uint40 arg) {
 322 |     |         uint256 offset = _getImmutableArgsOffset();
 323 |     |         /// @solidity memory-safe-assembly
 324 |     |         assembly {
 325 |     |             arg := shr(216, calldataload(add(offset, argOffset)))
 326 |     |         }
 327 |     |     }
 328 |     | 
 329 |     |     /// @dev Reads an immutable arg with type uint32.
 330 |     |     function _getArgUint32(uint256 argOffset) internal pure returns (uint32 arg) {
 331 |     |         uint256 offset = _getImmutableArgsOffset();
 332 |     |         /// @solidity memory-safe-assembly
 333 |     |         assembly {
 334 |     |             arg := shr(224, calldataload(add(offset, argOffset)))
 335 |     |         }
 336 |     |     }
 337 |     | 
 338 |     |     /// @dev Reads an immutable arg with type uint24.
 339 |     |     function _getArgUint24(uint256 argOffset) internal pure returns (uint24 arg) {
 340 |     |         uint256 offset = _getImmutableArgsOffset();
 341 |     |         /// @solidity memory-safe-assembly
 342 |     |         assembly {
 343 |     |             arg := shr(232, calldataload(add(offset, argOffset)))
 344 |     |         }
 345 |     |     }
 346 |     | 
 347 |     |     /// @dev Reads an immutable arg with type uint16.
 348 |     |     function _getArgUint16(uint256 argOffset) internal pure returns (uint16 arg) {
 349 |     |         uint256 offset = _getImmutableArgsOffset();
 350 |     |         /// @solidity memory-safe-assembly
 351 |     |         assembly {
 352 |     |             arg := shr(240, calldataload(add(offset, argOffset)))
 353 |     |         }
 354 |     |     }
 355 |     | 
 356 |     |     /// @dev Reads an immutable arg with type uint8.
 357 |     |     function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {
 358 |     |         uint256 offset = _getImmutableArgsOffset();
 359 |     |         /// @solidity memory-safe-assembly
 360 |     |         assembly {
 361 |     |             arg := shr(248, calldataload(add(offset, argOffset)))
 362 |     |         }
 363 |     |     }
 364 |     | 
 365 |     |     /// @return offset The offset of the packed immutable args in calldata.
 366 |     |     function _getImmutableArgsOffset() internal pure returns (uint256 offset) {
 367 |     |         /// @solidity memory-safe-assembly
 368 |     |         assembly {
 369 |     |             offset := sub(calldatasize(), shr(240, calldataload(sub(calldatasize(), 2))))
 370 |     |         }
 371 |     |     }
 372 |     | }

/home/ec2-user/git/cover/contracts/external/solady/LibClone.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /// @notice Minimal proxy library.
   5 |     | /// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)
   6 |     | /// @author Minimal proxy by 0age (https://github.com/0age)
   7 |     | /// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie
   8 |     | /// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)
   9 |     | ///
  10 |     | /// @dev Minimal proxy:
  11 |     | /// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,
  12 |     | /// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,
  13 |     | /// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.
  14 |     | ///
  15 |     | /// @dev Clones with immutable args (CWIA):
  16 |     | /// The implementation of CWIA here implements a `receive()` method that emits the
  17 |     | /// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,
  18 |     | /// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards
  19 |     | /// composability. The minimal proxy implementation does not offer this feature.
  20 |     | library LibClone {
  21 |     |     /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/
  22 |     |     /*                       CUSTOM ERRORS                        */
  23 |     |     /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/
  24 |     | 
  25 |     |     /// @dev Unable to deploy the clone.
  26 |     |     error DeploymentFailed();
  27 |     | 
  28 |     |     /// @dev The salt must start with either the zero address or the caller.
  29 |     |     error SaltDoesNotStartWithCaller();
  30 |     | 
  31 |     |     /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/
  32 |     |     /*                  MINIMAL PROXY OPERATIONS                  */
  33 |     |     /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/
  34 |     | 
  35 |     |     /// @dev Deploys a deterministic clone of `implementation`,
  36 |     |     /// using immutable  arguments encoded in `data`, with `salt`.
  37 |     |     function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)
  38 |     |         internal
  39 |     |         returns (address instance)
  40 |     |     {
  41 |     |         assembly {
  42 |     |             // Compute the boundaries of the data and cache the memory slots around it.
  43 |     |             let mBefore3 := mload(sub(data, 0x60))
  44 |     |             let mBefore2 := mload(sub(data, 0x40))
  45 |     |             let mBefore1 := mload(sub(data, 0x20))
  46 |     |             let dataLength := mload(data)
  47 |     |             let dataEnd := add(add(data, 0x20), dataLength)
  48 |     |             let mAfter1 := mload(dataEnd)
  49 |     | 
  50 |     |             // +2 bytes for telling how much data there is appended to the call.
  51 |     |             let extraLength := add(dataLength, 2)
  52 |     | 
  53 |     |             // Write the bytecode before the data.
  54 |     |             mstore(data, 0x5af43d3d93803e606057fd5bf3)
  55 |     |             // Write the address of the implementation.
  56 |     |             mstore(sub(data, 0x0d), implementation)
  57 |     |             // Write the rest of the bytecode.
  58 |     |             mstore(
  59 |     |                 sub(data, 0x21),
  60 |     |                 or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)
  61 |     |             )
  62 |     |             // `keccak256("ReceiveETH(uint256)")`
  63 |     |             mstore(
  64 |     |                 sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff
  65 |     |             )
  66 |     |             mstore(
  67 |     |                 sub(data, 0x5a),
  68 |     |                 or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)
  69 |     |             )
  70 |     |             mstore(dataEnd, shl(0xf0, extraLength))
  71 |     | 
  72 |     |             // Create the instance.
  73 |     |             instance := create2(0, sub(data, 0x4c), add(extraLength, 0x6c), salt)
  74 |     | 
  75 |     |             // If `instance` is zero, revert.
  76 |     |             if iszero(instance) {
  77 |     |                 // Store the function selector of `DeploymentFailed()`.
  78 |     |                 mstore(0x00, 0x30116425)
  79 |     |                 // Revert with (offset, size).
  80 |     |                 revert(0x1c, 0x04)
  81 |     |             }
  82 |     | 
  83 |     |             // Restore the overwritten memory surrounding `data`.
  84 |     |             mstore(dataEnd, mAfter1)
  85 |     |             mstore(data, dataLength)
  86 |     |             mstore(sub(data, 0x20), mBefore1)
  87 |     |             mstore(sub(data, 0x40), mBefore2)
  88 |     |             mstore(sub(data, 0x60), mBefore3)
  89 |     |         }
  90 |     |     }
  91 |     | 
  92 |     |     /// @dev Returns the initialization code hash of the clone of `implementation`
  93 |     |     /// using immutable arguments encoded in `data`.
  94 |     |     /// Used for mining vanity addresses with create2crunch.
  95 |     |     function initCodeHash(address implementation, bytes memory data)
  96 |     |         internal
  97 |     |         pure
  98 |     |         returns (bytes32 hash)
  99 |     |     {
 100 |     |         assembly {
 101 |     |             // Compute the boundaries of the data and cache the memory slots around it.
 102 |     |             let mBefore3 := mload(sub(data, 0x60))
 103 |     |             let mBefore2 := mload(sub(data, 0x40))
 104 |     |             let mBefore1 := mload(sub(data, 0x20))
 105 |     |             let dataLength := mload(data)
 106 |     |             let dataEnd := add(add(data, 0x20), dataLength)
 107 |     |             let mAfter1 := mload(dataEnd)
 108 |     | 
 109 |     |             // +2 bytes for telling how much data there is appended to the call.
 110 |     |             let extraLength := add(dataLength, 2)
 111 |     | 
 112 |     |             // Write the bytecode before the data.
 113 |     |             mstore(data, 0x5af43d3d93803e606057fd5bf3)
 114 |     |             // Write the address of the implementation.
 115 |     |             mstore(sub(data, 0x0d), implementation)
 116 |     |             // Write the rest of the bytecode.
 117 |     |             mstore(
 118 |     |                 sub(data, 0x21),
 119 |     |                 or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)
 120 |     |             )
 121 |     |             // `keccak256("ReceiveETH(uint256)")`
 122 |     |             mstore(
 123 |     |                 sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff
 124 |     |             )
 125 |     |             mstore(
 126 |     |                 sub(data, 0x5a),
 127 |     |                 or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)
 128 |     |             )
 129 |     |             mstore(dataEnd, shl(0xf0, extraLength))
 130 |     | 
 131 |     |             // Compute and store the bytecode hash.
 132 |     |             hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))
 133 |     | 
 134 |     |             // Restore the overwritten memory surrounding `data`.
 135 |     |             mstore(dataEnd, mAfter1)
 136 |     |             mstore(data, dataLength)
 137 |     |             mstore(sub(data, 0x20), mBefore1)
 138 |     |             mstore(sub(data, 0x40), mBefore2)
 139 |     |             mstore(sub(data, 0x60), mBefore3)
 140 |     |         }
 141 |     |     }
 142 |     | 
 143 |     |     /// @dev Returns the address of the deterministic clone of
 144 |     |     /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.
 145 |     |     function predictDeterministicAddress(
 146 |     |         address implementation,
 147 |     |         bytes memory data,
 148 |     |         bytes32 salt,
 149 |     |         address deployer
 150 |     |     ) internal pure returns (address predicted) {
 151 |     |         bytes32 hash = initCodeHash(implementation, data);
 152 |     |         predicted = predictDeterministicAddress(hash, salt, deployer);
 153 |     |     }
 154 |     | 
 155 |     |     /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/
 156 |     |     /*                      OTHER OPERATIONS                      */
 157 |     |     /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/
 158 |     | 
 159 |     |     /// @dev Returns the address when a contract with initialization code hash,
 160 |     |     /// `hash`, is deployed with `salt`, by `deployer`.
 161 |     |     function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)
 162 |     |         internal
 163 |     |         pure
 164 |     |         returns (address predicted)
 165 |     |     {
 166 |     |         /// @solidity memory-safe-assembly
 167 |     |         assembly {
 168 |     |             // Compute and store the bytecode hash.
 169 |     |             mstore8(0x00, 0xff) // Write the prefix.
 170 |     |             mstore(0x35, hash)
 171 |     |             mstore(0x01, shl(96, deployer))
 172 |     |             mstore(0x15, salt)
 173 |     |             predicted := keccak256(0x00, 0x55)
 174 |     |             // Restore the part of the free memory pointer that has been overwritten.
 175 |     |             mstore(0x35, 0)
 176 |     |         }
 177 |     |     }
 178 |     | 
 179 |     |     /// @dev Reverts if `salt` does not start with either the zero address or the caller.
 180 |     |     function checkStartsWithCaller(bytes32 salt) internal view {
 181 |     |         /// @solidity memory-safe-assembly
 182 |     |         assembly {
 183 |     |             // If the salt does not start with the zero address or the caller.
 184 |     |             if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {
 185 |     |                 // Store the function selector of `SaltDoesNotStartWithCaller()`.
 186 |     |                 mstore(0x00, 0x2f634836)
 187 |     |                 // Revert with (offset, size).
 188 |     |                 revert(0x1c, 0x04)
 189 |     |             }
 190 |     |         }
 191 |     |     }
 192 |     | }

/home/ec2-user/git/cover/contracts/interfaces/IERC20Minimal.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | interface IERC20Minimal {
  5 |     |     /// @notice Returns the balance of a token
  6 |     |     /// @param account The address for which to look up the balance for
  7 |     |     /// @return amount of tokens held by the account
  8 |     |     function balanceOf(address account) external view returns (uint256);
  9 |     | }

/home/ec2-user/git/cover/contracts/interfaces/IPool.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../interfaces/structs/PoolsharkStructs.sol';
  5 |     | 
  6 |     | interface IPool is PoolsharkStructs {
  7 |     |     function swap(
  8 |     |         SwapParams memory params
  9 |     |     ) external returns (
 10 |     |         int256 amount0,
 11 |     |         int256 amount1
 12 |     |     );
 13 |     | 
 14 |     |     function quote(
 15 |     |         QuoteParams memory params
 16 |     |     ) external view returns (
 17 |     |         int256 inAmount,
 18 |     |         int256 outAmount,
 19 |     |         uint160 priceAfter
 20 |     |     );
 21 |     | }
 22 |     | 

/home/ec2-user/git/cover/contracts/interfaces/IPositionERC1155.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.13;
  4 |     | 
  5 |     | import '../interfaces/structs/PoolsharkStructs.sol';
  6 |     | import "../external/openzeppelin/contracts/utils/introspection/IERC165.sol";
  7 |     | 
  8 |     | interface IPositionERC1155 is IERC165, PoolsharkStructs {
  9 |     |     event TransferSingle(
 10 |     |         address indexed sender,
 11 |     |         address indexed from,
 12 |     |         address indexed to,
 13 |     |         uint256 id,
 14 |     |         uint256 amount
 15 |     |     );
 16 |     | 
 17 |     |     event TransferBatch(
 18 |     |         address indexed sender,
 19 |     |         address indexed from,
 20 |     |         address indexed to,
 21 |     |         uint256[] ids,
 22 |     |         uint256[] amounts
 23 |     |     );
 24 |     | 
 25 |     |     event ApprovalForAll(
 26 |     |         address indexed account,
 27 |     |         address indexed sender,
 28 |     |         bool approve
 29 |     |     );
 30 |     | 
 31 |     |     function name() external view returns (string memory);
 32 |     | 
 33 |     |     function symbol() external view returns (string memory);
 34 |     | 
 35 |     |     function balanceOf(address account, uint256 id) external view returns (uint256);
 36 |     | 
 37 |     |     function balanceOfBatch(
 38 |     |         address[] calldata accounts,
 39 |     |         uint256[] calldata ids
 40 |     |     ) external view returns (
 41 |     |         uint256[] memory batchBalances
 42 |     |     );
 43 |     | 
 44 |     |     function totalSupply(uint256 id) external view returns (uint256);
 45 |     | 
 46 |     |     function isApprovedForAll(address owner, address spender) external view returns (bool);
 47 |     | 
 48 |     |     function setApprovalForAll(address sender, bool approved) external;
 49 |     | 
 50 |     |     function mint(
 51 |     |         address account,
 52 |     |         uint256 id,
 53 |     |         uint256 amount,
 54 |     |         PoolsharkStructs.CoverImmutables memory constants
 55 |     |     ) external;
 56 |     | 
 57 |     |     function burn(
 58 |     |         address account,
 59 |     |         uint256 id,
 60 |     |         uint256 amount,
 61 |     |         PoolsharkStructs.CoverImmutables memory constants
 62 |     |     ) external;
 63 |     | 
 64 |     |     function safeTransferFrom(
 65 |     |         address from,
 66 |     |         address to,
 67 |     |         uint256 id,
 68 |     |         uint256 amount
 69 |     |     ) external;
 70 |     | 
 71 |     |     function safeBatchTransferFrom(
 72 |     |         address from,
 73 |     |         address to,
 74 |     |         uint256[] calldata id,
 75 |     |         uint256[] calldata amount
 76 |     |     ) external;
 77 |     | }

/home/ec2-user/git/cover/contracts/interfaces/callbacks/ICoverPoolSwapCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | /// @title Callback for swaps
  5 |     | /// @notice Any contract that calls the `swap` function must implement this interface.
  6 |     | interface ICoverPoolSwapCallback {
  7 |     |     /// @notice Called to `msg.sender` after executing a swap.
  8 |     |     /// @dev In the implementation you must pay the pool tokens owed for the swap.
  9 |     |     /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.
 10 |     |     /// @param amount0Delta The amount of token0 either received by (positive) or sent from (negative) the user.
 11 |     |     /// @param amount1Delta The amount of token1 either received by (positive) or sent from (negative) the user.
 12 |     |     function coverPoolSwapCallback(
 13 |     |         int256 amount0Delta,
 14 |     |         int256 amount1Delta,
 15 |     |         bytes calldata data
 16 |     |     ) external;
 17 |     | }

/home/ec2-user/git/cover/contracts/interfaces/cover/ICoverPool.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../structs/CoverPoolStructs.sol';
   5 |     | import '../structs/PoolsharkStructs.sol';
   6 |     | 
   7 |     | /**
   8 |     |  * @title ICoverPool
   9 |     |  * @author Poolshark
  10 |     |  * @notice Defines the basic interface for a Cover Pool.
  11 |     |  */
  12 |     | interface ICoverPool is CoverPoolStructs {
  13 |     |     /**
  14 |     |      * @custom:struct MintParams
  15 |     |      */
  16 |     |     struct MintParams {
  17 |     |         /**
  18 |     |          * @custom:field to
  19 |     |          * @notice Address for the receiver of the minted position
  20 |     |          */
  21 |     |         address to;
  22 |     | 
  23 |     |         /**
  24 |     |          * @custom:field amount
  25 |     |          * @notice Token amount to be deposited into the minted position
  26 |     |          */
  27 |     |         uint128 amount;
  28 |     | 
  29 |     |         /**
  30 |     |          * @custom:field positionId
  31 |     |          * @notice 0 if creating a new position; id of previous if adding liquidity
  32 |     |          */
  33 |     |         uint32 positionId;
  34 |     | 
  35 |     |         /**
  36 |     |          * @custom:field lower
  37 |     |          * @notice The lower price tick for the position range
  38 |     |          */
  39 |     |         int24 lower;
  40 |     | 
  41 |     |         /**
  42 |     |          * @custom:field upper
  43 |     |          * @notice The upper price tick for the position range
  44 |     |          */
  45 |     |         int24 upper;
  46 |     | 
  47 |     |         /**
  48 |     |          * @custom:field zeroForOne
  49 |     |          * @notice True if depositing token0, the first token address in lexographical order
  50 |     |          * @notice False if depositing token1, the second token address in lexographical order 
  51 |     |          */
  52 |     |         bool zeroForOne;
  53 |     |     }
  54 |     | 
  55 |     |     /**
  56 |     |      * @notice Deposits `amountIn` of asset to be auctioned off each time price range is crossed further into.
  57 |     |      * - E.g. User supplies 1 WETH in the range 1500 USDC per WETH to 1400 USDC per WETH
  58 |     |               As latestTick crosses from 1500 USDC per WETH to 1400 USDC per WETH,
  59 |     |               the user's liquidity within each tick spacing is auctioned off.
  60 |     |      * @dev The position will be shrunk onto the correct side of latestTick.
  61 |     |      * @dev The position will be minted with the `to` address as the owner.
  62 |     |      * @param params The parameters for the function. See MintParams above.
  63 |     |      */
  64 |     |     function mint(
  65 |     |         MintParams memory params
  66 |     |     ) external;
  67 |     | 
  68 |     |     /**
  69 |     |      * @custom:struct BurnParams
  70 |     |      */
  71 |     |     struct BurnParams {
  72 |     |         /**
  73 |     |          * @custom:field to
  74 |     |          * @notice Address for the receiver of the collected position amounts
  75 |     |          */
  76 |     |         address to;
  77 |     | 
  78 |     |         /**
  79 |     |          * @custom:field burnPercent
  80 |     |          * @notice Percent of the remaining liquidity to be removed
  81 |     |          * @notice 1e38 represents 100%
  82 |     |          * @notice 5e37 represents 50%
  83 |     |          * @notice 1e37 represents 10%
  84 |     |          */
  85 |     |         uint128 burnPercent;
  86 |     | 
  87 |     |         /**
  88 |     |          * @custom:field positionId
  89 |     |          * @notice 0 if creating a new position; id of previous if adding liquidity
  90 |     |          */
  91 |     |         uint32 positionId;
  92 |     | 
  93 |     |         /**
  94 |     |          * @custom:field claim
  95 |     |          * @notice The most recent tick crossed in this range
  96 |     |          * @notice if `zeroForOne` is true, claim tick progresses from upper => lower
  97 |     |          * @notice if `zeroForOne` is false, claim tick progresses from lower => upper
  98 |     |          */
  99 |     |         int24 claim;
 100 |     | 
 101 |     |         /**
 102 |     |          * @custom:field zeroForOne
 103 |     |          * @notice True if deposited token0, the first token address in lexographical order
 104 |     |          * @notice False if deposited token1, the second token address in lexographical order 
 105 |     |          */
 106 |     |         bool zeroForOne;
 107 |     | 
 108 |     |         /**
 109 |     |          * @custom:field sync
 110 |     |          * @notice True will sync the pool latestTick
 111 |     |          * @notice False will skip syncing latestTick 
 112 |     |          */
 113 |     |         bool sync;
 114 |     |     }
 115 |     | 
 116 |     |     /**
 117 |     |      * @notice Withdraws the input token and returns any filled and/or unfilled amounts to the 'to' address specified. 
 118 |     |      * - E.g. User supplies 1 WETH in the range 1500 USDC per WETH to 1400 USDC per WETH
 119 |     |               As latestTick crosses from 1500 USDC per WETH to 1400 USDC per WETH,
 120 |     |               the user's liquidity within each tick spacing is auctioned off.
 121 |     |      * @dev The position will be shrunk based on the claim tick passed.
 122 |     |      * @dev The position amounts will be returned to the `to` address specified.
 123 |     |      * @dev The `sync` flag can be set to false so users can exit safely without syncing latestTick.
 124 |     |      * @param params The parameters for the function. See BurnParams above.
 125 |     |      */
 126 |     |     function burn(
 127 |     |         BurnParams memory params
 128 |     |     ) external; 
 129 |     | 
 130 |     |     /**
 131 |     |      * @notice Swaps `tokenIn` for `tokenOut`. 
 132 |     |                `tokenIn` will be `token0` if `zeroForOne` is true.
 133 |     |                `tokenIn` will be `token1` if `zeroForOne` is false.
 134 |     |                The pool price represents token1 per token0.
 135 |     |                The pool price will decrease if `zeroForOne` is true.
 136 |     |                The pool price will increase if `zeroForOne` is false. 
 137 |     |      * @param params The parameters for the function. See SwapParams above.
 138 |     |      * @return amount0Delta The amount of token0 spent (negative) or received (positive) by the user
 139 |     |      * @return amount1Delta The amount of token1 spent (negative) or received (positive) by the user
 140 |     |      */
 141 |     |     function swap(
 142 |     |         SwapParams memory params
 143 |     |     ) external returns (
 144 |     |         int256 amount0Delta,
 145 |     |         int256 amount1Delta
 146 |     |     );
 147 |     | 
 148 |     |     /**
 149 |     |      * @notice Quotes the amount of `tokenIn` for `tokenOut`. 
 150 |     |                `tokenIn` will be `token0` if `zeroForOne` is true.
 151 |     |                `tokenIn` will be `token1` if `zeroForOne` is false.
 152 |     |                The pool price represents token1 per token0.
 153 |     |                The pool price will decrease if `zeroForOne` is true.
 154 |     |                The pool price will increase if `zeroForOne` is false. 
 155 |     |      * @param params The parameters for the function. See SwapParams above.
 156 |     |      * @return inAmount  The amount of tokenIn to be spent
 157 |     |      * @return outAmount The amount of tokenOut to be received
 158 |     |      * @return priceAfter The Q64.96 square root price after the swap
 159 |     |      */
 160 |     |     function quote(
 161 |     |         QuoteParams memory params
 162 |     |     ) external returns (
 163 |     |         int256 inAmount,
 164 |     |         int256 outAmount,
 165 |     |         uint256 priceAfter
 166 |     |     );
 167 |     | 
 168 |     |     /**
 169 |     |      * @custom:struct SnapshotParams
 170 |     |      */
 171 |     |     struct SnapshotParams {
 172 |     |         /**
 173 |     |          * @custom:field to
 174 |     |          * @notice Address of the position owner
 175 |     |          */
 176 |     |         address owner;
 177 |     | 
 178 |     |         /**
 179 |     |          * @custom:field positionId
 180 |     |          * @notice id of position
 181 |     |          */
 182 |     |         uint32 positionId;
 183 |     | 
 184 |     |         /**
 185 |     |          * @custom:field burnPercent
 186 |     |          * @notice Percent of the remaining liquidity to be removed
 187 |     |          * @notice 1e38 represents 100%
 188 |     |          * @notice 5e37 represents 50%
 189 |     |          * @notice 1e37 represents 10%
 190 |     |          */
 191 |     |         uint128 burnPercent;
 192 |     | 
 193 |     |         /**
 194 |     |          * @custom:field claim
 195 |     |          * @notice The most recent tick crossed in this range
 196 |     |          * @notice if `zeroForOne` is true, claim tick progresses from upper => lower
 197 |     |          * @notice if `zeroForOne` is false, claim tick progresses from lower => upper
 198 |     |          */
 199 |     |         int24 claim;
 200 |     | 
 201 |     |         /**
 202 |     |          * @custom:field zeroForOne
 203 |     |          * @notice True if deposited token0, the first token address in lexographical order
 204 |     |          * @notice False if deposited token1, the second token address in lexographical order 
 205 |     |          */
 206 |     |         bool zeroForOne;
 207 |     |     }
 208 |     | 
 209 |     |     /**
 210 |     |      * @notice Snapshots the current state of an existing position. 
 211 |     |      * @param params The parameters for the function. See SwapParams above.
 212 |     |      * @return position The updated position containing `amountIn` and `amountOut`
 213 |     |      * @dev positions amounts reflected will be collected by the user if `burn` is called
 214 |     |      */
 215 |     |     function snapshot(
 216 |     |         SnapshotParams memory params
 217 |     |     ) external view returns (
 218 |     |         CoverPosition memory position
 219 |     |     );
 220 |     | 
 221 |     |     /**
 222 |     |      * @notice Sets and collect protocol fees from the pool. 
 223 |     |      * @param syncFee The new syncFee to be set if `setFees` is true.
 224 |     |      * @param fillFee The new fillFee to be set if `setFees` is true.
 225 |     |      * @return token0Fees The `token0` fees collected.
 226 |     |      * @return token1Fees The `token1` fees collected.
 227 |     |      * @dev `syncFee` is a basis point fee to be paid to users who sync latestTick
 228 |     |      * @dev `fillFee` is a basis point fee to be paid to the protocol for amounts filled
 229 |     |      * @dev All fees are zero by default unless the protocol decides to enable them.
 230 |     |      */
 231 |     |     function fees(
 232 |     |         uint16 syncFee,
 233 |     |         uint16 fillFee,
 234 |     |         bool setFees
 235 |     |     ) external returns (
 236 |     |         uint128 token0Fees,
 237 |     |         uint128 token1Fees
 238 |     |     );
 239 |     | 
 240 |     |     function immutables(
 241 |     |     ) external view returns (
 242 |     |         CoverImmutables memory constants
 243 |     |     );
 244 |     | 
 245 |     |     function priceBounds(
 246 |     |         int16 tickSpacing
 247 |     |     ) external pure returns (
 248 |     |         uint160 minPrice,
 249 |     |         uint160 maxPrice
 250 |     |     );
 251 |     | }
 252 |     | 

/home/ec2-user/git/cover/contracts/interfaces/cover/ICoverPoolFactory.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../base/storage/CoverPoolFactoryStorage.sol';
  5 |     | 
  6 |     | abstract contract ICoverPoolFactory is CoverPoolFactoryStorage {
  7 |     | 
  8 |     |     struct CoverPoolParams {
  9 |     |         bytes32 poolType;
 10 |     |         address tokenIn;
 11 |     |         address tokenOut;
 12 |     |         uint16 feeTier;
 13 |     |         int16  tickSpread;
 14 |     |         uint16 twapLength;
 15 |     |     }
 16 |     | 
 17 |     |     /**
 18 |     |      * @notice Creates a new CoverPool.
 19 |     |      * @param params The CoverPoolParams struct referenced above.
 20 |     |      */
 21 |     |     function createCoverPool(
 22 |     |         CoverPoolParams memory params
 23 |     |     ) external virtual returns (
 24 |     |         address pool,
 25 |     |         address poolToken
 26 |     |     );
 27 |     | 
 28 |     |     /**
 29 |     |      * @notice Fetches an existing CoverPool.
 30 |     |      * @param params The CoverPoolParams struct referenced above.
 31 |     |      */
 32 |     |     function getCoverPool(
 33 |     |         CoverPoolParams memory params
 34 |     |     ) external view virtual returns (
 35 |     |         address pool,
 36 |     |         address poolToken
 37 |     |     );
 38 |     | }
 39 |     | 

/home/ec2-user/git/cover/contracts/interfaces/cover/ICoverPoolManager.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/structs/CoverPoolStructs.sol';
  5 |     | 
  6 |     | /// @notice CoverPoolManager interface
  7 |     | interface ICoverPoolManager is CoverPoolStructs {
  8 |     |     function owner() external view returns (address);
  9 |     |     function feeTo() external view returns (address);
 10 |     |     function poolTypes(
 11 |     |         bytes32 poolType
 12 |     |     ) external view returns (
 13 |     |         address poolImpl,
 14 |     |         address tokenImpl,
 15 |     |         address twapImpl
 16 |     |     );
 17 |     |     function volatilityTiers(
 18 |     |         bytes32 implName,
 19 |     |         uint16 feeTier,
 20 |     |         int16  tickSpread,
 21 |     |         uint16 twapLength
 22 |     |     ) external view returns (
 23 |     |         VolatilityTier memory
 24 |     |     );
 25 |     | }
 26 |     | 

/home/ec2-user/git/cover/contracts/interfaces/external/uniswap/v3/IUniswapV3Factory.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title The interface for the Concentrated Liquidity Pool Factory
  5 |     | interface IUniswapV3Factory {
  6 |     |     /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled
  7 |     |     /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context
  8 |     |     /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee
  9 |     |     /// @return The tick spacing
 10 |     |     function feeTierTickSpacing(uint24 fee) external view returns (int24);
 11 |     | 
 12 |     |     /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist
 13 |     |     /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order
 14 |     |     /// @param tokenA The contract address of either token0 or token1
 15 |     |     /// @param tokenB The contract address of the other token
 16 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 17 |     |     /// @return pool The pool address
 18 |     |     function getPool(
 19 |     |         address tokenA,
 20 |     |         address tokenB,
 21 |     |         uint24 fee
 22 |     |     ) external view returns (address pool);
 23 |     | }
 24 |     | 

/home/ec2-user/git/cover/contracts/interfaces/external/uniswap/v3/IUniswapV3Pool.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | interface IUniswapV3Pool {
  5 |     |     /// @notice This is to be used at hedge pool initialization in case the cardinality is too low for the hedge pool.
  6 |     |     /// @notice Increase the maximum number of price and liquidity observations that this pool will store
  7 |     |     /// @param observationCardinalityNext The desired minimum number of observations for the pool to store
  8 |     |     function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
  9 |     | 
 10 |     |     function token0() external view returns (address);
 11 |     | 
 12 |     |     function token1() external view returns (address);
 13 |     | 
 14 |     |     function tickSpacing() external view returns (int24);
 15 |     | 
 16 |     |     /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
 17 |     |     /// when accessed externally.
 18 |     |     /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
 19 |     |     /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
 20 |     |     /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
 21 |     |     /// boundary.
 22 |     |     /// observationIndex The index of the last oracle observation that was written,
 23 |     |     /// observationCardinality The current maximum number of observations stored in the pool,
 24 |     |     /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
 25 |     |     /// feeProtocol The protocol fee for both tokens of the pool.
 26 |     |     /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
 27 |     |     /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
 28 |     |     /// unlocked Whether the pool is currently locked to reentrancy
 29 |     |     function slot0()
 30 |     |         external
 31 |     |         view
 32 |     |         returns (
 33 |     |             uint160 sqrtPriceX96,
 34 |     |             int24 tick,
 35 |     |             uint16 observationIndex,
 36 |     |             uint16 observationCardinality,
 37 |     |             uint16 observationCardinalityNext,
 38 |     |             uint8 feeProtocol,
 39 |     |             bool unlocked
 40 |     |         );
 41 |     | 
 42 |     |     /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
 43 |     |     /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
 44 |     |     /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned
 45 |     |     /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp
 46 |     |     /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block
 47 |     |     /// timestamp
 48 |     |     function observe(uint32[] calldata secondsAgos)
 49 |     |         external
 50 |     |         view
 51 |     |         returns (
 52 |     |             int56[] memory tickCumulatives,
 53 |     |             uint160[] memory secondsPerLiquidityCumulativeX128s
 54 |     |         );
 55 |     | }
 56 |     | 

/home/ec2-user/git/cover/contracts/interfaces/modules/sources/ITwapSource.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../structs/PoolsharkStructs.sol';
  5 |     | 
  6 |     | interface ITwapSource {
  7 |     |     function initialize(
  8 |     |         PoolsharkStructs.CoverImmutables memory constants
  9 |     |     ) external returns (
 10 |     |         uint8 initializable,
 11 |     |         int24 startingTick
 12 |     |     );
 13 |     | 
 14 |     |     function calculateAverageTick(
 15 |     |         PoolsharkStructs.CoverImmutables memory constants,
 16 |     |         int24 latestTick
 17 |     |     ) external view returns (
 18 |     |         int24 averageTick
 19 |     |     );
 20 |     | 
 21 |     |     function getPool(
 22 |     |         address tokenA,
 23 |     |         address tokenB,
 24 |     |         uint16 feeTier
 25 |     |     ) external view returns (
 26 |     |         address pool
 27 |     |     );
 28 |     | 
 29 |     |     function feeTierTickSpacing(
 30 |     |         uint16 feeTier
 31 |     |     ) external view returns (
 32 |     |         int24 tickSpacing
 33 |     |     );
 34 |     | 
 35 |     |     function factory()
 36 |     |     external view returns (address);
 37 |     | }
 38 |     | 

/home/ec2-user/git/cover/contracts/interfaces/structs/CoverPoolStructs.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './PoolsharkStructs.sol';
   5 |     | import '../modules/sources/ITwapSource.sol';
   6 |     | 
   7 |     | interface CoverPoolStructs is PoolsharkStructs {
   8 |     |     struct GlobalState {
   9 |     |         ProtocolFees protocolFees;
  10 |     |         uint160  latestPrice;      /// @dev price of latestTick
  11 |     |         uint128  liquidityGlobal;
  12 |     |         uint32   lastTime;         /// @dev last block checked
  13 |     |         uint32   auctionStart;     /// @dev last block price reference was updated
  14 |     |         uint32   accumEpoch;       /// @dev number of times this pool has been synced
  15 |     |         uint32   positionIdNext;
  16 |     |         int24    latestTick;       /// @dev latest updated inputPool price tick
  17 |     |         uint16   syncFee;
  18 |     |         uint16   fillFee;
  19 |     |         uint8    unlocked;
  20 |     |     }
  21 |     | 
  22 |     |     struct PoolState {
  23 |     |         uint160 price; /// @dev Starting price current
  24 |     |         uint128 liquidity; /// @dev Liquidity currently active
  25 |     |         uint128 amountInDelta; /// @dev Delta for the current tick auction
  26 |     |         uint128 amountInDeltaMaxClaimed;  /// @dev - needed when users claim and don't burn; should be cleared when users burn liquidity
  27 |     |         uint128 amountOutDeltaMaxClaimed; /// @dev - needed when users claim and don't burn; should be cleared when users burn liquidity
  28 |     |     }
  29 |     | 
  30 |     |     struct TickMap {
  31 |     |         uint256 blocks;                     /// @dev - sets of words
  32 |     |         mapping(uint256 => uint256) words;  /// @dev - sets to words
  33 |     |         mapping(uint256 => uint256) ticks;  /// @dev - words to ticks
  34 |     |         mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) epochs0; /// @dev - ticks to pool0 epochs
  35 |     |         mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) epochs1; /// @dev - ticks to pool1 epochs
  36 |     |     }
  37 |     | 
  38 |     |     struct Tick {
  39 |     |         Deltas deltas0;
  40 |     |         Deltas deltas1;                    
  41 |     |         int128 liquidityDelta;
  42 |     |         uint128 amountInDeltaMaxMinus;
  43 |     |         uint128 amountOutDeltaMaxMinus;
  44 |     |         uint128 amountInDeltaMaxStashed;
  45 |     |         uint128 amountOutDeltaMaxStashed;
  46 |     |         bool pool0Stash;
  47 |     |     }
  48 |     | 
  49 |     |     struct Deltas {
  50 |     |         uint128 amountInDelta;     /// @dev - amount filled
  51 |     |         uint128 amountOutDelta;    /// @dev - amount unfilled
  52 |     |         uint128 amountInDeltaMax;  /// @dev - max filled 
  53 |     |         uint128 amountOutDeltaMax; /// @dev - max unfilled
  54 |     |     }
  55 |     | 
  56 |     |     struct CoverPosition {
  57 |     |         uint160 claimPriceLast;    /// @dev - highest price claimed at
  58 |     |         uint128 liquidity;         /// @dev - expected amount to be used not actual
  59 |     |         uint128 amountIn;          /// @dev - token amount already claimed; balance
  60 |     |         uint128 amountOut;         /// @dev - necessary for non-custodial positions
  61 |     |         uint32  accumEpochLast;    /// @dev - last epoch this position was updated at
  62 |     |         int24 lower;
  63 |     |         int24 upper;
  64 |     |     }
  65 |     | 
  66 |     |     struct VolatilityTier {
  67 |     |         uint128 minAmountPerAuction; // based on 18 decimals and then converted based on token decimals
  68 |     |         uint16  auctionLength;
  69 |     |         uint16  blockTime; // average block time where 1e3 is 1 second
  70 |     |         uint16  syncFee;
  71 |     |         uint16  fillFee;
  72 |     |         int16   minPositionWidth;
  73 |     |         bool    minAmountLowerPriced;
  74 |     |     }
  75 |     | 
  76 |     |     struct ProtocolFees {
  77 |     |         uint128 token0;
  78 |     |         uint128 token1;
  79 |     |     }
  80 |     | 
  81 |     |     struct SyncFees {
  82 |     |         uint128 token0;
  83 |     |         uint128 token1;
  84 |     |     }
  85 |     | 
  86 |     |     struct CollectParams {
  87 |     |         SyncFees syncFees;
  88 |     |         address to;
  89 |     |         uint32 positionId;
  90 |     |         int24 lower;
  91 |     |         int24 claim;
  92 |     |         int24 upper;
  93 |     |         bool zeroForOne;
  94 |     |     }
  95 |     | 
  96 |     |     struct SizeParams {
  97 |     |         uint256 priceLower;
  98 |     |         uint256 priceUpper;
  99 |     |         uint128 liquidityAmount;
 100 |     |         bool zeroForOne;
 101 |     |         int24 latestTick;
 102 |     |         uint24 auctionCount;
 103 |     |     }
 104 |     | 
 105 |     |     struct AddParams {
 106 |     |         address to;
 107 |     |         uint128 amount;
 108 |     |         uint128 amountIn;
 109 |     |         uint32 positionId;
 110 |     |         int24 lower;
 111 |     |         int24 upper;
 112 |     |         bool zeroForOne;
 113 |     |     }
 114 |     | 
 115 |     |     struct RemoveParams {
 116 |     |         address owner;
 117 |     |         address to;
 118 |     |         uint128 amount;
 119 |     |         uint32 positionId;
 120 |     |         int24 lower;
 121 |     |         int24 upper;
 122 |     |         bool zeroForOne;
 123 |     |     }
 124 |     | 
 125 |     |     struct UpdateParams {
 126 |     |         address owner;
 127 |     |         address to;
 128 |     |         uint128 amount;
 129 |     |         uint32 positionId;
 130 |     |         int24 lower;
 131 |     |         int24 upper;
 132 |     |         int24 claim;
 133 |     |         bool zeroForOne;
 134 |     |     }
 135 |     | 
 136 |     |     struct MintCache {
 137 |     |         GlobalState state;
 138 |     |         CoverPosition position;
 139 |     |         CoverImmutables constants;
 140 |     |         SyncFees syncFees;
 141 |     |         PoolState pool0;
 142 |     |         PoolState pool1;
 143 |     |         uint256 liquidityMinted;
 144 |     |     }
 145 |     | 
 146 |     |     struct BurnCache {
 147 |     |         GlobalState state;
 148 |     |         CoverPosition position;
 149 |     |         CoverImmutables constants;
 150 |     |         SyncFees syncFees;
 151 |     |         PoolState pool0;
 152 |     |         PoolState pool1;
 153 |     |     }
 154 |     | 
 155 |     |     struct SwapCache {
 156 |     |         GlobalState state;
 157 |     |         SyncFees syncFees;
 158 |     |         CoverImmutables constants;
 159 |     |         PoolState pool0;
 160 |     |         PoolState pool1;
 161 |     |         uint256 price;
 162 |     |         uint256 liquidity;
 163 |     |         uint256 amountLeft;
 164 |     |         uint256 input;
 165 |     |         uint256 output;
 166 |     |         uint256 amountBoosted;
 167 |     |         uint256 auctionDepth;
 168 |     |         uint256 auctionBoost;
 169 |     |         uint256 amountInDelta;
 170 |     |         int256 amount0Delta;
 171 |     |         int256 amount1Delta;
 172 |     |         bool exactIn;
 173 |     |     }
 174 |     | 
 175 |     |     struct CoverPositionCache {
 176 |     |         CoverPosition position;
 177 |     |         Deltas deltas;
 178 |     |         uint160 priceLower;
 179 |     |         uint160 priceUpper;
 180 |     |         uint256 priceAverage;
 181 |     |         uint256 liquidityMinted;
 182 |     |         int24 requiredStart;
 183 |     |         uint24 auctionCount;
 184 |     |         bool denomTokenIn;
 185 |     |     }
 186 |     | 
 187 |     |     struct UpdatePositionCache {
 188 |     |         Deltas deltas;
 189 |     |         Deltas finalDeltas;
 190 |     |         PoolState pool;
 191 |     |         uint256 amountInFilledMax;    // considers the range covered by each update
 192 |     |         uint256 amountOutUnfilledMax; // considers the range covered by each update
 193 |     |         Tick claimTick;
 194 |     |         Tick finalTick;
 195 |     |         CoverPosition position;
 196 |     |         uint160 priceLower;
 197 |     |         uint160 priceClaim;
 198 |     |         uint160 priceUpper;
 199 |     |         uint160 priceSpread;
 200 |     |         bool earlyReturn;
 201 |     |         bool removeLower;
 202 |     |         bool removeUpper;
 203 |     |     }
 204 |     | 
 205 |     |     struct AccumulateCache {
 206 |     |         Deltas deltas0;
 207 |     |         Deltas deltas1;
 208 |     |         SyncFees syncFees;
 209 |     |         int24 newLatestTick;
 210 |     |         int24 nextTickToCross0;
 211 |     |         int24 nextTickToCross1;
 212 |     |         int24 nextTickToAccum0;
 213 |     |         int24 nextTickToAccum1;
 214 |     |         int24 stopTick0;
 215 |     |         int24 stopTick1;
 216 |     |     }
 217 |     | 
 218 |     |     struct AccumulateParams {
 219 |     |         Deltas deltas;
 220 |     |         Tick crossTick;
 221 |     |         Tick accumTick;
 222 |     |         bool updateAccumDeltas;
 223 |     |         bool isPool0;
 224 |     |     }
 225 |     | }
 226 |     | 

/home/ec2-user/git/cover/contracts/interfaces/structs/PoolsharkStructs.sol
   1 |     | // SPDX-License-Identifier: GPLv3
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../modules/sources/ITwapSource.sol';
   5 |     | 
   6 |     | interface PoolsharkStructs {
   7 |     |     struct LimitImmutables {
   8 |     |         address owner;
   9 |     |         address poolImpl;
  10 |     |         address factory;
  11 |     |         PriceBounds bounds;
  12 |     |         address token0;
  13 |     |         address token1;
  14 |     |         address poolToken;
  15 |     |         uint32 genesisTime;
  16 |     |         int16 tickSpacing;
  17 |     |         uint16 swapFee;
  18 |     |     }
  19 |     | 
  20 |     |     struct CoverImmutables {
  21 |     |         ITwapSource source;
  22 |     |         PriceBounds bounds;
  23 |     |         address owner;
  24 |     |         address token0;
  25 |     |         address token1;
  26 |     |         address poolImpl;
  27 |     |         address poolToken;
  28 |     |         address inputPool;
  29 |     |         uint128 minAmountPerAuction;
  30 |     |         uint32 genesisTime;
  31 |     |         int16  minPositionWidth;
  32 |     |         int16  tickSpread;
  33 |     |         uint16 twapLength;
  34 |     |         uint16 auctionLength;
  35 |     |         uint16 blockTime;
  36 |     |         uint8 token0Decimals;
  37 |     |         uint8 token1Decimals;
  38 |     |         bool minAmountLowerPriced;
  39 |     |     }
  40 |     | 
  41 |     |     struct PriceBounds {
  42 |     |         uint160 min;
  43 |     |         uint160 max;
  44 |     |     }
  45 |     | 
  46 |     |     struct QuoteResults {
  47 |     |         address pool;
  48 |     |         int256 amountIn;
  49 |     |         int256 amountOut;
  50 |     |         uint160 priceAfter;
  51 |     |     }
  52 |     | 
  53 |     |     /**
  54 |     |      * @custom:struct QuoteParams
  55 |     |      */
  56 |     |     struct QuoteParams {
  57 |     |         /**
  58 |     |          * @custom:field priceLimit
  59 |     |          * @dev The Q64.96 square root price at which to stop swapping.
  60 |     |          */
  61 |     |         uint160 priceLimit;
  62 |     | 
  63 |     |         /**
  64 |     |          * @custom:field amount
  65 |     |          * @dev The exact input amount if exactIn = true
  66 |     |          * @dev The exact output amount if exactIn = false.
  67 |     |          */
  68 |     |         uint128 amount;
  69 |     | 
  70 |     |         /**
  71 |     |          * @custom:field zeroForOne
  72 |     |          * @notice True if amount is an input amount.
  73 |     |          * @notice False if amount is an output amount. 
  74 |     |          */
  75 |     |         bool exactIn;
  76 |     | 
  77 |     |         /**
  78 |     |          * @custom:field zeroForOne
  79 |     |          * @notice True if swapping token0 for token1.
  80 |     |          * @notice False if swapping in token1 for token0. 
  81 |     |          */
  82 |     |         bool zeroForOne;
  83 |     |     }
  84 |     | 
  85 |     |     /**
  86 |     |      * @custom:struct SwapParams
  87 |     |      */
  88 |     |     struct SwapParams {
  89 |     |         /**
  90 |     |          * @custom:field to
  91 |     |          * @notice Address for the receiver of the swap output
  92 |     |          */
  93 |     |         address to;
  94 |     | 
  95 |     |         /**
  96 |     |          * @custom:field priceLimit
  97 |     |          * @dev The Q64.96 square root price at which to stop swapping.
  98 |     |          */
  99 |     |         uint160 priceLimit;
 100 |     | 
 101 |     |         /**
 102 |     |          * @custom:field amount
 103 |     |          * @dev The exact input amount if exactIn = true
 104 |     |          * @dev The exact output amount if exactIn = false.
 105 |     |          */
 106 |     |         uint128 amount;
 107 |     | 
 108 |     |         /**
 109 |     |          * @custom:field zeroForOne
 110 |     |          * @notice True if amount is an input amount.
 111 |     |          * @notice False if amount is an output amount. 
 112 |     |          */
 113 |     |         bool exactIn;
 114 |     | 
 115 |     |         /**
 116 |     |          * @custom:field zeroForOne
 117 |     |          * @notice True if swapping token0 for token1.
 118 |     |          * @notice False if swapping in token1 for token0. 
 119 |     |          */
 120 |     |         bool zeroForOne;
 121 |     |         
 122 |     |         /**
 123 |     |          * @custom:field callbackData
 124 |     |          * @notice Data to be passed through to the swap callback. 
 125 |     |          */
 126 |     |          bytes callbackData;
 127 |     |     }
 128 |     | }

/home/ec2-user/git/cover/contracts/libraries/Claims.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './Deltas.sol';
   5 |     | import '../interfaces/structs/CoverPoolStructs.sol';
   6 |     | import './EpochMap.sol';
   7 |     | import './TickMap.sol';
   8 |     | import './utils/String.sol';
   9 |     | 
  10 |     | library Claims {
  11 |     |     function validate(
  12 |     |         CoverPoolStructs.TickMap storage tickMap,
  13 |     |         CoverPoolStructs.GlobalState memory state,
  14 |     |         CoverPoolStructs.PoolState memory pool,
  15 |     |         CoverPoolStructs.UpdateParams memory params,
  16 |     |         CoverPoolStructs.UpdatePositionCache memory cache,
  17 |     |         PoolsharkStructs.CoverImmutables memory constants
  18 |     |     ) internal view returns (
  19 |     |         CoverPoolStructs.UpdateParams memory,
  20 |     |         CoverPoolStructs.UpdatePositionCache memory
  21 |     |     ) {
  22 |     |         // validate position liquidity
  23 |     |         if (cache.position.liquidity == 0) {
  24 |     |             cache.earlyReturn = true;
  25 |     |             return (params, cache);
  26 |     |         }
  27 |     |         if (params.amount > cache.position.liquidity) require (false, 'NotEnoughPositionLiquidity()');
  28 |     |         // if the position has not been crossed into at all
  29 |     |         else if (params.zeroForOne ? params.claim == params.upper 
  30 |     |                                         && EpochMap.get(params.upper, params.zeroForOne, tickMap, constants) <= cache.position.accumEpochLast
  31 |     |                                      : params.claim == params.lower 
  32 |     |                                         && EpochMap.get(params.lower, params.zeroForOne, tickMap, constants) <= cache.position.accumEpochLast
  33 |     |         ) {
  34 |     |             cache.earlyReturn = true;
  35 |     |             return (params, cache);
  36 |     |         }
  37 |     |         // early return if no update and amount burned is 0
  38 |     |         if (
  39 |     |             (
  40 |     |                 params.zeroForOne
  41 |     |                     ? params.claim == params.upper && cache.priceUpper != pool.price
  42 |     |                     : params.claim == params.lower && cache.priceLower != pool.price /// @dev - if pool price is start tick, set claimPriceLast to next tick crossed
  43 |     |             ) && params.claim == state.latestTick
  44 |     |         ) { if (params.amount == 0 && cache.position.claimPriceLast == pool.price) {
  45 |     |                 cache.earlyReturn = true;
  46 |     |                 return (params, cache);
  47 |     |             } 
  48 |     |         } /// @dev - nothing to update if pool price hasn't moved
  49 |     |         
  50 |     |         // claim tick sanity checks
  51 |     |         else if (
  52 |     |             // claim tick is on a prior tick
  53 |     |             cache.position.claimPriceLast > 0 &&
  54 |     |             (params.zeroForOne
  55 |     |                     ? cache.position.claimPriceLast < cache.priceClaim
  56 |     |                     : cache.position.claimPriceLast > cache.priceClaim
  57 |     |             ) && params.claim != state.latestTick
  58 |     |         ) require (false, 'InvalidClaimTick()'); /// @dev - wrong claim tick
  59 |     |         if (params.claim < params.lower || params.claim > params.upper) require (false, 'InvalidClaimTick()');
  60 |     | 
  61 |     |         uint32 claimTickEpoch = EpochMap.get(params.claim, params.zeroForOne, tickMap, constants);
  62 |     | 
  63 |     |         // validate claim tick
  64 |     |         if (params.claim == (params.zeroForOne ? params.lower : params.upper)) {
  65 |     |              if (claimTickEpoch <= cache.position.accumEpochLast)
  66 |     |                 require (false, 'WrongTickClaimedAt()');
  67 |     |         } else {
  68 |     |             // check end tick 
  69 |     |             if (params.zeroForOne) {
  70 |     |                 uint32 endTickAccumEpoch = EpochMap.get(cache.position.lower, params.zeroForOne, tickMap, constants);
  71 |     |                 if (endTickAccumEpoch > cache.position.accumEpochLast) {
  72 |     |                     // set claim to final tick
  73 |     |                     params.claim = cache.position.lower;
  74 |     |                     cache.priceClaim = cache.priceLower;
  75 |     |                     cache.claimTick = cache.finalTick;
  76 |     |                     // force user to remove all liquidity
  77 |     |                     params.amount = cache.position.liquidity;
  78 |     |                 } else {
  79 |     |                     int24 claimTickNext = TickMap.previous(params.claim, tickMap, constants);
  80 |     |                     uint32 claimTickNextEpoch = EpochMap.get(claimTickNext, params.zeroForOne, tickMap, constants);
  81 |     |                     ///@dev - next accumEpoch should not be greater
  82 |     |                     if (claimTickNextEpoch > cache.position.accumEpochLast) {
  83 |     |                         require (false, 'WrongTickClaimedAt()');
  84 |     |                     }
  85 |     |                 }
  86 |     |             } else {
  87 |     |                 uint32 endTickAccumEpoch = EpochMap.get(cache.position.upper, params.zeroForOne, tickMap, constants);
  88 |     |                 if (endTickAccumEpoch > cache.position.accumEpochLast) {
  89 |     |                     // set claim to final tick
  90 |     |                     params.claim = cache.position.upper;
  91 |     |                     cache.priceClaim = cache.priceUpper;
  92 |     |                     cache.claimTick = cache.finalTick;
  93 |     |                     // force user to remove all liquidity
  94 |     |                     params.amount = cache.position.liquidity;
  95 |     |                 } else {
  96 |     |                     int24 claimTickNext = TickMap.next(params.claim, tickMap, constants);
  97 |     |                     uint32 claimTickNextEpoch = EpochMap.get(claimTickNext, params.zeroForOne, tickMap, constants);
  98 |     |                     ///@dev - next accumEpoch should not be greater
  99 |     |                     if (claimTickNextEpoch > cache.position.accumEpochLast) {
 100 |     |                         require (false, 'WrongTickClaimedAt()');
 101 |     |                     }
 102 |     |                 }
 103 |     |             }
 104 |     |         }
 105 |     |         if (params.claim != params.upper && params.claim != params.lower) {
 106 |     |             // check accumEpochLast on claim tick
 107 |     |             if (claimTickEpoch <= cache.position.accumEpochLast)
 108 |     |                 require (false, 'WrongTickClaimedAt()');
 109 |     |             /// @dev - user cannot add liquidity if auction is active; checked for in Positions.validate()
 110 |     |         }
 111 |     |         //TODO: maybe check that the claim tick epoch is greater than the position epoch
 112 |     |         return (params, cache);
 113 |     |     }
 114 |     | 
 115 |     |     function getDeltas(
 116 |     |         CoverPoolStructs.UpdatePositionCache memory cache,
 117 |     |         CoverPoolStructs.UpdateParams memory params
 118 |     |     ) internal pure returns (
 119 |     |         CoverPoolStructs.UpdatePositionCache memory
 120 |     |     ) {
 121 |     |         // transfer deltas into cache
 122 |     |         if (params.claim == (params.zeroForOne ? params.lower : params.upper)) {
 123 |     |             (cache.claimTick, cache.deltas) = Deltas.from(cache.claimTick, cache.deltas, params.zeroForOne);
 124 |     |         } else {
 125 |     |             /// @dev - deltas are applied once per each tick claimed at
 126 |     |             /// @dev - deltas should never be applied if position is not crossed into
 127 |     |             // check if tick already claimed at
 128 |     |             bool transferDeltas = (cache.position.claimPriceLast == 0
 129 |     |                                && (params.claim != (params.zeroForOne ? params.upper : params.lower)))
 130 |     |                                || (params.zeroForOne ? cache.position.claimPriceLast > cache.priceClaim
 131 |     |                                                      : cache.position.claimPriceLast < cache.priceClaim && cache.position.claimPriceLast != 0);
 132 |     |             if (transferDeltas) {
 133 |     |                 (cache.claimTick, cache.deltas) = Deltas.unstash(cache.claimTick, cache.deltas, params.zeroForOne);
 134 |     |             }
 135 |     |         } /// @dev - deltas transfer from claim tick are replaced after applying changes
 136 |     |         return cache;
 137 |     |     }
 138 |     | 
 139 |     |     function applyDeltas(
 140 |     |         CoverPoolStructs.GlobalState memory state,
 141 |     |         CoverPoolStructs.UpdatePositionCache memory cache,
 142 |     |         CoverPoolStructs.UpdateParams memory params
 143 |     |     ) internal pure returns (
 144 |     |         CoverPoolStructs.UpdatePositionCache memory
 145 |     |     ) {
 146 |     |         uint256 percentInDelta; uint256 percentOutDelta;
 147 |     |         if(cache.deltas.amountInDeltaMax > 0) {
 148 |     |             percentInDelta = uint256(cache.amountInFilledMax) * 1e38 / uint256(cache.deltas.amountInDeltaMax);
 149 |     |             percentInDelta = percentInDelta > 1e38 ? 1e38 : percentInDelta;
 150 |     |             if (cache.deltas.amountOutDeltaMax > 0) {
 151 |     |                 percentOutDelta = uint256(cache.amountOutUnfilledMax) * 1e38 / uint256(cache.deltas.amountOutDeltaMax);
 152 |     |                 percentOutDelta = percentOutDelta > 1e38 ? 1e38 : percentOutDelta;
 153 |     |             }
 154 |     |         }
 155 |     |         (cache.deltas, cache.finalDeltas) = Deltas.transfer(cache.deltas, cache.finalDeltas, percentInDelta, percentOutDelta);
 156 |     |         (cache.deltas, cache.finalDeltas) = Deltas.transferMax(cache.deltas, cache.finalDeltas, percentInDelta, percentOutDelta);
 157 |     | 
 158 |     |         uint128 fillFeeAmount = cache.finalDeltas.amountInDelta * state.fillFee / 1e6;
 159 |     |         if (params.zeroForOne) {
 160 |     |             state.protocolFees.token1 += fillFeeAmount;
 161 |     |         } else {
 162 |     |             state.protocolFees.token0 += fillFeeAmount;
 163 |     |         }
 164 |     |         cache.finalDeltas.amountInDelta -= fillFeeAmount;
 165 |     |         cache.position.amountIn  += cache.finalDeltas.amountInDelta;
 166 |     |         cache.position.amountOut += cache.finalDeltas.amountOutDelta;
 167 |     | 
 168 |     |         if (params.claim != (params.zeroForOne ? params.lower : params.upper)) {
 169 |     |             // burn deltas on final tick of position
 170 |     |             cache.finalTick = Deltas.burnMaxMinus(cache.finalTick, cache.finalDeltas);
 171 |     |             // update deltas on claim tick
 172 |     |             if (params.claim == (params.zeroForOne ? params.upper : params.lower)) {
 173 |     |                 (cache.deltas, cache.claimTick) = Deltas.to(cache.deltas, cache.claimTick, params.zeroForOne);
 174 |     |             } else {
 175 |     |                 (cache.deltas, cache.claimTick) = Deltas.stash(cache.deltas, cache.claimTick, params.zeroForOne);
 176 |     |             }
 177 |     |         } else {
 178 |     |             (cache.deltas, cache.claimTick) = Deltas.to(cache.deltas, cache.claimTick, params.zeroForOne);
 179 |     |         }
 180 |     |         return cache;
 181 |     |     }
 182 |     | 
 183 |     |     /// @dev - calculate claim portion of partially claimed previous auction
 184 |     |     function section1(
 185 |     |         CoverPoolStructs.UpdatePositionCache memory cache,
 186 |     |         CoverPoolStructs.UpdateParams memory params,
 187 |     |         PoolsharkStructs.CoverImmutables memory constants
 188 |     |     ) internal pure returns (
 189 |     |         CoverPoolStructs.UpdatePositionCache memory
 190 |     |     ) {
 191 |     |         // delta check complete - update CPL for new position
 192 |     |         if(cache.position.claimPriceLast == 0) {
 193 |     |             cache.position.claimPriceLast = (params.zeroForOne ? cache.priceUpper 
 194 |     |                                                                : cache.priceLower);
 195 |     |         } else if (params.zeroForOne ? (cache.position.claimPriceLast != cache.priceUpper
 196 |     |                                         && cache.position.claimPriceLast > cache.priceClaim)
 197 |     |                                      : (cache.position.claimPriceLast != cache.priceLower
 198 |     |                                         && cache.position.claimPriceLast < cache.priceClaim))
 199 |     |         {
 200 |     |             // section 1 - complete previous auction claim
 201 |     |             {
 202 |     |                 // amounts claimed on this update
 203 |     |                 uint128 amountInFilledMax; uint128 amountOutUnfilledMax;
 204 |     |                 (
 205 |     |                     amountInFilledMax,
 206 |     |                     amountOutUnfilledMax
 207 |     |                 ) = Deltas.maxAuction(
 208 |     |                     cache.position.liquidity,
 209 |     |                     cache.position.claimPriceLast,
 210 |     |                     params.zeroForOne ? cache.priceUpper
 211 |     |                                       : cache.priceLower,
 212 |     |                     params.zeroForOne
 213 |     |                 );
 214 |     |                 cache.amountInFilledMax    += amountInFilledMax;
 215 |     |                 cache.amountOutUnfilledMax += amountOutUnfilledMax;
 216 |     |             }
 217 |     |             // move price to next tick in sequence for section 2
 218 |     |             cache.position.claimPriceLast  = params.zeroForOne ? ConstantProduct.getPriceAtTick(params.upper - constants.tickSpread, constants)
 219 |     |                                                                : ConstantProduct.getPriceAtTick(params.lower + constants.tickSpread, constants);
 220 |     |         }
 221 |     |         return cache;
 222 |     |     }
 223 |     | 
 224 |     |     /// @dev - calculate claim from position start up to claim tick
 225 |     |     function section2(
 226 |     |         CoverPoolStructs.UpdatePositionCache memory cache,
 227 |     |         CoverPoolStructs.UpdateParams memory params
 228 |     |     ) internal pure returns (
 229 |     |         CoverPoolStructs.UpdatePositionCache memory
 230 |     |     ) {
 231 |     |         // section 2 - position start up to claim tick
 232 |     |         if (params.zeroForOne ? cache.priceClaim < cache.position.claimPriceLast 
 233 |     |                               : cache.priceClaim > cache.position.claimPriceLast) {
 234 |     |             // calculate if we at least cover one full tick
 235 |     |             uint128 amountInFilledMax; uint128 amountOutUnfilledMax;
 236 |     |             (
 237 |     |                 amountInFilledMax,
 238 |     |                 amountOutUnfilledMax
 239 |     |             ) = Deltas.maxRoundUp(
 240 |     |                 cache.position.liquidity,
 241 |     |                 cache.position.claimPriceLast,
 242 |     |                 cache.priceClaim,
 243 |     |                 params.zeroForOne
 244 |     |             );
 245 |     |             cache.amountInFilledMax += amountInFilledMax;
 246 |     |             cache.amountOutUnfilledMax += amountOutUnfilledMax;
 247 |     |         }
 248 |     |         return cache;
 249 |     |     }
 250 |     | 
 251 |     |     /// @dev - calculate claim from current auction unfilled section
 252 |     |     function section3(
 253 |     |         CoverPoolStructs.UpdatePositionCache memory cache,
 254 |     |         CoverPoolStructs.UpdateParams memory params,
 255 |     |         CoverPoolStructs.PoolState memory pool
 256 |     |     ) internal pure returns (
 257 |     |         CoverPoolStructs.UpdatePositionCache memory
 258 |     |     ) {
 259 |     |         // section 3 - current auction unfilled section
 260 |     |         if (params.amount > 0) {
 261 |     |             // remove if burn
 262 |     |             uint128 amountOutRemoved = uint128(
 263 |     |                 params.zeroForOne
 264 |     |                     ? ConstantProduct.getDx(params.amount, pool.price, cache.priceClaim, false)
 265 |     |                     : ConstantProduct.getDy(params.amount, cache.priceClaim, pool.price, false)
 266 |     |             );
 267 |     |             uint128 amountInOmitted = uint128(
 268 |     |                 params.zeroForOne
 269 |     |                     ? ConstantProduct.getDy(params.amount, pool.price, cache.priceClaim, false)
 270 |     |                     : ConstantProduct.getDx(params.amount, cache.priceClaim, pool.price, false)
 271 |     |             );
 272 |     |             // add to position
 273 |     |             cache.position.amountOut += amountOutRemoved;
 274 |     |             // modify max deltas to be burned
 275 |     |             cache.finalDeltas.amountInDeltaMax  += amountInOmitted;
 276 |     |             cache.finalDeltas.amountOutDeltaMax += amountOutRemoved;
 277 |     |         }
 278 |     |         return cache;
 279 |     |     }
 280 |     | 
 281 |     |     /// @dev - calculate claim from position start up to claim tick
 282 |     |     function section4(
 283 |     |         CoverPoolStructs.UpdatePositionCache memory cache,
 284 |     |         CoverPoolStructs.UpdateParams memory params,
 285 |     |         CoverPoolStructs.PoolState memory pool
 286 |     |     ) internal pure returns (
 287 |     |         CoverPoolStructs.UpdatePositionCache memory
 288 |     |     ) {
 289 |     |         // section 4 - current auction filled section
 290 |     |         {
 291 |     |             // amounts claimed on this update
 292 |     |             uint128 amountInFilledMax; uint128 amountOutUnfilledMax;
 293 |     |             (
 294 |     |                 amountInFilledMax,
 295 |     |                 amountOutUnfilledMax
 296 |     |             ) = Deltas.maxAuction(
 297 |     |                 cache.position.liquidity,
 298 |     |                 (params.zeroForOne ? cache.position.claimPriceLast < cache.priceClaim
 299 |     |                                     : cache.position.claimPriceLast > cache.priceClaim) 
 300 |     |                                         ? cache.position.claimPriceLast 
 301 |     |                                         : cache.priceSpread,
 302 |     |                 pool.price,
 303 |     |                 params.zeroForOne
 304 |     |             );
 305 |     |             uint256 poolAmountInDeltaChange = uint256(cache.position.liquidity) * 1e38 
 306 |     |                                                 / uint256(pool.liquidity) * uint256(pool.amountInDelta) / 1e38;   
 307 |     |             
 308 |     |             cache.position.amountIn += uint128(poolAmountInDeltaChange);
 309 |     |             pool.amountInDelta -= uint128(poolAmountInDeltaChange); //CHANGE POOL TO MEMORY
 310 |     |             cache.finalDeltas.amountInDeltaMax += amountInFilledMax;
 311 |     |             cache.finalDeltas.amountOutDeltaMax += amountOutUnfilledMax;
 312 |     |             /// @dev - record how much delta max was claimed
 313 |     |             if (params.amount < cache.position.liquidity) {
 314 |     |                 (
 315 |     |                     amountInFilledMax,
 316 |     |                     amountOutUnfilledMax
 317 |     |                 ) = Deltas.maxAuction(
 318 |     |                     cache.position.liquidity - params.amount,
 319 |     |                     (params.zeroForOne ? cache.position.claimPriceLast < cache.priceClaim
 320 |     |                                     : cache.position.claimPriceLast > cache.priceClaim) 
 321 |     |                                             ? cache.position.claimPriceLast 
 322 |     |                                             : cache.priceSpread,
 323 |     |                     pool.price,
 324 |     |                     params.zeroForOne
 325 |     |                 );
 326 |     |                 pool.amountInDeltaMaxClaimed  += amountInFilledMax;
 327 |     |                 pool.amountOutDeltaMaxClaimed += amountOutUnfilledMax;
 328 |     |             }
 329 |     |         }
 330 |     |         if (params.amount > 0 /// @ dev - if removing L and second claim on same tick
 331 |     |             && (params.zeroForOne ? cache.position.claimPriceLast < cache.priceClaim
 332 |     |                                     : cache.position.claimPriceLast > cache.priceClaim)) {
 333 |     |                 // reduce delta max claimed based on liquidity removed
 334 |     |                 pool = Deltas.burnMaxPool(pool, cache, params);
 335 |     |         }
 336 |     |         // modify claim price for section 5
 337 |     |         cache.priceClaim = cache.priceSpread;
 338 |     |         // save pool changes to cache
 339 |     |         cache.pool = pool;
 340 |     |         return cache;
 341 |     |     }
 342 |     | 
 343 |     |     /// @dev - calculate claim from position start up to claim tick
 344 |     |     function section5(
 345 |     |         CoverPoolStructs.UpdatePositionCache memory cache,
 346 |     |         CoverPoolStructs.UpdateParams memory params
 347 |     |     ) internal pure returns (
 348 |     |         CoverPoolStructs.UpdatePositionCache memory
 349 |     |     ) {
 350 |     |         // section 5 - burned liquidity past claim tick
 351 |     |         {
 352 |     |             uint160 endPrice = params.zeroForOne ? cache.priceLower
 353 |     |                                                  : cache.priceUpper;
 354 |     |             if (params.amount > 0 && cache.priceClaim != endPrice) {
 355 |     |                 // update max deltas based on liquidity removed
 356 |     |                 uint128 amountInOmitted; uint128 amountOutRemoved;
 357 |     |                 (
 358 |     |                     amountInOmitted,
 359 |     |                     amountOutRemoved
 360 |     |                 ) = Deltas.max(
 361 |     |                     params.amount,
 362 |     |                     cache.priceClaim,
 363 |     |                     endPrice,
 364 |     |                     params.zeroForOne
 365 |     |                 );
 366 |     |                 cache.position.amountOut += amountOutRemoved;
 367 |     |                 /// @auditor - we don't add to cache.amountInFilledMax and cache.amountOutUnfilledMax 
 368 |     |                 ///            since this section of the curve is not reflected in the deltas
 369 |     |                 if (params.claim != (params.zeroForOne ? params.lower : params.upper)) {
 370 |     |                     cache.finalDeltas.amountInDeltaMax += amountInOmitted;
 371 |     |                     cache.finalDeltas.amountOutDeltaMax += amountOutRemoved;
 372 |     |                 }      
 373 |     |             }
 374 |     |         }
 375 |     |         return cache;
 376 |     |     }
 377 |     | }

/home/ec2-user/git/cover/contracts/libraries/Deltas.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../interfaces/structs/CoverPoolStructs.sol';
   5 |     | import './math/ConstantProduct.sol';
   6 |     | library Deltas {
   7 |     | 
   8 |     |     function max(
   9 |     |         uint128 liquidity,
  10 |     |         uint160 priceStart,
  11 |     |         uint160 priceEnd,
  12 |     |         bool   isPool0
  13 |     |     ) internal pure returns (
  14 |     |         uint128 amountInDeltaMax,
  15 |     |         uint128 amountOutDeltaMax
  16 |     |     ) {
  17 |     |         amountInDeltaMax = uint128(
  18 |     |             isPool0
  19 |     |                 ? ConstantProduct.getDy(
  20 |     |                     liquidity,
  21 |     |                     priceEnd,
  22 |     |                     priceStart,
  23 |     |                     false
  24 |     |                 )
  25 |     |                 : ConstantProduct.getDx(
  26 |     |                     liquidity,
  27 |     |                     priceStart,
  28 |     |                     priceEnd,
  29 |     |                     false
  30 |     |                 )
  31 |     |         );
  32 |     |         amountOutDeltaMax = uint128(
  33 |     |             isPool0
  34 |     |                 ? ConstantProduct.getDx(
  35 |     |                     liquidity,
  36 |     |                     priceEnd,
  37 |     |                     priceStart,
  38 |     |                     false
  39 |     |                 )
  40 |     |                 : ConstantProduct.getDy(
  41 |     |                     liquidity,
  42 |     |                     priceStart,
  43 |     |                     priceEnd,
  44 |     |                     false
  45 |     |                 )
  46 |     |         );
  47 |     |     }
  48 |     | 
  49 |     |     function maxRoundUp(
  50 |     |         uint128 liquidity,
  51 |     |         uint160 priceStart,
  52 |     |         uint160 priceEnd,
  53 |     |         bool   isPool0
  54 |     |     ) internal pure returns (
  55 |     |         uint128 amountInDeltaMax,
  56 |     |         uint128 amountOutDeltaMax
  57 |     |     ) {
  58 |     |         amountInDeltaMax = uint128(
  59 |     |             isPool0
  60 |     |                 ? ConstantProduct.getDy(
  61 |     |                     liquidity,
  62 |     |                     priceEnd,
  63 |     |                     priceStart,
  64 |     |                     true
  65 |     |                 )
  66 |     |                 : ConstantProduct.getDx(
  67 |     |                     liquidity,
  68 |     |                     priceStart,
  69 |     |                     priceEnd,
  70 |     |                     true
  71 |     |                 )
  72 |     |         );
  73 |     |         amountOutDeltaMax = uint128(
  74 |     |             isPool0
  75 |     |                 ? ConstantProduct.getDx(
  76 |     |                     liquidity,
  77 |     |                     priceEnd,
  78 |     |                     priceStart,
  79 |     |                     true
  80 |     |                 )
  81 |     |                 : ConstantProduct.getDy(
  82 |     |                     liquidity,
  83 |     |                     priceStart,
  84 |     |                     priceEnd,
  85 |     |                     true
  86 |     |                 )
  87 |     |         );
  88 |     |     }
  89 |     | 
  90 |     |     function maxAuction(
  91 |     |         uint128 liquidity,
  92 |     |         uint160 priceStart,
  93 |     |         uint160 priceEnd,
  94 |     |         bool isPool0
  95 |     |     ) internal pure returns (
  96 |     |         uint128 amountInDeltaMax,
  97 |     |         uint128 amountOutDeltaMax
  98 |     |     ) {
  99 |     |         amountInDeltaMax = uint128(
 100 |     |             isPool0
 101 |     |                 ? ConstantProduct.getDy(
 102 |     |                     liquidity,
 103 |     |                     priceStart,
 104 |     |                     priceEnd,
 105 |     |                     true
 106 |     |                 )
 107 |     |                 : ConstantProduct.getDx(
 108 |     |                     liquidity,
 109 |     |                     priceEnd,
 110 |     |                     priceStart,
 111 |     |                     true
 112 |     |                 )
 113 |     |         );
 114 |     |         amountOutDeltaMax = uint128(
 115 |     |             isPool0
 116 |     |                 ? ConstantProduct.getDx(
 117 |     |                     liquidity,
 118 |     |                     priceStart,
 119 |     |                     priceEnd,
 120 |     |                     true
 121 |     |                 )
 122 |     |                 : ConstantProduct.getDy(
 123 |     |                     liquidity,
 124 |     |                     priceEnd,
 125 |     |                     priceStart,
 126 |     |                     true
 127 |     |                 )
 128 |     |         );
 129 |     |     }
 130 |     | 
 131 |     |     function transfer(
 132 |     |         CoverPoolStructs.Deltas memory fromDeltas,
 133 |     |         CoverPoolStructs.Deltas memory toDeltas,
 134 |     |         uint256 percentInTransfer,
 135 |     |         uint256 percentOutTransfer
 136 |     |     ) internal pure returns (
 137 |     |         CoverPoolStructs.Deltas memory,
 138 |     |         CoverPoolStructs.Deltas memory
 139 |     |     ) {
 140 |     |         {
 141 |     |             uint128 amountInDeltaChange = uint128(uint256(fromDeltas.amountInDelta) * percentInTransfer / 1e38);
 142 |     |             if (amountInDeltaChange < fromDeltas.amountInDelta ) {
 143 |     |                 fromDeltas.amountInDelta -= amountInDeltaChange;
 144 |     |                 toDeltas.amountInDelta += amountInDeltaChange;
 145 |     |             } else {
 146 |     |                 toDeltas.amountInDelta += fromDeltas.amountInDelta;
 147 |     |                 fromDeltas.amountInDelta = 0;
 148 |     |             }
 149 |     |         }
 150 |     |         {
 151 |     |             uint128 amountOutDeltaChange = uint128(uint256(fromDeltas.amountOutDelta) * percentOutTransfer / 1e38);
 152 |     |             if (amountOutDeltaChange < fromDeltas.amountOutDelta ) {
 153 |     |                 fromDeltas.amountOutDelta -= amountOutDeltaChange;
 154 |     |                 toDeltas.amountOutDelta += amountOutDeltaChange;
 155 |     |             } else {
 156 |     |                 toDeltas.amountOutDelta += fromDeltas.amountOutDelta;
 157 |     |                 fromDeltas.amountOutDelta = 0;
 158 |     |             }
 159 |     |         }
 160 |     |         return (fromDeltas, toDeltas);
 161 |     |     }
 162 |     | 
 163 |     |     function transferMax(
 164 |     |         CoverPoolStructs.Deltas memory fromDeltas,
 165 |     |         CoverPoolStructs.Deltas memory toDeltas,
 166 |     |         uint256 percentInTransfer,
 167 |     |         uint256 percentOutTransfer
 168 |     |     ) internal pure returns (
 169 |     |         CoverPoolStructs.Deltas memory,
 170 |     |         CoverPoolStructs.Deltas memory
 171 |     |     ) {
 172 |     |         {
 173 |     |             uint128 amountInDeltaMaxChange = uint128(uint256(fromDeltas.amountInDeltaMax) * percentInTransfer / 1e38);
 174 |     |             if (fromDeltas.amountInDeltaMax > amountInDeltaMaxChange) {
 175 |     |                 fromDeltas.amountInDeltaMax -= amountInDeltaMaxChange;
 176 |     |                 toDeltas.amountInDeltaMax += amountInDeltaMaxChange;
 177 |     |             } else {
 178 |     |                 toDeltas.amountInDeltaMax += fromDeltas.amountInDeltaMax;
 179 |     |                 fromDeltas.amountInDeltaMax = 0;
 180 |     |             }
 181 |     |         }
 182 |     |         {
 183 |     |             uint128 amountOutDeltaMaxChange = uint128(uint256(fromDeltas.amountOutDeltaMax) * percentOutTransfer / 1e38);
 184 |     |             if (fromDeltas.amountOutDeltaMax > amountOutDeltaMaxChange) {
 185 |     |                 fromDeltas.amountOutDeltaMax -= amountOutDeltaMaxChange;
 186 |     |                 toDeltas.amountOutDeltaMax   += amountOutDeltaMaxChange;
 187 |     |             } else {
 188 |     |                 toDeltas.amountOutDeltaMax += fromDeltas.amountOutDeltaMax;
 189 |     |                 fromDeltas.amountOutDeltaMax = 0;
 190 |     |             }
 191 |     |         }
 192 |     |         return (fromDeltas, toDeltas);
 193 |     |     }
 194 |     | 
 195 |     |     function burnMaxCache(
 196 |     |         CoverPoolStructs.Deltas memory fromDeltas,
 197 |     |         CoverPoolStructs.Tick memory burnTick
 198 |     |     ) internal pure returns (
 199 |     |         CoverPoolStructs.Deltas memory
 200 |     |     ) {
 201 |     |         fromDeltas.amountInDeltaMax -= (fromDeltas.amountInDeltaMax 
 202 |     |                                          < burnTick.amountInDeltaMaxMinus) ? fromDeltas.amountInDeltaMax
 203 |     |                                                                            : burnTick.amountInDeltaMaxMinus;
 204 |     |         if (fromDeltas.amountInDeltaMax == 1) {
 205 |     |             fromDeltas.amountInDeltaMax = 0; // handle rounding issues
 206 |     |         }
 207 |     |         fromDeltas.amountOutDeltaMax -= (fromDeltas.amountOutDeltaMax 
 208 |     |                                           < burnTick.amountOutDeltaMaxMinus) ? fromDeltas.amountOutDeltaMax
 209 |     |                                                                              : burnTick.amountOutDeltaMaxMinus;
 210 |     |         return fromDeltas;
 211 |     |     }
 212 |     | 
 213 |     |     function burnMaxMinus(
 214 |     |         CoverPoolStructs.Tick memory fromTick,
 215 |     |         CoverPoolStructs.Deltas memory burnDeltas
 216 |     |     ) internal pure returns (
 217 |     |         CoverPoolStructs.Tick memory
 218 |     |     ) {
 219 |     |         fromTick.amountInDeltaMaxMinus -= (fromTick.amountInDeltaMaxMinus
 220 |     |                                             < burnDeltas.amountInDeltaMax) ? fromTick.amountInDeltaMaxMinus
 221 |     |                                                                            : burnDeltas.amountInDeltaMax;
 222 |     |         if (fromTick.amountInDeltaMaxMinus == 1) {
 223 |     |             fromTick.amountInDeltaMaxMinus = 0; // handle rounding issues
 224 |     |         }
 225 |     |         fromTick.amountOutDeltaMaxMinus -= (fromTick.amountOutDeltaMaxMinus 
 226 |     |                                              < burnDeltas.amountOutDeltaMax) ? fromTick.amountOutDeltaMaxMinus
 227 |     |                                                                                   : burnDeltas.amountOutDeltaMax;
 228 |     |         return fromTick;
 229 |     |     }
 230 |     | 
 231 |     |     function burnMaxPool(
 232 |     |         CoverPoolStructs.PoolState memory pool,
 233 |     |         CoverPoolStructs.UpdatePositionCache memory cache,
 234 |     |         CoverPoolStructs.UpdateParams memory params
 235 |     |     ) internal pure returns (
 236 |     |         CoverPoolStructs.PoolState memory
 237 |     |     )
 238 |     |     {
 239 |     |         uint128 amountInMaxClaimedBefore; uint128 amountOutMaxClaimedBefore;
 240 |     |         (
 241 |     |             amountInMaxClaimedBefore,
 242 |     |             amountOutMaxClaimedBefore
 243 |     |         ) = maxAuction(
 244 |     |             params.amount,
 245 |     |             cache.priceSpread,
 246 |     |             cache.position.claimPriceLast,
 247 |     |             params.zeroForOne
 248 |     |         );
 249 |     |         pool.amountInDeltaMaxClaimed  -= pool.amountInDeltaMaxClaimed > amountInMaxClaimedBefore ? amountInMaxClaimedBefore
 250 |     |                                                                                                  : pool.amountInDeltaMaxClaimed;
 251 |     |         pool.amountOutDeltaMaxClaimed -= pool.amountOutDeltaMaxClaimed > amountOutMaxClaimedBefore ? amountOutMaxClaimedBefore
 252 |     |                                                                                                    : pool.amountOutDeltaMaxClaimed;
 253 |     |         return pool;
 254 |     |     }
 255 |     | 
 256 |     |     struct FromLocals {
 257 |     |         CoverPoolStructs.Deltas fromDeltas;
 258 |     |         uint256 percentOnTick;
 259 |     |         uint128 amountInDeltaChange;
 260 |     |         uint128 amountOutDeltaChange;
 261 |     |     }
 262 |     | 
 263 |     |     function from(
 264 |     |         CoverPoolStructs.Tick memory fromTick,
 265 |     |         CoverPoolStructs.Deltas memory toDeltas,
 266 |     |         bool isPool0
 267 |     |     ) internal pure returns (
 268 |     |         CoverPoolStructs.Tick memory,
 269 |     |         CoverPoolStructs.Deltas memory
 270 |     |     ) {
 271 |     |         FromLocals memory locals;
 272 |     |         locals.fromDeltas = isPool0 ? fromTick.deltas0 
 273 |     |                                     : fromTick.deltas1;
 274 |     |         locals.percentOnTick = uint256(locals.fromDeltas.amountInDeltaMax) * 1e38 / (uint256(locals.fromDeltas.amountInDeltaMax) + uint256(fromTick.amountInDeltaMaxStashed));
 275 |     |         {
 276 |     |             locals.amountInDeltaChange = uint128(uint256(locals.fromDeltas.amountInDelta) * locals.percentOnTick / 1e38);
 277 |     |             locals.fromDeltas.amountInDelta -= locals.amountInDeltaChange;
 278 |     |             toDeltas.amountInDelta += locals.amountInDeltaChange;
 279 |     |             toDeltas.amountInDeltaMax += locals.fromDeltas.amountInDeltaMax;
 280 |     |             locals.fromDeltas.amountInDeltaMax = 0;
 281 |     |         }
 282 |     |         locals.percentOnTick = uint256(locals.fromDeltas.amountOutDeltaMax) * 1e38 / (uint256(locals.fromDeltas.amountOutDeltaMax) + uint256(fromTick.amountOutDeltaMaxStashed));
 283 |     |         {
 284 |     |             locals.amountOutDeltaChange = uint128(uint256(locals.fromDeltas.amountOutDelta) * locals.percentOnTick / 1e38);
 285 |     |             locals.fromDeltas.amountOutDelta -= locals.amountOutDeltaChange;
 286 |     |             toDeltas.amountOutDelta += locals.amountOutDeltaChange;
 287 |     |             toDeltas.amountOutDeltaMax += locals.fromDeltas.amountOutDeltaMax;
 288 |     |             locals.fromDeltas.amountOutDeltaMax = 0;
 289 |     |         }
 290 |     |         if (isPool0) {
 291 |     |             fromTick.deltas0 = locals.fromDeltas;
 292 |     |         } else {
 293 |     |             fromTick.deltas1 = locals.fromDeltas;
 294 |     |         }
 295 |     |         return (fromTick, toDeltas);
 296 |     |     }
 297 |     | 
 298 |     |     function to(
 299 |     |         CoverPoolStructs.Deltas memory fromDeltas,
 300 |     |         CoverPoolStructs.Tick memory toTick,
 301 |     |         bool isPool0
 302 |     |     ) internal pure returns (
 303 |     |         CoverPoolStructs.Deltas memory,
 304 |     |         CoverPoolStructs.Tick memory
 305 |     |     ) {
 306 |     |         CoverPoolStructs.Deltas memory toDeltas = isPool0 ? toTick.deltas0 
 307 |     |                                                           : toTick.deltas1;
 308 |     |         toDeltas.amountInDelta     += fromDeltas.amountInDelta;
 309 |     |         toDeltas.amountInDeltaMax  += fromDeltas.amountInDeltaMax;
 310 |     |         toDeltas.amountOutDelta    += fromDeltas.amountOutDelta;
 311 |     |         toDeltas.amountOutDeltaMax += fromDeltas.amountOutDeltaMax;
 312 |     |         if (isPool0) {
 313 |     |             toTick.deltas0 = toDeltas;
 314 |     |         } else {
 315 |     |             toTick.deltas1 = toDeltas;
 316 |     |         }
 317 |     |         fromDeltas = CoverPoolStructs.Deltas(0,0,0,0);
 318 |     |         return (fromDeltas, toTick);
 319 |     |     }
 320 |     | 
 321 |     |     function stash(
 322 |     |         CoverPoolStructs.Deltas memory fromDeltas,
 323 |     |         CoverPoolStructs.Tick memory toTick,
 324 |     |         bool isPool0
 325 |     |     ) internal pure returns (
 326 |     |         CoverPoolStructs.Deltas memory,
 327 |     |         CoverPoolStructs.Tick memory
 328 |     |     ) {
 329 |     |         CoverPoolStructs.Deltas memory toDeltas = isPool0 ? toTick.deltas0 
 330 |     |                                                           : toTick.deltas1;
 331 |     |         // store deltas on tick
 332 |     |         toDeltas.amountInDelta     += fromDeltas.amountInDelta;
 333 |     |         toDeltas.amountOutDelta    += fromDeltas.amountOutDelta;
 334 |     |         // store delta maxes on stashed deltas
 335 |     |         toTick.amountInDeltaMaxStashed  += fromDeltas.amountInDeltaMax;
 336 |     |         toTick.amountOutDeltaMaxStashed += fromDeltas.amountOutDeltaMax;
 337 |     |         if (isPool0) {
 338 |     |             toTick.deltas0 = toDeltas;
 339 |     |             toTick.pool0Stash = true;
 340 |     |         } else {
 341 |     |             toTick.deltas1 = toDeltas;
 342 |     |             toTick.pool0Stash = false;
 343 |     |         }
 344 |     |         fromDeltas = CoverPoolStructs.Deltas(0,0,0,0);
 345 |     |         return (fromDeltas, toTick);
 346 |     |     }
 347 |     | 
 348 |     |     struct UnstashLocals {
 349 |     |         CoverPoolStructs.Deltas fromDeltas;
 350 |     |         uint256 totalDeltaMax;
 351 |     |         uint256 percentStashed;
 352 |     |         uint128 amountInDeltaChange;
 353 |     |         uint128 amountOutDeltaChange;
 354 |     |     }
 355 |     | 
 356 |     |     function unstash(
 357 |     |         CoverPoolStructs.Tick memory fromTick,
 358 |     |         CoverPoolStructs.Deltas memory toDeltas,
 359 |     |         bool isPool0
 360 |     |     ) internal pure returns (
 361 |     |         CoverPoolStructs.Tick memory,
 362 |     |         CoverPoolStructs.Deltas memory
 363 |     |     ) {
 364 |     |         toDeltas.amountInDeltaMax  += fromTick.amountInDeltaMaxStashed;
 365 |     |         toDeltas.amountOutDeltaMax += fromTick.amountOutDeltaMaxStashed;
 366 |     | 
 367 |     |         UnstashLocals memory locals;
 368 |     |         locals.fromDeltas = isPool0 ? fromTick.deltas0 : fromTick.deltas1;
 369 |     |         locals.totalDeltaMax = uint256(fromTick.amountInDeltaMaxStashed) + uint256(locals.fromDeltas.amountInDeltaMax);
 370 |     |         
 371 |     |         if (locals.totalDeltaMax > 0) {
 372 |     |             locals.percentStashed = uint256(fromTick.amountInDeltaMaxStashed) * 1e38 / locals.totalDeltaMax;
 373 |     |             locals.amountInDeltaChange = uint128(uint256(locals.fromDeltas.amountInDelta) * locals.percentStashed / 1e38);
 374 |     |             locals.fromDeltas.amountInDelta -= locals.amountInDeltaChange;
 375 |     |             toDeltas.amountInDelta += locals.amountInDeltaChange;
 376 |     |         }
 377 |     |         
 378 |     |         locals.totalDeltaMax = uint256(fromTick.amountOutDeltaMaxStashed) + uint256(locals.fromDeltas.amountOutDeltaMax);
 379 |     |         
 380 |     |         if (locals.totalDeltaMax > 0) {
 381 |     |             locals.percentStashed = uint256(fromTick.amountOutDeltaMaxStashed) * 1e38 / locals.totalDeltaMax;
 382 |     |             locals.amountOutDeltaChange = uint128(uint256(locals.fromDeltas.amountOutDelta) * locals.percentStashed / 1e38);
 383 |     |             locals.fromDeltas.amountOutDelta -= locals.amountOutDeltaChange;
 384 |     |             toDeltas.amountOutDelta += locals.amountOutDeltaChange;
 385 |     |         }
 386 |     |         if (isPool0) {
 387 |     |             fromTick.deltas0 = locals.fromDeltas;
 388 |     |         } else {
 389 |     |             fromTick.deltas1 = locals.fromDeltas;
 390 |     |         }
 391 |     |         fromTick.amountInDeltaMaxStashed = 0;
 392 |     |         fromTick.amountOutDeltaMaxStashed = 0;
 393 |     | 
 394 |     |         return (fromTick, toDeltas);
 395 |     |     }
 396 |     | 
 397 |     |     function update(
 398 |     |         CoverPoolStructs.Tick memory tick,
 399 |     |         uint128 amount,
 400 |     |         uint160 priceLower,
 401 |     |         uint160 priceUpper,
 402 |     |         bool   isPool0,
 403 |     |         bool   isAdded
 404 |     |     ) internal pure returns (
 405 |     |         CoverPoolStructs.Tick memory,
 406 |     |         CoverPoolStructs.Deltas memory
 407 |     |     ) {
 408 |     |         // update max deltas
 409 |     |         uint128 amountInDeltaMax; uint128 amountOutDeltaMax;
 410 |     |         if (isPool0) {
 411 |     |             (
 412 |     |                 amountInDeltaMax,
 413 |     |                 amountOutDeltaMax
 414 |     |             ) = max(amount, priceUpper, priceLower, true);
 415 |     |         } else {
 416 |     |             (
 417 |     |                 amountInDeltaMax,
 418 |     |                 amountOutDeltaMax
 419 |     |             ) = max(amount, priceLower, priceUpper, false);
 420 |     |         }
 421 |     |         if (isAdded) {
 422 |     |             tick.amountInDeltaMaxMinus  += amountInDeltaMax;
 423 |     |             tick.amountOutDeltaMaxMinus += amountOutDeltaMax;
 424 |     |         } else {
 425 |     |             tick.amountInDeltaMaxMinus  -= tick.amountInDeltaMaxMinus  > amountInDeltaMax ? amountInDeltaMax
 426 |     |                                                                                           : tick.amountInDeltaMaxMinus;
 427 |     |             tick.amountOutDeltaMaxMinus -= tick.amountOutDeltaMaxMinus > amountOutDeltaMax ? amountOutDeltaMax                                                                           : tick.amountOutDeltaMaxMinus;
 428 |     |         }
 429 |     |         return (tick, CoverPoolStructs.Deltas(0,0,amountInDeltaMax, amountOutDeltaMax));
 430 |     |     }
 431 |     | }

/home/ec2-user/git/cover/contracts/libraries/EpochMap.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import './math/ConstantProduct.sol';
  5 |     | import '../interfaces/structs/CoverPoolStructs.sol';
  6 |     | 
  7 |     | library EpochMap {
  8 |     |     function set(
  9 |     |         int24  tick,
 10 |     |         uint256 epoch,
 11 |     |         bool zeroForOne,
 12 |     |         CoverPoolStructs.TickMap storage tickMap,
 13 |     |         PoolsharkStructs.CoverImmutables memory constants
 14 |     |     ) internal {
 15 |     |         (
 16 |     |             uint256 tickIndex,
 17 |     |             uint256 wordIndex,
 18 |     |             uint256 blockIndex,
 19 |     |             uint256 volumeIndex
 20 |     |         ) = getIndices(tick, constants);
 21 |     |         // assert epoch isn't bigger than max uint32
 22 |     |         uint256 epochValue = zeroForOne ? tickMap.epochs0[volumeIndex][blockIndex][wordIndex]
 23 |     |                                         : tickMap.epochs1[volumeIndex][blockIndex][wordIndex];
 24 |     |         // clear previous value
 25 |     |         epochValue &=  ~(((1 << 9) - 1) << ((tickIndex & 0x7) * 32));
 26 |     |         // add new value to word
 27 |     |         epochValue |= epoch << ((tickIndex & 0x7) * 32);
 28 |     |         // store word in map
 29 |     |         if (zeroForOne) {
 30 |     |             tickMap.epochs0[volumeIndex][blockIndex][wordIndex] = epochValue;
 31 |     |         } else {
 32 |     |             tickMap.epochs1[volumeIndex][blockIndex][wordIndex] = epochValue;
 33 |     |         }
 34 |     |     }
 35 |     | 
 36 |     |     function get(
 37 |     |         int24 tick,
 38 |     |         bool zeroForOne,
 39 |     |         CoverPoolStructs.TickMap storage tickMap,
 40 |     |         PoolsharkStructs.CoverImmutables memory constants
 41 |     |     ) internal view returns (
 42 |     |         uint32 epoch
 43 |     |     ) {
 44 |     |         (
 45 |     |             uint256 tickIndex,
 46 |     |             uint256 wordIndex,
 47 |     |             uint256 blockIndex,
 48 |     |             uint256 volumeIndex
 49 |     |         ) = getIndices(tick, constants);
 50 |     | 
 51 |     |         uint256 epochValue = zeroForOne ? tickMap.epochs0[volumeIndex][blockIndex][wordIndex]
 52 |     |                                         : tickMap.epochs1[volumeIndex][blockIndex][wordIndex];
 53 |     |         // right shift so first 8 bits are epoch value
 54 |     |         epochValue >>= ((tickIndex & 0x7) * 32);
 55 |     |         // clear other bits
 56 |     |         epochValue &= ((1 << 32) - 1);
 57 |     |         return uint32(epochValue);
 58 |     |     }
 59 |     | 
 60 |     |     function getIndices(
 61 |     |         int24 tick,
 62 |     |         PoolsharkStructs.CoverImmutables memory constants
 63 |     |     ) public pure returns (
 64 |     |             uint256 tickIndex,
 65 |     |             uint256 wordIndex,
 66 |     |             uint256 blockIndex,
 67 |     |             uint256 volumeIndex
 68 |     |         )
 69 |     |     {
 70 |     |         unchecked {
 71 |     |             if (tick > ConstantProduct.maxTick(constants.tickSpread)) require (false, 'TickIndexOverflow()');
 72 |     |             if (tick < ConstantProduct.minTick(constants.tickSpread)) require (false, 'TickIndexUnderflow()');
 73 |     |             if (tick % constants.tickSpread != 0) require (false, 'TickIndexInvalid()');
 74 |     |             tickIndex = uint256(int256((tick - ConstantProduct.minTick(constants.tickSpread))) / constants.tickSpread);
 75 |     |             wordIndex = tickIndex >> 3;        // 2^3 epochs per word
 76 |     |             blockIndex = tickIndex >> 11;      // 2^8 words per block
 77 |     |             volumeIndex = tickIndex >> 19;     // 2^8 blocks per volume
 78 |     |             if (blockIndex > 1023) require (false, 'BlockIndexOverflow()');
 79 |     |         }
 80 |     |     }
 81 |     | 
 82 |     |     function _tick (
 83 |     |         uint256 tickIndex,
 84 |     |         PoolsharkStructs.CoverImmutables memory constants
 85 |     |     ) internal pure returns (
 86 |     |         int24 tick
 87 |     |     ) {
 88 |     |         unchecked {
 89 |     |             if (tickIndex > uint24(ConstantProduct.maxTick(constants.tickSpread) * 2)) require (false, 'TickIndexOverflow()');
 90 |     |             tick = int24(int256(tickIndex) * int256(constants.tickSpread) + ConstantProduct.maxTick(constants.tickSpread));
 91 |     |         }
 92 |     |     }
 93 |     | }
 94 |     | 

/home/ec2-user/git/cover/contracts/libraries/Epochs.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../interfaces/modules/sources/ITwapSource.sol';
   5 |     | import '../interfaces/structs/CoverPoolStructs.sol';
   6 |     | import './Deltas.sol';
   7 |     | import './Ticks.sol';
   8 |     | import './TickMap.sol';
   9 |     | import './EpochMap.sol';
  10 |     | import '../test/echidna/EchidnaAssertions.sol';
  11 |     | 
  12 |     | library Epochs {
  13 |     |     event Sync(
  14 |     |         uint160 pool0Price,
  15 |     |         uint160 pool1Price,
  16 |     |         uint128 pool0Liquidity,
  17 |     |         uint128 pool1Liquidity,
  18 |     |         uint32 auctionStart,
  19 |     |         uint32 accumEpoch,
  20 |     |         int24 oldLatestTick,
  21 |     |         int24 newLatestTick
  22 |     |     );
  23 |     | 
  24 |     |     event FinalDeltasAccumulated(
  25 |     |         uint128 amountInDelta,
  26 |     |         uint128 amountOutDelta,
  27 |     |         uint32 accumEpoch,
  28 |     |         int24 accumTick,
  29 |     |         bool isPool0
  30 |     |     );
  31 |     | 
  32 |     |     event StashDeltasCleared(
  33 |     |         int24 stashTick,
  34 |     |         bool isPool0
  35 |     |     );
  36 |     | 
  37 |     |     event MaxLatestTickMove(
  38 |     |         int24 maxLatestTickMove,
  39 |     |         int24 newLatestTick
  40 |     |     );
  41 |     | 
  42 |     |     event StashDeltasAccumulated(
  43 |     |         uint128 amountInDelta,
  44 |     |         uint128 amountOutDelta,
  45 |     |         uint128 amountInDeltaMaxStashed,
  46 |     |         uint128 amountOutDeltaMaxStashed,
  47 |     |         uint32 accumEpoch,
  48 |     |         int24 stashTick,
  49 |     |         bool isPool0
  50 |     |     );
  51 |     | 
  52 |     |     event SyncFeesCollected(
  53 |     |         address collector,
  54 |     |         uint128 token0Amount,
  55 |     |         uint128 token1Amount
  56 |     |     );
  57 |     | 
  58 |     |     function simulateSync(
  59 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
  60 |     |         CoverPoolStructs.TickMap storage tickMap,
  61 |     |         CoverPoolStructs.PoolState memory pool0,
  62 |     |         CoverPoolStructs.PoolState memory pool1,
  63 |     |         CoverPoolStructs.GlobalState memory state,
  64 |     |         PoolsharkStructs.CoverImmutables memory constants
  65 |     |     ) internal returns (
  66 |     |         CoverPoolStructs.GlobalState memory,
  67 |     |         CoverPoolStructs.SyncFees memory,
  68 |     |         CoverPoolStructs.PoolState memory,
  69 |     |         CoverPoolStructs.PoolState memory
  70 |     |     ) {
  71 |     |         CoverPoolStructs.AccumulateCache memory cache;
  72 |     |         {
  73 |     |             bool earlyReturn;
  74 |     |             (cache.newLatestTick, earlyReturn) = _syncTick(state, constants);
  75 |     |             // assert tick is within bounds
  76 |     |             EchidnaAssertions.assertTickDivisibleByTickSpacing(cache.newLatestTick, constants.tickSpread);
  77 |     |             EchidnaAssertions.assertTickWithinBounds(
  78 |     |                 cache.newLatestTick,
  79 |     |                 ConstantProduct.minTick(constants.tickSpread) + constants.tickSpread,
  80 |     |                 ConstantProduct.maxTick(constants.tickSpread) - constants.tickSpread
  81 |     |             );
  82 |     |             if (earlyReturn) {
  83 |     |                 return (state, CoverPoolStructs.SyncFees(0, 0), pool0, pool1);
  84 |     |             }
  85 |     |             // else we have a TWAP update
  86 |     |         }
  87 |     | 
  88 |     |         // setup cache
  89 |     |         cache = CoverPoolStructs.AccumulateCache({
  90 |     |             deltas0: CoverPoolStructs.Deltas(0, 0, 0, 0), // deltas for pool0
  91 |     |             deltas1: CoverPoolStructs.Deltas(0, 0, 0, 0),  // deltas for pool1
  92 |     |             syncFees: CoverPoolStructs.SyncFees(0, 0),
  93 |     |             newLatestTick: cache.newLatestTick,
  94 |     |             nextTickToCross0: state.latestTick, // above
  95 |     |             nextTickToCross1: state.latestTick, // below
  96 |     |             nextTickToAccum0: TickMap.previous(state.latestTick, tickMap, constants), // below
  97 |     |             nextTickToAccum1: TickMap.next(state.latestTick, tickMap, constants),     // above
  98 |     |             stopTick0: (cache.newLatestTick > state.latestTick) // where we do stop for pool0 sync
  99 |     |                 ? state.latestTick - constants.tickSpread
 100 |     |                 : cache.newLatestTick, 
 101 |     |             stopTick1: (cache.newLatestTick > state.latestTick) // where we do stop for pool1 sync
 102 |     |                 ? cache.newLatestTick
 103 |     |                 : state.latestTick + constants.tickSpread
 104 |     |         });
 105 |     | 
 106 |     |         while (cache.nextTickToCross0 != cache.nextTickToAccum0) {
 107 |     |             // rollover and calculate sync fees
 108 |     |             (cache, pool0) = _rollover(state, cache, pool0, constants, true);
 109 |     |             // keep looping until accumulation reaches stopTick0 
 110 |     |             if (cache.nextTickToAccum0 >= cache.stopTick0) {
 111 |     |                 (pool0.liquidity, cache.nextTickToCross0, cache.nextTickToAccum0) = _cross(
 112 |     |                     ticks[cache.nextTickToAccum0].liquidityDelta,
 113 |     |                     tickMap,
 114 |     |                     constants,
 115 |     |                     cache.nextTickToCross0,
 116 |     |                     cache.nextTickToAccum0,
 117 |     |                     pool0.liquidity,
 118 |     |                     true
 119 |     |                 );
 120 |     |             } else break;
 121 |     |         }
 122 |     | 
 123 |     |         while (cache.nextTickToCross1 != cache.nextTickToAccum1) {
 124 |     |             (cache, pool1) = _rollover(state, cache, pool1, constants, false);
 125 |     |             // keep looping until accumulation reaches stopTick1 
 126 |     |             if (cache.nextTickToAccum1 <= cache.stopTick1) {
 127 |     |                 (pool1.liquidity, cache.nextTickToCross1, cache.nextTickToAccum1) = _cross(
 128 |     |                     ticks[cache.nextTickToAccum1].liquidityDelta,
 129 |     |                     tickMap,
 130 |     |                     constants,
 131 |     |                     cache.nextTickToCross1,
 132 |     |                     cache.nextTickToAccum1,
 133 |     |                     pool1.liquidity,
 134 |     |                     false
 135 |     |                 );
 136 |     |             } else break;
 137 |     |         }
 138 |     | 
 139 |     |         // update ending pool price for fully filled auction
 140 |     |         state.latestPrice = ConstantProduct.getPriceAtTick(cache.newLatestTick, constants);
 141 |     |         
 142 |     |         // set pool price and liquidity
 143 |     |         if (cache.newLatestTick > state.latestTick) {
 144 |     |             pool0.liquidity = 0;
 145 |     |             pool0.price = state.latestPrice;
 146 |     |             pool1.price = ConstantProduct.getPriceAtTick(cache.newLatestTick + constants.tickSpread, constants);
 147 |     |         } else {
 148 |     |             pool1.liquidity = 0;
 149 |     |             pool0.price = ConstantProduct.getPriceAtTick(cache.newLatestTick - constants.tickSpread, constants);
 150 |     |             pool1.price = state.latestPrice;
 151 |     |         }
 152 |     |         
 153 |     |         // set auction start as an offset of the pool genesis block
 154 |     |         state.auctionStart = uint32(block.timestamp) - constants.genesisTime;
 155 |     |         state.latestTick = cache.newLatestTick;
 156 |     |     
 157 |     |         return (state, cache.syncFees, pool0, pool1);
 158 |     |     }
 159 |     | 
 160 |     |     function syncLatest(
 161 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 162 |     |         CoverPoolStructs.TickMap storage tickMap,
 163 |     |         CoverPoolStructs.PoolState memory pool0,
 164 |     |         CoverPoolStructs.PoolState memory pool1,
 165 |     |         CoverPoolStructs.GlobalState memory state,
 166 |     |         PoolsharkStructs.CoverImmutables memory constants
 167 |     |     ) internal returns (
 168 |     |         CoverPoolStructs.GlobalState memory,
 169 |     |         CoverPoolStructs.SyncFees memory,
 170 |     |         CoverPoolStructs.PoolState memory,
 171 |     |         CoverPoolStructs.PoolState memory
 172 |     |     )
 173 |     |     {
 174 |     |         CoverPoolStructs.AccumulateCache memory cache;
 175 |     |         {
 176 |     |             bool earlyReturn;
 177 |     |             (cache.newLatestTick, earlyReturn) = _syncTick(state, constants);
 178 |     |             if (earlyReturn) {
 179 |     |                 return (state, CoverPoolStructs.SyncFees(0,0), pool0, pool1);
 180 |     |             }
 181 |     |             // else we have a TWAP update
 182 |     |         }
 183 |     | 
 184 |     |         // increase epoch counter
 185 |     |         state.accumEpoch += 1;
 186 |     | 
 187 |     |         // setup cache
 188 |     |         cache = CoverPoolStructs.AccumulateCache({
 189 |     |             deltas0: CoverPoolStructs.Deltas(0, 0, 0, 0), // deltas for pool0
 190 |     |             deltas1: CoverPoolStructs.Deltas(0, 0, 0, 0),  // deltas for pool1
 191 |     |             syncFees: CoverPoolStructs.SyncFees(0,0),
 192 |     |             newLatestTick: cache.newLatestTick,
 193 |     |             nextTickToCross0: state.latestTick, // above
 194 |     |             nextTickToCross1: state.latestTick, // below
 195 |     |             nextTickToAccum0: TickMap.previous(state.latestTick, tickMap, constants), // below
 196 |     |             nextTickToAccum1: TickMap.next(state.latestTick, tickMap, constants),     // above
 197 |     |             stopTick0: (cache.newLatestTick > state.latestTick) // where we do stop for pool0 sync
 198 |     |                 ? state.latestTick - constants.tickSpread
 199 |     |                 : cache.newLatestTick, 
 200 |     |             stopTick1: (cache.newLatestTick > state.latestTick) // where we do stop for pool1 sync
 201 |     |                 ? cache.newLatestTick
 202 |     |                 : state.latestTick + constants.tickSpread
 203 |     |         });
 204 |     |         while (cache.nextTickToCross0 != cache.nextTickToAccum0) {
 205 |     |             // rollover deltas
 206 |     |             (cache, pool0) = _rollover(state, cache, pool0, constants, true);
 207 |     |             if (cache.nextTickToAccum0 > cache.stopTick0 
 208 |     |                  && ticks[cache.nextTickToAccum0].amountInDeltaMaxMinus > 0) {
 209 |     |                 EpochMap.set(cache.nextTickToAccum0, state.accumEpoch, true, tickMap, constants);
 210 |     |             }
 211 |     |             // accumulate to next tick
 212 |     |             CoverPoolStructs.AccumulateParams memory params = CoverPoolStructs.AccumulateParams({
 213 |     |                 deltas: cache.deltas0,
 214 |     |                 crossTick: ticks[cache.nextTickToCross0],
 215 |     |                 accumTick: ticks[cache.nextTickToAccum0],
 216 |     |                 updateAccumDeltas: cache.newLatestTick > state.latestTick                // check twap move up or down
 217 |     |                                             ? cache.nextTickToAccum0 == cache.stopTick0  // move up - true at stop tick
 218 |     |                                             : cache.nextTickToAccum0 >= cache.stopTick0, // move down - at or above stop tick
 219 |     |                 isPool0: true
 220 |     |             });
 221 |     |             params = _accumulate(
 222 |     |                 cache,
 223 |     |                 params,
 224 |     |                 state
 225 |     |             );
 226 |     |             /// @dev - deltas in cache updated after _accumulate
 227 |     |             cache.deltas0 = params.deltas;
 228 |     |             ticks[cache.nextTickToAccum0] = params.accumTick;
 229 |     |             Ticks.cleanup(
 230 |     |                ticks,
 231 |     |                tickMap,
 232 |     |                constants,
 233 |     |                params.crossTick,
 234 |     |                cache.nextTickToCross0
 235 |     |             );
 236 |     |             // keep looping until accumulation reaches stopTick0 
 237 |     |             if (cache.nextTickToAccum0 >= cache.stopTick0) {
 238 |     |                 (pool0.liquidity, cache.nextTickToCross0, cache.nextTickToAccum0) = _cross(
 239 |     |                     ticks[cache.nextTickToAccum0].liquidityDelta,
 240 |     |                     tickMap,
 241 |     |                     constants,
 242 |     |                     cache.nextTickToCross0,
 243 |     |                     cache.nextTickToAccum0,
 244 |     |                     pool0.liquidity,
 245 |     |                     true
 246 |     |                 );
 247 |     |                 EchidnaAssertions.assertInfiniteLoop0(cache.nextTickToAccum0, cache.nextTickToCross0, ConstantProduct.minTick(constants.tickSpread));
 248 |     |             } else break;
 249 |     |         }
 250 |     |         // pool0 checkpoint
 251 |     |         {
 252 |     |             // create stopTick0 if necessary
 253 |     |             if (cache.nextTickToAccum0 != cache.stopTick0) {
 254 |     |                 TickMap.set(cache.stopTick0, tickMap, constants);
 255 |     |             }
 256 |     |             CoverPoolStructs.Tick memory stopTick0 = ticks[cache.stopTick0];
 257 |     |             // checkpoint at stopTick0
 258 |     |             (stopTick0) = _stash(
 259 |     |                 stopTick0,
 260 |     |                 cache,
 261 |     |                 state,
 262 |     |                 pool0.liquidity,
 263 |     |                 true
 264 |     |             );
 265 |     |             EpochMap.set(cache.stopTick0, state.accumEpoch, true, tickMap, constants);
 266 |     |             ticks[cache.stopTick0] = stopTick0;
 267 |     |         }
 268 |     |         while (cache.nextTickToCross1 != cache.nextTickToAccum1) {
 269 |     |             // rollover deltas pool1
 270 |     |             (cache, pool1) = _rollover(state, cache, pool1, constants, false);
 271 |     |             // accumulate deltas pool1
 272 |     |             if (cache.nextTickToAccum1 < cache.stopTick1 
 273 |     |                  && ticks[cache.nextTickToAccum1].amountInDeltaMaxMinus > 0) {
 274 |     |                 EpochMap.set(cache.nextTickToAccum1, state.accumEpoch, false, tickMap, constants);
 275 |     |             }
 276 |     |             {
 277 |     |                 CoverPoolStructs.AccumulateParams memory params = CoverPoolStructs.AccumulateParams({
 278 |     |                     deltas: cache.deltas1,
 279 |     |                     crossTick: ticks[cache.nextTickToCross1],
 280 |     |                     accumTick: ticks[cache.nextTickToAccum1],
 281 |     |                     updateAccumDeltas: cache.newLatestTick > state.latestTick                   // check twap move up or down
 282 |     |                                                 ? cache.nextTickToAccum1 <= cache.stopTick1     // move up - below or at
 283 |     |                                                 : cache.nextTickToAccum1 == cache.stopTick1,    // move down - at
 284 |     |                     isPool0: false
 285 |     |                 });
 286 |     |                 params = _accumulate(
 287 |     |                     cache,
 288 |     |                     params,
 289 |     |                     state
 290 |     |                 );
 291 |     |                 /// @dev - deltas in cache updated after _accumulate
 292 |     |                 cache.deltas1 = params.deltas;
 293 |     |                 ticks[cache.nextTickToAccum1] = params.accumTick;
 294 |     |                 Ticks.cleanup(
 295 |     |                     ticks,
 296 |     |                     tickMap,
 297 |     |                     constants,
 298 |     |                     params.crossTick,
 299 |     |                     cache.nextTickToCross1
 300 |     |                 );
 301 |     |             }
 302 |     |             // keep looping until accumulation reaches stopTick1 
 303 |     |             if (cache.nextTickToAccum1 <= cache.stopTick1) {
 304 |     |                 (pool1.liquidity, cache.nextTickToCross1, cache.nextTickToAccum1) = _cross(
 305 |     |                     ticks[cache.nextTickToAccum1].liquidityDelta,
 306 |     |                     tickMap,
 307 |     |                     constants,
 308 |     |                     cache.nextTickToCross1,
 309 |     |                     cache.nextTickToAccum1,
 310 |     |                     pool1.liquidity,
 311 |     |                     false
 312 |     |                 );
 313 |     |                 EchidnaAssertions.assertInfiniteLoop1(cache.nextTickToAccum1, cache.nextTickToCross1, ConstantProduct.maxTick(constants.tickSpread));
 314 |     |             } else break;
 315 |     |         }
 316 |     |         // pool1 checkpoint
 317 |     |         {
 318 |     |             // create stopTick1 if necessary
 319 |     |             if (cache.nextTickToAccum1 != cache.stopTick1) {
 320 |     |                 TickMap.set(cache.stopTick1, tickMap, constants);
 321 |     |             }
 322 |     |             CoverPoolStructs.Tick memory stopTick1 = ticks[cache.stopTick1];
 323 |     |             // update deltas on stopTick
 324 |     |             (stopTick1) = _stash(
 325 |     |                 stopTick1,
 326 |     |                 cache,
 327 |     |                 state,
 328 |     |                 pool1.liquidity,
 329 |     |                 false
 330 |     |             );
 331 |     |             ticks[cache.stopTick1] = stopTick1;
 332 |     |             EpochMap.set(cache.stopTick1, state.accumEpoch, false, tickMap, constants);
 333 |     |         }
 334 |     |         // update ending pool price for fully filled auction
 335 |     |         state.latestPrice = ConstantProduct.getPriceAtTick(cache.newLatestTick, constants);
 336 |     |         
 337 |     |         // set pool price and liquidity
 338 |     |         if (cache.newLatestTick > state.latestTick) {
 339 |     |             pool0.liquidity = 0;
 340 |     |             pool0.price = state.latestPrice;
 341 |     |             pool1.price = ConstantProduct.getPriceAtTick(cache.newLatestTick + constants.tickSpread, constants);
 342 |     |         } else {
 343 |     |             pool1.liquidity = 0;
 344 |     |             pool0.price = ConstantProduct.getPriceAtTick(cache.newLatestTick - constants.tickSpread, constants);
 345 |     |             pool1.price = state.latestPrice;
 346 |     |         }
 347 |     |         
 348 |     |         // set auction start as an offset of the pool genesis block
 349 |     |         state.auctionStart = uint32(block.timestamp - constants.genesisTime);
 350 |     | 
 351 |     |         // emit sync event
 352 |     |         emit Sync(pool0.price, pool1.price, pool0.liquidity, pool1.liquidity, state.auctionStart, state.accumEpoch, state.latestTick, cache.newLatestTick);
 353 |     |         
 354 |     |         // update latestTick
 355 |     |         state.latestTick = cache.newLatestTick;
 356 |     | 
 357 |     |         if (cache.syncFees.token0 > 0 || cache.syncFees.token1 > 0) {
 358 |     |             emit SyncFeesCollected(msg.sender, cache.syncFees.token0, cache.syncFees.token1);
 359 |     |         }
 360 |     |     
 361 |     |         return (state, cache.syncFees, pool0, pool1);
 362 |     |     }
 363 |     | 
 364 |     |     function _syncTick(
 365 |     |         CoverPoolStructs.GlobalState memory state,
 366 |     |         PoolsharkStructs.CoverImmutables memory constants
 367 |     |     ) internal returns(
 368 |     |         int24 newLatestTick,
 369 |     |         bool
 370 |     |     ) {
 371 |     |         // update last block checked
 372 |     |         if (block.timestamp - constants.genesisTime > type(uint32).max)
 373 |     |             require(false, 'MaxBlockTimestampExceeded()');
 374 |     |         if(state.lastTime == block.timestamp - constants.genesisTime) {
 375 |     |             return (state.latestTick, true);
 376 |     |         }
 377 |     |         state.lastTime = uint32(block.timestamp - constants.genesisTime);
 378 |     |         // check auctions elapsed
 379 |     |         uint32 timeElapsed = state.lastTime - state.auctionStart;
 380 |     |         int32 auctionsElapsed;
 381 |     | 
 382 |     |         // handle int32 overflow
 383 |     |         if (timeElapsed / constants.auctionLength <= uint32(type(int32).max))
 384 |     |             auctionsElapsed = int32(timeElapsed / constants.auctionLength) - 1; /// @dev - subtract 1 for 3/4 twapLength check
 385 |     |         else
 386 |     |             auctionsElapsed = type(int32).max - 1;
 387 |     | 
 388 |     |         // if 3/4 of twapLength or auctionLength has passed allow for latestTick move
 389 |     |         if (timeElapsed > 3 * constants.twapLength / 4 ||
 390 |     |             timeElapsed > constants.auctionLength) auctionsElapsed += 1;
 391 |     |         if (auctionsElapsed < 1) {
 392 |     |             return (state.latestTick, true);
 393 |     |         }
 394 |     |         newLatestTick = constants.source.calculateAverageTick(constants, state.latestTick);
 395 |     | 
 396 |     |         /// @dev - shift up/down one quartile to put pool ahead of TWAP
 397 |     |         if (newLatestTick > state.latestTick)
 398 |     |              newLatestTick += constants.tickSpread / 4;
 399 |     |         else if (newLatestTick <= state.latestTick - 3 * constants.tickSpread / 4)
 400 |     |              newLatestTick -= constants.tickSpread / 4;
 401 |     |         
 402 |     |         // make newLatestTick an even multiple of tickSpread
 403 |     |         newLatestTick = newLatestTick / constants.tickSpread * constants.tickSpread;
 404 |     | 
 405 |     |         // if unchanged return early
 406 |     |         if (newLatestTick == state.latestTick) {
 407 |     |             return (state.latestTick, true);
 408 |     |         }
 409 |     | 
 410 |     |         // rate-limit tick move
 411 |     |         int24 maxLatestTickMove;
 412 |     |         
 413 |     |         // handle int24 overflow
 414 |     |         if (auctionsElapsed <= type(int24).max / constants.tickSpread) {
 415 |     |             maxLatestTickMove = int24(constants.tickSpread * auctionsElapsed);
 416 |     |         } else {
 417 |     |             maxLatestTickMove = type(int24).max / constants.tickSpread * constants.tickSpread;
 418 |     |         }
 419 |     | 
 420 |     |         /// @dev - latestTick can only move based on auctionsElapsed 
 421 |     |         if (newLatestTick > state.latestTick) {
 422 |     |             if (newLatestTick - state.latestTick > maxLatestTickMove)
 423 |     |                 newLatestTick = state.latestTick + maxLatestTickMove;
 424 |     |         } else {
 425 |     |             if (state.latestTick - newLatestTick > maxLatestTickMove)
 426 |     |                 newLatestTick = state.latestTick - maxLatestTickMove;
 427 |     |         }
 428 |     |         emit MaxLatestTickMove(maxLatestTickMove, newLatestTick);
 429 |     |         return (newLatestTick, false);
 430 |     |     }
 431 |     | 
 432 |     |     function _rollover(
 433 |     |         CoverPoolStructs.GlobalState memory state,
 434 |     |         CoverPoolStructs.AccumulateCache memory cache,
 435 |     |         CoverPoolStructs.PoolState memory pool,
 436 |     |         PoolsharkStructs.CoverImmutables memory constants,
 437 |     |         bool isPool0
 438 |     |     ) internal pure returns (
 439 |     |         CoverPoolStructs.AccumulateCache memory,
 440 |     |         CoverPoolStructs.PoolState memory
 441 |     |     ) {
 442 |     |         if (pool.liquidity == 0) {
 443 |     |             return (cache, pool);
 444 |     |         }
 445 |     |         uint160 crossPrice; uint160 accumPrice; uint160 currentPrice;
 446 |     |         if (isPool0) {
 447 |     |             crossPrice = ConstantProduct.getPriceAtTick(cache.nextTickToCross0, constants);
 448 |     |             int24 nextTickToAccum = (cache.nextTickToAccum0 < cache.stopTick0)
 449 |     |                                         ? cache.stopTick0
 450 |     |                                         : cache.nextTickToAccum0;
 451 |     |             accumPrice = ConstantProduct.getPriceAtTick(nextTickToAccum, constants);
 452 |     |             // check for multiple auction skips
 453 |     |             if (cache.nextTickToCross0 == state.latestTick && cache.nextTickToCross0 - nextTickToAccum > constants.tickSpread) {
 454 |     |                 uint160 spreadPrice = ConstantProduct.getPriceAtTick(cache.nextTickToCross0 - constants.tickSpread, constants);
 455 |     |                 /// @dev - amountOutDeltaMax accounted for down below
 456 |     |                 cache.deltas0.amountOutDelta += uint128(ConstantProduct.getDx(pool.liquidity, accumPrice, spreadPrice, false));
 457 |     |             }
 458 |     |             currentPrice = pool.price;
 459 |     |             // if pool.price the bounds set currentPrice to start of auction
 460 |     |             if (!(pool.price > accumPrice && pool.price < crossPrice)) currentPrice = accumPrice;
 461 |     |             // if auction is current and fully filled => set currentPrice to crossPrice
 462 |     |             if (state.latestTick == cache.nextTickToCross0 && crossPrice == pool.price) currentPrice = crossPrice;
 463 |     |         } else {
 464 |     |             crossPrice = ConstantProduct.getPriceAtTick(cache.nextTickToCross1, constants);
 465 |     |             int24 nextTickToAccum = (cache.nextTickToAccum1 > cache.stopTick1)
 466 |     |                                         ? cache.stopTick1
 467 |     |                                         : cache.nextTickToAccum1;
 468 |     |             accumPrice = ConstantProduct.getPriceAtTick(nextTickToAccum, constants);
 469 |     |             // check for multiple auction skips
 470 |     |             if (cache.nextTickToCross1 == state.latestTick && nextTickToAccum - cache.nextTickToCross1 > constants.tickSpread) {
 471 |     |                 uint160 spreadPrice = ConstantProduct.getPriceAtTick(cache.nextTickToCross1 + constants.tickSpread, constants);
 472 |     |                 /// @dev - DeltaMax values accounted for down below
 473 |     |                 cache.deltas1.amountOutDelta += uint128(ConstantProduct.getDy(pool.liquidity, spreadPrice, accumPrice, false));
 474 |     |             }
 475 |     |             currentPrice = pool.price;
 476 |     |             if (!(pool.price < accumPrice && pool.price > crossPrice)) currentPrice = accumPrice;
 477 |     |             if (state.latestTick == cache.nextTickToCross1 && crossPrice == pool.price) currentPrice = crossPrice;
 478 |     |         }
 479 |     | 
 480 |     |         //handle liquidity rollover
 481 |     |         if (isPool0) {
 482 |     |             {
 483 |     |                 // amountIn pool did not receive
 484 |     |                 uint128 amountInDelta;
 485 |     |                 uint128 amountInDeltaMax  = uint128(ConstantProduct.getDy(pool.liquidity, accumPrice, crossPrice, false));
 486 |     |                 amountInDelta       = pool.amountInDelta;
 487 |     |                 amountInDeltaMax   -= (amountInDeltaMax < pool.amountInDeltaMaxClaimed) ? amountInDeltaMax 
 488 |     |                                                                                         : pool.amountInDeltaMaxClaimed;
 489 |     |                 pool.amountInDelta  = 0;
 490 |     |                 pool.amountInDeltaMaxClaimed = 0;
 491 |     | 
 492 |     |                 // update cache in deltas
 493 |     |                 cache.deltas0.amountInDelta     += amountInDelta;
 494 |     |                 cache.deltas0.amountInDeltaMax  += amountInDeltaMax;
 495 |     |             }
 496 |     |             {
 497 |     |                 // amountOut pool has leftover
 498 |     |                 uint128 amountOutDelta    = uint128(ConstantProduct.getDx(pool.liquidity, currentPrice, crossPrice, false));
 499 |     |                 uint128 amountOutDeltaMax = uint128(ConstantProduct.getDx(pool.liquidity, accumPrice, crossPrice, false));
 500 |     |                 amountOutDeltaMax -= (amountOutDeltaMax < pool.amountOutDeltaMaxClaimed) ? amountOutDeltaMax
 501 |     |                                                                                         : pool.amountOutDeltaMaxClaimed;
 502 |     |                 pool.amountOutDeltaMaxClaimed = 0;
 503 |     | 
 504 |     |                 // calculate sync fee
 505 |     |                 uint128 syncFeeAmount = state.syncFee * amountOutDelta / 1e6;
 506 |     |                 cache.syncFees.token0 += syncFeeAmount;
 507 |     |                 amountOutDelta -= syncFeeAmount;
 508 |     | 
 509 |     |                 // update cache out deltas
 510 |     |                 cache.deltas0.amountOutDelta    += amountOutDelta;
 511 |     |                 cache.deltas0.amountOutDeltaMax += amountOutDeltaMax;
 512 |     |             }
 513 |     |         } else {
 514 |     |             {
 515 |     |                 // amountIn pool did not receive
 516 |     |                 uint128 amountInDelta;
 517 |     |                 uint128 amountInDeltaMax = uint128(ConstantProduct.getDx(pool.liquidity, crossPrice, accumPrice, false));
 518 |     |                 amountInDelta       = pool.amountInDelta;
 519 |     |                 amountInDeltaMax   -= (amountInDeltaMax < pool.amountInDeltaMaxClaimed) ? amountInDeltaMax 
 520 |     |                                                                                         : pool.amountInDeltaMaxClaimed;
 521 |     |                 pool.amountInDelta  = 0;
 522 |     |                 pool.amountInDeltaMaxClaimed = 0;
 523 |     | 
 524 |     |                 // update cache in deltas
 525 |     |                 cache.deltas1.amountInDelta     += amountInDelta;
 526 |     |                 cache.deltas1.amountInDeltaMax  += amountInDeltaMax;
 527 |     |             }
 528 |     |             {
 529 |     |                 // amountOut pool has leftover
 530 |     |                 uint128 amountOutDelta    = uint128(ConstantProduct.getDy(pool.liquidity, crossPrice, currentPrice, false));
 531 |     |                 uint128 amountOutDeltaMax = uint128(ConstantProduct.getDy(pool.liquidity, crossPrice, accumPrice, false));
 532 |     |                 amountOutDeltaMax -= (amountOutDeltaMax < pool.amountOutDeltaMaxClaimed) ? amountOutDeltaMax
 533 |     |                                                                                         : pool.amountOutDeltaMaxClaimed;
 534 |     |                 pool.amountOutDeltaMaxClaimed = 0;
 535 |     | 
 536 |     |                 // calculate sync fee
 537 |     |                 uint128 syncFeeAmount = state.syncFee * amountOutDelta / 1e6;
 538 |     |                 cache.syncFees.token1 += syncFeeAmount;
 539 |     |                 amountOutDelta -= syncFeeAmount;    
 540 |     | 
 541 |     |                 // update cache out deltas
 542 |     |                 cache.deltas1.amountOutDelta    += amountOutDelta;
 543 |     |                 cache.deltas1.amountOutDeltaMax += amountOutDeltaMax;
 544 |     |             }
 545 |     |         }
 546 |     |         return (cache, pool);
 547 |     |     }
 548 |     | 
 549 |     |     function _accumulate(
 550 |     |         CoverPoolStructs.AccumulateCache memory cache,
 551 |     |         CoverPoolStructs.AccumulateParams memory params,
 552 |     |         CoverPoolStructs.GlobalState memory state
 553 |     |     ) internal returns (
 554 |     |         CoverPoolStructs.AccumulateParams memory
 555 |     |     ) {
 556 |     |         if (params.isPool0 == params.crossTick.pool0Stash &&
 557 |     |                 params.crossTick.amountInDeltaMaxStashed > 0) {
 558 |     |             /// @dev - else we migrate carry deltas onto cache
 559 |     |             // add carry amounts to cache
 560 |     |             (params.crossTick, params.deltas) = Deltas.unstash(params.crossTick, params.deltas, params.isPool0);
 561 |     |             // clear out stash
 562 |     |             params.crossTick.amountInDeltaMaxStashed  = 0;
 563 |     |             params.crossTick.amountOutDeltaMaxStashed = 0;
 564 |     |             emit StashDeltasCleared(
 565 |     |                 params.isPool0 ? cache.nextTickToCross0 : cache.nextTickToCross1,
 566 |     |                 params.isPool0
 567 |     |             );
 568 |     |         }
 569 |     |         if (params.updateAccumDeltas) {
 570 |     |             // migrate carry deltas from cache to accum tick
 571 |     |             CoverPoolStructs.Deltas memory accumDeltas = params.isPool0 ? params.accumTick.deltas0
 572 |     |                                                                         : params.accumTick.deltas1;
 573 |     |             if (params.accumTick.amountInDeltaMaxMinus > 0) {
 574 |     |                 // calculate percent of deltas left on tick
 575 |     |                 if (params.deltas.amountInDeltaMax > 0 && params.deltas.amountOutDeltaMax > 0) {
 576 |     |                     /// @dev - during mint it is ensured both of these values will be nonzero
 577 |     |                     uint256 percentInOnTick  = uint256(params.accumTick.amountInDeltaMaxMinus)  * 1e38 / (params.deltas.amountInDeltaMax);
 578 |     |                     uint256 percentOutOnTick = uint256(params.accumTick.amountOutDeltaMaxMinus) * 1e38 / (params.deltas.amountOutDeltaMax);
 579 |     |                     // transfer deltas to the accum tick
 580 |     |                     (params.deltas, accumDeltas) = Deltas.transfer(params.deltas, accumDeltas, percentInOnTick, percentOutOnTick);
 581 |     |                     
 582 |     |                     // burn tick deltas maxes from cache
 583 |     |                     params.deltas = Deltas.burnMaxCache(params.deltas, params.accumTick);
 584 |     |                     
 585 |     |                     // empty delta max minuses into delta max
 586 |     |                     accumDeltas.amountInDeltaMax  += params.accumTick.amountInDeltaMaxMinus;
 587 |     |                     accumDeltas.amountOutDeltaMax += params.accumTick.amountOutDeltaMaxMinus;
 588 |     | 
 589 |     |                     emit FinalDeltasAccumulated(
 590 |     |                         accumDeltas.amountInDelta,
 591 |     |                         accumDeltas.amountOutDelta,
 592 |     |                         state.accumEpoch,
 593 |     |                         params.isPool0 ? cache.nextTickToAccum0 : cache.nextTickToAccum1,
 594 |     |                         params.isPool0
 595 |     |                     );
 596 |     |                 } else {
 597 |     |                     emit FinalDeltasAccumulated(
 598 |     |                         0,0,0,
 599 |     |                         params.isPool0 ? cache.nextTickToAccum0 : cache.nextTickToAccum1,
 600 |     |                         params.isPool0
 601 |     |                     );
 602 |     |                 }
 603 |     | 
 604 |     |                 // clear out delta max minus and save on tick
 605 |     |                 params.accumTick.amountInDeltaMaxMinus  = 0;
 606 |     |                 if (params.isPool0) {
 607 |     |                     params.accumTick.deltas0 = accumDeltas;
 608 |     |                 } else {
 609 |     |                     params.accumTick.deltas1 = accumDeltas;
 610 |     |                 }
 611 |     | 
 612 |     |                 emit FinalDeltasAccumulated(
 613 |     |                     accumDeltas.amountInDelta,
 614 |     |                     accumDeltas.amountOutDelta,
 615 |     |                     state.accumEpoch,
 616 |     |                     params.isPool0 ? cache.nextTickToAccum0 : cache.nextTickToAccum1,
 617 |     |                     params.isPool0
 618 |     |                 );
 619 |     |             }
 620 |     |             // clear out delta max in either case
 621 |     |             params.accumTick.amountOutDeltaMaxMinus = 0;
 622 |     |         }
 623 |     |         // remove all liquidity
 624 |     |         params.crossTick.liquidityDelta = 0;
 625 |     | 
 626 |     |         return params;
 627 |     |     }
 628 |     | 
 629 |     |     //maybe call ticks on msg.sender to get tick
 630 |     |     function _cross(
 631 |     |         int128 liquidityDelta,
 632 |     |         CoverPoolStructs.TickMap storage tickMap,
 633 |     |         PoolsharkStructs.CoverImmutables memory constants,
 634 |     |         int24 nextTickToCross,
 635 |     |         int24 nextTickToAccum,
 636 |     |         uint128 currentLiquidity,
 637 |     |         bool zeroForOne
 638 |     |     ) internal returns (
 639 |     |         uint128,
 640 |     |         int24,
 641 |     |         int24
 642 |     |     )
 643 |     |     {
 644 |     |         nextTickToCross = nextTickToAccum;
 645 |     | 
 646 |     |         if (liquidityDelta > 0) {
 647 |     |             EchidnaAssertions.assertLiquidityOverflows(currentLiquidity, uint128(liquidityDelta), "EP-1");
 648 |     |             currentLiquidity += uint128(liquidityDelta);
 649 |     |         } else {
 650 |     |             EchidnaAssertions.assertLiquidityUnderflows(currentLiquidity, uint128(-liquidityDelta), "TKS-1");
 651 |     |             currentLiquidity -= uint128(-liquidityDelta);
 652 |     |         }
 653 |     |         if (zeroForOne) {
 654 |     |             nextTickToAccum = TickMap.previous(nextTickToAccum, tickMap, constants);
 655 |     |         } else {
 656 |     |             nextTickToAccum = TickMap.next(nextTickToAccum, tickMap, constants);
 657 |     |         }
 658 |     |         return (currentLiquidity, nextTickToCross, nextTickToAccum);
 659 |     |     }
 660 |     | 
 661 |     |     function _stash(
 662 |     |         CoverPoolStructs.Tick memory stashTick,
 663 |     |         CoverPoolStructs.AccumulateCache memory cache,
 664 |     |         CoverPoolStructs.GlobalState memory state,
 665 |     |         uint128 currentLiquidity,
 666 |     |         bool isPool0
 667 |     |     ) internal returns (CoverPoolStructs.Tick memory) {
 668 |     |         // return since there is nothing to update
 669 |     |         if (currentLiquidity == 0) return (stashTick);
 670 |     |         // handle deltas
 671 |     |         CoverPoolStructs.Deltas memory deltas = isPool0 ? cache.deltas0 : cache.deltas1;
 672 |     |         emit StashDeltasAccumulated(
 673 |     |             deltas.amountInDelta,
 674 |     |             deltas.amountOutDelta,
 675 |     |             deltas.amountInDeltaMax,
 676 |     |             deltas.amountOutDeltaMax,
 677 |     |             state.accumEpoch,
 678 |     |             isPool0 ? cache.stopTick0 : cache.stopTick1,
 679 |     |             isPool0
 680 |     |         );
 681 |     |         if (deltas.amountInDeltaMax > 0) {
 682 |     |             (deltas, stashTick) = Deltas.stash(deltas, stashTick, isPool0);
 683 |     |         }
 684 |     |         stashTick.liquidityDelta += int128(currentLiquidity);
 685 |     |         return (stashTick);
 686 |     |     }
 687 |     | }
 688 |     | 

/home/ec2-user/git/cover/contracts/libraries/Positions.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './Ticks.sol';
   5 |     | import './Deltas.sol';
   6 |     | import '../interfaces/IPositionERC1155.sol';
   7 |     | import '../interfaces/structs/CoverPoolStructs.sol';
   8 |     | import '../interfaces/cover/ICoverPool.sol';
   9 |     | import './math/OverflowMath.sol';
  10 |     | import './utils/SafeCast.sol';
  11 |     | import './Claims.sol';
  12 |     | import './EpochMap.sol';
  13 |     | import '../test/echidna/EchidnaAssertions.sol';
  14 |     | 
  15 |     | /// @notice Position management library for ranged liquidity.
  16 |     | library Positions {
  17 |     |     uint8 private constant _ENTERED = 2;
  18 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
  19 |     | 
  20 |     |     using SafeCast for uint256;
  21 |     | 
  22 |     |     event Mint(
  23 |     |         address indexed to,
  24 |     |         int24 lower,
  25 |     |         int24 upper,
  26 |     |         bool zeroForOne,
  27 |     |         uint32 positionId,
  28 |     |         uint32 epochLast,
  29 |     |         uint128 amountIn,
  30 |     |         uint128 liquidityMinted,
  31 |     |         uint128 amountInDeltaMaxMinted,
  32 |     |         uint128 amountOutDeltaMaxMinted
  33 |     |     );
  34 |     | 
  35 |     |     event Burn(
  36 |     |         address indexed to,
  37 |     |         uint32 positionId,
  38 |     |         int24 claim,
  39 |     |         bool zeroForOne,
  40 |     |         uint128 liquidityBurned,
  41 |     |         uint128 tokenInClaimed,
  42 |     |         uint128 tokenOutClaimed,
  43 |     |         uint128 tokenOutBurned,
  44 |     |         uint128 amountInDeltaMaxStashedBurned,
  45 |     |         uint128 amountOutDeltaMaxStashedBurned,
  46 |     |         uint128 amountInDeltaMaxBurned,
  47 |     |         uint128 amountOutDeltaMaxBurned,
  48 |     |         uint160 claimPriceLast
  49 |     |     );
  50 |     | 
  51 |     |     error SimulateMint(int24 lower, int24 upper, bool positionCreated);
  52 |     | 
  53 |     |     function resize(
  54 |     |         CoverPoolStructs.CoverPosition memory position,
  55 |     |         ICoverPool.MintParams memory params,
  56 |     |         CoverPoolStructs.GlobalState memory state,
  57 |     |         PoolsharkStructs.CoverImmutables memory constants
  58 |     |     ) internal pure returns (
  59 |     |         ICoverPool.MintParams memory,
  60 |     |         uint256
  61 |     |     )
  62 |     |     {
  63 |     |         ConstantProduct.checkTicks(params.lower, params.upper, constants.tickSpread);
  64 |     | 
  65 |     |         CoverPoolStructs.CoverPositionCache memory cache = CoverPoolStructs.CoverPositionCache({
  66 |     |             position: position,
  67 |     |             deltas: CoverPoolStructs.Deltas(0,0,0,0),
  68 |     |             requiredStart: params.zeroForOne ? state.latestTick - int24(constants.tickSpread) * constants.minPositionWidth
  69 |     |                                              : state.latestTick + int24(constants.tickSpread) * constants.minPositionWidth,
  70 |     |             auctionCount: uint24((params.upper - params.lower) / constants.tickSpread),
  71 |     |             priceLower: ConstantProduct.getPriceAtTick(params.lower, constants),
  72 |     |             priceUpper: ConstantProduct.getPriceAtTick(params.upper, constants),
  73 |     |             priceAverage: 0,
  74 |     |             liquidityMinted: 0,
  75 |     |             denomTokenIn: true
  76 |     |         });
  77 |     | 
  78 |     |         // cannot mint empty position
  79 |     |         if (params.amount == 0) require (false, 'PositionAmountZero()');
  80 |     | 
  81 |     |         // enforce safety window
  82 |     |         if (params.zeroForOne) {    
  83 |     |             if (params.lower >= cache.requiredStart) require (false, 'PositionInsideSafetyWindow()'); 
  84 |     |         } else {
  85 |     |             if (params.upper <= cache.requiredStart) require (false, 'PositionInsideSafetyWindow()');
  86 |     |         }
  87 |     | 
  88 |     |         cache.liquidityMinted = ConstantProduct.getLiquidityForAmounts(
  89 |     |             cache.priceLower,
  90 |     |             cache.priceUpper,
  91 |     |             params.zeroForOne ? cache.priceLower : cache.priceUpper,
  92 |     |             params.zeroForOne ? 0 : uint256(params.amount),
  93 |     |             params.zeroForOne ? uint256(params.amount) : 0
  94 |     |         );
  95 |     | 
  96 |     |         // handle partial mints
  97 |     |         if (params.zeroForOne) {
  98 |     |             if (params.upper > cache.requiredStart) {
  99 |     |                 params.upper = cache.requiredStart;
 100 |     |                 uint256 priceNewUpper = ConstantProduct.getPriceAtTick(params.upper, constants);
 101 |     |                 params.amount -= uint128(
 102 |     |                     ConstantProduct.getDx(cache.liquidityMinted, priceNewUpper, cache.priceUpper, false)
 103 |     |                 );
 104 |     |                 cache.priceUpper = uint160(priceNewUpper);
 105 |     |             }
 106 |     |             // update auction count
 107 |     |             cache.auctionCount = uint24((params.upper - params.lower) / constants.tickSpread);
 108 |     |             if (cache.auctionCount == 0) require (false, 'InvalidPositionWidth()');
 109 |     |         } else {
 110 |     |             if (params.lower < cache.requiredStart) {
 111 |     |                 params.lower = cache.requiredStart;
 112 |     |                 uint256 priceNewLower = ConstantProduct.getPriceAtTick(params.lower, constants);
 113 |     |                 params.amount -= uint128(
 114 |     |                     ConstantProduct.getDy(cache.liquidityMinted, cache.priceLower, priceNewLower, false)
 115 |     |                 );
 116 |     |                 cache.priceLower = uint160(priceNewLower);
 117 |     |             }
 118 |     |             // update auction count
 119 |     |             cache.auctionCount = uint24((params.upper - params.lower) / constants.tickSpread);
 120 |     |             if (cache.auctionCount == 0) require (false, 'InvalidPositionWidth()');
 121 |     |         }
 122 |     |         // enforce minimum position width
 123 |     |         if (cache.auctionCount < uint16(constants.minPositionWidth)) require (false, 'InvalidPositionWidth()');
 124 |     |         if (cache.liquidityMinted > uint128(type(int128).max)) require (false, 'LiquidityOverflow()');
 125 |     | 
 126 |     |         // enforce non-zero liquidity added
 127 |     |         if (cache.liquidityMinted == 0) {
 128 |     |             bool posCreated = false;
 129 |     |             revert SimulateMint(params.lower, params.upper, posCreated);
 130 |     |             // require(false, 'NoLiquidityBeingAdded()');
 131 |     |         }
 132 |     | 
 133 |     |         // enforce minimum amount per auction
 134 |     |         _size(
 135 |     |             CoverPoolStructs.SizeParams(
 136 |     |                 cache.priceLower,
 137 |     |                 cache.priceUpper,
 138 |     |                 uint128(position.liquidity + cache.liquidityMinted),
 139 |     |                 params.zeroForOne,
 140 |     |                 state.latestTick,
 141 |     |                 cache.auctionCount
 142 |     |             ),
 143 |     |             constants
 144 |     |         );
 145 |     |  
 146 |     |         return (
 147 |     |             params,
 148 |     |             cache.liquidityMinted
 149 |     |         );
 150 |     |     }
 151 |     | 
 152 |     |     function add(
 153 |     |        CoverPoolStructs.CoverPosition memory position,
 154 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 155 |     |         CoverPoolStructs.TickMap storage tickMap,
 156 |     |         CoverPoolStructs.GlobalState memory state,
 157 |     |         CoverPoolStructs.AddParams memory params,
 158 |     |         PoolsharkStructs.CoverImmutables memory constants
 159 |     |     ) internal returns (
 160 |     |         CoverPoolStructs.GlobalState memory,
 161 |     |         CoverPoolStructs.CoverPosition memory
 162 |     |     ) {
 163 |     |         // initialize cache
 164 |     |         CoverPoolStructs.CoverPositionCache memory cache = CoverPoolStructs.CoverPositionCache({
 165 |     |             position: position,
 166 |     |             deltas: CoverPoolStructs.Deltas(0,0,0,0),
 167 |     |             requiredStart: 0,
 168 |     |             auctionCount: 0,
 169 |     |             priceLower: ConstantProduct.getPriceAtTick(params.lower, constants),
 170 |     |             priceUpper: ConstantProduct.getPriceAtTick(params.upper, constants),
 171 |     |             priceAverage: 0,
 172 |     |             liquidityMinted: params.amount,
 173 |     |             denomTokenIn: true
 174 |     |         });
 175 |     |         /// call if claim != lower and liquidity being added
 176 |     |         /// initialize new position
 177 |     | 
 178 |     |         if (cache.position.liquidity == 0) {
 179 |     |             cache.position.accumEpochLast = state.accumEpoch;
 180 |     |             IPositionERC1155(constants.poolToken).mint(
 181 |     |                 params.to,
 182 |     |                 params.positionId,
 183 |     |                 1,
 184 |     |                 constants
 185 |     |             );
 186 |     |         } else {
 187 |     |             // safety check in case we somehow get here
 188 |     |             if (
 189 |     |                 params.zeroForOne
 190 |     |                     ? state.latestTick < params.upper ||
 191 |     |                         EpochMap.get(TickMap.previous(params.upper, tickMap, constants), params.zeroForOne, tickMap, constants)
 192 |     |                             > cache.position.accumEpochLast
 193 |     |                     : state.latestTick > params.lower ||
 194 |     |                         EpochMap.get(TickMap.next(params.lower, tickMap, constants), params.zeroForOne, tickMap, constants)
 195 |     |                             > cache.position.accumEpochLast
 196 |     |             ) {
 197 |     |                 bool posCreated = false;
 198 |     |                 revert SimulateMint(params.lower, params.upper, posCreated);
 199 |     |                 // require (false, string.concat('UpdatePositionFirstAt(', String.from(params.lower), ', ', String.from(params.upper), ')'));
 200 |     |             }
 201 |     |         }
 202 |     |         
 203 |     |         // add liquidity to ticks
 204 |     |         Ticks.insert(
 205 |     |             ticks,
 206 |     |             tickMap,
 207 |     |             state,
 208 |     |             constants,
 209 |     |             params.lower,
 210 |     |             params.upper,
 211 |     |             uint128(cache.liquidityMinted),
 212 |     |             params.zeroForOne
 213 |     |         );
 214 |     | 
 215 |     |         // update liquidity
 216 |     |         cache.position.liquidity += cache.liquidityMinted.toUint128();
 217 |     |         state.liquidityGlobal += cache.liquidityMinted.toUint128();
 218 |     | 
 219 |     |         //TODO: assert divisible by tick spacing
 220 |     | 
 221 |     |         {
 222 |     |             // update max deltas
 223 |     |             CoverPoolStructs.Tick memory finalTick = ticks[params.zeroForOne ? params.lower : params.upper];
 224 |     |             (finalTick, cache.deltas) = Deltas.update(
 225 |     |                 finalTick,
 226 |     |                 cache.liquidityMinted.toUint128(),
 227 |     |                 cache.priceLower, 
 228 |     |                 cache.priceUpper,
 229 |     |                 params.zeroForOne,
 230 |     |                 true
 231 |     |             );
 232 |     |             ticks[params.zeroForOne ? params.lower : params.upper] = finalTick;
 233 |     |             // revert if either max delta is zero
 234 |     |             if (cache.deltas.amountInDeltaMax == 0) {
 235 |     |                 // require(false, 'AmountInDeltaIsZero()');
 236 |     |                 bool posCreated = false;
 237 |     |                 revert SimulateMint(params.lower, params.upper, posCreated);
 238 |     |             } else if (cache.deltas.amountOutDeltaMax == 0) {
 239 |     |                 // require(false, 'AmountOutDeltaIsZero()');
 240 |     |                 bool posCreated = false;
 241 |     |                 revert SimulateMint(params.lower, params.upper, posCreated);
 242 |     |             }
 243 |     |         }
 244 |     | 
 245 |     |         emit Mint(
 246 |     |             params.to,
 247 |     |             params.lower,
 248 |     |             params.upper,
 249 |     |             params.zeroForOne,
 250 |     |             params.positionId,
 251 |     |             state.accumEpoch,
 252 |     |             params.amountIn,
 253 |     |             params.amount,
 254 |     |             cache.deltas.amountInDeltaMax,
 255 |     |             cache.deltas.amountOutDeltaMax
 256 |     |         );
 257 |     | 
 258 |     |         return (state, cache.position);
 259 |     |     }
 260 |     | 
 261 |     |     function remove(
 262 |     |         mapping(uint256 => CoverPoolStructs.CoverPosition)
 263 |     |             storage positions,
 264 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 265 |     |         CoverPoolStructs.TickMap storage tickMap,
 266 |     |         CoverPoolStructs.GlobalState memory state,
 267 |     |         CoverPoolStructs.RemoveParams memory params,
 268 |     |         PoolsharkStructs.CoverImmutables memory constants
 269 |     |     ) internal returns (uint128, CoverPoolStructs.GlobalState memory) {
 270 |     |         // initialize cache
 271 |     |         CoverPoolStructs.CoverPositionCache memory cache = CoverPoolStructs.CoverPositionCache({
 272 |     |             position: positions[params.positionId],
 273 |     |             deltas: CoverPoolStructs.Deltas(0,0,0,0),
 274 |     |             requiredStart: params.zeroForOne ? state.latestTick - int24(constants.tickSpread) * constants.minPositionWidth
 275 |     |                                              : state.latestTick + int24(constants.tickSpread) * constants.minPositionWidth,
 276 |     |             auctionCount: uint24((params.upper - params.lower) / constants.tickSpread),
 277 |     |             priceLower: ConstantProduct.getPriceAtTick(params.lower, constants),
 278 |     |             priceUpper: ConstantProduct.getPriceAtTick(params.upper, constants),
 279 |     |             priceAverage: 0,
 280 |     |             liquidityMinted: 0,
 281 |     |             denomTokenIn: true
 282 |     |         });
 283 |     | 
 284 |     |         // convert percentage to liquidity amount
 285 |     |         params.amount = _convert(cache.position.liquidity, params.amount);
 286 |     | 
 287 |     |         // early return if no liquidity to remove
 288 |     |         if (params.amount == 0) return (0, state);
 289 |     |         if (params.amount > cache.position.liquidity) {
 290 |     |             EchidnaAssertions.assertLiquidityUnderflows(cache.position.liquidity, params.amount, 'PS-1');
 291 |     |             require (false, 'NotEnoughPositionLiquidity()');
 292 |     |         } else {
 293 |     |             _size(
 294 |     |                 CoverPoolStructs.SizeParams(
 295 |     |                     cache.priceLower,
 296 |     |                     cache.priceUpper,
 297 |     |                     cache.position.liquidity - params.amount,
 298 |     |                     params.zeroForOne,
 299 |     |                     state.latestTick,
 300 |     |                     cache.auctionCount
 301 |     |                 ),
 302 |     |                 constants
 303 |     |             );
 304 |     |             /// @dev - validate needed in case user passes in wrong tick
 305 |     |             if (
 306 |     |                 params.zeroForOne
 307 |     |                     ? state.latestTick < params.upper ||
 308 |     |                         EpochMap.get(TickMap.previous(params.upper, tickMap, constants), params.zeroForOne, tickMap, constants)
 309 |     |                             > cache.position.accumEpochLast
 310 |     |                     : state.latestTick > params.lower ||
 311 |     |                         EpochMap.get(TickMap.next(params.lower, tickMap, constants), params.zeroForOne, tickMap, constants)
 312 |     |                             > cache.position.accumEpochLast
 313 |     |             ) {
 314 |     |                 require (false, 'WrongTickClaimedAt()');
 315 |     |             }
 316 |     |         }
 317 |     | 
 318 |     |         Ticks.remove(
 319 |     |             ticks,
 320 |     |             tickMap,
 321 |     |             constants,
 322 |     |             params.lower,
 323 |     |             params.upper,
 324 |     |             params.amount,
 325 |     |             params.zeroForOne,
 326 |     |             true,
 327 |     |             true
 328 |     |         );
 329 |     | 
 330 |     |         // update liquidity global
 331 |     |         EchidnaAssertions.assertLiquidityGlobalUnderflows(state.liquidityGlobal, params.amount, 'PS-2');
 332 |     |         state.liquidityGlobal -= params.amount;
 333 |     | 
 334 |     |         {
 335 |     |             // update max deltas
 336 |     |             CoverPoolStructs.Tick memory finalTick = ticks[params.zeroForOne ? params.lower : params.upper];
 337 |     |             (finalTick, cache.deltas) = Deltas.update(finalTick, params.amount, cache.priceLower, cache.priceUpper, params.zeroForOne, false);
 338 |     |             ticks[params.zeroForOne ? params.lower : params.upper] = finalTick;
 339 |     |         }
 340 |     | 
 341 |     |         cache.position.amountOut += uint128(
 342 |     |             params.zeroForOne
 343 |     |                 ? ConstantProduct.getDx(params.amount, cache.priceLower, cache.priceUpper, false)
 344 |     |                 : ConstantProduct.getDy(params.amount, cache.priceLower, cache.priceUpper, false)
 345 |     |         );
 346 |     |         cache.position.liquidity -= uint128(params.amount);
 347 |     |         if (cache.position.liquidity == 0) {
 348 |     |             cache.position.lower = 0;
 349 |     |             cache.position.upper = 0;
 350 |     |             IPositionERC1155(constants.poolToken).burn(
 351 |     |                 msg.sender,
 352 |     |                 params.positionId,
 353 |     |                 1, 
 354 |     |                 constants
 355 |     |             );
 356 |     |         }
 357 |     |         positions[params.positionId] = cache.position;
 358 |     | 
 359 |     |         if (params.amount > 0) {
 360 |     |             emit Burn(
 361 |     |                     params.to,
 362 |     |                     params.positionId,
 363 |     |                     params.zeroForOne ? params.upper : params.lower,
 364 |     |                     params.zeroForOne,
 365 |     |                     params.amount,
 366 |     |                     0, 0,
 367 |     |                     cache.position.amountOut,
 368 |     |                     0, 0,
 369 |     |                     cache.deltas.amountInDeltaMax,
 370 |     |                     cache.deltas.amountOutDeltaMax,
 371 |     |                     cache.position.claimPriceLast
 372 |     |             );
 373 |     |         }
 374 |     |         return (params.amount, state);
 375 |     |     }
 376 |     | 
 377 |     |     function update(
 378 |     |         mapping(uint256 => CoverPoolStructs.CoverPosition)
 379 |     |             storage positions,
 380 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 381 |     |         CoverPoolStructs.TickMap storage tickMap,
 382 |     |         CoverPoolStructs.GlobalState memory state,
 383 |     |         CoverPoolStructs.PoolState memory pool,
 384 |     |         CoverPoolStructs.UpdateParams memory params,
 385 |     |         PoolsharkStructs.CoverImmutables memory constants
 386 |     |     ) internal returns (
 387 |     |             CoverPoolStructs.GlobalState memory,
 388 |     |             CoverPoolStructs.PoolState memory,
 389 |     |             int24
 390 |     |         )
 391 |     |     {
 392 |     |         CoverPoolStructs.UpdatePositionCache memory cache;
 393 |     |         (
 394 |     |             params,
 395 |     |             cache,
 396 |     |             state
 397 |     |         ) = _deltas(
 398 |     |             positions,
 399 |     |             ticks,
 400 |     |             tickMap,
 401 |     |             state,
 402 |     |             pool,
 403 |     |             params,
 404 |     |             constants
 405 |     |         );
 406 |     | 
 407 |     |         if (cache.earlyReturn)
 408 |     |             return (state, pool, params.claim);
 409 |     | 
 410 |     |         pool.amountInDelta = cache.pool.amountInDelta;
 411 |     |         pool.amountInDeltaMaxClaimed  = cache.pool.amountInDeltaMaxClaimed;
 412 |     |         pool.amountOutDeltaMaxClaimed = cache.pool.amountOutDeltaMaxClaimed;
 413 |     | 
 414 |     |         // save claim tick
 415 |     |         ticks[params.claim] = cache.claimTick;
 416 |     |         if (params.claim != (params.zeroForOne ? params.lower : params.upper))
 417 |     |             ticks[params.zeroForOne ? params.lower : params.upper] = cache.finalTick;
 418 |     |         
 419 |     |         // update pool liquidity
 420 |     |         if (state.latestTick == params.claim
 421 |     |             && params.claim != (params.zeroForOne ? params.lower : params.upper)
 422 |     |         ) {
 423 |     |             EchidnaAssertions.assertLiquidityUnderflows(pool.liquidity, params.amount, 'PS-3');
 424 |     |             pool.liquidity -= params.amount;
 425 |     |         } 
 426 |     |         
 427 |     |         if (params.amount > 0) {
 428 |     |             if (params.claim == (params.zeroForOne ? params.lower : params.upper)) {
 429 |     |                 // only remove once if final tick of position
 430 |     |                 cache.removeLower = false;
 431 |     |                 cache.removeUpper = false;
 432 |     |             } else {
 433 |     |                 params.zeroForOne ? cache.removeUpper = true 
 434 |     |                                   : cache.removeLower = true;
 435 |     |             }
 436 |     |             Ticks.remove(
 437 |     |                 ticks,
 438 |     |                 tickMap,
 439 |     |                 constants,
 440 |     |                 params.zeroForOne ? params.lower : params.claim,
 441 |     |                 params.zeroForOne ? params.claim : params.upper,
 442 |     |                 params.amount,
 443 |     |                 params.zeroForOne,
 444 |     |                 cache.removeLower,
 445 |     |                 cache.removeUpper
 446 |     |             );
 447 |     |             // update position liquidity
 448 |     |             EchidnaAssertions.assertLiquidityUnderflows(cache.position.liquidity, params.amount, 'PS-4');
 449 |     |             cache.position.liquidity -= uint128(params.amount);
 450 |     |             // update global liquidity
 451 |     |             EchidnaAssertions.assertLiquidityGlobalUnderflows(state.liquidityGlobal, params.amount, 'PS-5');
 452 |     |             state.liquidityGlobal -= params.amount;
 453 |     |         }
 454 |     | 
 455 |     |         (
 456 |     |             cache,
 457 |     |             params
 458 |     |         ) = _checkpoint(state, pool, params, constants, cache);
 459 |     | 
 460 |     |         // clear out old position
 461 |     |         if (params.zeroForOne ? params.claim != params.upper 
 462 |     |                               : params.claim != params.lower) {
 463 |     |             /// @dev - this also clears out position end claims
 464 |     |             if (params.zeroForOne ? params.claim == params.lower 
 465 |     |                                   : params.claim == params.upper) {
 466 |     |                 // subtract remaining position liquidity out from global
 467 |     |                 EchidnaAssertions.assertLiquidityGlobalUnderflows(state.liquidityGlobal, cache.position.liquidity, 'PS-6');
 468 |     |                 state.liquidityGlobal -= cache.position.liquidity;
 469 |     |                 cache.position.liquidity = 0;
 470 |     |             }
 471 |     |             //TODO: unnecessary delete for pre-final tick claim
 472 |     |             delete positions[params.positionId];
 473 |     |         }
 474 |     |         // clear position values
 475 |     |         if (cache.position.liquidity == 0) {
 476 |     |             cache.position.lower = 0;
 477 |     |             cache.position.upper = 0;
 478 |     |             cache.position.accumEpochLast = 0;
 479 |     |             cache.position.claimPriceLast = 0;
 480 |     |             IPositionERC1155(constants.poolToken).burn(
 481 |     |                 msg.sender,
 482 |     |                 params.positionId,
 483 |     |                 1, 
 484 |     |                 constants
 485 |     |             );
 486 |     |         }
 487 |     |         // update position bounds
 488 |     |         if (params.zeroForOne) {
 489 |     |             cache.position.upper = params.claim;
 490 |     |         } else {
 491 |     |             cache.position.lower = params.claim;
 492 |     |         }
 493 |     |         positions[params.positionId] = cache.position;
 494 |     |         
 495 |     |         emit Burn(
 496 |     |             params.to,
 497 |     |             params.positionId,
 498 |     |             params.claim,
 499 |     |             params.zeroForOne,
 500 |     |             params.amount,
 501 |     |             cache.position.amountIn,
 502 |     |             cache.finalDeltas.amountOutDelta,
 503 |     |             cache.position.amountOut - cache.finalDeltas.amountOutDelta,
 504 |     |             uint128(cache.amountInFilledMax),
 505 |     |             uint128(cache.amountOutUnfilledMax),
 506 |     |             cache.finalDeltas.amountInDeltaMax,
 507 |     |             cache.finalDeltas.amountOutDeltaMax,
 508 |     |             cache.position.claimPriceLast
 509 |     |         );
 510 |     | 
 511 |     |         return (state, pool, params.claim);
 512 |     |     }
 513 |     | 
 514 |     |     function snapshot(
 515 |     |         mapping(uint256 => CoverPoolStructs.CoverPosition)
 516 |     |             storage positions,
 517 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 518 |     |         CoverPoolStructs.TickMap storage tickMap,
 519 |     |         CoverPoolStructs.GlobalState memory state,
 520 |     |         CoverPoolStructs.PoolState memory pool,
 521 |     |         CoverPoolStructs.UpdateParams memory params,
 522 |     |         PoolsharkStructs.CoverImmutables memory constants
 523 |     |     ) internal view returns (
 524 |     |         CoverPoolStructs.CoverPosition memory
 525 |     |     ) {
 526 |     |         if (state.unlocked == _ENTERED)
 527 |     |             require(false, 'ReentrancyGuardReadOnlyReentrantCall()');
 528 |     |         CoverPoolStructs.UpdatePositionCache memory cache;
 529 |     |         (
 530 |     |             params,
 531 |     |             cache,
 532 |     |             state
 533 |     |         ) = _deltas(
 534 |     |             positions,
 535 |     |             ticks,
 536 |     |             tickMap,
 537 |     |             state,
 538 |     |             pool,
 539 |     |             params,
 540 |     |             constants
 541 |     |         );
 542 |     | 
 543 |     |         if (cache.earlyReturn) {
 544 |     |             if (params.amount > 0)
 545 |     |                 cache.position.amountOut += uint128(
 546 |     |                     params.zeroForOne
 547 |     |                         ? ConstantProduct.getDx(params.amount, cache.priceLower, cache.priceUpper, false)
 548 |     |                         : ConstantProduct.getDy(params.amount, cache.priceLower, cache.priceUpper, false)
 549 |     |                 );
 550 |     |             return cache.position;
 551 |     |         }
 552 |     | 
 553 |     |         if (params.amount > 0) {
 554 |     |             cache.position.liquidity -= uint128(params.amount);
 555 |     |         }
 556 |     |         // checkpoint claimPriceLast
 557 |     |         (
 558 |     |             cache,
 559 |     |             params
 560 |     |         ) = _checkpoint(state, pool, params, constants, cache);
 561 |     |         
 562 |     |         // clear position values if empty
 563 |     |         if (cache.position.liquidity == 0) {
 564 |     |             cache.position.accumEpochLast = 0;
 565 |     |             cache.position.claimPriceLast = 0;
 566 |     |         }    
 567 |     |         return cache.position;
 568 |     |     }
 569 |     | 
 570 |     |     function _convert(
 571 |     |         uint128 liquidity,
 572 |     |         uint128 percent
 573 |     |     ) internal pure returns (
 574 |     |         uint128
 575 |     |     ) {
 576 |     |         // convert percentage to liquidity amount
 577 |     |         if (percent > 1e38) percent = 1e38;
 578 |     |         if (liquidity == 0 && percent > 0) require (false, 'NotEnoughPositionLiquidity()');
 579 |     |         return uint128(uint256(liquidity) * uint256(percent) / 1e38);
 580 |     |     }
 581 |     | 
 582 |     |     function _deltas(
 583 |     |         mapping(uint256 => CoverPoolStructs.CoverPosition)
 584 |     |             storage positions,
 585 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 586 |     |         CoverPoolStructs.TickMap storage tickMap,
 587 |     |         CoverPoolStructs.GlobalState memory state,
 588 |     |         CoverPoolStructs.PoolState memory pool,
 589 |     |         CoverPoolStructs.UpdateParams memory params,
 590 |     |         PoolsharkStructs.CoverImmutables memory constants
 591 |     |     ) internal view returns (
 592 |     |         CoverPoolStructs.UpdateParams memory,
 593 |     |         CoverPoolStructs.UpdatePositionCache memory,
 594 |     |         CoverPoolStructs.GlobalState memory
 595 |     |     ) {
 596 |     |         CoverPoolStructs.UpdatePositionCache memory cache;
 597 |     |         cache.position = positions[params.positionId];
 598 |     |         params.lower = cache.position.lower;
 599 |     |         params.upper = cache.position.upper;
 600 |     |         cache = CoverPoolStructs.UpdatePositionCache({
 601 |     |             position: cache.position,
 602 |     |             pool: pool,
 603 |     |             priceLower: ConstantProduct.getPriceAtTick(params.lower, constants),
 604 |     |             priceClaim: ConstantProduct.getPriceAtTick(params.claim, constants),
 605 |     |             priceUpper: ConstantProduct.getPriceAtTick(params.upper, constants),
 606 |     |             priceSpread: 0,
 607 |     |             amountInFilledMax: 0,
 608 |     |             amountOutUnfilledMax: 0,
 609 |     |             claimTick: ticks[params.claim],
 610 |     |             finalTick: ticks[params.zeroForOne ? params.lower : params.upper],
 611 |     |             earlyReturn: false,
 612 |     |             removeLower: true,
 613 |     |             removeUpper: true,
 614 |     |             deltas: CoverPoolStructs.Deltas(0,0,0,0),
 615 |     |             finalDeltas: CoverPoolStructs.Deltas(0,0,0,0)
 616 |     |         });
 617 |     |         if (params.claim == (params.zeroForOne ? params.lower : params.upper)) {
 618 |     |             params.amount = 1e38;
 619 |     |         }
 620 |     |         params.amount = _convert(cache.position.liquidity, params.amount);
 621 |     | 
 622 |     |         // check claim is valid
 623 |     |         (params, cache) = Claims.validate(
 624 |     |             tickMap,
 625 |     |             state,
 626 |     |             cache.pool,
 627 |     |             params,
 628 |     |             cache,
 629 |     |             constants
 630 |     |         );
 631 |     |         if (cache.earlyReturn) {
 632 |     |             return (params, cache, state);
 633 |     |         }
 634 |     |         cache.priceSpread = ConstantProduct.getPriceAtTick(params.zeroForOne ? params.claim - constants.tickSpread 
 635 |     |                                                                              : params.claim + constants.tickSpread,
 636 |     |                                                            constants);
 637 |     |         if (params.amount > 0)
 638 |     |             _size(
 639 |     |                 CoverPoolStructs.SizeParams(
 640 |     |                     cache.priceLower,
 641 |     |                     cache.priceUpper,
 642 |     |                     cache.position.liquidity - params.amount,
 643 |     |                     params.zeroForOne,
 644 |     |                     state.latestTick,
 645 |     |                     uint24((params.upper - params.lower) / constants.tickSpread)
 646 |     |                 ),
 647 |     |                 constants
 648 |     |             );
 649 |     |         // get deltas from claim tick
 650 |     |         cache = Claims.getDeltas(cache, params);
 651 |     |         /// @dev - section 1 => position start - previous auction
 652 |     |         cache = Claims.section1(cache, params, constants);
 653 |     |         /// @dev - section 2 => position start -> claim tick
 654 |     |         cache = Claims.section2(cache, params);
 655 |     |         // check if auction in progress 
 656 |     |         if (params.claim == state.latestTick 
 657 |     |             && params.claim != (params.zeroForOne ? params.lower : params.upper)) {
 658 |     |             /// @dev - section 3 => claim tick - unfilled section
 659 |     |             cache = Claims.section3(cache, params, cache.pool);
 660 |     |             /// @dev - section 4 => claim tick - filled section
 661 |     |             cache = Claims.section4(cache, params, cache.pool);
 662 |     |         }
 663 |     |         /// @dev - section 5 => claim tick -> position end
 664 |     |         cache = Claims.section5(cache, params);
 665 |     |         // adjust position amounts based on deltas
 666 |     |         cache = Claims.applyDeltas(state, cache, params);
 667 |     | 
 668 |     |         return (params, cache, state);
 669 |     |     }
 670 |     | 
 671 |     |     function _size(
 672 |     |         CoverPoolStructs.SizeParams memory params,
 673 |     |         PoolsharkStructs.CoverImmutables memory constants
 674 |     |     ) internal pure  
 675 |     |     {
 676 |     |         // early return if 100% of position burned
 677 |     |         if (constants.minAmountPerAuction == 0) return;
 678 |     |         if (params.liquidityAmount == 0 || params.auctionCount == 0) return;
 679 |     |         // set minAmountPerAuction based on token decimals
 680 |     |         uint256 minAmountPerAuction; bool denomTokenIn;
 681 |     |         if (params.latestTick > 0) {
 682 |     |             if (constants.minAmountLowerPriced) {
 683 |     |                 // token1 is the lower priced token
 684 |     |                 denomTokenIn = !params.zeroForOne;
 685 |     |                 minAmountPerAuction = constants.minAmountPerAuction / 10**(18 - constants.token1Decimals);
 686 |     |             } else {
 687 |     |                 // token0 is the higher priced token
 688 |     |                 denomTokenIn = params.zeroForOne;
 689 |     |                 minAmountPerAuction = constants.minAmountPerAuction / 10**(18 - constants.token0Decimals);
 690 |     |             }
 691 |     |         } else {
 692 |     |             if (constants.minAmountLowerPriced) {
 693 |     |                 // token0 is the lower priced token
 694 |     |                 denomTokenIn = params.zeroForOne;
 695 |     |                 minAmountPerAuction = constants.minAmountPerAuction / 10**(18 - constants.token0Decimals);
 696 |     |             } else {
 697 |     |                 // token1 is the higher priced token
 698 |     |                 denomTokenIn = !params.zeroForOne;
 699 |     |                 minAmountPerAuction = constants.minAmountPerAuction / 10**(18 - constants.token1Decimals);
 700 |     |             }
 701 |     |         }
 702 |     |         if (params.zeroForOne) {
 703 |     |             //calculate amount in the position currently
 704 |     |             uint128 amount = uint128(ConstantProduct.getDx(
 705 |     |                 params.liquidityAmount,
 706 |     |                 params.priceLower,
 707 |     |                 params.priceUpper,
 708 |     |                 false
 709 |     |             ));
 710 |     |             if (denomTokenIn) {
 711 |     |                 if (amount / params.auctionCount < minAmountPerAuction)
 712 |     |                     require (false, 'PositionAuctionAmountTooSmall()');
 713 |     |             } else {
 714 |     |                 // denominate in incoming token
 715 |     |                 uint256 priceAverage = (params.priceUpper + params.priceLower) / 2;
 716 |     |                 uint256 convertedAmount = amount * priceAverage / Q96 
 717 |     |                                                  * priceAverage / Q96; // convert by squaring price
 718 |     |                 if (convertedAmount / params.auctionCount < minAmountPerAuction) 
 719 |     |                     require (false, 'PositionAuctionAmountTooSmall()');
 720 |     |             }
 721 |     |         } else {
 722 |     |             uint128 amount = uint128(ConstantProduct.getDy(
 723 |     |                 params.liquidityAmount,
 724 |     |                 params.priceLower,
 725 |     |                 params.priceUpper,
 726 |     |                 false
 727 |     |             ));
 728 |     |             if (denomTokenIn) {
 729 |     |                 // denominate in token1
 730 |     |                 // calculate amount in position currently
 731 |     |                 if (amount / params.auctionCount < minAmountPerAuction) 
 732 |     |                     require (false, 'PositionAuctionAmountTooSmall()');
 733 |     |             } else {
 734 |     |                 // denominate in token0
 735 |     |                 uint256 priceAverage = (params.priceUpper + params.priceLower) / 2;
 736 |     |                 uint256 convertedAmount = amount * Q96 / priceAverage 
 737 |     |                                                  * Q96 / priceAverage; // convert by squaring price
 738 |     |                 if (convertedAmount / params.auctionCount < minAmountPerAuction) 
 739 |     |                     require (false, 'PositionAuctionAmountTooSmall()');
 740 |     |             }
 741 |     |         }
 742 |     |     }
 743 |     | 
 744 |     |     function _checkpoint(
 745 |     |         CoverPoolStructs.GlobalState memory state,
 746 |     |         CoverPoolStructs.PoolState memory pool,
 747 |     |         CoverPoolStructs.UpdateParams memory params,
 748 |     |         PoolsharkStructs.CoverImmutables memory constants,
 749 |     |         CoverPoolStructs.UpdatePositionCache memory cache
 750 |     |     ) internal pure returns (
 751 |     |         CoverPoolStructs.UpdatePositionCache memory,
 752 |     |         CoverPoolStructs.UpdateParams memory
 753 |     |     ) {
 754 |     |         // update claimPriceLast
 755 |     |         cache.priceClaim = ConstantProduct.getPriceAtTick(params.claim, constants);
 756 |     |         cache.position.claimPriceLast = (params.claim == state.latestTick)
 757 |     |             ? pool.price
 758 |     |             : cache.priceClaim;
 759 |     |         /// @dev - if tick 0% filled, set CPL to latestTick
 760 |     |         if (pool.price == cache.priceSpread) cache.position.claimPriceLast = cache.priceClaim;
 761 |     |         /// @dev - if tick 100% filled, set CPL to next tick to unlock
 762 |     |         if (pool.price == cache.priceClaim && params.claim == state.latestTick){
 763 |     |             cache.position.claimPriceLast = cache.priceSpread;
 764 |     |             // set claim tick to claim + tickSpread
 765 |     |             params.claim = params.zeroForOne ? params.claim - constants.tickSpread
 766 |     |                                              : params.claim + constants.tickSpread;
 767 |     |         }
 768 |     |         return (cache, params);
 769 |     |     }
 770 |     | }
 771 |     | 

/home/ec2-user/git/cover/contracts/libraries/TickMap.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../interfaces/structs/CoverPoolStructs.sol';
   5 |     | import './math/ConstantProduct.sol';
   6 |     | 
   7 |     | library TickMap {
   8 |     |     function set(
   9 |     |         int24 tick,
  10 |     |         CoverPoolStructs.TickMap storage tickMap,
  11 |     |         PoolsharkStructs.CoverImmutables memory constants
  12 |     |     ) internal returns (
  13 |     |         bool exists
  14 |     |     )    
  15 |     |     {
  16 |     |         (
  17 |     |             uint256 tickIndex,
  18 |     |             uint256 wordIndex,
  19 |     |             uint256 blockIndex
  20 |     |         ) = getIndices(tick, constants);
  21 |     | 
  22 |     |         // check if bit is already set
  23 |     |         uint256 word = tickMap.ticks[wordIndex] | 1 << (tickIndex & 0xFF);
  24 |     |         if (word == tickMap.ticks[wordIndex]) {
  25 |     |             return true;
  26 |     |         }
  27 |     | 
  28 |     |         tickMap.ticks[wordIndex]     = word; 
  29 |     |         tickMap.words[blockIndex]   |= 1 << (wordIndex & 0xFF); // same as modulus 255
  30 |     |         tickMap.blocks              |= 1 << blockIndex;
  31 |     |         return false;
  32 |     |     }
  33 |     | 
  34 |     |     function unset(
  35 |     |         int24 tick,
  36 |     |         CoverPoolStructs.TickMap storage tickMap,
  37 |     |         PoolsharkStructs.CoverImmutables memory constants
  38 |     |     ) internal {
  39 |     |         (
  40 |     |             uint256 tickIndex,
  41 |     |             uint256 wordIndex,
  42 |     |             uint256 blockIndex
  43 |     |         ) = getIndices(tick, constants);
  44 |     | 
  45 |     |         tickMap.ticks[wordIndex] &= ~(1 << (tickIndex & 0xFF));
  46 |     |         if (tickMap.ticks[wordIndex] == 0) {
  47 |     |             tickMap.words[blockIndex] &= ~(1 << (wordIndex & 0xFF));
  48 |     |             if (tickMap.words[blockIndex] == 0) {
  49 |     |                 tickMap.blocks &= ~(1 << blockIndex);
  50 |     |             }
  51 |     |         }
  52 |     |     }
  53 |     | 
  54 |     |     function previous(
  55 |     |         int24 tick,
  56 |     |         CoverPoolStructs.TickMap storage tickMap,
  57 |     |         PoolsharkStructs.CoverImmutables memory constants
  58 |     |     ) internal view returns (
  59 |     |         int24 previousTick
  60 |     |     ) {
  61 |     |         unchecked {
  62 |     |             (
  63 |     |               uint256 tickIndex,
  64 |     |               uint256 wordIndex,
  65 |     |               uint256 blockIndex
  66 |     |             ) = getIndices(tick, constants);
  67 |     | 
  68 |     |             uint256 word = tickMap.ticks[wordIndex] & ((1 << (tickIndex & 0xFF)) - 1);
  69 |     |             if (word == 0) {
  70 |     |                 uint256 block_ = tickMap.words[blockIndex] & ((1 << (wordIndex & 0xFF)) - 1);
  71 |     |                 if (block_ == 0) {
  72 |     |                     uint256 blockMap = tickMap.blocks & ((1 << blockIndex) - 1);
  73 |     |                     if (blockMap == 0) return tick;
  74 |     |                     blockIndex = _msb(blockMap);
  75 |     |                     block_ = tickMap.words[blockIndex];
  76 |     |                 }
  77 |     |                 wordIndex = (blockIndex << 8) | _msb(block_);
  78 |     |                 word = tickMap.ticks[wordIndex];
  79 |     |             }
  80 |     |             previousTick = _tick((wordIndex << 8) | _msb(word), constants);
  81 |     |         }
  82 |     |     }
  83 |     | 
  84 |     |     function next(
  85 |     |         int24 tick,
  86 |     |         CoverPoolStructs.TickMap storage tickMap,
  87 |     |         PoolsharkStructs.CoverImmutables memory constants
  88 |     |     ) internal view returns (
  89 |     |         int24 nextTick
  90 |     |     ) {
  91 |     |         unchecked {
  92 |     |             (
  93 |     |               uint256 tickIndex,
  94 |     |               uint256 wordIndex,
  95 |     |               uint256 blockIndex
  96 |     |             ) = getIndices(tick, constants);
  97 |     |             uint256 word;
  98 |     |             if ((tickIndex & 0xFF) != 255) {
  99 |     |                 word = tickMap.ticks[wordIndex] & ~((1 << ((tickIndex & 0xFF) + 1)) - 1);
 100 |     |             }
 101 |     |             if (word == 0) {
 102 |     |                 uint256 block_;
 103 |     |                 if ((blockIndex & 0xFF) != 255) {
 104 |     |                     block_ = tickMap.words[blockIndex] & ~((1 << ((wordIndex & 0xFF) + 1)) - 1);
 105 |     |                 }
 106 |     |                 if (block_ == 0) {
 107 |     |                     uint256 blockMap = tickMap.blocks & ~((1 << blockIndex + 1) - 1);
 108 |     |                     if (blockMap == 0) return tick;
 109 |     |                     blockIndex = _lsb(blockMap);
 110 |     |                     block_ = tickMap.words[blockIndex];
 111 |     |                 }
 112 |     |                 wordIndex = (blockIndex << 8) | _lsb(block_);
 113 |     |                 word = tickMap.ticks[wordIndex];
 114 |     |             }
 115 |     |             nextTick = _tick((wordIndex << 8) | _lsb(word), constants);
 116 |     |         }
 117 |     |     }
 118 |     | 
 119 |     |     function getIndices(
 120 |     |         int24 tick,
 121 |     |         PoolsharkStructs.CoverImmutables memory constants
 122 |     |     ) public pure returns (
 123 |     |             uint256 tickIndex,
 124 |     |             uint256 wordIndex,
 125 |     |             uint256 blockIndex
 126 |     |         )
 127 |     |     {
 128 |     |         unchecked {
 129 |     |             if (tick > ConstantProduct.maxTick(constants.tickSpread)) require (false, 'TickIndexOverflow()');
 130 |     |             if (tick < ConstantProduct.minTick(constants.tickSpread)) require (false, 'TickIndexUnderflow()');
 131 |     |             if (tick % constants.tickSpread != 0) require (false, 'TickIndexInvalid()');
 132 |     |             tickIndex = uint256(int256((tick - ConstantProduct.minTick(constants.tickSpread))) / constants.tickSpread);
 133 |     |             wordIndex = tickIndex >> 8;   // 2^8 ticks per word
 134 |     |             blockIndex = tickIndex >> 16; // 2^8 words per block
 135 |     |             if (blockIndex > 255) require (false, 'BlockIndexOverflow()');
 136 |     |         }
 137 |     |     }
 138 |     | 
 139 |     |     function _tick (
 140 |     |         uint256 tickIndex,
 141 |     |         PoolsharkStructs.CoverImmutables memory constants
 142 |     |     ) internal pure returns (
 143 |     |         int24 tick
 144 |     |     ) {
 145 |     |         unchecked {
 146 |     |             if (tickIndex > uint24(ConstantProduct.maxTick(constants.tickSpread) * 2)) require (false, 'TickIndexOverflow()');
 147 |     |             tick = int24(int256(tickIndex) * int256(constants.tickSpread) + ConstantProduct.minTick(constants.tickSpread));
 148 |     |         }
 149 |     |     }
 150 |     | 
 151 |     |     function _msb(
 152 |     |         uint256 x
 153 |     |     ) internal pure returns (
 154 |     |         uint8 r
 155 |     |     ) {
 156 |     |         unchecked {
 157 |     |             assert(x > 0);
 158 |     |             if (x >= 0x100000000000000000000000000000000) {
 159 |     |                 x >>= 128;
 160 |     |                 r += 128;
 161 |     |             }
 162 |     |             if (x >= 0x10000000000000000) {
 163 |     |                 x >>= 64;
 164 |     |                 r += 64;
 165 |     |             }
 166 |     |             if (x >= 0x100000000) {
 167 |     |                 x >>= 32;
 168 |     |                 r += 32;
 169 |     |             }
 170 |     |             if (x >= 0x10000) {
 171 |     |                 x >>= 16;
 172 |     |                 r += 16;
 173 |     |             }
 174 |     |             if (x >= 0x100) {
 175 |     |                 x >>= 8;
 176 |     |                 r += 8;
 177 |     |             }
 178 |     |             if (x >= 0x10) {
 179 |     |                 x >>= 4;
 180 |     |                 r += 4;
 181 |     |             }
 182 |     |             if (x >= 0x4) {
 183 |     |                 x >>= 2;
 184 |     |                 r += 2;
 185 |     |             }
 186 |     |             if (x >= 0x2) r += 1;
 187 |     |         }
 188 |     |     }
 189 |     | 
 190 |     |     function _lsb(
 191 |     |         uint256 x
 192 |     |     ) internal pure returns (
 193 |     |         uint8 r
 194 |     |     ) {
 195 |     |         unchecked {
 196 |     |             assert(x > 0); // if x is 0 return 0
 197 |     |             r = 255;
 198 |     |             if (x & type(uint128).max > 0) {
 199 |     |                 r -= 128;
 200 |     |             } else {
 201 |     |                 x >>= 128;
 202 |     |             }
 203 |     |             if (x & type(uint64).max > 0) {
 204 |     |                 r -= 64;
 205 |     |             } else {
 206 |     |                 x >>= 64;
 207 |     |             }
 208 |     |             if (x & type(uint32).max > 0) {
 209 |     |                 r -= 32;
 210 |     |             } else {
 211 |     |                 x >>= 32;
 212 |     |             }
 213 |     |             if (x & type(uint16).max > 0) {
 214 |     |                 r -= 16;
 215 |     |             } else {
 216 |     |                 x >>= 16;
 217 |     |             }
 218 |     |             if (x & type(uint8).max > 0) {
 219 |     |                 r -= 8;
 220 |     |             } else {
 221 |     |                 x >>= 8;
 222 |     |             }
 223 |     |             if (x & 0xf > 0) {
 224 |     |                 r -= 4;
 225 |     |             } else {
 226 |     |                 x >>= 4;
 227 |     |             }
 228 |     |             if (x & 0x3 > 0) {
 229 |     |                 r -= 2;
 230 |     |             } else {
 231 |     |                 x >>= 2;
 232 |     |             }
 233 |     |             if (x & 0x1 > 0) r -= 1;
 234 |     |         }
 235 |     |     }
 236 |     |     
 237 |     | }

/home/ec2-user/git/cover/contracts/libraries/Ticks.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../interfaces/structs/CoverPoolStructs.sol';
   5 |     | import '../utils/CoverPoolErrors.sol';
   6 |     | import './math/OverflowMath.sol';
   7 |     | import '../interfaces/modules/sources/ITwapSource.sol';
   8 |     | import './TickMap.sol';
   9 |     | import '../test/echidna/EchidnaAssertions.sol';
  10 |     | 
  11 |     | /// @notice Tick management library for ranged liquidity.
  12 |     | library Ticks {
  13 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
  14 |     | 
  15 |     |     event Initialize(
  16 |     |         int24 minTick,
  17 |     |         int24 maxTick,
  18 |     |         int24 latestTick,
  19 |     |         uint32 genesisTime,
  20 |     |         uint32 auctionStart,
  21 |     |         uint160 pool0Price,
  22 |     |         uint160 pool1Price
  23 |     |     );
  24 |     | 
  25 |     |     //TODO: ensure amountInDelta is always cleared out
  26 |     |     function quote(
  27 |     |         bool zeroForOne,
  28 |     |         uint160 priceLimit,
  29 |     |         CoverPoolStructs.GlobalState memory state,
  30 |     |         CoverPoolStructs.SwapCache memory cache,
  31 |     |         PoolsharkStructs.CoverImmutables memory constants
  32 |     |     ) internal pure returns (CoverPoolStructs.SwapCache memory) {
  33 |     |         if ((zeroForOne ? priceLimit >= cache.price
  34 |     |                         : priceLimit <= cache.price) ||
  35 |     |             (cache.liquidity == 0))
  36 |     |         {
  37 |     |             return cache;
  38 |     |         }
  39 |     |         uint256 nextPrice = state.latestPrice;
  40 |     |         // determine input boost from tick auction
  41 |     |         cache.auctionBoost = ((cache.auctionDepth <= constants.auctionLength) ? cache.auctionDepth
  42 |     |                                                                               : constants.auctionLength
  43 |     |                              ) * 1e14 / constants.auctionLength * uint16(constants.tickSpread);
  44 |     |         cache.amountBoosted = cache.amountLeft;
  45 |     |         if (cache.exactIn)
  46 |     |             cache.amountBoosted = cache.amountLeft * (1e18 + cache.auctionBoost) / 1e18;
  47 |     |         if (zeroForOne) {
  48 |     |             // trade token 0 (x) for token 1 (y)
  49 |     |             // price decreases
  50 |     |             if (priceLimit > nextPrice) {
  51 |     |                 // stop at price limit
  52 |     |                 nextPrice = priceLimit;
  53 |     |             }
  54 |     |             // max input or output that we can get
  55 |     |             uint256 amountMax = cache.exactIn ? ConstantProduct.getDx(cache.liquidity, nextPrice, cache.price, true)
  56 |     |                                               : ConstantProduct.getDy(cache.liquidity, nextPrice, cache.price, false);
  57 |     |             // check if all input is used
  58 |     |             if (cache.amountBoosted <= amountMax) {
  59 |     |                 // calculate price after swap
  60 |     |                 uint256 newPrice = ConstantProduct.getNewPrice(
  61 |     |                     cache.price,
  62 |     |                     cache.liquidity,
  63 |     |                     cache.amountBoosted,
  64 |     |                     zeroForOne,
  65 |     |                     cache.exactIn
  66 |     |                 );
  67 |     |                 if (cache.exactIn) {
  68 |     |                     cache.input = cache.amountLeft;
  69 |     |                     cache.output = ConstantProduct.getDy(cache.liquidity, newPrice, cache.price, false);
  70 |     |                 } else {
  71 |     |                     // input needs to be adjusted based on boost
  72 |     |                     cache.input = ConstantProduct.getDx(cache.liquidity, newPrice, uint256(cache.price), true) * (1e18 - cache.auctionBoost) / 1e18;
  73 |     |                     cache.output = cache.amountLeft;
  74 |     |                 }
  75 |     |                 cache.price = newPrice;
  76 |     |                 cache.amountLeft = 0;
  77 |     |             } else if (amountMax > 0) {
  78 |     |                 if (cache.exactIn) {
  79 |     |                     cache.input = amountMax * (1e18 - cache.auctionBoost) / 1e18; /// @dev - convert back to input amount
  80 |     |                     cache.output = ConstantProduct.getDy(cache.liquidity, nextPrice, cache.price, false);
  81 |     |                 } else {
  82 |     |                     // input needs to be adjusted based on boost
  83 |     |                     cache.input = ConstantProduct.getDx(cache.liquidity, nextPrice, cache.price, true) * (1e18 - cache.auctionBoost) / 1e18;
  84 |     |                     cache.output = amountMax;
  85 |     |                 }
  86 |     |                 cache.price = nextPrice;
  87 |     |                 cache.amountLeft -= cache.exactIn ? cache.input : cache.output;
  88 |     |             }
  89 |     |         } else {
  90 |     |             // price increases
  91 |     |             if (priceLimit < nextPrice) {
  92 |     |                 // stop at price limit
  93 |     |                 nextPrice = priceLimit;
  94 |     |             }
  95 |     |             uint256 amountMax = cache.exactIn ? ConstantProduct.getDy(cache.liquidity, uint256(cache.price), nextPrice, true)
  96 |     |                                               : ConstantProduct.getDx(cache.liquidity, uint256(cache.price), nextPrice, false);
  97 |     |             if (cache.amountBoosted <= amountMax) {
  98 |     |                 // calculate price after swap
  99 |     |                 uint256 newPrice = ConstantProduct.getNewPrice(
 100 |     |                     cache.price,
 101 |     |                     cache.liquidity,
 102 |     |                     cache.amountBoosted,
 103 |     |                     zeroForOne,
 104 |     |                     cache.exactIn
 105 |     |                 );
 106 |     |                 if (cache.exactIn) {
 107 |     |                     cache.input = cache.amountLeft;
 108 |     |                     cache.output = ConstantProduct.getDx(cache.liquidity, cache.price, newPrice, false);
 109 |     |                 } else {
 110 |     |                     // input needs to be adjusted based on boost
 111 |     |                     cache.input = ConstantProduct.getDy(cache.liquidity, cache.price, newPrice, true) * (1e18 - cache.auctionBoost) / 1e18;
 112 |     |                     cache.output = cache.amountLeft;
 113 |     |                 }
 114 |     |                 cache.price = newPrice;
 115 |     |                 cache.amountLeft = 0;
 116 |     |             } else if (amountMax > 0) {
 117 |     |                 if (cache.exactIn) {
 118 |     |                     cache.input = amountMax * (1e18 - cache.auctionBoost) / 1e18; 
 119 |     |                     cache.output = ConstantProduct.getDx(cache.liquidity, cache.price, nextPrice, false);
 120 |     |                 } else {
 121 |     |                     // input needs to be adjusted based on boost
 122 |     |                     cache.input = ConstantProduct.getDy(cache.liquidity, cache.price, nextPrice, true) * (1e18 - cache.auctionBoost) / 1e18;
 123 |     |                     cache.output = amountMax;
 124 |     |                 }
 125 |     |                 cache.price = nextPrice;
 126 |     |                 cache.amountLeft -= cache.exactIn ? cache.input : cache.output;
 127 |     |             }
 128 |     |         }
 129 |     |         cache.amountInDelta = cache.input;
 130 |     |         return cache;
 131 |     |     }
 132 |     | 
 133 |     |     function initialize(
 134 |     |         CoverPoolStructs.TickMap storage tickMap,
 135 |     |         CoverPoolStructs.PoolState storage pool0,
 136 |     |         CoverPoolStructs.PoolState storage pool1,
 137 |     |         CoverPoolStructs.GlobalState storage state,
 138 |     |         PoolsharkStructs.CoverImmutables memory constants 
 139 |     |     ) internal {
 140 |     |         if (state.unlocked == 0) {
 141 |     |             (state.unlocked, state.latestTick) = constants.source.initialize(constants);
 142 |     |             if (state.unlocked == 1) {
 143 |     |                 // initialize state
 144 |     |                 state.latestTick = (state.latestTick / int24(constants.tickSpread)) * int24(constants.tickSpread);
 145 |     |                 state.latestPrice = ConstantProduct.getPriceAtTick(state.latestTick, constants);
 146 |     |                 state.auctionStart = uint32(block.timestamp - constants.genesisTime);
 147 |     |                 state.accumEpoch = 1;
 148 |     |                 state.positionIdNext = 1;
 149 |     | 
 150 |     |                 // initialize ticks
 151 |     |                 TickMap.set(ConstantProduct.minTick(constants.tickSpread), tickMap, constants);
 152 |     |                 TickMap.set(ConstantProduct.maxTick(constants.tickSpread), tickMap, constants);
 153 |     |                 TickMap.set(state.latestTick, tickMap, constants);
 154 |     | 
 155 |     |                 // initialize price
 156 |     |                 pool0.price = ConstantProduct.getPriceAtTick(state.latestTick - constants.tickSpread, constants);
 157 |     |                 pool1.price = ConstantProduct.getPriceAtTick(state.latestTick + constants.tickSpread, constants);
 158 |     | 
 159 |     |                 // assert tick is within bounds
 160 |     |                 EchidnaAssertions.assertTickDivisibleByTickSpacing(state.latestTick, constants.tickSpread);
 161 |     |                 EchidnaAssertions.assertTickWithinBounds(
 162 |     |                     state.latestTick,
 163 |     |                     ConstantProduct.minTick(constants.tickSpread) + constants.tickSpread,
 164 |     |                     ConstantProduct.maxTick(constants.tickSpread) - constants.tickSpread
 165 |     |                 );
 166 |     |             
 167 |     |                 emit Initialize(
 168 |     |                     ConstantProduct.minTick(constants.tickSpread),
 169 |     |                     ConstantProduct.maxTick(constants.tickSpread),
 170 |     |                     state.latestTick,
 171 |     |                     constants.genesisTime,
 172 |     |                     state.auctionStart,
 173 |     |                     pool0.price,
 174 |     |                     pool1.price
 175 |     |                 );
 176 |     |             }
 177 |     |         }
 178 |     |     }
 179 |     | 
 180 |     |     function insert(
 181 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 182 |     |         CoverPoolStructs.TickMap storage tickMap,
 183 |     |         CoverPoolStructs.GlobalState memory state,
 184 |     |         PoolsharkStructs.CoverImmutables memory constants,
 185 |     |         int24 lower,
 186 |     |         int24 upper,
 187 |     |         uint128 amount,
 188 |     |         bool isPool0
 189 |     |     ) internal {
 190 |     |         /// @dev - validation of ticks is in Positions.validate
 191 |     |         if (amount > uint128(type(int128).max)) require (false, 'LiquidityOverflow()');
 192 |     |         if ((uint128(type(int128).max) - state.liquidityGlobal) < amount)
 193 |     |             require (false, 'LiquidityOverflow()');
 194 |     | 
 195 |     |         // load ticks into memory to reduce reads/writes
 196 |     |         CoverPoolStructs.Tick memory tickLower = ticks[lower];
 197 |     |         CoverPoolStructs.Tick memory tickUpper = ticks[upper];
 198 |     | 
 199 |     |         // sets bit in map
 200 |     |         TickMap.set(lower, tickMap, constants);
 201 |     | 
 202 |     |         // updates liquidity values
 203 |     |         if (isPool0) {
 204 |     |             tickLower.liquidityDelta -= int128(amount);
 205 |     |         } else {
 206 |     |             tickLower.liquidityDelta += int128(amount);
 207 |     |         }
 208 |     | 
 209 |     |         TickMap.set(upper, tickMap, constants);
 210 |     | 
 211 |     |         if (isPool0) {
 212 |     |             tickUpper.liquidityDelta += int128(amount);
 213 |     |         } else {
 214 |     |             tickUpper.liquidityDelta -= int128(amount);
 215 |     |         }
 216 |     |         ticks[lower] = tickLower;
 217 |     |         ticks[upper] = tickUpper;
 218 |     |     }
 219 |     | 
 220 |     |     function remove(
 221 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 222 |     |         CoverPoolStructs.TickMap storage tickMap,
 223 |     |         PoolsharkStructs.CoverImmutables memory constants,
 224 |     |         int24 lower,
 225 |     |         int24 upper,
 226 |     |         uint128 amount,
 227 |     |         bool isPool0,
 228 |     |         bool removeLower,
 229 |     |         bool removeUpper
 230 |     |     ) internal {
 231 |     |         {
 232 |     |             CoverPoolStructs.Tick memory tickLower = ticks[lower];
 233 |     |             if (removeLower) {
 234 |     |                 if (isPool0) {
 235 |     |                     tickLower.liquidityDelta += int128(amount);
 236 |     |                 } else {
 237 |     |                     tickLower.liquidityDelta -= int128(amount);
 238 |     |                 }
 239 |     |                 ticks[lower] = tickLower;
 240 |     |             }
 241 |     |             if (lower != ConstantProduct.minTick(constants.tickSpread)) {
 242 |     |                 cleanup(ticks, tickMap, constants, tickLower, lower);
 243 |     |             }
 244 |     |         }
 245 |     |         {
 246 |     |             CoverPoolStructs.Tick memory tickUpper = ticks[upper];
 247 |     |             if (removeUpper) {
 248 |     |                 if (isPool0) {
 249 |     |                     tickUpper.liquidityDelta -= int128(amount);
 250 |     |                 } else {
 251 |     |                     tickUpper.liquidityDelta += int128(amount);
 252 |     |                 }
 253 |     |                 ticks[upper] = tickUpper;
 254 |     |             }
 255 |     |             if (upper != ConstantProduct.maxTick(constants.tickSpread)) {
 256 |     |                 cleanup(ticks, tickMap, constants, tickUpper, upper);
 257 |     |             }
 258 |     |         }
 259 |     |     }
 260 |     | 
 261 |     |     function cleanup(
 262 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 263 |     |         CoverPoolStructs.TickMap storage tickMap,
 264 |     |         PoolsharkStructs.CoverImmutables memory constants,
 265 |     |         CoverPoolStructs.Tick memory tick,
 266 |     |         int24 tickIndex
 267 |     |     ) internal {
 268 |     |         if (!_empty(tick)){
 269 |     |             // if one of the values is 0 clear out both
 270 |     |             if (tick.amountInDeltaMaxMinus == 0 || tick.amountOutDeltaMaxMinus == 0) {
 271 |     |                 tick.amountInDeltaMaxMinus = 0;
 272 |     |                 tick.amountOutDeltaMaxMinus = 0;
 273 |     |             }
 274 |     |             if (tick.amountInDeltaMaxStashed == 0 || tick.amountOutDeltaMaxStashed == 0) {
 275 |     |                 tick.amountInDeltaMaxStashed = 0;
 276 |     |                 tick.amountOutDeltaMaxStashed = 0;
 277 |     |             }
 278 |     |             if (_inactive(tick)) {
 279 |     |                 // zero out all values for safety
 280 |     |                 tick.amountInDeltaMaxMinus = 0;
 281 |     |                 tick.amountOutDeltaMaxMinus = 0;
 282 |     |                 tick.amountInDeltaMaxStashed = 0;
 283 |     |                 tick.amountOutDeltaMaxStashed = 0;
 284 |     |                 TickMap.unset(tickIndex, tickMap, constants);
 285 |     |             }
 286 |     |         }
 287 |     |         if (_empty(tick)) {
 288 |     |             TickMap.unset(tickIndex, tickMap, constants);
 289 |     |             delete ticks[tickIndex];
 290 |     |         } else {
 291 |     |             ticks[tickIndex] = tick;
 292 |     |         }
 293 |     |     }
 294 |     | 
 295 |     |     function _inactive(
 296 |     |         CoverPoolStructs.Tick memory tick
 297 |     |     ) internal pure returns (
 298 |     |         bool
 299 |     |     ) {
 300 |     |         if (tick.amountInDeltaMaxStashed > 0 && tick.amountOutDeltaMaxStashed > 0) {
 301 |     |             return false;
 302 |     |         } else if (tick.amountInDeltaMaxMinus > 0 && tick.amountOutDeltaMaxMinus > 0){
 303 |     |             return false;
 304 |     |         } else if (tick.liquidityDelta != 0) {
 305 |     |             return false;
 306 |     |         }
 307 |     |         return true;
 308 |     |     }
 309 |     | 
 310 |     |     function _empty(
 311 |     |         CoverPoolStructs.Tick memory tick
 312 |     |     ) internal pure returns (
 313 |     |         bool
 314 |     |     ) {
 315 |     |         if (tick.amountInDeltaMaxStashed > 0 && tick.amountOutDeltaMaxStashed > 0) {
 316 |     |             return false;
 317 |     |         } else if (tick.amountInDeltaMaxMinus > 0 && tick.amountOutDeltaMaxMinus > 0){
 318 |     |             return false;
 319 |     |         } else if (tick.liquidityDelta != 0) {
 320 |     |             return false;
 321 |     |         } else if (tick.deltas0.amountInDeltaMax > 0 && tick.deltas0.amountOutDeltaMax > 0) {
 322 |     |             return false;
 323 |     |         } else if (tick.deltas1.amountInDeltaMax > 0 && tick.deltas1.amountOutDeltaMax > 0) {
 324 |     |             return false;
 325 |     |         }
 326 |     |         return true;
 327 |     |     }
 328 |     | }
 329 |     | 

/home/ec2-user/git/cover/contracts/libraries/math/ConstantProduct.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './OverflowMath.sol';
   5 |     | import '../../interfaces/structs/CoverPoolStructs.sol';
   6 |     | 
   7 |     | /// @notice Math library that facilitates ranged liquidity calculations.
   8 |     | library ConstantProduct {
   9 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
  10 |     | 
  11 |     |     struct PriceBounds {
  12 |     |         uint160 min;
  13 |     |         uint160 max;
  14 |     |     }
  15 |     | 
  16 |     |     /////////////////////////////////////////////////////////////
  17 |     |     ///////////////////////// DYDX MATH /////////////////////////
  18 |     |     /////////////////////////////////////////////////////////////
  19 |     | 
  20 |     |     function getDy(
  21 |     |         uint256 liquidity,
  22 |     |         uint256 priceLower,
  23 |     |         uint256 priceUpper,
  24 |     |         bool roundUp
  25 |     |     ) internal pure returns (uint256 dy) {
  26 |     |         unchecked {
  27 |     |             if (liquidity == 0) return 0;
  28 |     |             if (roundUp) {
  29 |     |                 dy = OverflowMath.mulDivRoundingUp(liquidity, priceUpper - priceLower, Q96);
  30 |     |             } else {
  31 |     |                 dy = OverflowMath.mulDiv(liquidity, priceUpper - priceLower, Q96);
  32 |     |             }
  33 |     |         }
  34 |     |     }
  35 |     | 
  36 |     |     function getDx(
  37 |     |         uint256 liquidity,
  38 |     |         uint256 priceLower,
  39 |     |         uint256 priceUpper,
  40 |     |         bool roundUp
  41 |     |     ) internal pure returns (uint256 dx) {
  42 |     |         unchecked {
  43 |     |             if (liquidity == 0) return 0;
  44 |     |             if (roundUp) {
  45 |     |                 dx = OverflowMath.divRoundingUp(
  46 |     |                         OverflowMath.mulDivRoundingUp(
  47 |     |                             liquidity << 96, 
  48 |     |                             priceUpper - priceLower,
  49 |     |                             priceUpper
  50 |     |                         ),
  51 |     |                         priceLower
  52 |     |                 );
  53 |     |             } else {
  54 |     |                 dx = OverflowMath.mulDiv(
  55 |     |                         liquidity << 96,
  56 |     |                         priceUpper - priceLower,
  57 |     |                         priceUpper
  58 |     |                 ) / priceLower;
  59 |     |             }
  60 |     |         }
  61 |     |     }
  62 |     | 
  63 |     |     function getLiquidityForAmounts(
  64 |     |         uint256 priceLower,
  65 |     |         uint256 priceUpper,
  66 |     |         uint256 currentPrice,
  67 |     |         uint256 dy,
  68 |     |         uint256 dx
  69 |     |     ) internal pure returns (uint256 liquidity) {
  70 |     |         unchecked {
  71 |     |             if (priceUpper <= currentPrice) {
  72 |     |                 liquidity = OverflowMath.mulDiv(dy, Q96, priceUpper - priceLower);
  73 |     |             } else if (currentPrice <= priceLower) {
  74 |     |                 liquidity = OverflowMath.mulDiv(
  75 |     |                     dx,
  76 |     |                     OverflowMath.mulDiv(priceLower, priceUpper, Q96),
  77 |     |                     priceUpper - priceLower
  78 |     |                 );
  79 |     |             } else {
  80 |     |                 uint256 liquidity0 = OverflowMath.mulDiv(
  81 |     |                     dx,
  82 |     |                     OverflowMath.mulDiv(priceUpper, currentPrice, Q96),
  83 |     |                     priceUpper - currentPrice
  84 |     |                 );
  85 |     |                 uint256 liquidity1 = OverflowMath.mulDiv(dy, Q96, currentPrice - priceLower);
  86 |     |                 liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
  87 |     |             }
  88 |     |         }
  89 |     |     }
  90 |     | 
  91 |     |     function getAmountsForLiquidity(
  92 |     |         uint256 priceLower,
  93 |     |         uint256 priceUpper,
  94 |     |         uint256 currentPrice,
  95 |     |         uint256 liquidityAmount,
  96 |     |         bool roundUp
  97 |     |     ) internal pure returns (uint128 token0amount, uint128 token1amount) {
  98 |     |         if (priceUpper <= currentPrice) {
  99 |     |             token1amount = uint128(getDy(liquidityAmount, priceLower, priceUpper, roundUp));
 100 |     |         } else if (currentPrice <= priceLower) {
 101 |     |             token0amount = uint128(getDx(liquidityAmount, priceLower, priceUpper, roundUp));
 102 |     |         } else {
 103 |     |             token0amount = uint128(getDx(liquidityAmount, currentPrice, priceUpper, roundUp));
 104 |     |             token1amount = uint128(getDy(liquidityAmount, priceLower, currentPrice, roundUp));
 105 |     |         }
 106 |     |         if (token0amount > uint128(type(int128).max)) require(false, 'AmountsOutOfBounds()');
 107 |     |         if (token1amount > uint128(type(int128).max)) require(false, 'AmountsOutOfBounds()');
 108 |     |     }
 109 |     | 
 110 |     |     function getNewPrice(
 111 |     |         uint256 price,
 112 |     |         uint256 liquidity,
 113 |     |         uint256 amount,
 114 |     |         bool zeroForOne,
 115 |     |         bool exactIn
 116 |     |     ) internal pure returns (
 117 |     |         uint256 newPrice
 118 |     |     ) {
 119 |     |         if (exactIn) {
 120 |     |             if (zeroForOne) {
 121 |     |                 uint256 liquidityPadded = liquidity << 96;
 122 |     |                 newPrice = OverflowMath.mulDivRoundingUp(
 123 |     |                         liquidityPadded,
 124 |     |                         price,
 125 |     |                         liquidityPadded + price * amount
 126 |     |                     );
 127 |     |             } else {
 128 |     |                 newPrice = price + (amount << 96) / liquidity;
 129 |     |             }
 130 |     |         } else {
 131 |     |             if (zeroForOne) {
 132 |     |                 newPrice = price - 
 133 |     |                         OverflowMath.divRoundingUp(amount << 96, liquidity);
 134 |     |             } else {
 135 |     |                 uint256 liquidityPadded = uint256(liquidity) << 96;
 136 |     |                 newPrice = OverflowMath.mulDivRoundingUp(
 137 |     |                         liquidityPadded, 
 138 |     |                         price,
 139 |     |                         liquidityPadded - uint256(price) * amount
 140 |     |                 );
 141 |     |             }
 142 |     |         }
 143 |     |     }
 144 |     | 
 145 |     |     function getPrice(
 146 |     |         uint256 sqrtPrice
 147 |     |     ) internal pure returns (uint256 price) {
 148 |     |         if (sqrtPrice >= 2 ** 48)
 149 |     |             price = OverflowMath.mulDiv(sqrtPrice, sqrtPrice, 2 ** 96);
 150 |     |         else
 151 |     |             price = sqrtPrice;
 152 |     |     }
 153 |     | 
 154 |     |     /////////////////////////////////////////////////////////////
 155 |     |     ///////////////////////// TICK MATH /////////////////////////
 156 |     |     /////////////////////////////////////////////////////////////
 157 |     | 
 158 | *   |     int24 internal constant MIN_TICK = -887272;   /// @dev - tick for price of 2^-128
 159 | *   |     int24 internal constant MAX_TICK = -MIN_TICK; /// @dev - tick for price of 2^128
 160 |     | 
 161 | *   |     function minTick(
 162 |     |         int16 tickSpacing
 163 |     |     ) internal pure returns (
 164 | *   |         int24 tick
 165 |     |     ) {
 166 | *   |         return MIN_TICK / tickSpacing * tickSpacing;
 167 |     |     }
 168 |     | 
 169 | *   |     function maxTick(
 170 |     |         int16 tickSpacing
 171 |     |     ) internal pure returns (
 172 | *   |         int24 tick
 173 |     |     ) {
 174 | *   |         return MAX_TICK / tickSpacing * tickSpacing;
 175 |     |     }
 176 |     | 
 177 |     |     function priceBounds(
 178 |     |         int16 tickSpacing
 179 |     |     ) internal pure returns (
 180 |     |         uint160,
 181 |     |         uint160
 182 |     |     ) {
 183 |     |         return (minPrice(tickSpacing), maxPrice(tickSpacing));
 184 |     |     }
 185 |     | 
 186 |     |     function minPrice(
 187 |     |         int16 tickSpacing
 188 |     |     ) internal pure returns (
 189 |     |         uint160 price
 190 |     |     ) {
 191 |     |         PoolsharkStructs.CoverImmutables  memory constants;
 192 |     |         constants.tickSpread = tickSpacing;
 193 |     |         return getPriceAtTick(minTick(tickSpacing), constants);
 194 |     |     }
 195 |     | 
 196 |     |     function maxPrice(
 197 |     |         int16 tickSpacing
 198 |     |     ) internal pure returns (
 199 |     |         uint160 price
 200 |     |     ) {
 201 |     |         PoolsharkStructs.CoverImmutables  memory constants;
 202 |     |         constants.tickSpread = tickSpacing;
 203 |     |         return getPriceAtTick(maxTick(tickSpacing), constants);
 204 |     |     }
 205 |     | 
 206 |     |     function checkTicks(
 207 |     |         int24 lower,
 208 |     |         int24 upper,
 209 |     |         int16 tickSpacing
 210 |     |     ) internal pure
 211 |     |     {
 212 |     |         if (lower < minTick(tickSpacing)) require (false, 'LowerTickOutOfBounds()');
 213 |     |         if (upper > maxTick(tickSpacing)) require (false, 'UpperTickOutOfBounds()');
 214 |     |         if (lower % tickSpacing != 0) require (false, 'LowerTickOutsideTickSpacing()');
 215 |     |         if (upper % tickSpacing != 0) require (false, 'UpperTickOutsideTickSpacing()');
 216 |     |         if (lower >= upper) require (false, 'LowerUpperTickOrderInvalid()');
 217 |     |     }
 218 |     | 
 219 |     |     function checkPrice(
 220 |     |         uint160 price,
 221 |     |         PriceBounds memory bounds
 222 |     |     ) internal pure {
 223 |     |         if (price < bounds.min || price >= bounds.max) require (false, 'PriceOutOfBounds()');
 224 |     |     }
 225 |     | 
 226 |     |     /// @notice Calculates sqrt(1.0001^tick) * 2^96.
 227 |     |     /// @dev Throws if |tick| > max tick.
 228 |     |     /// @param tick The input tick for the above formula.
 229 |     |     /// @return price Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
 230 |     |     /// at the given tick.
 231 |     |     function getPriceAtTick(
 232 |     |         int24 tick,
 233 |     |         PoolsharkStructs.CoverImmutables memory constants
 234 |     |     ) internal pure returns (
 235 |     |         uint160 price
 236 |     |     ) {
 237 |     |         uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
 238 |     |         if (absTick > uint256(uint24(maxTick(constants.tickSpread)))) require (false, 'TickOutOfBounds()');
 239 |     |         unchecked {
 240 |     |             uint256 ratio = absTick & 0x1 != 0
 241 |     |                 ? 0xfffcb933bd6fad37aa2d162d1a594001
 242 |     |                 : 0x100000000000000000000000000000000;
 243 |     |             if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
 244 |     |             if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
 245 |     |             if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
 246 |     |             if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
 247 |     |             if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
 248 |     |             if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
 249 |     |             if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
 250 |     |             if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
 251 |     |             if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
 252 |     |             if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
 253 |     |             if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
 254 |     |             if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
 255 |     |             if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
 256 |     |             if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
 257 |     |             if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
 258 |     |             if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
 259 |     |             if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
 260 |     |             if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
 261 |     |             if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
 262 |     | 
 263 |     |             if (tick > 0) ratio = type(uint256).max / ratio;
 264 |     |             // This divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
 265 |     |             // We then downcast because we know the result always fits within 160 bits due to our tick input constraint.
 266 |     |             // We round up in the division so getTickAtPrice of the output price is always consistent.
 267 |     |             price = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
 268 |     |         }
 269 |     |     }
 270 |     | 
 271 |     |     /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio.
 272 |     |     /// @param price The sqrt ratio for which to compute the tick as a Q64.96.
 273 |     |     /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio.
 274 |     |     function getTickAtPrice(
 275 |     |         uint160 price,
 276 |     |         PoolsharkStructs.CoverImmutables  memory constants
 277 |     |     ) internal pure returns (int24 tick) {
 278 |     |         // Second inequality must be < because the price can never reach the price at the max tick.
 279 |     |         if (price < constants.bounds.min || price > constants.bounds.max)
 280 |     |             require (false, 'PriceOutOfBounds()');
 281 |     |         uint256 ratio = uint256(price) << 32;
 282 |     | 
 283 |     |         uint256 r = ratio;
 284 |     |         uint256 msb = 0;
 285 |     | 
 286 |     |         assembly {
 287 |     |             let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
 288 |     |             msb := or(msb, f)
 289 |     |             r := shr(f, r)
 290 |     |         }
 291 |     |         assembly {
 292 |     |             let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
 293 |     |             msb := or(msb, f)
 294 |     |             r := shr(f, r)
 295 |     |         }
 296 |     |         assembly {
 297 |     |             let f := shl(5, gt(r, 0xFFFFFFFF))
 298 |     |             msb := or(msb, f)
 299 |     |             r := shr(f, r)
 300 |     |         }
 301 |     |         assembly {
 302 |     |             let f := shl(4, gt(r, 0xFFFF))
 303 |     |             msb := or(msb, f)
 304 |     |             r := shr(f, r)
 305 |     |         }
 306 |     |         assembly {
 307 |     |             let f := shl(3, gt(r, 0xFF))
 308 |     |             msb := or(msb, f)
 309 |     |             r := shr(f, r)
 310 |     |         }
 311 |     |         assembly {
 312 |     |             let f := shl(2, gt(r, 0xF))
 313 |     |             msb := or(msb, f)
 314 |     |             r := shr(f, r)
 315 |     |         }
 316 |     |         assembly {
 317 |     |             let f := shl(1, gt(r, 0x3))
 318 |     |             msb := or(msb, f)
 319 |     |             r := shr(f, r)
 320 |     |         }
 321 |     |         assembly {
 322 |     |             let f := gt(r, 0x1)
 323 |     |             msb := or(msb, f)
 324 |     |         }
 325 |     | 
 326 |     |         if (msb >= 128) r = ratio >> (msb - 127);
 327 |     |         else r = ratio << (127 - msb);
 328 |     | 
 329 |     |         int256 log_2 = (int256(msb) - 128) << 64;
 330 |     | 
 331 |     |         assembly {
 332 |     |             r := shr(127, mul(r, r))
 333 |     |             let f := shr(128, r)
 334 |     |             log_2 := or(log_2, shl(63, f))
 335 |     |             r := shr(f, r)
 336 |     |         }
 337 |     |         assembly {
 338 |     |             r := shr(127, mul(r, r))
 339 |     |             let f := shr(128, r)
 340 |     |             log_2 := or(log_2, shl(62, f))
 341 |     |             r := shr(f, r)
 342 |     |         }
 343 |     |         assembly {
 344 |     |             r := shr(127, mul(r, r))
 345 |     |             let f := shr(128, r)
 346 |     |             log_2 := or(log_2, shl(61, f))
 347 |     |             r := shr(f, r)
 348 |     |         }
 349 |     |         assembly {
 350 |     |             r := shr(127, mul(r, r))
 351 |     |             let f := shr(128, r)
 352 |     |             log_2 := or(log_2, shl(60, f))
 353 |     |             r := shr(f, r)
 354 |     |         }
 355 |     |         assembly {
 356 |     |             r := shr(127, mul(r, r))
 357 |     |             let f := shr(128, r)
 358 |     |             log_2 := or(log_2, shl(59, f))
 359 |     |             r := shr(f, r)
 360 |     |         }
 361 |     |         assembly {
 362 |     |             r := shr(127, mul(r, r))
 363 |     |             let f := shr(128, r)
 364 |     |             log_2 := or(log_2, shl(58, f))
 365 |     |             r := shr(f, r)
 366 |     |         }
 367 |     |         assembly {
 368 |     |             r := shr(127, mul(r, r))
 369 |     |             let f := shr(128, r)
 370 |     |             log_2 := or(log_2, shl(57, f))
 371 |     |             r := shr(f, r)
 372 |     |         }
 373 |     |         assembly {
 374 |     |             r := shr(127, mul(r, r))
 375 |     |             let f := shr(128, r)
 376 |     |             log_2 := or(log_2, shl(56, f))
 377 |     |             r := shr(f, r)
 378 |     |         }
 379 |     |         assembly {
 380 |     |             r := shr(127, mul(r, r))
 381 |     |             let f := shr(128, r)
 382 |     |             log_2 := or(log_2, shl(55, f))
 383 |     |             r := shr(f, r)
 384 |     |         }
 385 |     |         assembly {
 386 |     |             r := shr(127, mul(r, r))
 387 |     |             let f := shr(128, r)
 388 |     |             log_2 := or(log_2, shl(54, f))
 389 |     |             r := shr(f, r)
 390 |     |         }
 391 |     |         assembly {
 392 |     |             r := shr(127, mul(r, r))
 393 |     |             let f := shr(128, r)
 394 |     |             log_2 := or(log_2, shl(53, f))
 395 |     |             r := shr(f, r)
 396 |     |         }
 397 |     |         assembly {
 398 |     |             r := shr(127, mul(r, r))
 399 |     |             let f := shr(128, r)
 400 |     |             log_2 := or(log_2, shl(52, f))
 401 |     |             r := shr(f, r)
 402 |     |         }
 403 |     |         assembly {
 404 |     |             r := shr(127, mul(r, r))
 405 |     |             let f := shr(128, r)
 406 |     |             log_2 := or(log_2, shl(51, f))
 407 |     |             r := shr(f, r)
 408 |     |         }
 409 |     |         assembly {
 410 |     |             r := shr(127, mul(r, r))
 411 |     |             let f := shr(128, r)
 412 |     |             log_2 := or(log_2, shl(50, f))
 413 |     |         }
 414 |     | 
 415 |     |         int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number
 416 |     | 
 417 |     |         int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
 418 |     |         int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
 419 |     | 
 420 |     |         tick = tickLow == tickHi ? tickLow : getPriceAtTick(tickHi, constants) <= price
 421 |     |             ? tickHi
 422 |     |             : tickLow;
 423 |     |     }
 424 |     | }

/home/ec2-user/git/cover/contracts/libraries/math/OverflowMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /// @notice Math library that facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision.
   5 |     | library OverflowMath {
   6 |     | 
   7 |     |     // @dev no underflow or overflow checks
   8 |     |     function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
   9 |     |         assembly {
  10 |     |             z := add(div(x, y), gt(mod(x, y), 0))
  11 |     |         }
  12 |     |     }
  13 |     | 
  14 |     |     /// @notice Calculates floor(abdenominator) with full precision - throws if result overflows an uint256 or denominator == 0.
  15 |     |     /// @param a The multiplicand.
  16 |     |     /// @param b The multiplier.
  17 |     |     /// @param denominator The divisor.
  18 |     |     /// @return result The 256-bit result.
  19 |     |     /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.
  20 |     |     function mulDiv(
  21 |     |         uint256 a,
  22 |     |         uint256 b,
  23 |     |         uint256 denominator
  24 |     |     ) internal pure returns (uint256 result) {
  25 |     |         unchecked {
  26 |     |             // 512-bit multiply [prod1 prod0] = a * b.
  27 |     |             // Compute the product mod 2**256 and mod 2**256 - 1,
  28 |     |             // then use the Chinese Remainder Theorem to reconstruct
  29 |     |             // the 512 bit result. The result is stored in two 256
  30 |     |             // variables such that product = prod1 * 2**256 + prod0.
  31 |     |             uint256 prod0; // Least significant 256 bits of the product.
  32 |     |             uint256 prod1; // Most significant 256 bits of the product.
  33 |     |             assembly {
  34 |     |                 let mm := mulmod(a, b, not(0))
  35 |     |                 prod0 := mul(a, b)
  36 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  37 |     |             }
  38 |     |             // Handle non-overflow cases, 256 by 256 division.
  39 |     |             if (prod1 == 0) {
  40 |     |                 require(denominator > 0);
  41 |     |                 assembly {
  42 |     |                     result := div(prod0, denominator)
  43 |     |                 }
  44 |     |                 return result;
  45 |     |             }
  46 |     |             // Make sure the result is less than 2**256 -
  47 |     |             // also prevents denominator == 0.
  48 |     |             require(denominator > prod1);
  49 |     |             ///////////////////////////////////////////////
  50 |     |             // 512 by 256 division.
  51 |     |             ///////////////////////////////////////////////
  52 |     |             // Make division exact by subtracting the remainder from [prod1 prod0] -
  53 |     |             // compute remainder using mulmod.
  54 |     |             uint256 remainder;
  55 |     |             assembly {
  56 |     |                 remainder := mulmod(a, b, denominator)
  57 |     |             }
  58 |     |             // Subtract 256 bit number from 512 bit number.
  59 |     |             assembly {
  60 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
  61 |     |                 prod0 := sub(prod0, remainder)
  62 |     |             }
  63 |     |             // Factor powers of two out of denominator -
  64 |     |             // compute largest power of two divisor of denominator
  65 |     |             // (always >= 1).
  66 |     |             uint256 twos = uint256(-int256(denominator)) & denominator;
  67 |     |             // Divide denominator by power of two.
  68 |     |             assembly {
  69 |     |                 denominator := div(denominator, twos)
  70 |     |             }
  71 |     |             // Divide [prod1 prod0] by the factors of two.
  72 |     |             assembly {
  73 |     |                 prod0 := div(prod0, twos)
  74 |     |             }
  75 |     |             // Shift in bits from prod1 into prod0. For this we need
  76 |     |             // to flip `twos` such that it is 2**256 / twos -
  77 |     |             // if twos is zero, then it becomes one.
  78 |     |             assembly {
  79 |     |                 twos := add(div(sub(0, twos), twos), 1)
  80 |     |             }
  81 |     |             prod0 |= prod1 * twos;
  82 |     |             // Invert denominator mod 2**256 -
  83 |     |             // now that denominator is an odd number, it has an inverse
  84 |     |             // modulo 2**256 such that denominator * inv = 1 mod 2**256.
  85 |     |             // Compute the inverse by starting with a seed that is correct
  86 |     |             // for four bits. That is, denominator * inv = 1 mod 2**4.
  87 |     |             uint256 inv = (3 * denominator) ^ 2;
  88 |     |             // Now use Newton-Raphson iteration to improve the precision.
  89 |     |             // Thanks to Hensel's lifting lemma, this also works in modular
  90 |     |             // arithmetic, doubling the correct bits in each step.
  91 |     |             inv *= 2 - denominator * inv; // Inverse mod 2**8.
  92 |     |             inv *= 2 - denominator * inv; // Inverse mod 2**16.
  93 |     |             inv *= 2 - denominator * inv; // Inverse mod 2**32.
  94 |     |             inv *= 2 - denominator * inv; // Inverse mod 2**64.
  95 |     |             inv *= 2 - denominator * inv; // Inverse mod 2**128.
  96 |     |             inv *= 2 - denominator * inv; // Inverse mod 2**256.
  97 |     |             // Because the division is now exact we can divide by multiplying
  98 |     |             // with the modular inverse of denominator. This will give us the
  99 |     |             // correct result modulo 2**256. Since the precoditions guarantee
 100 |     |             // that the outcome is less than 2**256, this is the final result.
 101 |     |             // We don't need to compute the high bits of the result and prod1
 102 |     |             // is no longer required.
 103 |     |             result = prod0 * inv;
 104 |     |             return result;
 105 |     |         }
 106 |     |     }
 107 |     | 
 108 |     |     /// @notice Calculates ceil(abdenominator) with full precision - throws if result overflows an uint256 or denominator == 0.
 109 |     |     /// @param a The multiplicand.
 110 |     |     /// @param b The multiplier.
 111 |     |     /// @param denominator The divisor.
 112 |     |     /// @return result The 256-bit result.
 113 |     |     function mulDivRoundingUp(
 114 |     |         uint256 a,
 115 |     |         uint256 b,
 116 |     |         uint256 denominator
 117 |     |     ) internal pure returns (uint256 result) {
 118 |     |         result = mulDiv(a, b, denominator);
 119 |     |         unchecked {
 120 |     |             if (mulmod(a, b, denominator) != 0) {
 121 |     |                 if (result >= type(uint256).max) require (false, 'MaxUintExceeded()');
 122 |     |                 result++;
 123 |     |             }
 124 |     |         }
 125 |     |     }
 126 |     | }
 127 |     | 

/home/ec2-user/git/cover/contracts/libraries/pool/BurnCall.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/structs/CoverPoolStructs.sol';
   5 |     | import '../Positions.sol';
   6 |     | import '../utils/PositionTokens.sol';
   7 |     | import '../utils/Collect.sol';
   8 |     | 
   9 |     | library BurnCall {
  10 |     |     event Burn(
  11 |     |         address indexed to,
  12 |     |         int24 lower,
  13 |     |         int24 upper,
  14 |     |         int24 claim,
  15 |     |         bool zeroForOne,
  16 |     |         uint128 liquidityBurned,
  17 |     |         uint128 tokenInClaimed,
  18 |     |         uint128 tokenOutClaimed,
  19 |     |         uint128 tokenOutBurned,
  20 |     |         uint128 amountInDeltaMaxStashedBurned,
  21 |     |         uint128 amountOutDeltaMaxStashedBurned,
  22 |     |         uint128 amountInDeltaMaxBurned,
  23 |     |         uint128 amountOutDeltaMaxBurned,
  24 |     |         uint160 claimPriceLast
  25 |     |     );
  26 |     | 
  27 |     |     error SimulateBurn(int24 lower, int24 upper, bool positionExists);
  28 |     | 
  29 |     |     function perform(
  30 |     |         mapping(uint256 => CoverPoolStructs.CoverPosition)
  31 |     |             storage positions,
  32 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
  33 |     |         CoverPoolStructs.TickMap storage tickMap,
  34 |     |         CoverPoolStructs.GlobalState storage globalState,
  35 |     |         CoverPoolStructs.PoolState storage pool0,
  36 |     |         CoverPoolStructs.PoolState storage pool1,
  37 |     |         ICoverPool.BurnParams memory params,
  38 |     |         CoverPoolStructs.BurnCache memory cache
  39 |     |     ) internal {
  40 |     |         cache.position = positions[params.positionId];
  41 |     |         if (PositionTokens.balanceOf(cache.constants, msg.sender, params.positionId) == 0)
  42 |     |             // check for balance held
  43 |     |             require(false, 'PositionNotFound()');
  44 |     |         //TODO: should check epochs here
  45 |     |         if (cache.position.claimPriceLast > 0
  46 |     |             || params.claim != (params.zeroForOne ? cache.position.upper : cache.position.lower) 
  47 |     |             || params.claim == cache.state.latestTick)
  48 |     |         {
  49 |     |             // if position has been crossed into
  50 |     |             if (params.zeroForOne) {
  51 |     |                 (
  52 |     |                     cache.state,
  53 |     |                     cache.pool0,
  54 |     |                     params.claim
  55 |     |                 ) = Positions.update(
  56 |     |                     positions,
  57 |     |                     ticks,
  58 |     |                     tickMap,
  59 |     |                     cache.state,
  60 |     |                     cache.pool0,
  61 |     |                     CoverPoolStructs.UpdateParams(
  62 |     |                         msg.sender,
  63 |     |                         params.to,
  64 |     |                         params.burnPercent,
  65 |     |                         params.positionId,
  66 |     |                         cache.position.lower,
  67 |     |                         cache.position.upper,
  68 |     |                         params.claim,
  69 |     |                         params.zeroForOne
  70 |     |                     ),
  71 |     |                     cache.constants
  72 |     |                 );
  73 |     |             } else {
  74 |     |                 (
  75 |     |                     cache.state,
  76 |     |                     cache.pool1,
  77 |     |                     params.claim
  78 |     |                 ) = Positions.update(
  79 |     |                     positions,
  80 |     |                     ticks,
  81 |     |                     tickMap,
  82 |     |                     cache.state,
  83 |     |                     cache.pool1,
  84 |     |                     CoverPoolStructs.UpdateParams(
  85 |     |                         msg.sender,
  86 |     |                         params.to,
  87 |     |                         params.burnPercent,
  88 |     |                         params.positionId,
  89 |     |                         cache.position.lower,
  90 |     |                         cache.position.upper,
  91 |     |                         params.claim,
  92 |     |                         params.zeroForOne
  93 |     |                     ),
  94 |     |                     cache.constants
  95 |     |                 );
  96 |     |             }
  97 |     |         } else {
  98 |     |             // if position hasn't been crossed into
  99 |     |             (, cache.state) = Positions.remove(
 100 |     |                 positions,
 101 |     |                 ticks,
 102 |     |                 tickMap,
 103 |     |                 cache.state,
 104 |     |                 CoverPoolStructs.RemoveParams(
 105 |     |                     msg.sender,
 106 |     |                     params.to,
 107 |     |                     params.burnPercent,
 108 |     |                     params.positionId,
 109 |     |                     cache.position.lower,
 110 |     |                     cache.position.upper,
 111 |     |                     params.zeroForOne
 112 |     |                 ),
 113 |     |                 cache.constants
 114 |     |             );
 115 |     |         }
 116 |     |         save(cache, globalState, pool0, pool1);
 117 |     |         Collect.burn(
 118 |     |             cache,
 119 |     |             positions,
 120 |     |             CoverPoolStructs.CollectParams(
 121 |     |                 cache.syncFees,
 122 |     |                 params.to, //address(0) goes to msg.sender
 123 |     |                 params.positionId,
 124 |     |                 cache.position.lower,
 125 |     |                 params.claim,
 126 |     |                 cache.position.upper,
 127 |     |                 params.zeroForOne
 128 |     |             )
 129 |     |         );
 130 |     |     }
 131 |     | 
 132 |     |     // Echidna funcs
 133 |     |     function getResizedTicks(
 134 |     |         mapping(uint256 => CoverPoolStructs.CoverPosition)
 135 |     |             storage positions,
 136 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 137 |     |         CoverPoolStructs.TickMap storage tickMap,
 138 |     |         CoverPoolStructs.GlobalState storage globalState,
 139 |     |         CoverPoolStructs.PoolState storage pool0,
 140 |     |         CoverPoolStructs.PoolState storage pool1,
 141 |     |         ICoverPool.BurnParams memory params,
 142 |     |         CoverPoolStructs.BurnCache memory cache
 143 |     |     ) external {
 144 |     |         // check for invalid receiver
 145 |     |         if (params.to == address(0))
 146 |     |             require(false, 'CollectToZeroAddress()');
 147 |     |         cache.position = positions[params.positionId];
 148 |     |         if (PositionTokens.balanceOf(cache.constants, msg.sender, params.positionId) == 0)
 149 |     |             // check for balance held
 150 |     |             require(false, 'PositionNotFound()');
 151 |     |         if (cache.position.claimPriceLast > 0
 152 |     |             || params.claim != (params.zeroForOne ? cache.position.upper : cache.position.lower) 
 153 |     |             || params.claim == cache.state.latestTick)
 154 |     |         {
 155 |     |             // if position has been crossed into
 156 |     |             if (params.zeroForOne) {
 157 |     |                 (
 158 |     |                     cache.state,
 159 |     |                     cache.pool0,
 160 |     |                     params.claim
 161 |     |                 ) = Positions.update(
 162 |     |                     positions,
 163 |     |                     ticks,
 164 |     |                     tickMap,
 165 |     |                     cache.state,
 166 |     |                     cache.pool0,
 167 |     |                     CoverPoolStructs.UpdateParams(
 168 |     |                         msg.sender,
 169 |     |                         params.to,
 170 |     |                         params.burnPercent,
 171 |     |                         params.positionId,
 172 |     |                         cache.position.lower,
 173 |     |                         cache.position.upper,
 174 |     |                         params.claim,
 175 |     |                         params.zeroForOne
 176 |     |                     ),
 177 |     |                     cache.constants
 178 |     |                 );
 179 |     |             } else {
 180 |     |                 (
 181 |     |                     cache.state,
 182 |     |                     cache.pool1,
 183 |     |                     params.claim
 184 |     |                 ) = Positions.update(
 185 |     |                     positions,
 186 |     |                     ticks,
 187 |     |                     tickMap,
 188 |     |                     cache.state,
 189 |     |                     cache.pool1,
 190 |     |                     CoverPoolStructs.UpdateParams(
 191 |     |                         msg.sender,
 192 |     |                         params.to,
 193 |     |                         params.burnPercent,
 194 |     |                         params.positionId,
 195 |     |                         cache.position.lower,
 196 |     |                         cache.position.upper,
 197 |     |                         params.claim,
 198 |     |                         params.zeroForOne
 199 |     |                     ),
 200 |     |                     cache.constants
 201 |     |                 );
 202 |     |             }
 203 |     |         } else {
 204 |     |             // if position hasn't been crossed into
 205 |     |             (, cache.state) = Positions.remove(
 206 |     |                 positions,
 207 |     |                 ticks,
 208 |     |                 tickMap,
 209 |     |                 cache.state,
 210 |     |                 CoverPoolStructs.RemoveParams(
 211 |     |                     msg.sender,
 212 |     |                     params.to,
 213 |     |                     params.burnPercent,
 214 |     |                     params.positionId,
 215 |     |                     cache.position.lower,
 216 |     |                     cache.position.upper,
 217 |     |                     params.zeroForOne
 218 |     |                 ),
 219 |     |                 cache.constants
 220 |     |             );
 221 |     |         }
 222 |     |         save(cache, globalState, pool0, pool1);
 223 |     |         int24 lower = cache.position.lower;
 224 |     |         int24 upper = cache.position.upper;
 225 |     |         bool positionExists = cache.position.liquidity != 0;
 226 |     | 
 227 |     |         Collect.burn(
 228 |     |             cache,
 229 |     |             positions,
 230 |     |             CoverPoolStructs.CollectParams(
 231 |     |                 cache.syncFees,
 232 |     |                 params.to, //address(0) goes to msg.sender
 233 |     |                 params.positionId,
 234 |     |                 cache.position.lower,
 235 |     |                 params.claim,
 236 |     |                 cache.position.upper,
 237 |     |                 params.zeroForOne
 238 |     |             )
 239 |     |         );
 240 |     | 
 241 |     |         revert SimulateBurn(lower, upper, positionExists);
 242 |     |     }
 243 |     | 
 244 |     |     function save(
 245 |     |         CoverPoolStructs.BurnCache memory cache,
 246 |     |         CoverPoolStructs.GlobalState storage globalState,
 247 |     |         CoverPoolStructs.PoolState storage pool0,
 248 |     |         CoverPoolStructs.PoolState storage pool1
 249 |     |     ) internal {
 250 |     |         // globalState
 251 |     |         globalState.protocolFees = cache.state.protocolFees;
 252 |     |         globalState.latestPrice = cache.state.latestPrice;
 253 |     |         globalState.liquidityGlobal = cache.state.liquidityGlobal;
 254 |     |         globalState.lastTime = cache.state.lastTime;
 255 |     |         globalState.auctionStart = cache.state.auctionStart;
 256 |     |         globalState.accumEpoch = cache.state.accumEpoch;
 257 |     |         globalState.positionIdNext = cache.state.positionIdNext;
 258 |     |         globalState.latestTick = cache.state.latestTick;
 259 |     |         
 260 |     |         // pool0
 261 |     |         pool0.price = cache.pool0.price;
 262 |     |         pool0.liquidity = cache.pool0.liquidity;
 263 |     |         pool0.amountInDelta = cache.pool0.amountInDelta;
 264 |     |         pool0.amountInDeltaMaxClaimed = cache.pool0.amountInDeltaMaxClaimed;
 265 |     |         pool0.amountOutDeltaMaxClaimed = cache.pool0.amountOutDeltaMaxClaimed;
 266 |     | 
 267 |     |         // pool1
 268 |     |         pool1.price = cache.pool1.price;
 269 |     |         pool1.liquidity = cache.pool1.liquidity;
 270 |     |         pool1.amountInDelta = cache.pool1.amountInDelta;
 271 |     |         pool1.amountInDeltaMaxClaimed = cache.pool1.amountInDeltaMaxClaimed;
 272 |     |         pool1.amountOutDeltaMaxClaimed = cache.pool1.amountOutDeltaMaxClaimed;
 273 |     |     }
 274 |     | }
 275 |     | 

/home/ec2-user/git/cover/contracts/libraries/pool/MintCall.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/structs/CoverPoolStructs.sol';
   5 |     | import '../Positions.sol';
   6 |     | import '../utils/PositionTokens.sol';
   7 |     | import '../utils/Collect.sol';
   8 |     | 
   9 | *   | library MintCall {
  10 |     |     event Mint(
  11 |     |         address indexed to,
  12 |     |         int24 lower,
  13 |     |         int24 upper,
  14 |     |         bool zeroForOne,
  15 |     |         uint32 positionId,
  16 |     |         uint32 epochLast,
  17 |     |         uint128 amountIn,
  18 |     |         uint128 liquidityMinted,
  19 |     |         uint128 amountInDeltaMaxMinted,
  20 |     |         uint128 amountOutDeltaMaxMinted
  21 |     |     );
  22 |     | 
  23 |     |     error SimulateMint(int24 lower, int24 upper, bool positionCreated);
  24 |     | 
  25 |     |     function perform(
  26 |     |         mapping(uint256 => CoverPoolStructs.CoverPosition)
  27 |     |             storage positions,
  28 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
  29 |     |         CoverPoolStructs.TickMap storage tickMap,
  30 |     |         CoverPoolStructs.GlobalState storage globalState,
  31 |     |         CoverPoolStructs.PoolState storage pool0,
  32 |     |         CoverPoolStructs.PoolState storage pool1,
  33 |     |         ICoverPool.MintParams memory params,
  34 |     |         CoverPoolStructs.MintCache memory cache
  35 |     |     ) internal returns (CoverPoolStructs.MintCache memory) {
  36 |     |         if (params.positionId > 0) {
  37 |     |             if (PositionTokens.balanceOf(cache.constants, msg.sender, params.positionId) == 0)
  38 |     |                 // check for balance held
  39 |     |                 require(false, 'PositionNotFound()');
  40 |     |             // load existing position
  41 |     |             cache.position = positions[params.positionId];
  42 |     |         }
  43 |     |         // resize position
  44 |     |         (params, cache.liquidityMinted) = Positions.resize(
  45 |     |             cache.position,
  46 |     |             params, 
  47 |     |             cache.state,
  48 |     |             cache.constants
  49 |     |         );
  50 |     |         if (params.positionId == 0 ||                       // new position
  51 |     |                 params.lower != cache.position.lower ||     // lower mismatch
  52 |     |                 params.upper != cache.position.upper) {     // upper mismatch
  53 |     |             CoverPoolStructs.CoverPosition memory newPosition;
  54 |     |             newPosition.lower = params.lower;
  55 |     |             newPosition.upper = params.upper;
  56 |     |             // use new position in cache
  57 |     |             cache.position = newPosition;
  58 |     |             params.positionId = cache.state.positionIdNext;
  59 |     |             cache.state.positionIdNext += 1;
  60 |     |         }
  61 |     |         // save global state to protect against reentrancy
  62 |     |         save(cache, globalState, pool0, pool1);
  63 |     |         // params.amount must be > 0 here
  64 |     |         SafeTransfers.transferIn(params.zeroForOne ? cache.constants.token0 
  65 |     |                                                    : cache.constants.token1,
  66 |     |                                  params.amount
  67 |     |                                 );
  68 |     |         (cache.state, cache.position) = Positions.add(
  69 |     |             cache.position,
  70 |     |             ticks,
  71 |     |             tickMap,
  72 |     |             cache.state,
  73 |     |             CoverPoolStructs.AddParams(
  74 |     |                 params.to,
  75 |     |                 uint128(cache.liquidityMinted),
  76 |     |                 params.amount,
  77 |     |                 params.positionId,
  78 |     |                 params.lower,
  79 |     |                 params.upper,
  80 |     |                 params.zeroForOne
  81 |     |             ),
  82 |     |             cache.constants
  83 |     |         );
  84 |     |         positions[params.positionId] = cache.position;
  85 |     |         save(cache, globalState, pool0, pool1);
  86 |     |         Collect.mint(
  87 |     |             cache,
  88 |     |             CoverPoolStructs.CollectParams(
  89 |     |                 cache.syncFees,
  90 |     |                 params.to,
  91 |     |                 params.positionId,
  92 |     |                 params.lower,
  93 |     |                 0, // not needed for mint collect
  94 |     |                 params.upper,
  95 |     |                 params.zeroForOne
  96 |     |             )
  97 |     |         );
  98 |     |         return cache;
  99 |     |     }
 100 |     | 
 101 |     |     // Echidna funcs
 102 | *   |     function getResizedTicks(
 103 |     |         mapping(uint256 => CoverPoolStructs.CoverPosition)
 104 |     |             storage positions,
 105 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 106 |     |         CoverPoolStructs.TickMap storage tickMap,
 107 |     |         CoverPoolStructs.GlobalState storage globalState,
 108 |     |         CoverPoolStructs.PoolState storage pool0,
 109 |     |         CoverPoolStructs.PoolState storage pool1,
 110 |     |         ICoverPool.MintParams memory params,
 111 |     |         CoverPoolStructs.MintCache memory cache
 112 |     |     ) external {
 113 | *   |         bool positionCreated = false;
 114 | *   |         if (params.positionId > 0) {
 115 |     |             if (PositionTokens.balanceOf(cache.constants, msg.sender, params.positionId) == 0)
 116 |     |                 // check for balance held
 117 |     |                 require(false, 'PositionNotFound()');
 118 |     |             // load existing position
 119 |     |             cache.position = positions[params.positionId];
 120 |     |         }
 121 |     |         // assume cache.state is already set
 122 |     | 
 123 |     |         // resize position
 124 |     |         (params, cache.liquidityMinted) = Positions.resize(
 125 |     |             cache.position,
 126 |     |             params, 
 127 |     |             cache.state,
 128 |     |             cache.constants
 129 |     |         );
 130 |     | 
 131 |     |         if (params.positionId == 0 ||                       // new position
 132 |     |                 params.lower != cache.position.lower ||     // lower mismatch
 133 |     |                 params.upper != cache.position.upper) {     // upper mismatch
 134 |     |             CoverPoolStructs.CoverPosition memory newPosition;
 135 |     |             newPosition.lower = params.lower;
 136 |     |             newPosition.upper = params.upper;
 137 |     |             // use new position in cache
 138 |     |             cache.position = newPosition;
 139 |     |             params.positionId = cache.state.positionIdNext;
 140 |     |             cache.state.positionIdNext += 1;
 141 |     |         }
 142 |     |         // save global state to protect against reentrancy
 143 |     |         save(cache, globalState, pool0, pool1);
 144 |     |         // transfer in token amount
 145 |     |         SafeTransfers.transferIn(params.zeroForOne ? cache.constants.token0 
 146 |     |                                                    : cache.constants.token1,
 147 |     |                                  params.amount
 148 |     |                                 );
 149 |     | 
 150 |     |         (cache.state, cache.position) = Positions.add(
 151 |     |             cache.position,
 152 |     |             ticks,
 153 |     |             tickMap,
 154 |     |             cache.state,
 155 |     |             CoverPoolStructs.AddParams(
 156 |     |                 params.to,
 157 |     |                 uint128(cache.liquidityMinted),
 158 |     |                 params.amount,
 159 |     |                 params.positionId,
 160 |     |                 params.lower,
 161 |     |                 params.upper,
 162 |     |                 params.zeroForOne
 163 |     |             ),
 164 |     |             cache.constants
 165 |     |         );
 166 |     |         positions[params.positionId] = cache.position;
 167 |     |         save(cache, globalState, pool0, pool1);
 168 |     |         Collect.mint(
 169 |     |             cache,
 170 |     |             CoverPoolStructs.CollectParams(
 171 |     |                 cache.syncFees,
 172 |     |                 params.to,
 173 |     |                 params.positionId,
 174 |     |                 params.lower,
 175 |     |                 0, // not needed for mint collect
 176 |     |                 params.upper,
 177 |     |                 params.zeroForOne
 178 |     |             )
 179 |     |         );
 180 |     | 
 181 |     |         revert SimulateMint(params.lower, params.upper, positionCreated);
 182 |     |     }
 183 |     | 
 184 |     |     function save(
 185 |     |         CoverPoolStructs.MintCache memory cache,
 186 |     |         CoverPoolStructs.GlobalState storage globalState,
 187 |     |         CoverPoolStructs.PoolState storage pool0,
 188 |     |         CoverPoolStructs.PoolState storage pool1
 189 |     |     ) internal {
 190 |     |         // globalState
 191 |     |         globalState.protocolFees = cache.state.protocolFees;
 192 |     |         globalState.latestPrice = cache.state.latestPrice;
 193 |     |         globalState.liquidityGlobal = cache.state.liquidityGlobal;
 194 |     |         globalState.lastTime = cache.state.lastTime;
 195 |     |         globalState.auctionStart = cache.state.auctionStart;
 196 |     |         globalState.accumEpoch = cache.state.accumEpoch;
 197 |     |         globalState.positionIdNext = cache.state.positionIdNext;
 198 |     |         globalState.latestTick = cache.state.latestTick;
 199 |     |         
 200 |     |         // pool0
 201 |     |         pool0.price = cache.pool0.price;
 202 |     |         pool0.liquidity = cache.pool0.liquidity;
 203 |     |         pool0.amountInDelta = cache.pool0.amountInDelta;
 204 |     |         pool0.amountInDeltaMaxClaimed = cache.pool0.amountInDeltaMaxClaimed;
 205 |     |         pool0.amountOutDeltaMaxClaimed = cache.pool0.amountOutDeltaMaxClaimed;
 206 |     | 
 207 |     |         // pool1
 208 |     |         pool1.price = cache.pool1.price;
 209 |     |         pool1.liquidity = cache.pool1.liquidity;
 210 |     |         pool1.amountInDelta = cache.pool1.amountInDelta;
 211 |     |         pool1.amountInDeltaMaxClaimed = cache.pool1.amountInDeltaMaxClaimed;
 212 |     |         pool1.amountOutDeltaMaxClaimed = cache.pool1.amountOutDeltaMaxClaimed;
 213 |     |     }
 214 |     | }
 215 |     | 

/home/ec2-user/git/cover/contracts/libraries/pool/QuoteCall.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/structs/CoverPoolStructs.sol';
  5 |     | import '../../interfaces/cover/ICoverPool.sol';
  6 |     | import '../Ticks.sol';
  7 |     | 
  8 |     | library QuoteCall {
  9 |     |     uint8 private constant _ENTERED = 2;
 10 |     | 
 11 |     |     function perform(
 12 |     |         ICoverPool.QuoteParams memory params,
 13 |     |         CoverPoolStructs.SwapCache memory cache
 14 |     |     ) internal view returns (
 15 |     |         int256,
 16 |     |         int256,
 17 |     |         uint256
 18 |     |     ) {
 19 |     |         if (cache.state.unlocked == _ENTERED)
 20 |     |             require(false, 'ReentrancyGuardReadOnlyReentrantCall()');
 21 |     |         {
 22 |     |             CoverPoolStructs.PoolState memory pool = params.zeroForOne ? cache.pool1 : cache.pool0;
 23 |     |             cache = CoverPoolStructs.SwapCache({
 24 |     |                 state: cache.state,
 25 |     |                 syncFees: cache.syncFees,
 26 |     |                 constants: cache.constants,
 27 |     |                 pool0: cache.pool0,
 28 |     |                 pool1: cache.pool1,
 29 |     |                 price: pool.price,
 30 |     |                 liquidity: pool.liquidity,
 31 |     |                 amountLeft: params.amount,
 32 |     |                 auctionDepth: block.timestamp - cache.constants.genesisTime - cache.state.auctionStart,
 33 |     |                 auctionBoost: 0,
 34 |     |                 input: 0,
 35 |     |                 output: 0,
 36 |     |                 amountBoosted: 0,
 37 |     |                 amountInDelta: 0,
 38 |     |                 amount0Delta: 0,
 39 |     |                 amount1Delta: 0,
 40 |     |                 exactIn: params.exactIn
 41 |     |             });
 42 |     |         }
 43 |     |         // call quote
 44 |     |         cache = Ticks.quote(
 45 |     |             params.zeroForOne,
 46 |     |             params.priceLimit,
 47 |     |             cache.state,
 48 |     |             cache,
 49 |     |             cache.constants
 50 |     |         );
 51 |     | 
 52 |     |         // calculate deltas
 53 |     |         cache = calculateDeltas(params, cache);
 54 |     |         
 55 |     |         return (
 56 |     |             params.zeroForOne ? -cache.amount0Delta : -cache.amount1Delta,
 57 |     |             params.zeroForOne ? cache.amount1Delta : cache.amount0Delta,
 58 |     |             cache.price
 59 |     |         );
 60 |     |     }
 61 |     | 
 62 |     |     function calculateDeltas(
 63 |     |         ICoverPool.QuoteParams memory params,
 64 |     |         CoverPoolStructs.SwapCache memory cache
 65 |     |     ) internal pure returns (
 66 |     |         CoverPoolStructs.SwapCache memory
 67 |     |     ) {
 68 |     |         // calculate amount deltas
 69 |     |         cache.amount0Delta = params.zeroForOne ? -int256(cache.input) 
 70 |     |                                                : int256(cache.output);
 71 |     |         cache.amount1Delta = params.zeroForOne ? int256(cache.output) 
 72 |     |                                                : -int256(cache.input);
 73 |     |         
 74 |     |         // factor in sync fees
 75 |     |         cache.amount0Delta += int128(cache.syncFees.token0);
 76 |     |         cache.amount1Delta += int128(cache.syncFees.token1);
 77 |     | 
 78 |     |         return cache;
 79 |     |     }
 80 |     | }
 81 |     | 

/home/ec2-user/git/cover/contracts/libraries/pool/SwapCall.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/structs/CoverPoolStructs.sol';
   5 |     | import '../../interfaces/IERC20Minimal.sol';
   6 |     | import '../../interfaces/callbacks/ICoverPoolSwapCallback.sol';
   7 |     | import '../Epochs.sol';
   8 |     | import '../Positions.sol';
   9 |     | import '../utils/Collect.sol';
  10 |     | import '../utils/SafeCast.sol';
  11 |     | 
  12 |     | library SwapCall {
  13 |     |     using SafeCast for int256;
  14 |     | 
  15 |     |     event SwapPool0(
  16 |     |         address indexed recipient,
  17 |     |         uint128 amountIn,
  18 |     |         uint128 amountOut,
  19 |     |         uint160 priceLimit,
  20 |     |         uint160 newPrice
  21 |     |     );
  22 |     | 
  23 |     |     event SwapPool1(
  24 |     |         address indexed recipient,
  25 |     |         uint128 amountIn,
  26 |     |         uint128 amountOut,
  27 |     |         uint160 priceLimit,
  28 |     |         uint160 newPrice
  29 |     |     );
  30 |     | 
  31 |     |     function perform(
  32 |     |         ICoverPool.SwapParams memory params,
  33 |     |         CoverPoolStructs.SwapCache memory cache,
  34 |     |         CoverPoolStructs.GlobalState storage globalState,
  35 |     |         CoverPoolStructs.PoolState storage pool0,
  36 |     |         CoverPoolStructs.PoolState storage pool1
  37 |     |     ) internal returns (
  38 |     |         int256,
  39 |     |         int256
  40 |     |     ) {
  41 |     |         {
  42 |     |             CoverPoolStructs.PoolState memory pool = params.zeroForOne ? cache.pool1 : cache.pool0;
  43 |     |             cache = CoverPoolStructs.SwapCache({
  44 |     |                 state: cache.state,
  45 |     |                 syncFees: cache.syncFees,
  46 |     |                 constants: cache.constants,
  47 |     |                 pool0: cache.pool0,
  48 |     |                 pool1: cache.pool1,
  49 |     |                 price: pool.price,
  50 |     |                 liquidity: pool.liquidity,
  51 |     |                 amountLeft: params.amount,
  52 |     |                 auctionDepth: block.timestamp - cache.constants.genesisTime - cache.state.auctionStart,
  53 |     |                 auctionBoost: 0,
  54 |     |                 input: 0,
  55 |     |                 output: 0,
  56 |     |                 amountBoosted: 0,
  57 |     |                 amountInDelta: 0,
  58 |     |                 amount0Delta: 0,
  59 |     |                 amount1Delta: 0,
  60 |     |                 exactIn: params.exactIn
  61 |     |             });
  62 |     |         }
  63 |     | 
  64 |     |         // call quote
  65 |     |         cache = Ticks.quote(params.zeroForOne, params.priceLimit, cache.state, cache, cache.constants);
  66 |     | 
  67 |     |         // save state to storage before callback
  68 |     |         save(params, cache, globalState, pool0, pool1);
  69 |     | 
  70 |     |         // calculate amount deltas
  71 |     |         cache = calculateDeltas(params, cache);
  72 |     | 
  73 |     |         EchidnaAssertions.assertPoolBalanceExceeded(
  74 |     |             (params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0)),
  75 |     |             cache.output
  76 |     |         );
  77 |     |         // transfer swap output
  78 |     |         SafeTransfers.transferOut(
  79 |     |             params.to,
  80 |     |             params.zeroForOne ? cache.constants.token1
  81 |     |                               : cache.constants.token0,
  82 |     |             params.zeroForOne ? cache.amount1Delta.toUint256()
  83 |     |                               : cache.amount0Delta.toUint256()
  84 |     |         );
  85 |     | 
  86 |     |         // check balance and execute callback
  87 |     |         uint256 balanceStart = balance(params, cache);
  88 |     |         ICoverPoolSwapCallback(msg.sender).coverPoolSwapCallback(
  89 |     |             cache.amount0Delta,
  90 |     |             cache.amount1Delta,
  91 |     |             params.callbackData
  92 |     |         );
  93 |     | 
  94 |     |         // check balance requirements after callback
  95 |     |         if (balance(params, cache) < balanceStart + cache.input)
  96 |     |             require(false, 'SwapInputAmountTooLow()');
  97 |     |     
  98 |     |         if (params.zeroForOne) {
  99 |     |             // transfer out if sync fees > swap input
 100 |     |             if (cache.amount0Delta > 0) {
 101 |     |                 SafeTransfers.transferOut(params.to, cache.constants.token0, cache.amount0Delta.toUint256());
 102 |     |             }
 103 |     |             emit SwapPool1(params.to, uint128(cache.input), uint128(cache.output), uint160(cache.price), params.priceLimit);
 104 |     |         } else {
 105 |     |             if (cache.amount1Delta > 0) {
 106 |     |                 SafeTransfers.transferOut(params.to, cache.constants.token1, cache.amount1Delta.toUint256());
 107 |     |             }
 108 |     |             emit SwapPool0(params.to, uint128(cache.input), uint128(cache.output), uint160(cache.price), params.priceLimit);
 109 |     |         }
 110 |     | 
 111 |     |         return (
 112 |     |             cache.amount0Delta,
 113 |     |             cache.amount1Delta
 114 |     |         );
 115 |     |     }
 116 |     | 
 117 |     |     function balance(
 118 |     |         address token
 119 |     |     ) private view returns (uint256) {
 120 |     |         (
 121 |     |             bool success,
 122 |     |             bytes memory data
 123 |     |         ) = token.staticcall(
 124 |     |                                     abi.encodeWithSelector(
 125 |     |                                         IERC20Minimal.balanceOf.selector,
 126 |     |                                         address(this)
 127 |     |                                     )
 128 |     |                                 );
 129 |     |         require(success && data.length >= 32);
 130 |     |         return abi.decode(data, (uint256));
 131 |     |     }
 132 |     | 
 133 |     |     function save(
 134 |     |         ICoverPool.SwapParams memory params,
 135 |     |         CoverPoolStructs.SwapCache memory cache,
 136 |     |         CoverPoolStructs.GlobalState storage globalState,
 137 |     |         CoverPoolStructs.PoolState storage pool0,
 138 |     |         CoverPoolStructs.PoolState storage pool1
 139 |     |     ) internal {
 140 |     |         // save pool changes to cache
 141 |     |         if (params.zeroForOne) {
 142 |     |             cache.pool1.price = uint160(cache.price);
 143 |     |             cache.pool1.amountInDelta += uint128(cache.amountInDelta);
 144 |     |         } else {
 145 |     |             cache.pool0.price = uint160(cache.price);
 146 |     |             cache.pool0.amountInDelta += uint128(cache.amountInDelta);
 147 |     |         }
 148 |     | 
 149 |     |         // save global state changes to storage
 150 |     |         globalState.latestPrice = cache.state.latestPrice;
 151 |     |         globalState.liquidityGlobal = cache.state.liquidityGlobal;
 152 |     |         globalState.lastTime = cache.state.lastTime;
 153 |     |         globalState.auctionStart = cache.state.auctionStart;
 154 |     |         globalState.accumEpoch = cache.state.accumEpoch;
 155 |     |         globalState.latestTick = cache.state.latestTick;
 156 |     | 
 157 |     |         // save pool0 changes to storage
 158 |     |         pool0.price = cache.pool0.price;
 159 |     |         pool0.liquidity = cache.pool0.liquidity;
 160 |     |         pool0.amountInDelta = cache.pool0.amountInDelta;
 161 |     |         pool0.amountInDeltaMaxClaimed = cache.pool0.amountInDeltaMaxClaimed;
 162 |     |         pool0.amountOutDeltaMaxClaimed = cache.pool0.amountOutDeltaMaxClaimed;
 163 |     | 
 164 |     |         // save pool1 changes to storage
 165 |     |         pool1.price = cache.pool1.price;
 166 |     |         pool1.liquidity = cache.pool1.liquidity;
 167 |     |         pool1.amountInDelta = cache.pool1.amountInDelta;
 168 |     |         pool1.amountInDeltaMaxClaimed = cache.pool1.amountInDeltaMaxClaimed;
 169 |     |         pool1.amountOutDeltaMaxClaimed = cache.pool1.amountOutDeltaMaxClaimed;
 170 |     |     }
 171 |     | 
 172 |     |     function balance(
 173 |     |         ICoverPool.SwapParams memory params,
 174 |     |         CoverPoolStructs.SwapCache memory cache
 175 |     |     ) private view returns (uint256) {
 176 |     |         (
 177 |     |             bool success,
 178 |     |             bytes memory data
 179 |     |         ) = (params.zeroForOne ? cache.constants.token0
 180 |     |                                : cache.constants.token1)
 181 |     |                                .staticcall(
 182 |     |                                     abi.encodeWithSelector(
 183 |     |                                         IERC20Minimal.balanceOf.selector,
 184 |     |                                         address(this)
 185 |     |                                     )
 186 |     |                                 );
 187 |     |         if(!success || data.length < 32) require(false, 'InvalidERC20ReturnData()');
 188 |     |         return abi.decode(data, (uint256));
 189 |     |     }
 190 |     | 
 191 |     |     function calculateDeltas(
 192 |     |         ICoverPool.SwapParams memory params,
 193 |     |         CoverPoolStructs.SwapCache memory cache
 194 |     |     ) internal pure returns (
 195 |     |         CoverPoolStructs.SwapCache memory
 196 |     |     ) {
 197 |     |         // calculate amount deltas
 198 |     |         cache.amount0Delta = params.zeroForOne ? -int256(cache.input) 
 199 |     |                                                : int256(cache.output);
 200 |     |         cache.amount1Delta = params.zeroForOne ? int256(cache.output) 
 201 |     |                                                : -int256(cache.input);
 202 |     |         
 203 |     |         // factor in sync fees
 204 |     |         cache.amount0Delta += int128(cache.syncFees.token0);
 205 |     |         cache.amount1Delta += int128(cache.syncFees.token1);
 206 |     | 
 207 |     |         return cache;
 208 |     |     }
 209 |     | }
 210 |     | 

/home/ec2-user/git/cover/contracts/libraries/sources/UniswapV3Source.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/external/uniswap/v3/IUniswapV3Factory.sol';
   5 |     | import '../../interfaces/external/uniswap/v3/IUniswapV3Pool.sol';
   6 |     | import '../../interfaces/structs/CoverPoolStructs.sol';
   7 |     | import '../../interfaces/modules/sources/ITwapSource.sol';
   8 |     | import '../math/ConstantProduct.sol';
   9 |     | 
  10 | *   | contract UniswapV3Source is ITwapSource {
  11 |     |     error WaitUntilBelowMaxTick();
  12 |     |     error WaitUntilAboveMinTick();
  13 |     | 
  14 |     |     address public immutable uniV3Factory;
  15 | *   |     uint32 public constant oneSecond = 1000;
  16 |     | 
  17 |     |     constructor(
  18 |     |         address _uniV3Factory
  19 |     |     ) {
  20 |     |         uniV3Factory = _uniV3Factory;
  21 |     |     }
  22 |     | 
  23 | *   |     function initialize(
  24 |     |         PoolsharkStructs.CoverImmutables memory constants
  25 |     |     ) external returns (
  26 | *   |         uint8 initializable,
  27 | *   |         int24 startingTick
  28 |     |     )
  29 | *   |     {
  30 |     |         // get the number of blocks covered by the twapLength
  31 | *   |         uint32 blockCount = uint32(constants.twapLength) * oneSecond / constants.blockTime;
  32 | *   |         (
  33 | *   |             bool observationsCountEnough,
  34 | *   |             bool observationsLengthEnough
  35 | *   |         ) = _isPoolObservationsEnough(
  36 | *   |                 constants.inputPool,
  37 | *   |                 blockCount
  38 |     |         );
  39 | *   |         if (!observationsLengthEnough) {
  40 |     |             _increaseV3Observations(constants.inputPool, blockCount);
  41 |     |             return (0, 0);
  42 | *   |         } else if (!observationsCountEnough) {
  43 |     |             return (0, 0);
  44 |     |         }
  45 |     |         // ready to initialize if we get here
  46 | *   |         initializable = 1;
  47 | *   |         int24[4] memory averageTicks = _calculateAverageTicks(constants);
  48 |     |         // take the average of the 4 samples as a starting tick
  49 | *   |         startingTick = (averageTicks[0] + averageTicks[1] + averageTicks[2] + averageTicks[3]) / 4;
  50 |     |     }
  51 |     | 
  52 |     |     function factory() external view returns (address) {
  53 |     |         return uniV3Factory;
  54 |     |     }
  55 |     | 
  56 |     |     function feeTierTickSpacing(
  57 |     |         uint16 feeTier
  58 |     |     ) external view returns (
  59 |     |         int24
  60 |     |     )
  61 |     |     {
  62 |     |         return IUniswapV3Factory(uniV3Factory).feeTierTickSpacing(feeTier);
  63 |     |     }
  64 |     | 
  65 |     |     function getPool(
  66 |     |         address token0,
  67 |     |         address token1,
  68 |     |         uint16 feeTier
  69 |     |     ) external view returns(
  70 |     |         address pool
  71 |     |     ) {
  72 |     |         return IUniswapV3Factory(uniV3Factory).getPool(token0, token1, feeTier);
  73 |     |     }
  74 |     | 
  75 | *   |     function calculateAverageTick(
  76 |     |         PoolsharkStructs.CoverImmutables memory constants,
  77 |     |         int24 latestTick
  78 |     |     ) external view returns (
  79 | *   |         int24 averageTick
  80 |     |     )
  81 | *   |     {
  82 | *   |         int24[4] memory averageTicks = _calculateAverageTicks(constants);
  83 | *   |         int24 minTickVariance = ConstantProduct.maxTick(constants.tickSpread) * 2;
  84 | *   |         for (uint i; i < 4; i++) {
  85 | *   |             int24 absTickVariance = latestTick - averageTicks[i] >= 0 ? latestTick - averageTicks[i]
  86 | *   |                                                                       : averageTicks[i] - latestTick;
  87 | *   |             if (absTickVariance <= minTickVariance) {
  88 |     |                 /// @dev - averageTick has the least possible variance from latestTick
  89 | *   |                 minTickVariance = absTickVariance;
  90 | *   |                 averageTick = averageTicks[i];
  91 |     |             }
  92 |     |         }
  93 |     |     }
  94 |     | 
  95 | *   |     function _calculateAverageTicks(
  96 |     |         PoolsharkStructs.CoverImmutables memory constants
  97 |     |     ) internal view returns (
  98 | *   |         int24[4] memory averageTicks
  99 |     |     )
 100 | *   |     {
 101 | *   |         uint32[] memory secondsAgos = new uint32[](4);
 102 |     |         /// @dev - take 4 samples
 103 |     |         /// @dev - twapLength must be >= 5 * blockTime
 104 | *   |         uint32 timeDelta = (constants.blockTime / oneSecond == 0) ? 2 
 105 | *   |                                                                 : constants.blockTime * 2 / oneSecond;
 106 | *   |         secondsAgos[0] = 0;
 107 | *   |         secondsAgos[1] = timeDelta;
 108 | *   |         secondsAgos[2] = constants.twapLength - timeDelta;
 109 | *   |         secondsAgos[3] = constants.twapLength;
 110 | *   |         (int56[] memory tickCumulatives, ) = IUniswapV3Pool(constants.inputPool).observe(secondsAgos);
 111 |     |         
 112 |     |         // take the smallest absolute value of 4 samples
 113 | *   |         averageTicks[0] = int24(((tickCumulatives[0] - tickCumulatives[2]) / (int32(secondsAgos[2] - secondsAgos[0]))));
 114 | *   |         averageTicks[1] = int24(((tickCumulatives[0] - tickCumulatives[3]) / (int32(secondsAgos[3] - secondsAgos[0]))));
 115 | *   |         averageTicks[2] = int24(((tickCumulatives[1] - tickCumulatives[2]) / (int32(secondsAgos[2] - secondsAgos[1]))));
 116 | *   |         averageTicks[3] = int24(((tickCumulatives[1] - tickCumulatives[3]) / (int32(secondsAgos[3] - secondsAgos[1]))));
 117 |     | 
 118 |     |         // make sure all samples fit within min/max bounds
 119 | *   |         int24 minAverageTick = ConstantProduct.minTick(constants.tickSpread) + constants.tickSpread;
 120 | *   |         int24 maxAverageTick = ConstantProduct.maxTick(constants.tickSpread) - constants.tickSpread;
 121 | *   |         for (uint i; i < 4; i++) {
 122 | *   |             if (averageTicks[i] < minAverageTick)
 123 |     |                 averageTicks[i] = minAverageTick;
 124 | *   |             if (averageTicks[i] > maxAverageTick)
 125 |     |                 averageTicks[i] = maxAverageTick;
 126 |     |         }
 127 |     |     }
 128 |     | 
 129 | *   |     function _isPoolObservationsEnough(
 130 |     |         address pool,
 131 |     |         uint32 blockCount
 132 |     |     ) internal view returns (
 133 | *   |         bool,
 134 | *   |         bool
 135 |     |     )
 136 |     |     {
 137 |     | 
 138 | *   |         (, , , uint16 observationsCount, uint16 observationsLength, , ) = IUniswapV3Pool(pool).slot0();
 139 | *   |         return (observationsCount >= blockCount, observationsLength >= blockCount);
 140 |     |     }
 141 |     | 
 142 |     |     function _increaseV3Observations(address pool, uint32 blockCount) internal {
 143 |     |         IUniswapV3Pool(pool).increaseObservationCardinalityNext(uint16(blockCount));
 144 |     |     }
 145 |     | }
 146 |     | 

/home/ec2-user/git/cover/contracts/libraries/utils/Collect.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/structs/CoverPoolStructs.sol';
   5 |     | import '../../interfaces/IERC20Minimal.sol';
   6 |     | import '../Epochs.sol';
   7 |     | import '../Positions.sol';
   8 |     | import '../utils/SafeTransfers.sol';
   9 |     | 
  10 |     | library Collect {
  11 |     |     function mint(
  12 |     |         CoverPoolStructs.MintCache memory cache,
  13 |     |         CoverPoolStructs.CollectParams memory params
  14 |     |     ) internal {
  15 |     |         if (params.syncFees.token0 == 0 && params.syncFees.token1 == 0) return;
  16 |     |         // store amounts for transferOut
  17 |     |         uint128 amountIn;
  18 |     |         uint128 amountOut;
  19 |     | 
  20 |     |         // factor in sync fees
  21 |     |         if (params.zeroForOne) {
  22 |     |             amountIn  += params.syncFees.token1;
  23 |     |             amountOut += params.syncFees.token0;
  24 |     |         } else {
  25 |     |             amountIn  += params.syncFees.token0;
  26 |     |             amountOut += params.syncFees.token1;
  27 |     |         }
  28 |     | 
  29 |     |         /// zero out balances and transfer out
  30 |     |         if (amountIn > 0) {
  31 |     |             EchidnaAssertions.assertPoolBalanceExceeded(
  32 |     |                 (params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0)),
  33 |     |                 amountIn
  34 |     |             );
  35 |     |             SafeTransfers.transferOut(params.to, params.zeroForOne ? cache.constants.token1 : cache.constants.token0, amountIn);
  36 |     |         } 
  37 |     |         if (amountOut > 0) {
  38 |     |             EchidnaAssertions.assertPoolBalanceExceeded(
  39 |     |                 (params.zeroForOne ? balance(cache.constants.token0) : balance(cache.constants.token1)),
  40 |     |                 amountOut
  41 |     |             );
  42 |     |             SafeTransfers.transferOut(params.to, params.zeroForOne ? cache.constants.token0 : cache.constants.token1, amountOut);
  43 |     |         }
  44 |     |     }
  45 |     | 
  46 |     |     function balance(
  47 |     |         address token
  48 |     |     ) private view returns (uint256) {
  49 |     |         (
  50 |     |             bool success,
  51 |     |             bytes memory data
  52 |     |         ) = token.staticcall(
  53 |     |                                     abi.encodeWithSelector(
  54 |     |                                         IERC20Minimal.balanceOf.selector,
  55 |     |                                         address(this)
  56 |     |                                     )
  57 |     |                                 );
  58 |     |         require(success && data.length >= 32);
  59 |     |         return abi.decode(data, (uint256));
  60 |     |     }
  61 |     | 
  62 |     |     function burn(
  63 |     |         CoverPoolStructs.BurnCache memory cache,
  64 |     |         mapping(uint256 => CoverPoolStructs.CoverPosition)
  65 |     |             storage positions,
  66 |     |         CoverPoolStructs.CollectParams memory params
  67 |     |     ) internal {
  68 |     |         params.zeroForOne ? params.upper = params.claim : params.lower = params.claim;
  69 |     | 
  70 |     |         // store amounts for transferOut
  71 |     |         uint128 amountIn  = positions[params.positionId].amountIn;
  72 |     |         uint128 amountOut = positions[params.positionId].amountOut;
  73 |     | 
  74 |     |         // factor in sync fees
  75 |     |         if (params.zeroForOne) {
  76 |     |             amountIn  += params.syncFees.token1;
  77 |     |             amountOut += params.syncFees.token0;
  78 |     |         } else {
  79 |     |             amountIn  += params.syncFees.token0;
  80 |     |             amountOut += params.syncFees.token1;
  81 |     |         }
  82 |     | 
  83 |     |         /// zero out balances and transfer out
  84 |     |         if (amountIn > 0) {
  85 |     |             EchidnaAssertions.assertPoolBalanceExceeded(
  86 |     |                 (params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0)),
  87 |     |                 amountIn
  88 |     |             );
  89 |     |             positions[params.positionId].amountIn = 0;
  90 |     |             SafeTransfers.transferOut(params.to, params.zeroForOne ? cache.constants.token1 : cache.constants.token0, amountIn);
  91 |     |         } 
  92 |     |         if (amountOut > 0) {
  93 |     |             EchidnaAssertions.assertPoolBalanceExceeded(
  94 |     |                 (params.zeroForOne ? balance(cache.constants.token0) : balance(cache.constants.token1)),
  95 |     |                 amountOut
  96 |     |             );
  97 |     |             positions[params.positionId].amountOut = 0;
  98 |     |             SafeTransfers.transferOut(params.to, params.zeroForOne ? cache.constants.token0 : cache.constants.token1, amountOut);
  99 |     |         }
 100 |     |     }
 101 |     | }
 102 |     | 

/home/ec2-user/git/cover/contracts/libraries/utils/PositionTokens.sol
  1 |     | // SPDX-License-Identifier: GPLv3
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import "../math/OverflowMath.sol";
  5 |     | import '../../interfaces/IPositionERC1155.sol';
  6 |     | import "../../interfaces/cover/ICoverPoolFactory.sol";
  7 |     | import "../../interfaces/structs/CoverPoolStructs.sol";
  8 |     | 
  9 |     | /// @notice Token library for ERC-1155 calls.
 10 |     | library PositionTokens {
 11 |     |     function balanceOf(
 12 |     |         PoolsharkStructs.CoverImmutables memory constants,
 13 |     |         address owner,
 14 |     |         uint32 positionId
 15 |     |     ) internal view returns (
 16 |     |         uint256
 17 |     |     )
 18 |     |     {
 19 |     |         return IPositionERC1155(constants.poolToken).balanceOf(owner, positionId);
 20 |     |     }
 21 |     | }

/home/ec2-user/git/cover/contracts/libraries/utils/SafeCast.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | /// @title Safe casting methods
  5 |     | /// @notice Contains methods for safely casting between types
  6 |     | library SafeCast {
  7 |     |     /// @notice Cast a uint256 to a uint128, revert on overflow
  8 |     |     /// @param y The uint256 to be downcasted
  9 |     |     /// @return z The downcasted integer, now type uint128
 10 |     |     function toUint128(uint256 y) internal pure returns (uint128 z) {
 11 |     |         if((z = uint128(y)) != y) require(false, 'Uint256ToUint128:Overflow()');
 12 |     |     }
 13 |     | 
 14 |     |     /// @notice Cast a uint256 to a uint128, revert on overflow
 15 |     |     /// @param y The uint256 to be downcasted
 16 |     |     /// @return z The downcasted integer, now type uint128
 17 |     |     function toUint128(int128 y) internal pure returns (uint128 z) {
 18 |     |         if(y < 0) require(false, 'Int128ToUint128:Underflow()');
 19 |     |         z = uint128(y);
 20 |     |     }
 21 |     | 
 22 |     |     /// @notice Cast a uint256 to a uint160, revert on overflow
 23 |     |     /// @param y The uint256 to be downcasted
 24 |     |     /// @return z The downcasted integer, now type uint160
 25 |     |     function toUint160(uint256 y) internal pure returns (uint160 z) {
 26 |     |         if((z = uint160(y)) != y) require(false, 'Uint256ToUint160:Overflow()');
 27 |     |     }
 28 |     | 
 29 |     |     /// @notice Cast a uint256 to a uint160, revert on overflow
 30 |     |     /// @param y The uint256 to be downcasted
 31 |     |     /// @return z The downcasted integer, now type uint160
 32 |     |     function toUint32(uint256 y) internal pure returns (uint32 z) {
 33 |     |         if((z = uint32(y)) != y) require(false, 'Uint256ToUint32:Overflow()');
 34 |     |     }
 35 |     | 
 36 |     |     /// @notice Cast a int256 to a int128, revert on overflow or underflow
 37 |     |     /// @param y The int256 to be downcasted
 38 |     |     /// @return z The downcasted integer, now type int128
 39 |     |     function toInt128(int256 y) internal pure returns (int128 z) {
 40 |     |         if ((z = int128(y)) != y) require(false, 'Int256ToInt128:Overflow()');
 41 |     |     }
 42 |     | 
 43 |     |     /// @notice Cast a int256 to a int128, revert on overflow or underflow
 44 |     |     /// @param y The int256 to be downcasted
 45 |     |     /// @return z The downcasted integer, now type int128
 46 |     |     function toInt128(uint128 y) internal pure returns (int128 z) {
 47 |     |         if(y > uint128(type(int128).max)) require(false, 'Uint128ToInt128:Overflow()');
 48 |     |         z = int128(y);
 49 |     |     }
 50 |     | 
 51 |     |     /// @notice Cast a uint256 to a int256, revert on overflow
 52 |     |     /// @param y The uint256 to be casted
 53 |     |     /// @return z The casted integer, now type int256
 54 |     |     function toInt256(uint256 y) internal pure returns (int256 z) {
 55 |     |         if(y > uint256(type(int256).max)) require(false, 'Uint256ToInt256:Overflow()');
 56 |     |         z = int256(y);
 57 |     |     }
 58 |     | 
 59 |     |     /// @notice Cast a uint256 to a uint128, revert on overflow
 60 |     |     /// @param y The uint256 to be downcasted
 61 |     |     /// @return z The downcasted integer, now type uint128
 62 |     |     function toUint256(int256 y) internal pure returns (uint256 z) {
 63 |     |         if(y < 0) require(false, 'Int256ToUint256:Underflow()');
 64 |     |         z = uint256(y);
 65 |     |     }
 66 |     | }

/home/ec2-user/git/cover/contracts/libraries/utils/SafeTransfers.sol
   1 |     | //SPDX-License-Identifier: Unlicense
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../external/openzeppelin/contracts/token/ERC20/ERC20.sol';
   5 |     | 
   6 |     | library SafeTransfers {
   7 |     |     /**
   8 |     |      * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
   9 |     |      *      This will revert due to insufficient balance or insufficient allowance.
  10 |     |      *      This function returns the actual amount received,
  11 |     |      *      which may be less than `amount` if there is a fee attached to the transfer.
  12 |     |      *
  13 |     |      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
  14 |     |      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
  15 |     |      */
  16 |     |     // slither-disable-next-line assembly
  17 |     |     function transferIn(address token, uint256 amount) internal returns (uint256) {
  18 |     |         if (token == address(0)) {
  19 |     |             if (msg.value < amount) require(false, 'TransferFailed(msg.sender, address(this)');
  20 |     |             return amount;
  21 |     |         }
  22 |     |         if (amount == 0) return 0;
  23 |     |         IERC20 erc20Token = IERC20(token);
  24 |     |         uint256 balanceBefore = IERC20(token).balanceOf(address(this));
  25 |     | 
  26 |     |         // ? We are checking the transfer, but since we are doing so in an assembly block
  27 |     |         // ? Slither does not pick up on that and results in a hit
  28 |     |         // slither-disable-next-line unchecked-transfer
  29 |     |         erc20Token.transferFrom(msg.sender, address(this), amount);
  30 |     | 
  31 |     |         bool success;
  32 |     |         assembly {
  33 |     |             switch returndatasize()
  34 |     |             case 0 {
  35 |     |                 // This is a non-standard ERC-20
  36 |     |                 success := 1 // set success to true
  37 |     |             }
  38 |     |             case 32 {
  39 |     |                 // This is a compliant ERC-20
  40 |     |                 returndatacopy(0, 0, 32)
  41 |     |                 success := mload(0) // Set `success = returndata` of external call
  42 |     |             }
  43 |     |             default {
  44 |     |                 // This is an excessively non-compliant ERC-20, revert.
  45 |     |                 success := 0
  46 |     |             }
  47 |     |         }
  48 |     |         if (!success) require(false, 'TransferFailed(msg.sender, address(this)');
  49 |     | 
  50 |     |         // Calculate the amount that was *actually* transferred
  51 |     |         uint256 balanceAfter = IERC20(token).balanceOf(address(this));
  52 |     | 
  53 |     |         return balanceAfter - balanceBefore; // underflow already checked above, just subtract
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
  58 |     |      *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
  59 |     |      *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
  60 |     |      *      it is >= amount, this should not revert in normal conditions.
  61 |     |      *
  62 |     |      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
  63 |     |      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
  64 |     |      */
  65 |     |     // slither-disable-next-line assembly
  66 |     |     function transferOut(
  67 |     |         address to,
  68 |     |         address token,
  69 |     |         uint256 amount
  70 |     |     ) internal {
  71 |     |         if (token == address(0)) {
  72 |     |             if (address(this).balance < amount) require(false, 'TransferFailed(address(this), to');
  73 |     |             payable(to).transfer(amount);
  74 |     |             return;
  75 |     |         }
  76 |     |         if (amount == 0) return;
  77 |     |         IERC20 erc20Token = IERC20(token);
  78 |     |         // ? We are checking the transfer, but since we are doing so in an assembly block
  79 |     |         // ? Slither does not pick up on that and results in a hit
  80 |     |         // slither-disable-next-line unchecked-transfer
  81 |     |         erc20Token.transfer(to, amount);
  82 |     | 
  83 |     |         bool success;
  84 |     |         assembly {
  85 |     |             switch returndatasize()
  86 |     |             case 0 {
  87 |     |                 // This is a non-standard ERC-20
  88 |     |                 success := 1 // set success to true
  89 |     |             }
  90 |     |             case 32 {
  91 |     |                 // This is a complaint ERC-20
  92 |     |                 returndatacopy(0, 0, 32)
  93 |     |                 success := mload(0) // Set `success = returndata` of external call
  94 |     |             }
  95 |     |             default {
  96 |     |                 // This is an excessively non-compliant ERC-20, revert.
  97 |     |                 success := 0
  98 |     |             }
  99 |     |         }
 100 |     |         if (!success) require(false, 'TransferFailed(address(this), msg.sender');
 101 |     |     }
 102 |     | 
 103 |     |     /**
 104 |     |      * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
 105 |     |      *      This will revert due to insufficient balance or insufficient allowance.
 106 |     |      *      This function returns the actual amount received,
 107 |     |      *      which may be less than `amount` if there is a fee attached to the transfer.
 108 |     |      *
 109 |     |      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
 110 |     |      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
 111 |     |      */
 112 |     |     // slither-disable-next-line assembly
 113 | *   |     function transferInto(address token, address sender, uint256 amount) internal returns (uint256) {
 114 | *   |         if (token == address(0)) {
 115 |     |             if (msg.value < amount) require(false, 'TransferFailed(msg.sender, address(this)');
 116 |     |             return amount;
 117 |     |         }
 118 | *   |         IERC20 erc20Token = IERC20(token);
 119 | *   |         uint256 balanceBefore = IERC20(token).balanceOf(address(this));
 120 |     | 
 121 |     |         /// @dev - msg.sender here is the pool
 122 | *r  |         erc20Token.transferFrom(sender, msg.sender, amount);
 123 |     | 
 124 | *   |         bool success;
 125 |     |         assembly {
 126 | *   |             switch returndatasize()
 127 | *   |             case 0 {
 128 |     |                 // This is a non-standard ERC-20
 129 |     |                 success := 1 // set success to true
 130 |     |             }
 131 | *   |             case 32 {
 132 |     |                 // This is a compliant ERC-20
 133 | *   |                 returndatacopy(0, 0, 32)
 134 | *   |                 success := mload(0) // Set `success = returndata` of external call
 135 |     |             }
 136 |     |             default {
 137 |     |                 // This is an excessively non-compliant ERC-20, revert.
 138 |     |                 success := 0
 139 |     |             }
 140 |     |         }
 141 | *   |         if (!success) require(false, 'TransferFailed(msg.sender, address(this)');
 142 |     | 
 143 |     |         // Calculate the amount that was *actually* transferred
 144 | *   |         uint256 balanceAfter = IERC20(token).balanceOf(address(this));
 145 |     | 
 146 | *   |         return balanceAfter - balanceBefore; // underflow already checked above, just subtract
 147 |     |     }
 148 |     | }
 149 |     | 

/home/ec2-user/git/cover/contracts/libraries/utils/String.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | library String {
  5 |     |     bytes16 private constant alphabet = "0123456789abcdef";
  6 |     | 
  7 |     |     function from(bytes32 value) internal pure returns(string memory) {
  8 |     |         return toString(abi.encodePacked(value));
  9 |     |     }
 10 |     | 
 11 |     |     function from(address account) internal pure returns(string memory) {
 12 |     |         return toString(abi.encodePacked(account));
 13 |     |     }
 14 |     | 
 15 |     |     function from(uint256 value) internal pure returns(string memory) {
 16 |     |         unchecked {
 17 |     |             uint256 length = log10(value) + 1;
 18 |     |             string memory buffer = new string(length);
 19 |     |             uint256 ptr;
 20 |     |             /// @solidity memory-safe-assembly
 21 |     |             assembly {
 22 |     |                 ptr := add(buffer, add(32, length))
 23 |     |             }
 24 |     |             while (true) {
 25 |     |                 ptr--;
 26 |     |                 /// @solidity memory-safe-assembly
 27 |     |                 assembly {
 28 |     |                     mstore8(ptr, byte(mod(value, 10), alphabet))
 29 |     |                 }
 30 |     |                 value /= 10;
 31 |     |                 if (value == 0) break;
 32 |     |             }
 33 |     |             return buffer;
 34 |     |         }
 35 |     |     }
 36 |     | 
 37 |     |     function from(int256 value) internal pure returns (string memory) {
 38 |     |         return string(abi.encodePacked(value < 0 ? "-" : "", from(abs(value))));
 39 |     |     }
 40 |     | 
 41 |     |     function abs(int256 n) internal pure returns (uint256) {
 42 |     |         unchecked {
 43 |     |             // must be unchecked in order to support `n = type(int256).min`
 44 |     |             return uint256(n >= 0 ? n : -n);
 45 |     |         }
 46 |     |     }
 47 |     | 
 48 |     |     function log10(uint256 value) internal pure returns (uint256) {
 49 |     |         uint256 result = 0;
 50 |     |         unchecked {
 51 |     |             if (value >= 10 ** 64) {
 52 |     |                 value /= 10 ** 64;
 53 |     |                 result += 64;
 54 |     |             }
 55 |     |             if (value >= 10 ** 32) {
 56 |     |                 value /= 10 ** 32;
 57 |     |                 result += 32;
 58 |     |             }
 59 |     |             if (value >= 10 ** 16) {
 60 |     |                 value /= 10 ** 16;
 61 |     |                 result += 16;
 62 |     |             }
 63 |     |             if (value >= 10 ** 8) {
 64 |     |                 value /= 10 ** 8;
 65 |     |                 result += 8;
 66 |     |             }
 67 |     |             if (value >= 10 ** 4) {
 68 |     |                 value /= 10 ** 4;
 69 |     |                 result += 4;
 70 |     |             }
 71 |     |             if (value >= 10 ** 2) {
 72 |     |                 value /= 10 ** 2;
 73 |     |                 result += 2;
 74 |     |             }
 75 |     |             if (value >= 10 ** 1) {
 76 |     |                 result += 1;
 77 |     |             }
 78 |     |         }
 79 |     |         return result;
 80 |     |     }
 81 |     | 
 82 |     |     function toString(bytes memory data) internal pure returns(string memory) {
 83 |     |         bytes memory str = new bytes(2 + data.length * 2);
 84 |     |         str[0] = "0";
 85 |     |         str[1] = "x";
 86 |     |         for (uint i = 0; i < data.length; i++) {
 87 |     |             str[2+i*2] = alphabet[uint(uint8(data[i] >> 4))];
 88 |     |             str[3+i*2] = alphabet[uint(uint8(data[i] & 0x0f))];
 89 |     |         }
 90 |     |         return string(str);
 91 |     |     }
 92 |     | }

/home/ec2-user/git/cover/contracts/test/Token20.sol
  1 |     | //SPDX-License-Identifier: Unlicense
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../external/openzeppelin/contracts/token/ERC20/ERC20.sol';
  5 |     | import '../external/openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol';
  6 |     | 
  7 | *   | contract Token20 is ERC20, ERC20Burnable {
  8 |     |     uint8 _decimals;
  9 |     | 
 10 |     |     constructor(
 11 |     |         string memory tokenName,
 12 |     |         string memory tokenSymbol,
 13 |     |         uint8 decimals_
 14 |     |     ) ERC20(tokenName, tokenSymbol) {
 15 |     |         _decimals = decimals_;
 16 |     |     }
 17 |     | 
 18 | *   |     function mint(address to, uint256 amount) external {
 19 | *   |         _mint(to, amount);
 20 |     |     }
 21 |     | 
 22 |     |     function decimals() public view override returns (uint8) {
 23 |     |         return _decimals;
 24 |     |     }
 25 |     | 
 26 |     |     function setDecimals(uint8 decimals_) public {
 27 |     |         _decimals = decimals_;
 28 |     |     }
 29 |     | }
 30 |     | 

/home/ec2-user/git/cover/contracts/test/UniswapV3FactoryMock.sol
  1 |     | //SPDX-License-Identifier: Unlicense
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../interfaces/external/uniswap/v3/IUniswapV3Factory.sol';
  5 |     | import './UniswapV3PoolMock.sol';
  6 |     | 
  7 |     | contract UniswapV3FactoryMock is IUniswapV3Factory {
  8 |     |     address mockPool;
  9 |     |     address mockPool2;
 10 |     |     address owner;
 11 |     | 
 12 |     |     mapping(uint24 => int24) public feeTierTickSpacing;
 13 |     |     mapping(address => mapping(address => mapping(uint24 => address))) public override getPool;
 14 |     | 
 15 |     |     constructor(address tokenA, address tokenB) {
 16 |     |         owner = msg.sender;
 17 |     |         (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB)
 18 |     |                                                            : (tokenB, tokenA);
 19 |     | 
 20 |     |         feeTierTickSpacing[500] = 10;
 21 |     |         feeTierTickSpacing[3000] = 60;
 22 |     |         feeTierTickSpacing[10000] = 200;
 23 |     | 
 24 |     |         // create mock pool 1
 25 |     |         mockPool = address(new UniswapV3PoolMock(token0, token1, 500, 10));
 26 |     |         getPool[token0][token1][500] = mockPool;
 27 |     | 
 28 |     |         // create mock pool 2
 29 |     |         mockPool2 = address(new UniswapV3PoolMock(token0, token1, 3000, 60));
 30 |     |         getPool[token0][token1][3000] = mockPool2;
 31 |     |     }
 32 |     | }
 33 |     | 

/home/ec2-user/git/cover/contracts/test/UniswapV3PoolMock.sol
  1 |     | //SPDX-License-Identifier: Unlicense
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../interfaces/external/uniswap/v3/IUniswapV3Pool.sol';
  5 |     | import './UniswapV3PoolMock.sol';
  6 |     | 
  7 | *   | contract UniswapV3PoolMock is IUniswapV3Pool {
  8 |     |     address internal admin;
  9 |     |     address public token0;
 10 |     |     address public token1;
 11 |     |     int24 public tickSpacing;
 12 |     |     uint256 swapFee;
 13 |     | 
 14 |     |     uint16 observationCardinality;
 15 |     |     uint16 observationCardinalityNext;
 16 |     | 
 17 |     |     int56 tickCumulative0;
 18 |     |     int56 tickCumulative1;
 19 |     |     int56 tickCumulative2;
 20 |     |     int56 tickCumulative3;
 21 |     | 
 22 |     |     constructor(
 23 |     |         address _token0,
 24 |     |         address _token1,
 25 |     |         uint24 _swapFee,
 26 |     |         int24 _tickSpacing
 27 |     |     ) {
 28 |     |         require(_token0 < _token1, 'wrong token order');
 29 |     |         admin = msg.sender;
 30 |     |         token0 = _token0;
 31 |     |         token1 = _token1;
 32 |     |         swapFee = _swapFee;
 33 |     |         tickSpacing = _tickSpacing;
 34 |     |         observationCardinality = 4;
 35 |     |         observationCardinalityNext = 4;
 36 |     |         tickCumulative0 = 10;
 37 |     |         tickCumulative1 = 9;
 38 |     |         tickCumulative2 = 6;
 39 |     |         tickCumulative3 = 5;
 40 |     |     }
 41 |     | 
 42 | *   |     function slot0()
 43 |     |         external
 44 |     |         view
 45 |     |         returns (
 46 | *   |             uint160 sqrtPriceX96,
 47 | *   |             int24 tick,
 48 | *   |             uint16 observationIndex,
 49 | *   |             uint16 cardinality,
 50 | *   |             uint16 cardinalityNext,
 51 | *   |             uint8 feeProtocol,
 52 | *   |             bool unlocked
 53 |     |         )
 54 |     |     {
 55 | *   |         return (1 << 96, 0, 4, observationCardinality, observationCardinalityNext, 100, true);
 56 |     |     }
 57 |     | 
 58 | *   |     function observe(uint32[] calldata secondsAgos)
 59 |     |         external
 60 |     |         view
 61 |     |         returns (
 62 | *   |             int56[] memory tickCumulatives,
 63 | *   |             uint160[] memory secondsPerLiquidityCumulativeX128s
 64 |     |         )
 65 |     |     {
 66 |     |         secondsAgos;
 67 | *   |         tickCumulatives = new int56[](secondsAgos.length);
 68 | *   |         tickCumulatives[0] = int56(tickCumulative0);
 69 | *   |         tickCumulatives[1] = int56(tickCumulative1);
 70 | *   |         tickCumulatives[2] = int56(tickCumulative2);
 71 | *   |         tickCumulatives[3] = int56(tickCumulative3);
 72 | *   |         secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);
 73 | *   |         secondsPerLiquidityCumulativeX128s[0] = uint160(949568451203788412348119);
 74 | *   |         secondsPerLiquidityCumulativeX128s[1] = uint160(949568451203788412348119);
 75 | *   |         secondsPerLiquidityCumulativeX128s[2] = uint160(949568438263103965182699);
 76 | *   |         secondsPerLiquidityCumulativeX128s[3] = uint160(949568438263103965182699);
 77 |     |     }
 78 |     | 
 79 |     |     function increaseObservationCardinalityNext(uint16 cardinalityNext) external {
 80 |     |         observationCardinalityNext = cardinalityNext;
 81 |     |     }
 82 |     | 
 83 | *   |     function setTickCumulatives(int56 _tickCumulative0, int56 _tickCumulative1, int56 _tickCumulative2, int56 _tickCumulative3) external {
 84 | *   |         tickCumulative0 = _tickCumulative0;
 85 | *   |         tickCumulative1 = _tickCumulative1;
 86 | *   |         tickCumulative2 = _tickCumulative2;
 87 | *   |         tickCumulative3 = _tickCumulative3;
 88 |     |     }
 89 |     | 
 90 |     |     function setObservationCardinality(uint16 _observationCardinality, uint16 _observationCardinalityNext) external {
 91 |     |         observationCardinality = _observationCardinality;
 92 |     |         observationCardinalityNext = _observationCardinalityNext;
 93 |     |     }
 94 |     | }
 95 |     | 

/home/ec2-user/git/cover/contracts/test/echidna/EchidnaAssertions.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/structs/CoverPoolStructs.sol';
  5 |     | import '../../libraries/math/ConstantProduct.sol';
  6 |     | 
  7 |     | library EchidnaAssertions {
  8 |     | 
  9 |     |     event LiquidityGlobalUnderflow(uint128 liquidityGlobal, uint128 amount, string location);
 10 |     |     event LiquidityUnderflow(uint128 liquidity, uint128 amount, string location);
 11 |     |     event LiquidityOverflow(uint128 liquidity, uint128 amount, string location);
 12 |     |     event LiquidityUnlock(int128 liquidity);
 13 |     |     event PoolBalanceExceeded(uint256 poolBalance, uint256 outputAmount);
 14 |     |     event LiquidityDelta(int128 liquidityDelta);
 15 |     |     event TickDivisibleByTickSpacing(int24 tick, int16 tickSpacing);
 16 |     |     event TickWithinBounds(int24 tick, int24 minTick, int24 maxTick);
 17 |     |     event InfiniteLoop0(int24 accumTick, int24 crossTick);
 18 |     |     event InfiniteLoop1(int24 accumTick, int24 crossTick);
 19 |     | 
 20 |     |     function assertLiquidityGlobalUnderflows(uint128 liquidityGlobal, uint128 amount, string memory location) internal {
 21 |     |         emit LiquidityGlobalUnderflow(liquidityGlobal, amount, location);
 22 |     |         assert(liquidityGlobal >= amount);
 23 |     |     }
 24 |     | 
 25 |     |     function assertLiquidityUnderflows(uint128 liquidity, uint128 amount, string memory location) internal {
 26 |     |         emit LiquidityUnderflow(liquidity, amount, location);
 27 |     |         assert(liquidity >= amount);
 28 |     |     }
 29 |     | 
 30 |     |     function assertLiquidityOverflows(uint128 liquidity, uint128 amount, string memory location) internal {
 31 |     |         emit LiquidityUnderflow(liquidity, amount, location);
 32 |     |         assert(uint256(liquidity) + uint256(amount) <= uint128(type(int128).max));
 33 |     |     }
 34 |     | 
 35 |     |     function assertAmountInDeltaMaxMinusUnderflows(uint128 liquidityAbs, uint128 amount, string memory location) internal {
 36 |     |         emit LiquidityUnderflow(liquidityAbs, amount, location);
 37 |     |         assert(liquidityAbs >= amount);
 38 |     |     }
 39 |     | 
 40 |     |     function assertAmountOutDeltaMaxMinusUnderflows(uint128 liquidityAbs, uint128 amount, string memory location) internal {
 41 |     |         emit LiquidityUnderflow(liquidityAbs, amount, location);
 42 |     |         assert(liquidityAbs >= amount);
 43 |     |     }
 44 |     | 
 45 |     |     function assertPositiveLiquidityOnUnlock(int128 liquidity) internal {
 46 |     |         emit LiquidityUnlock(liquidity);
 47 |     |         assert(liquidity >= 0);
 48 |     |     }
 49 |     | 
 50 |     |     function assertPoolBalanceExceeded(uint256 poolBalance, uint256 outputAmount) internal {
 51 |     |         emit PoolBalanceExceeded(poolBalance, outputAmount);
 52 |     |         assert(poolBalance >= outputAmount);
 53 |     |     }
 54 |     | 
 55 |     |     function assertTickDivisibleByTickSpacing(int24 tick, int16 tickSpacing) internal {
 56 |     |         emit TickDivisibleByTickSpacing(tick, tickSpacing);
 57 |     |         assert(tick % tickSpacing == 0);
 58 |     |     }
 59 |     | 
 60 |     |     function assertTickWithinBounds(int24 tick, int24 minTick, int24 maxTick) internal {
 61 |     |         emit TickWithinBounds(tick, minTick, maxTick);
 62 |     |         assert(tick >= minTick);
 63 |     |         assert(tick <= maxTick);
 64 |     |     }
 65 |     | 
 66 |     |     function assertInfiniteLoop0(int24 accumTick, int24 crossTick, int24 minTick) internal {
 67 |     |         emit InfiniteLoop0(accumTick, crossTick);
 68 |     |         assert(accumTick < crossTick || (accumTick == crossTick && accumTick == minTick));
 69 |     |     }
 70 |     | 
 71 |     |     function assertInfiniteLoop1(int24 accumTick, int24 crossTick, int24 maxTick) internal {
 72 |     |         emit InfiniteLoop1(accumTick, crossTick);
 73 |     |         assert(accumTick > crossTick || (accumTick == crossTick && accumTick == maxTick));
 74 |     |     }
 75 |     | }

/home/ec2-user/git/cover/contracts/utils/CoverPoolErrors.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | abstract contract CoverPoolErrors {
  5 |     |     error Locked();
  6 |     |     error OwnerOnly();
  7 |     |     error InvalidToken();
  8 |     |     error InvalidPosition();
  9 |     |     error InvalidSwapFee();
 10 |     |     error InvalidTokenDecimals();
 11 |     |     error InvalidTickSpread();
 12 |     |     error LiquidityOverflow();
 13 |     |     error Token0Missing();
 14 |     |     error Token1Missing();
 15 |     |     error InvalidTick();
 16 |     |     error FactoryOnly();
 17 |     |     error LowerNotEvenTick();
 18 |     |     error UpperNotOddTick();
 19 |     |     error MaxTickLiquidity();
 20 |     |     error CollectToZeroAddress();
 21 |     |     error Overflow();
 22 |     |     error NotEnoughOutputLiquidity();
 23 |     |     error WaitUntilTwapLengthSufficient();
 24 |     | }
 25 |     | 
 26 |     | abstract contract PositionERC1155Errors {
 27 |     |     error SpenderNotApproved(address owner, address spender);
 28 |     |     error TransferFromOrToAddress0();
 29 |     |     error MintToAddress0();
 30 |     |     error BurnFromAddress0();
 31 |     |     error BurnExceedsBalance(address from, uint256 id, uint256 amount);
 32 |     |     error LengthMismatch(uint256 accountsLength, uint256 idsLength);
 33 |     |     error SelfApproval(address owner);
 34 |     |     error TransferExceedsBalance(address from, uint256 id, uint256 amount);
 35 |     |     error TransferToSelf();
 36 |     |     error ERC1155NotSupported();
 37 |     | }
 38 |     | 
 39 |     | abstract contract CoverPoolFactoryErrors {
 40 |     |     error OwnerOnly();
 41 |     |     error InvalidTokenAddress();
 42 |     |     error InvalidTokenDecimals();
 43 |     |     error PoolAlreadyExists();
 44 |     |     error FeeTierNotSupported();
 45 |     |     error VolatilityTierNotSupported();
 46 |     |     error InvalidTickSpread();
 47 |     |     error PoolTypeNotFound();
 48 |     |     error CurveMathNotFound();
 49 |     |     error TickSpreadNotMultipleOfTickSpacing();
 50 |     |     error TickSpreadNotAtLeastDoubleTickSpread();
 51 |     | }
 52 |     | 
 53 |     | abstract contract CoverTransferErrors {
 54 |     |     error TransferFailed(address from, address dest);
 55 |     | }
 56 |     | 

/home/ec2-user/git/cover/contracts/utils/CoverPoolManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.13;
   4 |     | 
   5 |     | import '../interfaces/cover/ICoverPool.sol';
   6 |     | import '../interfaces/cover/ICoverPoolFactory.sol';
   7 |     | import '../interfaces/cover/ICoverPoolManager.sol';
   8 |     | import '../base/events/CoverPoolManagerEvents.sol';
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Defines the actions which can be executed by the factory admin.
  12 |     |  */
  13 |     | contract CoverPoolManager is ICoverPoolManager, CoverPoolManagerEvents {
  14 |     |     address public owner;
  15 |     |     address public feeTo;
  16 |     |     address public factory;
  17 |     |     uint16  public constant MAX_PROTOCOL_FEE = 1e4; /// @dev - max protocol fee of 1%
  18 |     |     uint16  public constant oneSecond = 1000;
  19 |     |     // sourceName => sourceAddress
  20 |     |     mapping(bytes32 => address) internal _poolTypes;
  21 |     |     mapping(bytes32 => address) internal _poolTokens;
  22 |     |     mapping(bytes32 => address) internal _twapSources;
  23 |     |     // sourceName => feeTier => tickSpread => twapLength => VolatilityTier
  24 |     |     mapping(bytes32 => mapping(uint16 => mapping(int16 => mapping(uint16 => VolatilityTier)))) internal _volatilityTiers;
  25 |     | 
  26 |     |     constructor() {
  27 |     |         owner = msg.sender;
  28 |     |         feeTo = msg.sender;
  29 |     |         emit OwnerTransfer(address(0), msg.sender);
  30 |     |         emit FeeToTransfer(address(0), msg.sender);
  31 |     |     }
  32 |     | 
  33 |     |     /**
  34 |     |      * @dev Throws if called by any account other than the owner.
  35 |     |      */
  36 |     |     modifier onlyOwner() {
  37 |     |         _checkOwner();
  38 |     |         _;
  39 |     |     }
  40 |     | 
  41 |     |     modifier onlyFeeTo() {
  42 |     |         _checkFeeTo();
  43 |     |         _;
  44 |     |     }
  45 |     | 
  46 |     |     /**
  47 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
  48 |     |      * Can only be called by the current owner.
  49 |     |      */
  50 |     |     function transferOwner(address newOwner) public virtual onlyOwner {
  51 |     |         if(newOwner == address(0)) require (false, 'TransferredToZeroAddress()');
  52 |     |         _transferOwner(newOwner);
  53 |     |     }
  54 |     | 
  55 |     |     function transferFeeTo(address newFeeTo) public virtual onlyFeeTo {
  56 |     |         if(newFeeTo == address(0)) require (false, 'TransferredToZeroAddress()');
  57 |     |         _transferFeeTo(newFeeTo);
  58 |     |     }
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
  62 |     |      * Internal function without access restriction.
  63 |     |      */
  64 |     |     function _transferOwner(address newOwner) internal virtual {
  65 |     |         address oldOwner = owner;
  66 |     |         owner = newOwner;
  67 |     |         emit OwnerTransfer(oldOwner, newOwner);
  68 |     |     }
  69 |     | 
  70 |     |     /**
  71 |     |      * @dev Transfers fee collection to a new account (`newFeeTo`).
  72 |     |      * Internal function without access restriction.
  73 |     |      */
  74 |     |     function _transferFeeTo(address newFeeTo) internal virtual {
  75 |     |         address oldFeeTo = feeTo;
  76 |     |         feeTo = newFeeTo;
  77 |     |         emit FeeToTransfer(oldFeeTo, newFeeTo);
  78 |     |     }
  79 |     | 
  80 |     |     function enablePoolType(
  81 |     |         bytes32 poolType,
  82 |     |         address poolImpl,
  83 |     |         address tokenImpl,
  84 |     |         address twapImpl
  85 |     |     ) external onlyOwner {
  86 |     |         if (poolType == bytes32("")) require (false, 'TwapSourceNameInvalid()');
  87 |     |         if (poolImpl == address(0) || twapImpl == address(0)) require (false, 'TwapSourceAddressZero()');
  88 |     |         if (_twapSources[poolType] != address(0)) require (false, 'ImplementationAlreadyExists()');
  89 |     |         if (_poolTypes[poolType] != address(0)) require (false, 'ImplementationAlreadyExists()');
  90 |     |         _poolTypes[poolType] = poolImpl;
  91 |     |         _poolTokens[poolType] = tokenImpl;
  92 |     |         _twapSources[poolType] = twapImpl;
  93 |     |         emit PoolTypeEnabled(poolType, poolImpl, twapImpl, ITwapSource(twapImpl).factory());
  94 |     |     }
  95 |     | 
  96 |     |     function enableVolatilityTier(
  97 |     |         bytes32 poolType,
  98 |     |         uint16  feeTier,
  99 |     |         int16   tickSpread,
 100 |     |         uint16  twapLength,
 101 |     |         VolatilityTier memory volTier
 102 |     |     ) external onlyOwner {
 103 |     |         if (_volatilityTiers[poolType][feeTier][tickSpread][twapLength].auctionLength != 0) {
 104 |     |             require (false, 'VolatilityTierAlreadyEnabled()');
 105 |     |         } else if (volTier.auctionLength == 0 ||  volTier.minPositionWidth <= 0) {
 106 |     |             require (false, 'VolatilityTierCannotBeZero()');
 107 |     |         } else if (twapLength < 5 * volTier.blockTime / oneSecond) {
 108 |     |             require (false, 'VoltatilityTierTwapTooShort()');
 109 |     |         } else if (volTier.syncFee > 10000 || volTier.fillFee > 10000) {
 110 |     |             require (false, 'ProtocolFeeCeilingExceeded()');
 111 |     |         }
 112 |     |         address sourceAddress = _twapSources[poolType];
 113 |     |         {
 114 |     |             // check fee tier exists
 115 |     |             if (sourceAddress == address(0)) require (false, 'TwapSourceNotFound()');
 116 |     |             int24 tickSpacing = ITwapSource(sourceAddress).feeTierTickSpacing(feeTier);
 117 |     |             if (tickSpacing == 0) {
 118 |     |                 require (false, 'FeeTierNotSupported()');
 119 |     |             }
 120 |     |             // check tick multiple
 121 |     |             int24 tickMultiple = tickSpread / tickSpacing;
 122 |     |             if (tickMultiple * tickSpacing != tickSpread) {
 123 |     |                 require (false, 'TickSpreadNotMultipleOfTickSpacing()');
 124 |     |             } else if (tickMultiple < 2) {
 125 |     |                 require (false, 'TickSpreadNotAtLeastDoubleTickSpread()');
 126 |     |             }
 127 |     |         }
 128 |     |         // twapLength * blockTime should never overflow uint16
 129 |     |         _volatilityTiers[poolType][feeTier][tickSpread][twapLength] = volTier;
 130 |     | 
 131 |     |         emit VolatilityTierEnabled(
 132 |     |             poolType,
 133 |     |             feeTier,
 134 |     |             tickSpread,
 135 |     |             twapLength,
 136 |     |             volTier.minAmountPerAuction,
 137 |     |             volTier.auctionLength,
 138 |     |             volTier.blockTime,
 139 |     |             volTier.syncFee,
 140 |     |             volTier.fillFee,
 141 |     |             volTier.minPositionWidth,
 142 |     |             volTier.minAmountLowerPriced
 143 |     |         );
 144 |     |     }
 145 |     | 
 146 |     |     function modifyVolatilityTierFees(
 147 |     |         bytes32 implName,
 148 |     |         uint16 feeTier,
 149 |     |         int16 tickSpread,
 150 |     |         uint16 twapLength,
 151 |     |         uint16 syncFee,
 152 |     |         uint16 fillFee
 153 |     |     ) external onlyOwner {
 154 |     |         if (syncFee > 10000 || fillFee > 10000) {
 155 |     |             require (false, 'ProtocolFeeCeilingExceeded()');
 156 |     |         }
 157 |     |         _volatilityTiers[implName][feeTier][tickSpread][twapLength].syncFee = syncFee;
 158 |     |         _volatilityTiers[implName][feeTier][tickSpread][twapLength].fillFee = fillFee;
 159 |     |     }
 160 |     | 
 161 |     |     function setFactory(
 162 |     |         address factory_
 163 |     |     ) external onlyOwner {
 164 |     |         if (factory != address(0)) require (false, 'FactoryAlreadySet()');
 165 |     |         emit FactoryChanged(factory, factory_);
 166 |     |         factory = factory_;
 167 |     |     }
 168 |     | 
 169 |     |     function collectProtocolFees(
 170 |     |         address[] calldata collectPools
 171 |     |     ) external {
 172 |     |         if (collectPools.length == 0) require (false, 'EmptyPoolsArray()');
 173 |     |         uint128[] memory token0Fees = new uint128[](collectPools.length);
 174 |     |         uint128[] memory token1Fees = new uint128[](collectPools.length);
 175 |     |         for (uint i; i < collectPools.length; i++) {
 176 |     |             (token0Fees[i], token1Fees[i]) = ICoverPool(collectPools[i]).fees(0,0,false);
 177 |     |         }
 178 |     |         emit ProtocolFeesCollected(collectPools, token0Fees, token1Fees);
 179 |     |     }
 180 |     | 
 181 |     |     function modifyProtocolFees(
 182 |     |         address[] calldata modifyPools,
 183 |     |         uint16[] calldata syncFees,
 184 |     |         uint16[] calldata fillFees,
 185 |     |         bool[] calldata setFees
 186 |     |     ) external onlyOwner {
 187 |     |         if (modifyPools.length == 0) require (false, 'EmptyPoolsArray()');
 188 |     |         if (modifyPools.length != syncFees.length
 189 |     |             || syncFees.length != fillFees.length
 190 |     |             || fillFees.length != setFees.length) {
 191 |     |             require (false, 'MismatchedArrayLengths()');
 192 |     |         }
 193 |     |         uint128[] memory token0Fees = new uint128[](modifyPools.length);
 194 |     |         uint128[] memory token1Fees = new uint128[](modifyPools.length);
 195 |     |         for (uint i; i < modifyPools.length; i++) {
 196 |     |             if (syncFees[i] > MAX_PROTOCOL_FEE) require (false, 'ProtocolFeeCeilingExceeded()');
 197 |     |             if (fillFees[i] > MAX_PROTOCOL_FEE) require (false, 'ProtocolFeeCeilingExceeded()');
 198 |     |             (
 199 |     |                 token0Fees[i],
 200 |     |                 token1Fees[i]
 201 |     |             ) =ICoverPool(modifyPools[i]).fees(
 202 |     |                 syncFees[i],
 203 |     |                 fillFees[i],
 204 |     |                 setFees[i]
 205 |     |             );
 206 |     |         }
 207 |     |         emit ProtocolFeesModified(modifyPools, syncFees, fillFees, setFees, token0Fees, token1Fees);
 208 |     |     }
 209 |     | 
 210 |     |     function poolTypes(
 211 |     |         bytes32 poolType
 212 |     |     ) external view returns (
 213 |     |         address poolImpl,
 214 |     |         address tokenImpl,
 215 |     |         address twapImpl
 216 |     |     ) {
 217 |     |         return (
 218 |     |             _poolTypes[poolType],
 219 |     |             _poolTokens[poolType],
 220 |     |             _twapSources[poolType]
 221 |     |         );
 222 |     |     }
 223 |     | 
 224 |     |     function volatilityTiers(
 225 |     |         bytes32 implName,
 226 |     |         uint16 feeTier,
 227 |     |         int16 tickSpread,
 228 |     |         uint16 twapLength
 229 |     |     ) external view returns (
 230 |     |         VolatilityTier memory config
 231 |     |     ) {
 232 |     |         config = _volatilityTiers[implName][feeTier][tickSpread][twapLength];
 233 |     |     }
 234 |     |     
 235 |     |     /**
 236 |     |      * @dev Throws if the sender is not the owner.
 237 |     |      */
 238 |     |     function _checkOwner() internal view {
 239 |     |         if (owner != msg.sender) require (false, 'OwnerOnly()');
 240 |     |     }
 241 |     | 
 242 |     |     /**
 243 |     |      * @dev Throws if the sender is not the feeTo.
 244 |     |      */
 245 |     |     function _checkFeeTo() internal view {
 246 |     |         if (feeTo != msg.sender) require (false, 'FeeToOnly()');
 247 |     |     }
 248 |     | }

/home/ec2-user/git/cover/contracts/utils/PositionERC1155.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.13;
   4 |     | 
   5 |     | import '../interfaces/IPool.sol';
   6 |     | import "./CoverPoolErrors.sol";
   7 |     | import '../base/storage/PositionERC1155Immutables.sol';
   8 |     | import "../interfaces/IPositionERC1155.sol";
   9 |     | import '../external/solady/LibClone.sol';
  10 |     | 
  11 | *   | contract PositionERC1155 is
  12 |     |     IPositionERC1155,
  13 |     |     PositionERC1155Immutables,
  14 |     |     PositionERC1155Errors 
  15 |     | {
  16 |     |     error OwnerOnly();
  17 |     | 
  18 |     |     address public immutable factory;
  19 |     |     address public immutable original;
  20 |     | 
  21 |     |     constructor(
  22 |     |         address factory_
  23 |     |     ) {
  24 |     |         factory = factory_;
  25 |     |         original = address(this);
  26 |     |     }
  27 |     | 
  28 |     |     /// @dev token id => owner => balance
  29 |     |     mapping(uint256 => mapping(address => uint256)) private _tokenBalances;
  30 |     | 
  31 |     |     /// @dev owner => spender => approved
  32 |     |     mapping(address => mapping(address => bool)) private _spenderApprovals;
  33 |     | 
  34 |     |     /// @dev token id => total supply
  35 |     |     mapping(uint256 => uint256) private _totalSupplyById;
  36 |     | 
  37 |     |     string private constant _NAME = "Poolshark LP";
  38 |     |     string private constant _SYMBOL = "PSHARK-LP";
  39 |     | 
  40 |     |     modifier onlyCanonicalClones(
  41 |     |         PoolsharkStructs.CoverImmutables memory constants
  42 |     |     ) {
  43 |     |         if(!_onlyCanonicalPools(constants)) require (false, 'CanoncialPoolsOnly()');
  44 |     |         if(!_onlyCanonicalPoolTokens(constants)) require (false, 'CanoncialPoolTokensOnly()');
  45 |     |         _;
  46 |     |     }
  47 |     | 
  48 |     |     modifier checkApproval(address _from, address _spender) {
  49 |     |         if (_from != _spender)
  50 |     |             if(!_isApprovedForAll(_from, _spender)) 
  51 |     |                 revert SpenderNotApproved(_from, _spender);
  52 |     |         _;
  53 |     |     }
  54 |     | 
  55 |     |     modifier checkAddresses(address _from, address _to) {
  56 |     |         if (_from == address(0) || _to == address(0)) revert TransferFromOrToAddress0();
  57 |     |         if (_from == _to) revert TransferToSelf();
  58 |     |         _;
  59 |     |     }
  60 |     | 
  61 |     |     modifier checkLength(uint256 _lengthA, uint256 _lengthB) {
  62 |     |         if (_lengthA != _lengthB) revert LengthMismatch(_lengthA, _lengthB);
  63 |     |         _;
  64 |     |     }
  65 |     | 
  66 |     |     modifier checkERC1155Support(address recipient) {
  67 |     |         if (!_verifyERC1155Support(recipient)) revert ERC1155NotSupported();
  68 |     |         _;
  69 |     |     }
  70 |     | 
  71 |     |     function mint(
  72 |     |         address _account,
  73 |     |         uint256 _id,
  74 |     |         uint256 _amount,
  75 |     |         PoolsharkStructs.CoverImmutables memory constants
  76 |     |     ) external 
  77 |     |         onlyCanonicalClones(constants)
  78 |     |         checkERC1155Support(_account)
  79 |     |     {
  80 |     |         _mint(_account, _id, _amount);
  81 |     |     }
  82 |     | 
  83 |     |     function burn(
  84 |     |         address _account,
  85 |     |         uint256 _id,
  86 |     |         uint256 _amount,
  87 |     |         PoolsharkStructs.CoverImmutables memory constants
  88 |     |     ) external
  89 |     |         onlyCanonicalClones(constants)
  90 |     |     {
  91 |     |         _burn(_account, _id, _amount);
  92 |     |     }
  93 |     | 
  94 |     |     function setApprovalForAll(address _spender, bool _approved) public virtual override {
  95 |     |         _setApprovalForAll(msg.sender, _spender, _approved);
  96 |     |     }
  97 |     | 
  98 |     |     function safeTransferFrom(
  99 |     |         address _from,
 100 |     |         address _to,
 101 |     |         uint256 _id,
 102 |     |         uint256 _amount
 103 |     |     ) public virtual override
 104 |     |         checkAddresses(_from, _to)
 105 |     |         checkApproval(_from, msg.sender)
 106 |     |         checkERC1155Support(_to)
 107 |     |     {
 108 |     |         address _spender = msg.sender;
 109 |     |         _transfer(_from, _to, _id, _amount);
 110 |     |         emit TransferSingle(_spender, _from, _to, _id, _amount);
 111 |     |     }
 112 |     | 
 113 |     |     function safeBatchTransferFrom(
 114 |     |         address _from,
 115 |     |         address _to,
 116 |     |         uint256[] calldata _ids,
 117 |     |         uint256[] calldata _amounts
 118 |     |     ) public virtual override
 119 |     |         checkLength(_ids.length, _amounts.length)
 120 |     |         checkAddresses(_from, _to)
 121 |     |         checkApproval(_from, msg.sender)
 122 |     |         checkERC1155Support(_to)
 123 |     |     {
 124 |     |         unchecked {
 125 |     |             for (uint256 i; i < _ids.length; ++i) {
 126 |     |                 _transfer(_from, _to, _ids[i], _amounts[i]);
 127 |     |             }
 128 |     |         }
 129 |     |         emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);
 130 |     |     }
 131 |     | 
 132 |     |     function isApprovedForAll(address _owner, address _spender) public view virtual override returns (bool) {
 133 |     |         return _isApprovedForAll(_owner, _spender);
 134 |     |     }
 135 |     | 
 136 |     |     function supportsInterface(bytes4 interfaceID) external pure returns (bool) {
 137 |     |       return  interfaceID == 0x01ffc9a7 ||    // ERC-165 support
 138 |     |               interfaceID == 0xd9b67a26;      // ERC-1155 support
 139 |     |     }
 140 |     | 
 141 |     |     function name() public pure virtual override returns (string memory) {
 142 |     |         return _NAME;
 143 |     |     }
 144 |     | 
 145 |     |     function symbol() public pure virtual override returns (string memory) {
 146 |     |         return _SYMBOL;
 147 |     |     }
 148 |     | 
 149 |     |     function totalSupply(uint256 _id) public view virtual override returns (uint256) {
 150 |     |         return _totalSupplyById[_id];
 151 |     |     }
 152 |     | 
 153 |     |     function balanceOf(address _account, uint256 _id) public view virtual override returns (uint256) {
 154 |     |         return _tokenBalances[_id][_account];
 155 |     |     }
 156 |     | 
 157 |     |     function balanceOfBatch(
 158 |     |         address[] calldata _accounts,
 159 |     |         uint256[] calldata _ids
 160 |     |     ) public view virtual override
 161 |     |         checkLength(_accounts.length, _ids.length)
 162 |     |         returns (uint256[] memory batchBalances)
 163 |     |     {
 164 |     |         batchBalances = new uint256[](_accounts.length);
 165 |     |         unchecked {
 166 |     |             for (uint256 i; i < _accounts.length; ++i) {
 167 |     |                 batchBalances[i] = balanceOf(_accounts[i], _ids[i]);
 168 |     |             }
 169 |     |         }
 170 |     |     }
 171 |     | 
 172 |     |     function _mint(
 173 |     |         address _account,
 174 |     |         uint256 _id,
 175 |     |         uint256 _amount
 176 |     |     ) internal virtual {
 177 |     |         if (_account == address(0)) revert MintToAddress0();
 178 |     |         _beforeTokenTransfer(address(0), _account, _id, _amount);
 179 |     |         _totalSupplyById[_id] += _amount;
 180 |     |         uint256 _accountBalance = _tokenBalances[_id][_account];
 181 |     |         unchecked {
 182 |     |             _tokenBalances[_id][_account] = _accountBalance + _amount;
 183 |     |         }
 184 |     |         emit TransferSingle(msg.sender, address(0), _account, _id, _amount);
 185 |     |     }
 186 |     | 
 187 |     |     function _burn(
 188 |     |         address _account,
 189 |     |         uint256 _id,
 190 |     |         uint256 _amount
 191 |     |     ) internal virtual {
 192 |     |         if (_account == address(0)) revert BurnFromAddress0();
 193 |     |         uint256 _accountBalance = _tokenBalances[_id][_account];
 194 |     |         if (_accountBalance < _amount) revert BurnExceedsBalance(_account, _id, _amount);
 195 |     |         _beforeTokenTransfer(_account, address(0), _id, _amount);
 196 |     |         unchecked {
 197 |     |             _tokenBalances[_id][_account] = _accountBalance - _amount;
 198 |     |             _totalSupplyById[_id] -= _amount;
 199 |     |         }
 200 |     |         emit TransferSingle(msg.sender, _account, address(0), _id, _amount);
 201 |     |     }
 202 |     | 
 203 |     |     function _transfer(
 204 |     |         address _from,
 205 |     |         address _to,
 206 |     |         uint256 _id,
 207 |     |         uint256 _amount
 208 |     |     ) internal virtual {
 209 |     |         uint256 _fromBalance = _tokenBalances[_id][_from];
 210 |     |         if (_fromBalance < _amount) revert TransferExceedsBalance(_from, _id, _amount);
 211 |     |         _beforeTokenTransfer(_from, _to, _id, _amount);
 212 |     |         unchecked {
 213 |     |             _tokenBalances[_id][_from] = _fromBalance - _amount;
 214 |     |         }
 215 |     |         uint256 _toBalance = _tokenBalances[_id][_to];
 216 |     |         unchecked {
 217 |     |             _tokenBalances[_id][_to] = _toBalance + _amount;
 218 |     |         }
 219 |     |     }
 220 |     | 
 221 |     |     function _setApprovalForAll(
 222 |     |         address _owner,
 223 |     |         address _spender,
 224 |     |         bool _approved
 225 |     |     ) internal virtual {
 226 |     |         if (_owner == _spender) revert SelfApproval(_owner);
 227 |     |         _spenderApprovals[_owner][_spender] = _approved;
 228 |     |         emit ApprovalForAll(_owner, _spender, _approved);
 229 |     |     }
 230 |     | 
 231 |     |     function _isApprovedForAll(address _owner, address _spender) internal view virtual returns (bool) {
 232 |     |         return _owner == _spender || _spenderApprovals[_owner][_spender];
 233 |     |     }
 234 |     | 
 235 |     |     /// @notice Hook that is called before any token transfer.
 236 |     |     function _beforeTokenTransfer(
 237 |     |         address from,
 238 |     |         address to,
 239 |     |         uint256 id,
 240 |     |         uint256 amount
 241 |     |     ) internal virtual {}
 242 |     | 
 243 |     |     function _onlyCanonicalPoolTokens(
 244 |     |         PoolsharkStructs.CoverImmutables memory constants
 245 |     |     ) private view returns (bool) {
 246 |     |         // generate key for pool
 247 |     |         bytes32 key = keccak256(
 248 |     |             abi.encode(
 249 |     |                 constants.token0,
 250 |     |                 constants.token1,
 251 |     |                 constants.source,
 252 |     |                 constants.inputPool,
 253 |     |                 constants.tickSpread,
 254 |     |                 constants.twapLength
 255 |     |             )
 256 |     |         );
 257 |     | 
 258 |     |         // compute address
 259 |     |         address predictedAddress = LibClone.predictDeterministicAddress(
 260 |     |             original,
 261 |     |             abi.encodePacked(
 262 |     |                 poolImpl()
 263 |     |             ),
 264 |     |             key,
 265 |     |             factory
 266 |     |         );
 267 |     | 
 268 |     |         if (predictedAddress != address(this)) return false;
 269 |     | 
 270 |     |         return true;
 271 |     |     }
 272 |     | 
 273 |     |     function _onlyCanonicalPools(
 274 |     |         PoolsharkStructs.CoverImmutables memory constants
 275 |     |     ) private view returns (bool) {
 276 |     |         // generate key for pool
 277 |     |         bytes32 key = keccak256(
 278 |     |             abi.encode(
 279 |     |                 constants.token0,
 280 |     |                 constants.token1,
 281 |     |                 constants.source,
 282 |     |                 constants.inputPool,
 283 |     |                 constants.tickSpread,
 284 |     |                 constants.twapLength
 285 |     |             )
 286 |     |         );
 287 |     | 
 288 |     |         // compute address
 289 |     |         address predictedAddress = LibClone.predictDeterministicAddress(
 290 |     |             poolImpl(),
 291 |     |             encodeCover(constants),
 292 |     |             key,
 293 |     |             factory
 294 |     |         );
 295 |     | 
 296 |     |         if (predictedAddress != msg.sender) return false;
 297 |     | 
 298 |     |         return true;
 299 |     |     }
 300 |     | 
 301 |     |     /// @notice Return if the `_target` contract supports ERC-1155 interface
 302 |     |     /// @param _target The address of the contract
 303 |     |     /// @return supported Whether the contract is supported (true) or not (false)
 304 |     |     function _verifyERC1155Support(address _target) private view returns (bool supported) {
 305 |     |         if (_target.code.length == 0) return true;
 306 |     |         bytes memory encodedParams = abi.encodeWithSelector(
 307 |     |             IERC165.supportsInterface.selector,
 308 |     |             type(IPositionERC1155).interfaceId
 309 |     |         );
 310 |     |         (bool success, bytes memory result) = _target.staticcall{gas: 30_000}(encodedParams);
 311 |     |         if (result.length < 32) return false;
 312 |     |         return success && abi.decode(result, (bool));
 313 |     |     }
 314 |     | 
 315 |     |     function encodeCover(
 316 |     |         CoverImmutables memory constants
 317 |     |     ) private pure returns (bytes memory) {
 318 |     |         bytes memory value1 = abi.encodePacked(
 319 |     |             constants.owner,
 320 |     |             constants.token0,
 321 |     |             constants.token1,
 322 |     |             constants.source,
 323 |     |             constants.poolToken,
 324 |     |             constants.inputPool,
 325 |     |             constants.bounds.min,
 326 |     |             constants.bounds.max
 327 |     |         );
 328 |     |         bytes memory value2 = abi.encodePacked(
 329 |     |             constants.minAmountPerAuction,
 330 |     |             constants.genesisTime,
 331 |     |             constants.minPositionWidth,
 332 |     |             constants.tickSpread,
 333 |     |             constants.twapLength,
 334 |     |             constants.auctionLength
 335 |     |         );
 336 |     |         bytes memory value3 = abi.encodePacked(
 337 |     |             constants.blockTime,
 338 |     |             constants.token0Decimals,
 339 |     |             constants.token1Decimals,
 340 |     |             constants.minAmountLowerPriced
 341 |     |         );
 342 |     |         return abi.encodePacked(value1, value2, value3);
 343 |     |     }
 344 |     | }

