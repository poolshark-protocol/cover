<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/home/ec2-user/git/cover/contracts/CoverEchidnaPool.sol</b>
<code>
   1 |     | <span class='unexecuted'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./CoverPoolFactory.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./utils/CoverPoolManager.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./test/Token20.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./interfaces/structs/CoverPoolStructs.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./libraries/math/ConstantProduct.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./libraries/pool/MintCall.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./libraries/pool/BurnCall.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./test/UniswapV3FactoryMock.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./libraries/sources/UniswapV3Source.sol&#39;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>//TODO: make sure no assertions fail</span>
  15 |     | <span class='neutral'>//TODO: add the ability to change the TWAP randomly</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>// Fuzz CoverPool functionality</span>
  18 | *r  | <span class='executed'>contract CoverEchidnaPool {</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    event PassedMint();</span>
  21 |     | <span class='neutral'>    event PassedBurn();</span>
  22 |     | <span class='neutral'>    event Prices(uint160 price0, uint160 price1);</span>
  23 |     | <span class='neutral'>    event LiquidityGlobal(uint128 liqBefore, uint128 liqAfter);</span>
  24 |     | <span class='neutral'>    event Liquidity(uint128 liq0Before, uint128 liq1Before, uint128 liq0After, uint128 liq1After);</span>
  25 |     | <span class='neutral'>    event PositionTicks(int24 lower, int24 upper);</span>
  26 |     | <span class='neutral'>    event BurnTicks(int24 lower, int24 upper, bool positionExists);</span>
  27 |     | <span class='neutral'>    event LiquidityMinted(uint256 amount, uint256 tokenAmount, bool zeroForOne);</span>
  28 |     | <span class='neutral'>    event PositionCreated(bool isCreated);</span>
  29 |     | <span class='neutral'>    event AmountInDeltaMaxMinus(uint128 beforeDelta, uint128 afterDelta);</span>
  30 |     | <span class='neutral'>    event AmountOutDeltaMaxMinus(uint128 beforeDelta, uint128 afterDelta);</span>
  31 |     | <span class='neutral'>    event LiquidityDeltaAndDeltaMaxMinus(int128 delta, uint128 abs);</span>
  32 |     | <span class='neutral'>    event Deployed(address contractAddress);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    int16 tickSpacing;</span>
  35 |     | <span class='neutral'>    uint16 swapFee;</span>
  36 |     | <span class='neutral'>    address private implementation;</span>
  37 |     | <span class='neutral'>    address private poolMock;</span>
  38 |     | <span class='neutral'>    address private poolFactoryMock;</span>
  39 |     | <span class='neutral'>    address private twapSource;</span>
  40 |     | <span class='neutral'>    CoverPoolFactory private factory;</span>
  41 |     | <span class='neutral'>    CoverPoolManager private manager;</span>
  42 |     | <span class='neutral'>    CoverPool private pool;</span>
  43 |     | <span class='neutral'>    Token20 private token0;</span>
  44 |     | <span class='neutral'>    Token20 private token1;</span>
  45 |     | <span class='neutral'>    Token20 private tokenIn;</span>
  46 |     | <span class='neutral'>    Token20 private tokenOut;</span>
  47 |     | <span class='neutral'>    Position[] private positions;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    struct LiquidityDeltaValues {</span>
  50 |     | <span class='neutral'>        int128 liquidityDeltaLowerBefore;</span>
  51 |     | <span class='neutral'>        int128 liquidityDeltaUpperBefore;</span>
  52 |     | <span class='neutral'>        int128 liquidityDeltaLowerAfter;</span>
  53 |     | <span class='neutral'>        int128 liquidityDeltaUpperAfter;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    struct PoolValues {</span>
  57 |     | <span class='neutral'>        uint160 price0Before;</span>
  58 |     | <span class='neutral'>        uint128 liquidity0Before;</span>
  59 |     | <span class='neutral'>        uint160 price1Before;</span>
  60 |     | <span class='neutral'>        uint128 liquidity1Before;</span>
  61 |     | <span class='neutral'>        uint160 price0After;</span>
  62 |     | <span class='neutral'>        uint128 liquidity0After;</span>
  63 |     | <span class='neutral'>        uint160 price1After;</span>
  64 |     | <span class='neutral'>        uint128 liquidity1After;</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>        uint128 liquidityGlobalBefore;</span>
  67 |     | <span class='neutral'>        uint128 liquidityGlobalAfter;</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>        // CoverPoolStructs.PoolState pool0Before;</span>
  70 |     | <span class='neutral'>        // CoverPoolStructs.PoolState pool1Before;</span>
  71 |     | <span class='neutral'>        // CoverPoolStructs.GlobalState stateBefore;</span>
  72 |     | <span class='neutral'>        // CoverPoolStructs.GlobalState stateAfter;</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>        // CoverPoolStructs.Tick tickLowerBefore;</span>
  75 |     | <span class='neutral'>        // CoverPoolStructs.Tick tickUpperBefore;</span>
  76 |     | <span class='neutral'>        // CoverPoolStructs.Tick tickLowerAfter;</span>
  77 |     | <span class='neutral'>        // CoverPoolStructs.Tick tickUpperAfter;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        uint128 amountInDeltaMaxMinusUpperBefore;</span>
  80 |     | <span class='neutral'>        uint128 amountInDeltaMaxMinusLowerBefore;</span>
  81 |     | <span class='neutral'>        uint128 amountInDeltaMaxMinusUpperAfter;</span>
  82 |     | <span class='neutral'>        uint128 amountInDeltaMaxMinusLowerAfter;</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>        uint128 amountOutDeltaMaxMinusUpperBefore;</span>
  85 |     | <span class='neutral'>        uint128 amountOutDeltaMaxMinusLowerBefore;</span>
  86 |     | <span class='neutral'>        uint128 amountOutDeltaMaxMinusUpperAfter;</span>
  87 |     | <span class='neutral'>        uint128 amountOutDeltaMaxMinusLowerAfter;</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        uint160 price0;</span>
  90 |     | <span class='neutral'>        uint160 price1;</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>        uint32 positionIdNextBefore;</span>
  93 |     | <span class='neutral'>        uint32 positionIdNextAfter;</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    struct SwapCallbackData {</span>
  97 |     | <span class='neutral'>        address sender;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    struct Position {</span>
 101 |     | <span class='neutral'>        address owner;</span>
 102 |     | <span class='neutral'>        uint32 positionId;</span>
 103 |     | <span class='neutral'>        int24 lower;</span>
 104 |     | <span class='neutral'>        int24 upper;</span>
 105 |     | <span class='neutral'>        bool zeroForOne;</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    struct PoolStructs {</span>
 109 |     | <span class='neutral'>        CoverPoolStructs.Tick lower;</span>
 110 |     | <span class='neutral'>        CoverPoolStructs.Tick upper;</span>
 111 |     | <span class='neutral'>        CoverPoolStructs.PoolState pool0;</span>
 112 |     | <span class='neutral'>        CoverPoolStructs.PoolState pool1;</span>
 113 |     | <span class='neutral'>        CoverPoolStructs.GlobalState state;</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    modifier tickPreconditions(int24 lower, int24 upper) {</span>
 117 | *r  | <span class='executed'>        require(lower &lt; upper);</span>
 118 | *r  | <span class='executed'>        require(upper &lt; 887272);</span>
 119 | *r  | <span class='executed'>        require(lower &gt; -887272);</span>
 120 | *r  | <span class='executed'>        require(lower % tickSpacing == 0);</span>
 121 | *r  | <span class='executed'>        require(upper % tickSpacing == 0);</span>
 122 |     | <span class='neutral'>        _;</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>    constructor() {</span>
 126 |     | <span class='unexecuted'>        manager = new CoverPoolManager();</span>
 127 |     | <span class='unexecuted'>        factory = new CoverPoolFactory(address(manager));</span>
 128 |     | <span class='unexecuted'>        implementation = address(new CoverPool(address(factory)));</span>
 129 |     | <span class='unexecuted'>        tokenIn = new Token20(&quot;IN&quot;, &quot;IN&quot;, 18);</span>
 130 |     | <span class='unexecuted'>        tokenOut = new Token20(&quot;OUT&quot;, &quot;OUT&quot;, 18);</span>
 131 |     | <span class='unexecuted'>        (token0, token1) = address(tokenIn) &lt; address(tokenOut) ? (tokenIn, tokenOut) </span>
 132 |     | <span class='unexecuted'>                                                                : (tokenOut, tokenIn);</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>        // mock sources</span>
 135 |     | <span class='unexecuted'>        poolFactoryMock = address(new UniswapV3FactoryMock(address(tokenIn), address(tokenOut)));</span>
 136 |     | <span class='unexecuted'>        twapSource = address(new UniswapV3Source(poolFactoryMock));</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>        poolMock = UniswapV3FactoryMock(poolFactoryMock).getPool(address(token0), address(token1), 500);</span>
 139 |     | <span class='unexecuted'>        emit Deployed(UniswapV3FactoryMock(poolFactoryMock).getPool(address(token0), address(token1), 500));</span>
 140 |     | <span class='unexecuted'>        UniswapV3PoolMock(poolMock).setObservationCardinality(5, 5);</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='unexecuted'>        CoverPoolStructs.VolatilityTier memory volTier = CoverPoolStructs.VolatilityTier({</span>
 143 |     | <span class='unexecuted'>            minAmountPerAuction: 0,</span>
 144 |     | <span class='unexecuted'>            auctionLength: 5,</span>
 145 |     | <span class='unexecuted'>            blockTime: 1000,</span>
 146 |     | <span class='unexecuted'>            syncFee: 0,</span>
 147 |     | <span class='unexecuted'>            fillFee: 0,</span>
 148 |     | <span class='unexecuted'>            minPositionWidth: 1,</span>
 149 |     | <span class='unexecuted'>            minAmountLowerPriced: true</span>
 150 |     | <span class='neutral'>        });</span>
 151 |     | <span class='neutral'>        </span>
 152 |     | <span class='neutral'>        // add pool type</span>
 153 |     | <span class='unexecuted'>        manager.enablePoolType(bytes32(uint256(0x1)), address(implementation), twapSource);</span>
 154 |     | <span class='unexecuted'>        manager.enableVolatilityTier(bytes32(uint256(0x1)), 500, 20, 5, volTier);</span>
 155 |     | <span class='unexecuted'>        tickSpacing = 20;</span>
 156 |     | <span class='unexecuted'>        ICoverPoolFactory.CoverPoolParams memory params;</span>
 157 |     | <span class='unexecuted'>        params.poolType = bytes32(uint256(0x1));</span>
 158 |     | <span class='unexecuted'>        params.tokenIn = address(tokenIn);</span>
 159 |     | <span class='unexecuted'>        params.tokenOut = address(tokenOut);</span>
 160 |     | <span class='unexecuted'>        params.feeTier = 500;</span>
 161 |     | <span class='unexecuted'>        params.tickSpread = 20;</span>
 162 |     | <span class='unexecuted'>        params.twapLength = 5;</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>        // launch pool</span>
 165 |     | <span class='unexecuted'>        address poolAddr = factory.createCoverPool(params);</span>
 166 |     | <span class='unexecuted'>        pool = CoverPool(poolAddr);</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 | *   | <span class='executed'>    function mint(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {</span>
 170 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 171 | *   | <span class='executed'>        mintAndApprove();</span>
 172 | *   | <span class='executed'>        amount = amount + 1;</span>
 173 |     | <span class='neutral'>        </span>
 174 |     | <span class='neutral'>        // Ensure the newly created position is using different ticks</span>
 175 | *   | <span class='executed'>        for(uint i = 0; i &lt; positions.length;) {</span>
 176 | *   | <span class='executed'>            if(positions[i].owner == msg.sender &amp;&amp; positions[i].lower == lower &amp;&amp; positions[i].upper == upper &amp;&amp; positions[i].zeroForOne == zeroForOne) {</span>
 177 |     | <span class='unexecuted'>                revert(&quot;Position already exists&quot;);</span>
 178 |     | <span class='neutral'>            }</span>
 179 |     | <span class='neutral'>            unchecked {</span>
 180 | *   | <span class='executed'>                ++i;</span>
 181 |     | <span class='neutral'>            }</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'></span>
 184 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 185 | *   | <span class='executed'>        PoolStructs memory poolStructs;</span>
 186 | *   | <span class='executed'>        LiquidityDeltaValues memory values;</span>
 187 |     | <span class='neutral'>        </span>
 188 |     | <span class='neutral'>        // storage structs</span>
 189 | *   | <span class='executed'>        poolStructs.pool0 = getPoolState(true);</span>
 190 | *   | <span class='executed'>        poolStructs.pool1 = getPoolState(false);</span>
 191 | *   | <span class='executed'>        poolStructs.state = getGlobalState();</span>
 192 | *   | <span class='executed'>        poolStructs.lower = getTick(lower);</span>
 193 | *   | <span class='executed'>        poolStructs.upper = getTick(upper);</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>        // pool price and liquidity</span>
 196 | *   | <span class='executed'>        poolValues.price0Before = poolStructs.pool0.price;</span>
 197 | *   | <span class='executed'>        poolValues.liquidity0Before = poolStructs.pool0.liquidity;</span>
 198 | *   | <span class='executed'>        poolValues.price1Before = poolStructs.pool1.price;</span>
 199 | *   | <span class='executed'>        poolValues.liquidity1Before = poolStructs.pool1.liquidity;</span>
 200 | *   | <span class='executed'>        poolValues.liquidityGlobalBefore = poolStructs.state.liquidityGlobal;</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>        // tick values</span>
 203 | *   | <span class='executed'>        values.liquidityDeltaLowerBefore = poolStructs.lower.liquidityDelta;</span>
 204 | *   | <span class='executed'>        values.liquidityDeltaUpperBefore = poolStructs.upper.liquidityDelta;</span>
 205 | *   | <span class='executed'>        poolValues.amountInDeltaMaxMinusLowerBefore = poolStructs.lower.amountInDeltaMaxMinus;</span>
 206 | *   | <span class='executed'>        poolValues.amountInDeltaMaxMinusUpperBefore = poolStructs.upper.amountInDeltaMaxMinus;</span>
 207 | *   | <span class='executed'>        poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;</span>
 208 | *   | <span class='executed'>        poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;</span>
 209 |     | <span class='neutral'></span>
 210 | *   | <span class='executed'>        ICoverPool.MintParams memory params;</span>
 211 | *   | <span class='executed'>        params.to = msg.sender;</span>
 212 | *   | <span class='executed'>        params.amount = amount;</span>
 213 | *   | <span class='executed'>        params.positionId = 0;</span>
 214 | *   | <span class='executed'>        params.lower = lower;</span>
 215 | *   | <span class='executed'>        params.upper = upper;</span>
 216 | *   | <span class='executed'>        params.zeroForOne = zeroForOne;</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>        // Get the ticks the position will be minted with rather than what was passed directly by fuzzer</span>
 219 |     | <span class='neutral'>        // This is so the we can properly compare before and after mint states of particular ticks.</span>
 220 | *   | <span class='executed'>        bool posCreated;</span>
 221 | *   | <span class='executed'>        (lower, upper, posCreated) = pool.getResizedTicksForMint(params);</span>
 222 |     | <span class='neutral'>        //TODO: amount can change as well here so we should change this functionality or account for the change</span>
 223 | *   | <span class='executed'>        emit PositionTicks(lower, upper);</span>
 224 | *   | <span class='executed'>        emit PositionCreated(posCreated);</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>        // ACTION </span>
 227 | *r  | <span class='executed'>        pool.mint(params);</span>
 228 | *   | <span class='executed'>        if (posCreated) positions.push(Position(msg.sender, poolValues.positionIdNextBefore, lower, upper, zeroForOne));</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>        // storage structs</span>
 231 | *   | <span class='executed'>        poolStructs.pool0 = getPoolState(true);</span>
 232 | *   | <span class='executed'>        poolStructs.pool1 = getPoolState(false);</span>
 233 | *   | <span class='executed'>        poolStructs.state = getGlobalState();</span>
 234 | *   | <span class='executed'>        poolStructs.lower = getTick(lower);</span>
 235 | *   | <span class='executed'>        poolStructs.upper = getTick(upper);</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>        // pool price and liquidity</span>
 238 | *   | <span class='executed'>        poolValues.price0After = poolStructs.pool0.price;</span>
 239 | *   | <span class='executed'>        poolValues.liquidity0After = poolStructs.pool0.liquidity;</span>
 240 | *   | <span class='executed'>        poolValues.price1After = poolStructs.pool1.price;</span>
 241 | *   | <span class='executed'>        poolValues.liquidity1After = poolStructs.pool1.liquidity;</span>
 242 | *   | <span class='executed'>        poolValues.liquidityGlobalAfter = poolStructs.state.liquidityGlobal;</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>        // lower tick</span>
 245 | *   | <span class='executed'>        values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;</span>
 246 | *   | <span class='executed'>        poolValues.amountInDeltaMaxMinusLowerAfter = poolStructs.lower.amountInDeltaMaxMinus;</span>
 247 | *   | <span class='executed'>        poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='neutral'>        // upper tick</span>
 250 | *   | <span class='executed'>        values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;</span>
 251 | *   | <span class='executed'>        poolValues.amountInDeltaMaxMinusUpperAfter = poolStructs.upper.amountInDeltaMaxMinus;</span>
 252 | *   | <span class='executed'>        poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;</span>
 253 |     | <span class='neutral'>        </span>
 254 |     | <span class='neutral'>        // POST CONDITIONS</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>        // Ensure prices have not crossed</span>
 257 | *   | <span class='executed'>        emit Prices(poolValues.price0After, poolValues.price1After);</span>
 258 | *   | <span class='executed'>        assert(poolValues.price0After &lt;= poolValues.price1After);</span>
 259 |     | <span class='neutral'>        </span>
 260 |     | <span class='neutral'>        // Ensure that amountOutDeltaMaxMinus is incremented when not undercutting</span>
 261 |     | <span class='neutral'>        //NOTE: delta max minus should be strictly greater as both values should be non-zero</span>
 262 | *   | <span class='executed'>        if (posCreated) {</span>
 263 | *   | <span class='executed'>            emit PositionTicks(lower, upper);</span>
 264 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
 265 | *   | <span class='executed'>            assert(lower &lt; upper);</span>
 266 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
 267 | *   | <span class='executed'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>            // check delta maxes</span>
 270 | *   | <span class='executed'>            if(zeroForOne){</span>
 271 | *   | <span class='executed'>                emit AmountInDeltaMaxMinus(poolValues.amountInDeltaMaxMinusLowerBefore, poolValues.amountInDeltaMaxMinusLowerAfter);</span>
 272 | *   | <span class='executed'>                assert(poolValues.amountInDeltaMaxMinusLowerAfter &gt; poolValues.amountInDeltaMaxMinusLowerBefore);</span>
 273 | *   | <span class='executed'>                emit AmountOutDeltaMaxMinus(poolValues.amountOutDeltaMaxMinusLowerBefore, poolValues.amountOutDeltaMaxMinusLowerAfter);</span>
 274 | *   | <span class='executed'>                assert(poolValues.amountOutDeltaMaxMinusLowerAfter &gt; poolValues.amountOutDeltaMaxMinusLowerBefore);</span>
 275 |     | <span class='neutral'>            } else {</span>
 276 | *   | <span class='executed'>                emit AmountInDeltaMaxMinus(poolValues.amountInDeltaMaxMinusUpperBefore, poolValues.amountInDeltaMaxMinusUpperAfter);</span>
 277 | *   | <span class='executed'>                assert(poolValues.amountInDeltaMaxMinusUpperAfter &gt; poolValues.amountInDeltaMaxMinusUpperBefore);</span>
 278 | *   | <span class='executed'>                emit AmountOutDeltaMaxMinus(poolValues.amountOutDeltaMaxMinusUpperBefore, poolValues.amountOutDeltaMaxMinusUpperAfter);</span>
 279 | *   | <span class='executed'>                assert(poolValues.amountOutDeltaMaxMinusUpperAfter &gt; poolValues.amountOutDeltaMaxMinusUpperBefore);</span>
 280 |     | <span class='neutral'>            }</span>
 281 | *   | <span class='executed'>            emit LiquidityGlobal(poolValues.liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 282 |     | <span class='neutral'>            //emit Liquidity(poolValues.liquidity0Before, poolValues.liquidity1Before, poolValues.liquidity0After, poolValues.liquidity1After);</span>
 283 |     | <span class='neutral'>            // Ensure liquidityGlobal is incremented after mint</span>
 284 | *   | <span class='executed'>            assert(poolValues.liquidityGlobalAfter &gt; poolValues.liquidityGlobalBefore);</span>
 285 |     | <span class='neutral'>        }</span>
 286 |     | <span class='neutral'>        // Ensure pool liquidity is non-zero after mint with no undercuts</span>
 287 |     | <span class='neutral'>        // if (zeroForOne) {</span>
 288 |     | <span class='neutral'>        //     if (poolValues.price0After &lt; poolValues.price0Before) assert(poolValues.liquidity0After &gt; 0);</span>
 289 |     | <span class='neutral'>        // }</span>
 290 |     | <span class='neutral'>        // else {</span>
 291 |     | <span class='neutral'>        //     if (poolValues.price1After &gt; poolValues.price1Before) assert(poolValues.liquidity1After &gt; 0);</span>
 292 |     | <span class='neutral'>        // }</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 | *   | <span class='executed'>    function mintVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {</span>
 296 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 297 |     | <span class='neutral'>        // check if it&#39;s going to sync beforehand</span>
 298 | *   | <span class='executed'>        mintAndApprove();</span>
 299 | *   | <span class='executed'>        amount = amount + 1;</span>
 300 |     | <span class='neutral'>        // Ensure the newly created position is using different ticks</span>
 301 | *   | <span class='executed'>        for(uint i = 0; i &lt; positions.length;) {</span>
 302 | *   | <span class='executed'>            if(positions[i].owner == msg.sender &amp;&amp; positions[i].lower == lower &amp;&amp; positions[i].upper == upper &amp;&amp; positions[i].zeroForOne == zeroForOne) {</span>
 303 |     | <span class='unexecuted'>                revert(&quot;Position already exists&quot;);</span>
 304 |     | <span class='neutral'>            }</span>
 305 |     | <span class='neutral'>            unchecked {</span>
 306 | *   | <span class='executed'>                ++i;</span>
 307 |     | <span class='neutral'>            }</span>
 308 |     | <span class='neutral'>        }</span>
 309 |     | <span class='neutral'></span>
 310 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 311 | *   | <span class='executed'>        PoolStructs memory poolStructs;</span>
 312 | *   | <span class='executed'>        LiquidityDeltaValues memory values;</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>        // storage structs</span>
 315 | *   | <span class='executed'>        poolStructs.pool0 = getPoolState(true);</span>
 316 | *   | <span class='executed'>        poolStructs.pool1 = getPoolState(false);</span>
 317 | *   | <span class='executed'>        poolStructs.state = getGlobalState();</span>
 318 | *   | <span class='executed'>        poolStructs.lower = getTick(lower);</span>
 319 | *   | <span class='executed'>        poolStructs.upper = getTick(upper);</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='neutral'>        // pool price and liquidity</span>
 322 | *   | <span class='executed'>        poolValues.price0Before = poolStructs.pool0.price;</span>
 323 | *   | <span class='executed'>        poolValues.liquidity0Before = poolStructs.pool0.liquidity;</span>
 324 | *   | <span class='executed'>        poolValues.price1Before = poolStructs.pool1.price;</span>
 325 | *   | <span class='executed'>        poolValues.liquidity1Before = poolStructs.pool1.liquidity;</span>
 326 | *   | <span class='executed'>        poolValues.liquidityGlobalBefore = poolStructs.state.liquidityGlobal;</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='neutral'>        // tick values</span>
 329 | *   | <span class='executed'>        values.liquidityDeltaLowerBefore = poolStructs.lower.liquidityDelta;</span>
 330 | *   | <span class='executed'>        values.liquidityDeltaUpperBefore = poolStructs.upper.liquidityDelta;</span>
 331 | *   | <span class='executed'>        poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;</span>
 332 | *   | <span class='executed'>        poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;</span>
 333 |     | <span class='neutral'></span>
 334 | *   | <span class='executed'>        ICoverPool.MintParams memory params;</span>
 335 | *   | <span class='executed'>        params.to = msg.sender;</span>
 336 | *   | <span class='executed'>        params.amount = amount;</span>
 337 | *   | <span class='executed'>        params.lower = lower;</span>
 338 | *   | <span class='executed'>        params.upper = upper;</span>
 339 | *   | <span class='executed'>        params.zeroForOne = zeroForOne;</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='neutral'>        // Get the ticks the position will be minted with rather than what was passed directly by fuzzer</span>
 342 |     | <span class='neutral'>        // This is so the we can properly compare before and after mint states of particular ticks.</span>
 343 | *   | <span class='executed'>        bool posCreated;</span>
 344 | *   | <span class='executed'>        (lower, upper, posCreated) = pool.getResizedTicksForMint(params);</span>
 345 | *   | <span class='executed'>        emit PositionTicks(lower, upper);</span>
 346 | *   | <span class='executed'>        emit PositionCreated(posCreated);</span>
 347 |     | <span class='neutral'></span>
 348 |     | <span class='neutral'>        // ACTION </span>
 349 | *r  | <span class='executed'>        pool.mint(params);</span>
 350 | *   | <span class='executed'>        if (posCreated) positions.push(Position(msg.sender, poolValues.positionIdNextBefore, lower, upper, zeroForOne));</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>        // pool price and liquidity</span>
 353 | *   | <span class='executed'>        poolValues.price0After = poolStructs.pool0.price;</span>
 354 | *   | <span class='executed'>        poolValues.liquidity0After = poolStructs.pool0.liquidity;</span>
 355 | *   | <span class='executed'>        poolValues.price1After = poolStructs.pool1.price;</span>
 356 | *   | <span class='executed'>        poolValues.liquidity1After = poolStructs.pool1.liquidity;</span>
 357 | *   | <span class='executed'>        poolValues.liquidityGlobalAfter = poolStructs.state.liquidityGlobal;</span>
 358 |     | <span class='neutral'></span>
 359 |     | <span class='neutral'>        // tick values</span>
 360 | *   | <span class='executed'>        values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;</span>
 361 | *   | <span class='executed'>        values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;</span>
 362 | *   | <span class='executed'>        poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;</span>
 363 | *   | <span class='executed'>        poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>        // POST CONDITIONS</span>
 366 |     | <span class='neutral'></span>
 367 |     | <span class='neutral'>        // Ensure prices have not crossed</span>
 368 | *   | <span class='executed'>        emit Prices(poolValues.price0After, poolValues.price1After);</span>
 369 | *   | <span class='executed'>        assert(poolValues.price0After &lt;= poolValues.price1After);</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>        // Ensure liquidityDelta is always less or equal to amountOutDeltaMaxMinus</span>
 372 | *   | <span class='executed'>        if(zeroForOne){</span>
 373 | *   | <span class='executed'>            emit AmountInDeltaMaxMinus(poolValues.amountOutDeltaMaxMinusLowerBefore, poolValues.amountOutDeltaMaxMinusLowerAfter);</span>
 374 | *   | <span class='executed'>            assert(poolValues.amountOutDeltaMaxMinusLowerAfter &gt;= poolValues.amountOutDeltaMaxMinusLowerBefore);</span>
 375 | *   | <span class='executed'>            emit AmountOutDeltaMaxMinus(poolValues.amountOutDeltaMaxMinusLowerBefore, poolValues.amountOutDeltaMaxMinusLowerAfter);</span>
 376 | *   | <span class='executed'>            assert(poolValues.amountOutDeltaMaxMinusLowerAfter &gt;= poolValues.amountOutDeltaMaxMinusLowerBefore);</span>
 377 |     | <span class='neutral'>        } else {</span>
 378 | *   | <span class='executed'>            emit AmountInDeltaMaxMinus(poolValues.amountOutDeltaMaxMinusUpperBefore, poolValues.amountOutDeltaMaxMinusUpperAfter);</span>
 379 | *   | <span class='executed'>            assert(poolValues.amountOutDeltaMaxMinusUpperAfter &gt;= poolValues.amountOutDeltaMaxMinusUpperBefore);</span>
 380 | *   | <span class='executed'>            emit AmountOutDeltaMaxMinus(poolValues.amountOutDeltaMaxMinusUpperBefore, poolValues.amountOutDeltaMaxMinusUpperAfter);</span>
 381 | *   | <span class='executed'>            assert(poolValues.amountOutDeltaMaxMinusUpperAfter &gt;= poolValues.amountOutDeltaMaxMinusUpperBefore);</span>
 382 |     | <span class='neutral'>        }</span>
 383 |     | <span class='neutral'></span>
 384 | *   | <span class='executed'>        if (posCreated) {</span>
 385 | *   | <span class='executed'>            emit PositionTicks(lower, upper);</span>
 386 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
 387 | *   | <span class='executed'>            assert(lower &lt; upper);</span>
 388 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
 389 | *   | <span class='executed'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
 390 |     | <span class='neutral'>        }</span>
 391 |     | <span class='neutral'>        </span>
 392 | *   | <span class='executed'>        emit LiquidityGlobal(poolValues.liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 393 | *   | <span class='executed'>        emit Liquidity(poolValues.liquidity0Before, poolValues.liquidity1Before, poolValues.liquidity0After, poolValues.liquidity1After);</span>
 394 |     | <span class='neutral'>        </span>
 395 |     | <span class='neutral'>        // Ensure liquidityGlobal is incremented after mint</span>
 396 | *   | <span class='executed'>        assert(poolValues.liquidityGlobalAfter &gt;= poolValues.liquidityGlobalBefore);</span>
 397 |     | <span class='neutral'></span>
 398 |     | <span class='neutral'>        // Ensure pool liquidity is non-zero after mint with no undercuts</span>
 399 |     | <span class='neutral'>        // if (zeroForOne) {</span>
 400 |     | <span class='neutral'>        //     if (poolValues.price0After &lt; poolValues.price0Before) assert(poolValues.liquidity0After &gt; 0);</span>
 401 |     | <span class='neutral'>        // }</span>
 402 |     | <span class='neutral'>        // else {</span>
 403 |     | <span class='neutral'>        //     if (poolValues.price1After &gt; poolValues.price1Before) assert(poolValues.liquidity1After &gt; 0);</span>
 404 |     | <span class='neutral'>        // }</span>
 405 |     | <span class='neutral'>    }</span>
 406 |     | <span class='neutral'></span>
 407 | *   | <span class='executed'>    function swap(uint160 priceLimit, uint128 amount, bool zeroForOne) public {</span>
 408 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 409 | *   | <span class='executed'>        mintAndApprove();</span>
 410 |     | <span class='neutral'></span>
 411 | *   | <span class='executed'>        CoverPoolStructs.SwapParams memory params;</span>
 412 | *   | <span class='executed'>        params.to = msg.sender;</span>
 413 | *   | <span class='executed'>        params.priceLimit = priceLimit;</span>
 414 | *   | <span class='executed'>        params.amount = amount;</span>
 415 | *   | <span class='executed'>        params.exactIn = true; // TODO: exactIn always true for now</span>
 416 | *   | <span class='executed'>        params.zeroForOne = zeroForOne;</span>
 417 | *   | <span class='executed'>        params.callbackData = abi.encodePacked(address(this));</span>
 418 |     | <span class='neutral'>        </span>
 419 |     | <span class='neutral'>        // ACTION</span>
 420 | *r  | <span class='executed'>        pool.swap(params);</span>
 421 |     | <span class='neutral'></span>
 422 |     | <span class='neutral'>        // POST CONDITIONS</span>
 423 | *   | <span class='executed'>        CoverPoolStructs.PoolState memory pool0 = getPoolState(true);</span>
 424 | *   | <span class='executed'>        CoverPoolStructs.PoolState memory pool1 = getPoolState(false);</span>
 425 | *   | <span class='executed'>        uint160 price0 = pool0.price;</span>
 426 | *   | <span class='executed'>        uint160 price1 = pool1.price;</span>
 427 |     | <span class='neutral'>        </span>
 428 |     | <span class='neutral'>        // Ensure prices never cross</span>
 429 | *   | <span class='executed'>        emit Prices(price0, price1);</span>
 430 | *   | <span class='executed'>        assert(price0 &lt;= price1);</span>
 431 |     | <span class='neutral'>    }</span>
 432 |     | <span class='neutral'></span>
 433 | *   | <span class='executed'>    function syncTick(int24 newLatestTick, bool autoSync) public  {</span>
 434 | *   | <span class='executed'>        UniswapV3PoolMock(poolMock).setTickCumulatives(</span>
 435 | *   | <span class='executed'>            newLatestTick * 10,</span>
 436 | *   | <span class='executed'>            newLatestTick * 8,</span>
 437 | *   | <span class='executed'>            newLatestTick * 7,</span>
 438 | *   | <span class='executed'>            newLatestTick * 5</span>
 439 |     | <span class='neutral'>        );</span>
 440 |     | <span class='neutral'></span>
 441 | *   | <span class='executed'>        if (autoSync) {</span>
 442 |     | <span class='neutral'>            // quote of 0 should start at new tick</span>
 443 |     | <span class='neutral'>            //TODO: find new latest tick based on auction depth</span>
 444 | *   | <span class='executed'>            CoverPoolStructs.SwapParams memory params;</span>
 445 | *   | <span class='executed'>            params.to = msg.sender;</span>
 446 | *   | <span class='executed'>            params.priceLimit = 0;</span>
 447 | *   | <span class='executed'>            params.amount = 0;</span>
 448 | *   | <span class='executed'>            params.exactIn = true;</span>
 449 | *   | <span class='executed'>            params.zeroForOne = true;</span>
 450 | *   | <span class='executed'>            params.callbackData = abi.encodePacked(address(this));</span>
 451 |     | <span class='neutral'>        </span>
 452 |     | <span class='neutral'>            // ACTION</span>
 453 | *   | <span class='executed'>            pool.swap(params);</span>
 454 |     | <span class='neutral'></span>
 455 |     | <span class='neutral'>            // POST CONDITIONS</span>
 456 |     | <span class='neutral'>            //TODO: find new latest tick based on auction depth</span>
 457 |     | <span class='neutral'>            //new latestTick should match</span>
 458 |     | <span class='neutral'>            //if there was liquidity delta on that tick it should be unlocked</span>
 459 |     | <span class='neutral'>            //amountInDelta should be zeroed out if tick moved</span>
 460 | *   | <span class='executed'>            PoolStructs memory poolStructs;</span>
 461 | *   | <span class='executed'>            poolStructs.pool0 = getPoolState(true);</span>
 462 | *   | <span class='executed'>            poolStructs.pool1 = getPoolState(false);</span>
 463 | *   | <span class='executed'>            poolStructs.state = getGlobalState();</span>
 464 | *   | <span class='executed'>            emit Prices(poolStructs.pool0.price, poolStructs.pool1.price);</span>
 465 | *   | <span class='executed'>            assert(poolStructs.pool0.price &lt;= poolStructs.pool1.price);</span>
 466 |     | <span class='neutral'>        }</span>
 467 |     | <span class='neutral'>    }</span>
 468 |     | <span class='neutral'></span>
 469 | *   | <span class='executed'>    function burn(int24 claimAt, uint256 positionIndex, uint128 burnPercent) public {</span>
 470 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 471 | *   | <span class='executed'>        positionIndex = positionIndex % positions.length;</span>
 472 | *   | <span class='executed'>        Position memory pos = positions[positionIndex];</span>
 473 | *r  | <span class='executed'>        require(claimAt &gt;= pos.lower &amp;&amp; claimAt &lt;= pos.upper);</span>
 474 | *r  | <span class='executed'>        require(claimAt % tickSpacing == 0);</span>
 475 | *   | <span class='executed'>        PoolStructs memory poolStructs;</span>
 476 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 477 |     | <span class='neutral'></span>
 478 | *   | <span class='executed'>        poolStructs.pool0 = getPoolState(true);</span>
 479 | *   | <span class='executed'>        poolStructs.pool1 = getPoolState(false);</span>
 480 | *   | <span class='executed'>        poolStructs.state = getGlobalState();</span>
 481 | *   | <span class='executed'>        poolStructs.lower = getTick(pos.lower);</span>
 482 | *   | <span class='executed'>        poolStructs.upper = getTick(pos.upper);</span>
 483 |     | <span class='neutral'></span>
 484 | *   | <span class='executed'>        ICoverPool.BurnParams memory params;</span>
 485 | *   | <span class='executed'>        params.to = pos.owner;</span>
 486 | *   | <span class='executed'>        params.burnPercent = burnPercent == 1e38 ? burnPercent : _between(burnPercent, 1e36, 1e38); //1e38;</span>
 487 | *   | <span class='executed'>        params.positionId = pos.positionId;</span>
 488 | *   | <span class='executed'>        params.claim = claimAt;</span>
 489 | *   | <span class='executed'>        params.zeroForOne = pos.zeroForOne;</span>
 490 |     | <span class='neutral'></span>
 491 | *   | <span class='executed'>        poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;</span>
 492 | *   | <span class='executed'>        poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;</span>
 493 | *   | <span class='executed'>        poolValues.liquidityGlobalBefore = poolStructs.state.liquidityGlobal;</span>
 494 |     | <span class='neutral'>        </span>
 495 | *   | <span class='executed'>        emit PositionTicks(pos.lower, pos.upper);</span>
 496 | *   | <span class='executed'>        (int24 lower, int24 upper, bool positionExists) = pool.getResizedTicksForBurn(params);</span>
 497 | *   | <span class='executed'>        emit BurnTicks(lower, upper, positionExists);</span>
 498 |     | <span class='neutral'></span>
 499 |     | <span class='neutral'>        // ACTION</span>
 500 | *r  | <span class='executed'>        pool.burn(params);</span>
 501 |     | <span class='unexecuted'>        if (!positionExists) {</span>
 502 |     | <span class='unexecuted'>            positions[positionIndex] = positions[positions.length - 1];</span>
 503 |     | <span class='unexecuted'>            delete positions[positions.length - 1];</span>
 504 |     | <span class='neutral'>        }</span>
 505 |     | <span class='neutral'>        else {</span>
 506 |     | <span class='neutral'>            // Update position data in array if not fully burned</span>
 507 |     | <span class='unexecuted'>            positions[positionIndex] = Position(pos.owner, pos.positionId, lower, upper, pos.zeroForOne);</span>
 508 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
 509 |     | <span class='unexecuted'>            assert(lower &lt; upper);</span>
 510 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
 511 |     | <span class='unexecuted'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
 512 |     | <span class='neutral'>        }</span>
 513 |     | <span class='neutral'></span>
 514 |     | <span class='unexecuted'>        poolStructs.pool0 = getPoolState(true);</span>
 515 |     | <span class='unexecuted'>        poolStructs.pool1 = getPoolState(false);</span>
 516 |     | <span class='unexecuted'>        poolStructs.state = getGlobalState();</span>
 517 |     | <span class='unexecuted'>        poolStructs.lower = getTick(pos.lower);</span>
 518 |     | <span class='unexecuted'>        poolStructs.upper = getTick(pos.upper);</span>
 519 |     | <span class='neutral'></span>
 520 |     | <span class='unexecuted'>        poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;</span>
 521 |     | <span class='unexecuted'>        poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;</span>
 522 |     | <span class='unexecuted'>        poolValues.liquidityGlobalAfter = poolStructs.state.liquidityGlobal;</span>
 523 |     | <span class='neutral'></span>
 524 |     | <span class='unexecuted'>        uint160 price0 = poolStructs.pool0.price;</span>
 525 |     | <span class='unexecuted'>        uint160 price1 = poolStructs.pool1.price;</span>
 526 |     | <span class='neutral'>        </span>
 527 |     | <span class='neutral'>        // POST CONDITIONS</span>
 528 |     | <span class='neutral'></span>
 529 |     | <span class='neutral'>        // Ensure prices never cross</span>
 530 |     | <span class='unexecuted'>        emit Prices(price0, price1);</span>
 531 |     | <span class='unexecuted'>        assert(price0 &lt;= price1);</span>
 532 |     | <span class='neutral'></span>
 533 |     | <span class='neutral'>        // Ensure liquidityGlobal is decremented after burn</span>
 534 |     | <span class='unexecuted'>        emit LiquidityGlobal(poolValues.liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 535 |     | <span class='unexecuted'>        assert((poolValues.liquidityGlobalAfter &lt;= poolValues.liquidityGlobalBefore));</span>
 536 |     | <span class='neutral'>    }</span>
 537 |     | <span class='neutral'></span>
 538 | *   | <span class='executed'>    function claim(int24 claimAt, uint256 positionIndex) public {</span>
 539 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 540 | *   | <span class='executed'>        positionIndex = positionIndex % positions.length;</span>
 541 | *   | <span class='executed'>        Position memory pos = positions[positionIndex];</span>
 542 | *   | <span class='executed'>        claimAt = pos.lower + (claimAt % (pos.upper - pos.lower));</span>
 543 | *r  | <span class='executed'>        require(claimAt % tickSpacing == 0);</span>
 544 |     | <span class='neutral'></span>
 545 |     | <span class='neutral'>        // PoolValues memory poolValues;</span>
 546 | *   | <span class='executed'>        PoolStructs memory poolStructs;</span>
 547 |     | <span class='neutral'></span>
 548 | *   | <span class='executed'>        poolStructs.pool0 = getPoolState(true);</span>
 549 | *   | <span class='executed'>        poolStructs.pool1 = getPoolState(false);</span>
 550 | *   | <span class='executed'>        poolStructs.state = getGlobalState();</span>
 551 | *   | <span class='executed'>        poolStructs.lower = getTick(pos.lower);</span>
 552 | *   | <span class='executed'>        poolStructs.upper = getTick(pos.upper);</span>
 553 |     | <span class='neutral'></span>
 554 | *   | <span class='executed'>        ICoverPool.BurnParams memory params;</span>
 555 | *   | <span class='executed'>        params.to = pos.owner;</span>
 556 | *   | <span class='executed'>        params.burnPercent = 0;</span>
 557 | *   | <span class='executed'>        params.positionId = pos.positionId;</span>
 558 | *   | <span class='executed'>        params.claim = claimAt;</span>
 559 | *   | <span class='executed'>        params.zeroForOne = pos.zeroForOne;</span>
 560 |     | <span class='neutral'>        </span>
 561 | *   | <span class='executed'>        emit PositionTicks(pos.lower, pos.upper);</span>
 562 | *   | <span class='executed'>        (int24 lower, int24 upper, bool positionExists) = pool.getResizedTicksForBurn(params);</span>
 563 | *   | <span class='executed'>        emit BurnTicks(lower, upper, positionExists);</span>
 564 |     | <span class='neutral'></span>
 565 |     | <span class='neutral'>        // ACTION</span>
 566 | *r  | <span class='executed'>        pool.burn(params);</span>
 567 |     | <span class='unexecuted'>        if (!positionExists) {</span>
 568 |     | <span class='unexecuted'>            positions[positionIndex] = positions[positions.length - 1];</span>
 569 |     | <span class='unexecuted'>            delete positions[positions.length - 1];</span>
 570 |     | <span class='neutral'>        }</span>
 571 |     | <span class='neutral'>        else {</span>
 572 |     | <span class='neutral'>            // Update position data in array if not fully burned</span>
 573 |     | <span class='unexecuted'>            positions[positionIndex] = Position(pos.owner, pos.positionId, lower, upper, pos.zeroForOne);</span>
 574 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
 575 |     | <span class='unexecuted'>            assert(lower &lt; upper);</span>
 576 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
 577 |     | <span class='unexecuted'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
 578 |     | <span class='neutral'>        }</span>
 579 |     | <span class='neutral'></span>
 580 |     | <span class='neutral'>        // POST CONDITIONS</span>
 581 |     | <span class='unexecuted'>        poolStructs.pool0 = getPoolState(true);</span>
 582 |     | <span class='unexecuted'>        poolStructs.pool1 = getPoolState(false);</span>
 583 |     | <span class='unexecuted'>        poolStructs.state = getGlobalState();</span>
 584 |     | <span class='unexecuted'>        poolStructs.lower = getTick(pos.lower);</span>
 585 |     | <span class='unexecuted'>        poolStructs.upper = getTick(pos.upper);</span>
 586 |     | <span class='neutral'></span>
 587 |     | <span class='unexecuted'>        uint160 price0 = poolStructs.pool0.price;</span>
 588 |     | <span class='unexecuted'>        uint160 price1 = poolStructs.pool1.price;</span>
 589 |     | <span class='neutral'></span>
 590 |     | <span class='neutral'>        // Ensure prices never cross</span>
 591 |     | <span class='unexecuted'>        emit Prices(price0, price1);</span>
 592 |     | <span class='unexecuted'>        assert(price0 &lt;= price1);</span>
 593 |     | <span class='neutral'>    }</span>
 594 |     | <span class='neutral'></span>
 595 | *   | <span class='executed'>    function mintThenBurnZeroLiquidityChangeVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {</span>
 596 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 597 | *   | <span class='executed'>        mintAndApprove();</span>
 598 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 599 | *   | <span class='executed'>        PoolStructs memory poolStructs;</span>
 600 | *   | <span class='executed'>        LiquidityDeltaValues memory values;</span>
 601 |     | <span class='neutral'></span>
 602 | *   | <span class='executed'>        poolStructs.pool0 = getPoolState(true);</span>
 603 | *   | <span class='executed'>        poolStructs.pool1 = getPoolState(false);</span>
 604 | *   | <span class='executed'>        poolStructs.state = getGlobalState();</span>
 605 | *   | <span class='executed'>        poolStructs.lower = getTick(lower);</span>
 606 | *   | <span class='executed'>        poolStructs.upper = getTick(upper);</span>
 607 |     | <span class='neutral'></span>
 608 | *   | <span class='executed'>        poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;</span>
 609 | *   | <span class='executed'>        poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;</span>
 610 |     | <span class='neutral'></span>
 611 |     | <span class='neutral'>        // ACTION </span>
 612 | *   | <span class='executed'>        mintVariable(amount, zeroForOne, lower, upper);</span>
 613 | *   | <span class='executed'>        emit PassedMint();</span>
 614 | *   | <span class='executed'>        burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);</span>
 615 |     | <span class='unexecuted'>        emit PassedBurn();</span>
 616 |     | <span class='neutral'></span>
 617 |     | <span class='neutral'>        // POST CONDITIONS</span>
 618 |     | <span class='unexecuted'>        poolStructs.pool0 = getPoolState(true);</span>
 619 |     | <span class='unexecuted'>        poolStructs.pool1 = getPoolState(false);</span>
 620 |     | <span class='unexecuted'>        poolStructs.state = getGlobalState();</span>
 621 |     | <span class='unexecuted'>        poolStructs.lower = getTick(lower);</span>
 622 |     | <span class='unexecuted'>        poolStructs.upper = getTick(upper);</span>
 623 |     | <span class='neutral'></span>
 624 |     | <span class='unexecuted'>        values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;</span>
 625 |     | <span class='unexecuted'>        values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;</span>
 626 |     | <span class='unexecuted'>        poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;</span>
 627 |     | <span class='unexecuted'>        poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;</span>
 628 |     | <span class='neutral'></span>
 629 |     | <span class='unexecuted'>        uint160 price0After = poolStructs.pool0.price;</span>
 630 |     | <span class='unexecuted'>        uint160 price1After = poolStructs.pool1.price;</span>
 631 |     | <span class='unexecuted'>        poolValues.liquidityGlobalAfter = poolStructs.state.liquidityGlobal;</span>
 632 |     | <span class='neutral'></span>
 633 |     | <span class='neutral'>        // POST CONDITIONS</span>
 634 |     | <span class='neutral'></span>
 635 |     | <span class='neutral'>        // Ensure prices never cross</span>
 636 |     | <span class='unexecuted'>        emit Prices(price0After, price1After);</span>
 637 |     | <span class='unexecuted'>        assert(price0After &lt;= price1After);</span>
 638 |     | <span class='neutral'></span>
 639 |     | <span class='neutral'>        // Ensure liquidityGlobal is decremented after burn</span>
 640 |     | <span class='neutral'>        // emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 641 |     | <span class='neutral'>        // assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);</span>
 642 |     | <span class='neutral'>    }</span>
 643 |     | <span class='neutral'></span>
 644 | *   | <span class='executed'>    function mintThenBurnZeroLiquidityChange(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {</span>
 645 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 646 | *   | <span class='executed'>        mintAndApprove();</span>
 647 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 648 | *   | <span class='executed'>        PoolStructs memory poolStructs;</span>
 649 | *   | <span class='executed'>        LiquidityDeltaValues memory values;</span>
 650 |     | <span class='neutral'></span>
 651 | *   | <span class='executed'>        poolStructs.pool0 = getPoolState(true);</span>
 652 | *   | <span class='executed'>        poolStructs.pool1 = getPoolState(false);</span>
 653 | *   | <span class='executed'>        poolStructs.state = getGlobalState();</span>
 654 | *   | <span class='executed'>        poolStructs.lower = getTick(lower);</span>
 655 | *   | <span class='executed'>        poolStructs.upper = getTick(upper);</span>
 656 |     | <span class='neutral'></span>
 657 | *   | <span class='executed'>        poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;</span>
 658 | *   | <span class='executed'>        poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;</span>
 659 |     | <span class='neutral'></span>
 660 |     | <span class='neutral'>        // ACTION </span>
 661 | *   | <span class='executed'>        mint(amount, zeroForOne, lower, upper);</span>
 662 | *   | <span class='executed'>        emit PassedMint();</span>
 663 | *   | <span class='executed'>        burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);</span>
 664 |     | <span class='unexecuted'>        emit PassedBurn();</span>
 665 |     | <span class='neutral'></span>
 666 |     | <span class='unexecuted'>        poolStructs.pool0 = getPoolState(true);</span>
 667 |     | <span class='unexecuted'>        poolStructs.pool1 = getPoolState(false);</span>
 668 |     | <span class='unexecuted'>        poolStructs.state = getGlobalState();</span>
 669 |     | <span class='unexecuted'>        poolStructs.lower = getTick(lower);</span>
 670 |     | <span class='unexecuted'>        poolStructs.upper = getTick(upper);</span>
 671 |     | <span class='neutral'></span>
 672 |     | <span class='unexecuted'>        values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;</span>
 673 |     | <span class='unexecuted'>        values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;</span>
 674 |     | <span class='unexecuted'>        poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;</span>
 675 |     | <span class='unexecuted'>        poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;</span>
 676 |     | <span class='neutral'></span>
 677 |     | <span class='unexecuted'>        uint160 price0After = poolStructs.pool0.price;</span>
 678 |     | <span class='unexecuted'>        uint160 price1After = poolStructs.pool1.price;</span>
 679 |     | <span class='neutral'>        </span>
 680 |     | <span class='neutral'>        // POST CONDITIONS</span>
 681 |     | <span class='neutral'></span>
 682 |     | <span class='neutral'>        // Ensure prices never cross</span>
 683 |     | <span class='unexecuted'>        emit Prices(price0After, price1After);</span>
 684 |     | <span class='unexecuted'>        assert(price0After &lt;= price1After);</span>
 685 |     | <span class='neutral'></span>
 686 |     | <span class='neutral'>        // Ensure liquidityGlobal is decremented after burn</span>
 687 |     | <span class='neutral'>        // emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 688 |     | <span class='neutral'>        // assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);</span>
 689 |     | <span class='neutral'>    }</span>
 690 |     | <span class='neutral'></span>
 691 | *   | <span class='executed'>    function mintThenPartialBurnTwiceLiquidityChange(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint128 percent) public tickPreconditions(lower, upper) {</span>
 692 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 693 | *   | <span class='executed'>        percent = 1 + (percent % (1e38 - 1));</span>
 694 | *   | <span class='executed'>        mintAndApprove();</span>
 695 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 696 | *   | <span class='executed'>        PoolStructs memory poolStructs;</span>
 697 | *   | <span class='executed'>        LiquidityDeltaValues memory values;</span>
 698 |     | <span class='neutral'></span>
 699 | *   | <span class='executed'>        poolStructs.pool0 = getPoolState(true);</span>
 700 | *   | <span class='executed'>        poolStructs.pool1 = getPoolState(false);</span>
 701 | *   | <span class='executed'>        poolStructs.state = getGlobalState();</span>
 702 | *   | <span class='executed'>        poolStructs.lower = getTick(lower);</span>
 703 | *   | <span class='executed'>        poolStructs.upper = getTick(upper);</span>
 704 |     | <span class='neutral'></span>
 705 | *   | <span class='executed'>        poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;</span>
 706 | *   | <span class='executed'>        poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;</span>
 707 |     | <span class='neutral'></span>
 708 |     | <span class='neutral'>        // ACTION </span>
 709 | *   | <span class='executed'>        mint(amount, zeroForOne, lower, upper);</span>
 710 | *   | <span class='executed'>        emit PassedMint();</span>
 711 | *   | <span class='executed'>        burn(zeroForOne ? lower : upper, positions.length - 1, percent);</span>
 712 |     | <span class='unexecuted'>        emit PassedBurn();</span>
 713 |     | <span class='unexecuted'>        burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);</span>
 714 |     | <span class='unexecuted'>        emit PassedBurn();</span>
 715 |     | <span class='neutral'></span>
 716 |     | <span class='unexecuted'>        poolStructs.pool0 = getPoolState(true);</span>
 717 |     | <span class='unexecuted'>        poolStructs.pool1 = getPoolState(false);</span>
 718 |     | <span class='unexecuted'>        poolStructs.state = getGlobalState();</span>
 719 |     | <span class='unexecuted'>        poolStructs.lower = getTick(lower);</span>
 720 |     | <span class='unexecuted'>        poolStructs.upper = getTick(upper);</span>
 721 |     | <span class='neutral'></span>
 722 |     | <span class='unexecuted'>        values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;</span>
 723 |     | <span class='unexecuted'>        values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;</span>
 724 |     | <span class='unexecuted'>        poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;</span>
 725 |     | <span class='unexecuted'>        poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;</span>
 726 |     | <span class='neutral'></span>
 727 |     | <span class='unexecuted'>        uint160 price0After = poolStructs.pool0.price;</span>
 728 |     | <span class='unexecuted'>        uint160 price1After = poolStructs.pool1.price;</span>
 729 |     | <span class='neutral'></span>
 730 |     | <span class='neutral'>        // POST CONDITIONS</span>
 731 |     | <span class='neutral'></span>
 732 |     | <span class='neutral'>        // Ensure prices never cross</span>
 733 |     | <span class='unexecuted'>        emit Prices(price0After, price1After);</span>
 734 |     | <span class='unexecuted'>        assert(price0After &lt;= price1After);</span>
 735 |     | <span class='neutral'></span>
 736 |     | <span class='neutral'>        // Ensure liquidityGlobal is decremented after burn</span>
 737 |     | <span class='neutral'>        // emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 738 |     | <span class='neutral'>        // assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);</span>
 739 |     | <span class='neutral'>    }</span>
 740 |     | <span class='neutral'></span>
 741 | *   | <span class='executed'>    function mintThenPartialBurnTwiceLiquidityChangeVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint128 percent) public tickPreconditions(lower, upper) {</span>
 742 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 743 | *   | <span class='executed'>        percent = 1 + (percent % (1e38 - 1));</span>
 744 | *   | <span class='executed'>        mintAndApprove();</span>
 745 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 746 | *   | <span class='executed'>        PoolStructs memory poolStructs;</span>
 747 | *   | <span class='executed'>        LiquidityDeltaValues memory values;</span>
 748 |     | <span class='neutral'></span>
 749 | *   | <span class='executed'>        poolStructs.pool0 = getPoolState(true);</span>
 750 | *   | <span class='executed'>        poolStructs.pool1 = getPoolState(false);</span>
 751 | *   | <span class='executed'>        poolStructs.state = getGlobalState();</span>
 752 | *   | <span class='executed'>        poolStructs.lower = getTick(lower);</span>
 753 | *   | <span class='executed'>        poolStructs.upper = getTick(upper);</span>
 754 |     | <span class='neutral'></span>
 755 | *   | <span class='executed'>        poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;</span>
 756 | *   | <span class='executed'>        poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;</span>
 757 |     | <span class='neutral'></span>
 758 |     | <span class='neutral'>        // ACTION </span>
 759 | *   | <span class='executed'>        mintVariable(amount, zeroForOne, lower, upper);</span>
 760 | *   | <span class='executed'>        emit PassedMint();</span>
 761 | *   | <span class='executed'>        burn(zeroForOne ? lower : upper, positions.length - 1, percent);</span>
 762 |     | <span class='unexecuted'>        emit PassedBurn();</span>
 763 |     | <span class='unexecuted'>        burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);</span>
 764 |     | <span class='unexecuted'>        emit PassedBurn();</span>
 765 |     | <span class='neutral'></span>
 766 |     | <span class='unexecuted'>        poolStructs.pool0 = getPoolState(true);</span>
 767 |     | <span class='unexecuted'>        poolStructs.pool1 = getPoolState(false);</span>
 768 |     | <span class='unexecuted'>        poolStructs.state = getGlobalState();</span>
 769 |     | <span class='unexecuted'>        poolStructs.lower = getTick(lower);</span>
 770 |     | <span class='unexecuted'>        poolStructs.upper = getTick(upper);</span>
 771 |     | <span class='neutral'></span>
 772 |     | <span class='unexecuted'>        values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;</span>
 773 |     | <span class='unexecuted'>        values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;</span>
 774 |     | <span class='unexecuted'>        poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;</span>
 775 |     | <span class='unexecuted'>        poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;</span>
 776 |     | <span class='neutral'></span>
 777 |     | <span class='unexecuted'>        uint160 price0After = poolStructs.pool0.price;</span>
 778 |     | <span class='unexecuted'>        uint160 price1After = poolStructs.pool1.price;</span>
 779 |     | <span class='neutral'>        </span>
 780 |     | <span class='neutral'>        // POST CONDITIONS</span>
 781 |     | <span class='neutral'></span>
 782 |     | <span class='neutral'>        // Ensure prices never cross</span>
 783 |     | <span class='unexecuted'>        emit Prices(price0After, price1After);</span>
 784 |     | <span class='unexecuted'>        assert(price0After &lt;= price1After);</span>
 785 |     | <span class='neutral'></span>
 786 |     | <span class='neutral'>        // Ensure liquidityGlobal is decremented after burn</span>
 787 |     | <span class='neutral'>        // emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 788 |     | <span class='neutral'>        // assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);</span>
 789 |     | <span class='neutral'>    }</span>
 790 |     | <span class='neutral'></span>
 791 | *   | <span class='executed'>    function coverPoolSwapCallback(</span>
 792 |     | <span class='neutral'>        int256 amount0Delta,</span>
 793 |     | <span class='neutral'>        int256 amount1Delta,</span>
 794 |     | <span class='neutral'>        bytes calldata data</span>
 795 |     | <span class='neutral'>    ) external {</span>
 796 | *   | <span class='executed'>        if (amount0Delta &lt; 0) {</span>
 797 | *   | <span class='executed'>            SafeTransfers.transferInto(address(token0), address(pool), uint256(-amount0Delta));</span>
 798 |     | <span class='neutral'>        } else {</span>
 799 | *   | <span class='executed'>            SafeTransfers.transferInto(address(token1), address(pool), uint256(-amount1Delta));</span>
 800 |     | <span class='neutral'>        }</span>
 801 |     | <span class='neutral'>        data;</span>
 802 |     | <span class='neutral'>    }</span>
 803 |     | <span class='neutral'></span>
 804 | *   | <span class='executed'>    function mintAndApprove() internal {</span>
 805 | *   | <span class='executed'>        tokenIn.mint(msg.sender, 100000000000 ether);</span>
 806 | *   | <span class='executed'>        tokenOut.mint(msg.sender, 100000000000 ether);</span>
 807 | *   | <span class='executed'>        tokenIn.mint(address(this), 100000000000 ether);</span>
 808 | *   | <span class='executed'>        tokenOut.mint(address(this), 100000000000 ether);</span>
 809 | *   | <span class='executed'>        tokenIn.approve(address(pool), type(uint256).max);</span>
 810 | *   | <span class='executed'>        tokenOut.approve(address(pool), type(uint256).max);</span>
 811 |     | <span class='neutral'>    }</span>
 812 |     | <span class='neutral'></span>
 813 | *   | <span class='executed'>    function _between(uint128 val, uint low, uint high) internal pure returns(uint128) {</span>
 814 | *   | <span class='executed'>        return uint128(low + (val % (high-low +1))); </span>
 815 |     | <span class='neutral'>    }</span>
 816 |     | <span class='neutral'></span>
 817 |     | <span class='neutral'>    function liquidityMintedBackcalculates(uint128 amount, bool zeroForOne, int24 lower, int24 upper) tickPreconditions(lower, upper) internal {</span>
 818 |     | <span class='neutral'>        // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation</span>
 819 |     | <span class='neutral'>        amount = amount + 1e5 + 1;</span>
 820 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory immutables = pool.immutables();</span>
 821 |     | <span class='neutral'>        uint256 priceLower = ConstantProduct.getPriceAtTick(lower, immutables);</span>
 822 |     | <span class='neutral'>        uint256 priceUpper = ConstantProduct.getPriceAtTick(upper, immutables);</span>
 823 |     | <span class='neutral'></span>
 824 |     | <span class='neutral'>        uint256 liquidityMinted = ConstantProduct.getLiquidityForAmounts(</span>
 825 |     | <span class='neutral'>            priceLower,</span>
 826 |     | <span class='neutral'>            priceUpper,</span>
 827 |     | <span class='neutral'>            zeroForOne ? priceLower : priceUpper,</span>
 828 |     | <span class='neutral'>            zeroForOne ? 0 : uint256(amount),</span>
 829 |     | <span class='neutral'>            zeroForOne ? uint256(amount) : 0</span>
 830 |     | <span class='neutral'>        );</span>
 831 |     | <span class='neutral'></span>
 832 |     | <span class='neutral'>        (uint256 token0Amount, uint256 token1Amount) = ConstantProduct.getAmountsForLiquidity(</span>
 833 |     | <span class='neutral'>            priceLower,</span>
 834 |     | <span class='neutral'>            priceUpper,</span>
 835 |     | <span class='neutral'>            zeroForOne ? priceLower : priceUpper,</span>
 836 |     | <span class='neutral'>            liquidityMinted,</span>
 837 |     | <span class='neutral'>            true</span>
 838 |     | <span class='neutral'>        );</span>
 839 |     | <span class='neutral'></span>
 840 |     | <span class='neutral'>        if(zeroForOne) {</span>
 841 |     | <span class='neutral'>            emit LiquidityMinted(amount, token0Amount, zeroForOne);</span>
 842 |     | <span class='neutral'>            assert(token0Amount &lt;= amount);</span>
 843 |     | <span class='neutral'>            </span>
 844 |     | <span class='neutral'>        }</span>
 845 |     | <span class='neutral'>        else {</span>
 846 |     | <span class='neutral'>            emit LiquidityMinted(amount, token1Amount, zeroForOne);</span>
 847 |     | <span class='neutral'>            assert(token1Amount &lt;= amount);</span>
 848 |     | <span class='neutral'>        }</span>
 849 |     | <span class='neutral'>    }</span>
 850 |     | <span class='neutral'></span>
 851 | *   | <span class='executed'>    function getTick(</span>
 852 |     | <span class='neutral'>        int24 tickIdx</span>
 853 |     | <span class='neutral'>    ) internal view returns (</span>
 854 | *   | <span class='executed'>        CoverPoolStructs.Tick memory tick</span>
 855 |     | <span class='neutral'>    ) {</span>
 856 | *   | <span class='executed'>        (</span>
 857 | *   | <span class='executed'>            tick.deltas0,</span>
 858 | *   | <span class='executed'>            tick.deltas1,</span>
 859 | *   | <span class='executed'>            tick.liquidityDelta,</span>
 860 | *   | <span class='executed'>            tick.amountInDeltaMaxMinus,</span>
 861 | *   | <span class='executed'>            tick.amountOutDeltaMaxMinus,</span>
 862 | *   | <span class='executed'>            tick.amountInDeltaMaxStashed,</span>
 863 | *   | <span class='executed'>            tick.amountOutDeltaMaxStashed,</span>
 864 | *   | <span class='executed'>            tick.pool0Stash</span>
 865 | *   | <span class='executed'>        ) = pool.ticks(tickIdx);</span>
 866 |     | <span class='neutral'>    }</span>
 867 |     | <span class='neutral'></span>
 868 | *   | <span class='executed'>    function getPoolState(</span>
 869 |     | <span class='neutral'>        bool isPool0</span>
 870 |     | <span class='neutral'>    ) internal view returns (</span>
 871 | *   | <span class='executed'>        CoverPoolStructs.PoolState memory poolState</span>
 872 |     | <span class='neutral'>    ) {</span>
 873 | *   | <span class='executed'>        (</span>
 874 | *   | <span class='executed'>            poolState.price,</span>
 875 | *   | <span class='executed'>            poolState.liquidity,</span>
 876 | *   | <span class='executed'>            poolState.amountInDelta,</span>
 877 | *   | <span class='executed'>            poolState.amountInDeltaMaxClaimed,</span>
 878 | *   | <span class='executed'>            poolState.amountOutDeltaMaxClaimed</span>
 879 | *   | <span class='executed'>        ) = isPool0 ? pool.pool0()</span>
 880 | *   | <span class='executed'>                    : pool.pool1();</span>
 881 |     | <span class='neutral'>    }</span>
 882 |     | <span class='neutral'></span>
 883 |     | <span class='neutral'></span>
 884 | *   | <span class='executed'>    function getGlobalState(</span>
 885 |     | <span class='neutral'>    ) internal view returns (</span>
 886 | *   | <span class='executed'>        CoverPoolStructs.GlobalState memory state</span>
 887 |     | <span class='neutral'>    ) {</span>
 888 | *   | <span class='executed'>        state = pool.getGlobalState();</span>
 889 |     | <span class='neutral'>    }</span>
 890 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/CoverPool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./interfaces/ICoverPool.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./interfaces/ICoverPoolManager.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./base/storage/CoverPoolStorage.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./base/storage/CoverPoolImmutables.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./interfaces/structs/PoolsharkStructs.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./utils/CoverPoolErrors.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./libraries/Epochs.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./libraries/pool/SwapCall.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./libraries/pool/QuoteCall.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./libraries/pool/MintCall.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;./libraries/pool/BurnCall.sol&#39;;</span>
  15 |     | <span class='neutral'>import &#39;./libraries/math/ConstantProduct.sol&#39;;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>/// @notice Poolshark Cover Pool Implementation</span>
  19 | *   | <span class='executed'>contract CoverPool is</span>
  20 |     | <span class='neutral'>    ICoverPool,</span>
  21 |     | <span class='neutral'>    CoverPoolStorage,</span>
  22 |     | <span class='neutral'>    CoverPoolImmutables</span>
  23 |     | <span class='neutral'>{</span>
  24 |     | <span class='unexecuted'>    address public immutable factory;</span>
  25 |     | <span class='unexecuted'>    address public immutable original;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    event SimulateMint(bytes b);</span>
  28 |     | <span class='neutral'>    event SimulateMint(bytes4 b);</span>
  29 |     | <span class='neutral'>    event SimulateMint(bool b);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    modifier ownerOnly() {</span>
  32 |     | <span class='unexecuted'>        _onlyOwner();</span>
  33 |     | <span class='neutral'>        _;</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    modifier lock() {</span>
  37 |     | <span class='unexecuted'>        _prelock();</span>
  38 |     | <span class='neutral'>        _;</span>
  39 |     | <span class='unexecuted'>        _postlock();</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>    constructor(</span>
  43 |     | <span class='neutral'>        address factory_</span>
  44 |     | <span class='neutral'>    ) {</span>
  45 |     | <span class='unexecuted'>        original = address(this);</span>
  46 |     | <span class='unexecuted'>        factory = factory_;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    function mint(</span>
  50 |     | <span class='neutral'>        MintParams memory params</span>
  51 |     | <span class='unexecuted'>    ) external override lock {</span>
  52 |     | <span class='unexecuted'>        MintCache memory cache = MintCache({</span>
  53 |     | <span class='unexecuted'>            state: globalState,</span>
  54 |     | <span class='unexecuted'>            position: CoverPosition(address(0),0,0,0,0,0,0,0),</span>
  55 |     | <span class='unexecuted'>            constants: immutables(),</span>
  56 |     | <span class='unexecuted'>            syncFees: SyncFees(0,0),</span>
  57 |     | <span class='unexecuted'>            liquidityMinted: 0,</span>
  58 |     | <span class='unexecuted'>            pool0: pool0,</span>
  59 |     | <span class='unexecuted'>            pool1: pool1</span>
  60 |     | <span class='neutral'>        });</span>
  61 |     | <span class='unexecuted'>        (</span>
  62 |     | <span class='unexecuted'>            cache.state,</span>
  63 |     | <span class='unexecuted'>            cache.syncFees,</span>
  64 |     | <span class='unexecuted'>            cache.pool0, </span>
  65 |     | <span class='unexecuted'>            cache.pool1</span>
  66 |     | <span class='unexecuted'>        ) = Epochs.syncLatest(</span>
  67 |     | <span class='unexecuted'>            ticks,</span>
  68 |     | <span class='unexecuted'>            tickMap,</span>
  69 |     | <span class='unexecuted'>            cache.pool0,</span>
  70 |     | <span class='unexecuted'>            cache.pool1,</span>
  71 |     | <span class='unexecuted'>            cache.state,</span>
  72 |     | <span class='unexecuted'>            cache.constants</span>
  73 |     | <span class='neutral'>        );</span>
  74 |     | <span class='unexecuted'>        cache = MintCall.perform(</span>
  75 |     | <span class='unexecuted'>            params,</span>
  76 |     | <span class='unexecuted'>            cache,</span>
  77 |     | <span class='unexecuted'>            tickMap,</span>
  78 |     | <span class='unexecuted'>            ticks,</span>
  79 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1</span>
  80 |     | <span class='neutral'>        );</span>
  81 |     | <span class='unexecuted'>        pool0 = cache.pool0;</span>
  82 |     | <span class='unexecuted'>        pool1 = cache.pool1;</span>
  83 |     | <span class='unexecuted'>        globalState = cache.state;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>    function burn(</span>
  87 |     | <span class='neutral'>        BurnParams memory params</span>
  88 |     | <span class='unexecuted'>    ) external override lock {</span>
  89 |     | <span class='unexecuted'>        if (params.to == address(0)) revert CollectToZeroAddress();</span>
  90 |     | <span class='unexecuted'>        BurnCache memory cache = BurnCache({</span>
  91 |     | <span class='unexecuted'>            state: globalState,</span>
  92 |     | <span class='unexecuted'>            position: CoverPosition(address(0),0,0,0,0,0,0,0),</span>
  93 |     | <span class='unexecuted'>            constants: immutables(),</span>
  94 |     | <span class='unexecuted'>            syncFees: SyncFees(0,0),</span>
  95 |     | <span class='unexecuted'>            pool0: pool0,</span>
  96 |     | <span class='unexecuted'>            pool1: pool1</span>
  97 |     | <span class='neutral'>        });</span>
  98 |     | <span class='unexecuted'>        if (params.sync)</span>
  99 |     | <span class='unexecuted'>            (</span>
 100 |     | <span class='unexecuted'>                cache.state,</span>
 101 |     | <span class='unexecuted'>                cache.syncFees,</span>
 102 |     | <span class='unexecuted'>                cache.pool0,</span>
 103 |     | <span class='unexecuted'>                cache.pool1</span>
 104 |     | <span class='unexecuted'>            ) = Epochs.syncLatest(</span>
 105 |     | <span class='unexecuted'>                ticks,</span>
 106 |     | <span class='unexecuted'>                tickMap,</span>
 107 |     | <span class='unexecuted'>                cache.pool0,</span>
 108 |     | <span class='unexecuted'>                cache.pool1,</span>
 109 |     | <span class='unexecuted'>                cache.state,</span>
 110 |     | <span class='unexecuted'>                cache.constants</span>
 111 |     | <span class='neutral'>        );</span>
 112 |     | <span class='unexecuted'>        cache = BurnCall.perform(</span>
 113 |     | <span class='unexecuted'>            params, </span>
 114 |     | <span class='unexecuted'>            cache, </span>
 115 |     | <span class='unexecuted'>            tickMap,</span>
 116 |     | <span class='unexecuted'>            ticks,</span>
 117 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1</span>
 118 |     | <span class='neutral'>        );</span>
 119 |     | <span class='unexecuted'>        pool0 = cache.pool0;</span>
 120 |     | <span class='unexecuted'>        pool1 = cache.pool1;</span>
 121 |     | <span class='unexecuted'>        globalState = cache.state;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>    function swap(</span>
 125 |     | <span class='neutral'>        SwapParams memory params</span>
 126 |     | <span class='neutral'>    ) external override lock returns (</span>
 127 |     | <span class='unexecuted'>        int256,</span>
 128 |     | <span class='unexecuted'>        int256</span>
 129 |     | <span class='neutral'>    ) </span>
 130 |     | <span class='neutral'>    {</span>
 131 |     | <span class='unexecuted'>        SwapCache memory cache;</span>
 132 |     | <span class='unexecuted'>        cache.pool0 = pool0;</span>
 133 |     | <span class='unexecuted'>        cache.pool1 = pool1;</span>
 134 |     | <span class='unexecuted'>        cache.state = globalState;</span>
 135 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
 136 |     | <span class='unexecuted'>        (</span>
 137 |     | <span class='unexecuted'>            cache.state,</span>
 138 |     | <span class='unexecuted'>            cache.syncFees,</span>
 139 |     | <span class='unexecuted'>            cache.pool0,</span>
 140 |     | <span class='unexecuted'>            cache.pool1</span>
 141 |     | <span class='unexecuted'>        ) = Epochs.syncLatest(</span>
 142 |     | <span class='unexecuted'>            ticks,</span>
 143 |     | <span class='unexecuted'>            tickMap,</span>
 144 |     | <span class='unexecuted'>            cache.pool0,</span>
 145 |     | <span class='unexecuted'>            cache.pool1,</span>
 146 |     | <span class='unexecuted'>            cache.state,</span>
 147 |     | <span class='unexecuted'>            immutables()</span>
 148 |     | <span class='neutral'>        );</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='unexecuted'>        return SwapCall.perform(</span>
 151 |     | <span class='unexecuted'>            params,</span>
 152 |     | <span class='unexecuted'>            cache,</span>
 153 |     | <span class='unexecuted'>            globalState,</span>
 154 |     | <span class='unexecuted'>            pool0,</span>
 155 |     | <span class='unexecuted'>            pool1</span>
 156 |     | <span class='neutral'>        );</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>    function quote(</span>
 160 |     | <span class='neutral'>        QuoteParams memory params</span>
 161 |     | <span class='neutral'>    ) external override returns (</span>
 162 |     | <span class='unexecuted'>        int256 inAmount,</span>
 163 |     | <span class='unexecuted'>        int256 outAmount,</span>
 164 |     | <span class='unexecuted'>        uint256 priceAfter</span>
 165 |     | <span class='neutral'>    ) {</span>
 166 |     | <span class='unexecuted'>        SwapCache memory cache;</span>
 167 |     | <span class='unexecuted'>        cache.pool0 = pool0;</span>
 168 |     | <span class='unexecuted'>        cache.pool1 = pool1;</span>
 169 |     | <span class='unexecuted'>        cache.state = globalState;</span>
 170 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
 171 |     | <span class='unexecuted'>        (</span>
 172 |     | <span class='unexecuted'>            cache.state,</span>
 173 |     | <span class='unexecuted'>            cache.syncFees,</span>
 174 |     | <span class='unexecuted'>            cache.pool0,</span>
 175 |     | <span class='unexecuted'>            cache.pool1</span>
 176 |     | <span class='unexecuted'>        ) = Epochs.simulateSync(</span>
 177 |     | <span class='unexecuted'>            ticks,</span>
 178 |     | <span class='unexecuted'>            tickMap,</span>
 179 |     | <span class='unexecuted'>            cache.pool0,</span>
 180 |     | <span class='unexecuted'>            cache.pool1,</span>
 181 |     | <span class='unexecuted'>            cache.state,</span>
 182 |     | <span class='unexecuted'>            cache.constants</span>
 183 |     | <span class='neutral'>        );</span>
 184 |     | <span class='unexecuted'>        return QuoteCall.perform(params, cache);</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='unexecuted'>    function snapshot(</span>
 188 |     | <span class='neutral'>       SnapshotParams memory params </span>
 189 |     | <span class='neutral'>    ) external view override returns (</span>
 190 |     | <span class='unexecuted'>        CoverPosition memory</span>
 191 |     | <span class='neutral'>    ) {</span>
 192 |     | <span class='unexecuted'>        return Positions.snapshot(</span>
 193 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1,</span>
 194 |     | <span class='unexecuted'>            ticks,</span>
 195 |     | <span class='unexecuted'>            tickMap,</span>
 196 |     | <span class='unexecuted'>            globalState,</span>
 197 |     | <span class='unexecuted'>            params.zeroForOne ? pool0 : pool1,</span>
 198 |     | <span class='unexecuted'>            UpdateParams(</span>
 199 |     | <span class='unexecuted'>                params.owner,</span>
 200 |     | <span class='unexecuted'>                params.owner,</span>
 201 |     | <span class='unexecuted'>                params.burnPercent,</span>
 202 |     | <span class='unexecuted'>                params.positionId,</span>
 203 |     | <span class='unexecuted'>                0, 0,</span>
 204 |     | <span class='unexecuted'>                params.claim,</span>
 205 |     | <span class='unexecuted'>                params.zeroForOne</span>
 206 |     | <span class='neutral'>            ),</span>
 207 |     | <span class='unexecuted'>            immutables()</span>
 208 |     | <span class='neutral'>        );</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='unexecuted'>    function fees(</span>
 212 |     | <span class='neutral'>        uint16 syncFee,</span>
 213 |     | <span class='neutral'>        uint16 fillFee,</span>
 214 |     | <span class='neutral'>        bool setFees</span>
 215 |     | <span class='neutral'>    ) external override ownerOnly returns (</span>
 216 |     | <span class='unexecuted'>        uint128 token0Fees,</span>
 217 |     | <span class='unexecuted'>        uint128 token1Fees</span>
 218 |     | <span class='unexecuted'>    ) {</span>
 219 |     | <span class='unexecuted'>        if (setFees) {</span>
 220 |     | <span class='unexecuted'>            globalState.syncFee = syncFee;</span>
 221 |     | <span class='unexecuted'>            globalState.fillFee = fillFee;</span>
 222 |     | <span class='neutral'>        }</span>
 223 |     | <span class='unexecuted'>        token0Fees = globalState.protocolFees.token0;</span>
 224 |     | <span class='unexecuted'>        token1Fees = globalState.protocolFees.token1;</span>
 225 |     | <span class='unexecuted'>        address feeTo = ICoverPoolManager(owner()).feeTo();</span>
 226 |     | <span class='unexecuted'>        globalState.protocolFees.token0 = 0;</span>
 227 |     | <span class='unexecuted'>        globalState.protocolFees.token1 = 0;</span>
 228 |     | <span class='unexecuted'>        SafeTransfers.transferOut(feeTo, token0(), token0Fees);</span>
 229 |     | <span class='unexecuted'>        SafeTransfers.transferOut(feeTo, token1(), token1Fees);</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='unexecuted'>     function getResizedTicksForMint(</span>
 233 |     | <span class='neutral'>        MintParams memory params</span>
 234 |     | <span class='unexecuted'>    ) external returns (int24 lower, int24 upper, bool positionCreated){</span>
 235 |     | <span class='unexecuted'>        MintCache memory cache;</span>
 236 |     | <span class='neutral'>        {</span>
 237 |     | <span class='unexecuted'>            cache.state = globalState;</span>
 238 |     | <span class='unexecuted'>            cache.constants = immutables();</span>
 239 |     | <span class='unexecuted'>            cache.pool0 = pool0;</span>
 240 |     | <span class='unexecuted'>            cache.pool1 = pool1;</span>
 241 |     | <span class='neutral'>        }</span>
 242 |     | <span class='unexecuted'>        (</span>
 243 |     | <span class='unexecuted'>            cache.state,</span>
 244 |     | <span class='unexecuted'>            cache.syncFees,</span>
 245 |     | <span class='unexecuted'>            cache.pool0,</span>
 246 |     | <span class='unexecuted'>            cache.pool1</span>
 247 |     | <span class='unexecuted'>        ) = Epochs.simulateSync(</span>
 248 |     | <span class='unexecuted'>            ticks,</span>
 249 |     | <span class='unexecuted'>            tickMap,</span>
 250 |     | <span class='unexecuted'>            cache.pool0,</span>
 251 |     | <span class='unexecuted'>            cache.pool1,</span>
 252 |     | <span class='unexecuted'>            cache.state,</span>
 253 |     | <span class='unexecuted'>            cache.constants</span>
 254 |     | <span class='neutral'>        );</span>
 255 |     | <span class='unexecuted'>        try MintCall.getResizedTicks(</span>
 256 |     | <span class='unexecuted'>            params,</span>
 257 |     | <span class='unexecuted'>            cache,</span>
 258 |     | <span class='unexecuted'>            tickMap,</span>
 259 |     | <span class='unexecuted'>            ticks,</span>
 260 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1</span>
 261 |     | <span class='neutral'>        ) {</span>
 262 |     | <span class='unexecuted'>        } catch (bytes memory data) {</span>
 263 |     | <span class='unexecuted'>            emit SimulateMint(data);</span>
 264 |     | <span class='unexecuted'>            bytes4 sig;</span>
 265 |     | <span class='neutral'>            assembly {</span>
 266 |     | <span class='unexecuted'>                sig := mload(add(data, 0x20))</span>
 267 |     | <span class='neutral'>            }</span>
 268 |     | <span class='neutral'>            </span>
 269 |     | <span class='neutral'>            // SimulateMint error</span>
 270 |     | <span class='unexecuted'>            if (sig == hex&quot;5cc1f67b&quot;) {</span>
 271 |     | <span class='unexecuted'>                (, lower, upper, positionCreated) = abi.decode(abi.encodePacked(bytes28(0), data),(bytes32,int24,int24,bool));</span>
 272 |     | <span class='neutral'>            }</span>
 273 |     | <span class='neutral'>            else {</span>
 274 |     | <span class='unexecuted'>                lower = -8388608;</span>
 275 |     | <span class='unexecuted'>                upper = -8388608;</span>
 276 |     | <span class='unexecuted'>                positionCreated = false;</span>
 277 |     | <span class='neutral'>            }</span>
 278 |     | <span class='neutral'>        }</span>
 279 |     | <span class='neutral'>    }</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='unexecuted'>    function getResizedTicksForBurn(</span>
 282 |     | <span class='neutral'>        BurnParams memory params</span>
 283 |     | <span class='unexecuted'>    ) external returns (int24 lower, int24 upper, bool positionExists){</span>
 284 |     | <span class='unexecuted'>        if (params.to == address(0)) revert CollectToZeroAddress();</span>
 285 |     | <span class='unexecuted'>        BurnCache memory cache;</span>
 286 |     | <span class='neutral'>        {</span>
 287 |     | <span class='unexecuted'>            cache.state = globalState;</span>
 288 |     | <span class='unexecuted'>            cache.constants = immutables();</span>
 289 |     | <span class='unexecuted'>            cache.pool0 = pool0;</span>
 290 |     | <span class='unexecuted'>            cache.pool1 = pool1;</span>
 291 |     | <span class='neutral'>        }</span>
 292 |     | <span class='unexecuted'>        (</span>
 293 |     | <span class='unexecuted'>            cache.state,</span>
 294 |     | <span class='unexecuted'>            cache.syncFees,</span>
 295 |     | <span class='unexecuted'>            cache.pool0,</span>
 296 |     | <span class='unexecuted'>            cache.pool1</span>
 297 |     | <span class='unexecuted'>        ) = Epochs.simulateSync(</span>
 298 |     | <span class='unexecuted'>            ticks,</span>
 299 |     | <span class='unexecuted'>            tickMap,</span>
 300 |     | <span class='unexecuted'>            cache.pool0,</span>
 301 |     | <span class='unexecuted'>            cache.pool1,</span>
 302 |     | <span class='unexecuted'>            cache.state,</span>
 303 |     | <span class='unexecuted'>            cache.constants</span>
 304 |     | <span class='neutral'>        );</span>
 305 |     | <span class='unexecuted'>        try BurnCall.getResizedTicks(</span>
 306 |     | <span class='unexecuted'>            params,</span>
 307 |     | <span class='unexecuted'>            cache,</span>
 308 |     | <span class='unexecuted'>            tickMap,</span>
 309 |     | <span class='unexecuted'>            ticks,</span>
 310 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1</span>
 311 |     | <span class='neutral'>        ) {</span>
 312 |     | <span class='unexecuted'>        } catch (bytes memory data) {</span>
 313 |     | <span class='unexecuted'>            bytes4 sig;</span>
 314 |     | <span class='neutral'>            assembly {</span>
 315 |     | <span class='unexecuted'>                sig := mload(add(data, 0x20))</span>
 316 |     | <span class='neutral'>            }</span>
 317 |     | <span class='neutral'>            // SimulateBurn error</span>
 318 |     | <span class='unexecuted'>            if (sig == hex&quot;97dd6e0a&quot;) {</span>
 319 |     | <span class='unexecuted'>                (, lower, upper, positionExists) = abi.decode(abi.encodePacked(bytes28(0), data),(bytes32,int24,int24,bool));</span>
 320 |     | <span class='neutral'>            }</span>
 321 |     | <span class='neutral'>             else {</span>
 322 |     | <span class='unexecuted'>                lower = -8388608;</span>
 323 |     | <span class='unexecuted'>                upper = -8388608;</span>
 324 |     | <span class='unexecuted'>                positionExists = false;</span>
 325 |     | <span class='neutral'>            }</span>
 326 |     | <span class='neutral'>        }</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='unexecuted'>    function getGlobalState() public view returns(</span>
 330 |     | <span class='unexecuted'>        GlobalState memory</span>
 331 |     | <span class='neutral'>    ) {</span>
 332 |     | <span class='unexecuted'>        return globalState;</span>
 333 |     | <span class='neutral'>    }</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='unexecuted'>    function immutables() public view returns (</span>
 336 |     | <span class='unexecuted'>        CoverImmutables memory</span>
 337 |     | <span class='neutral'>    ) {</span>
 338 |     | <span class='unexecuted'>        return CoverImmutables(</span>
 339 |     | <span class='unexecuted'>            ITwapSource(twapSource()),</span>
 340 |     | <span class='unexecuted'>            PriceBounds(minPrice(), maxPrice()),</span>
 341 |     | <span class='unexecuted'>            owner(),</span>
 342 |     | <span class='unexecuted'>            token0(),</span>
 343 |     | <span class='unexecuted'>            token1(),</span>
 344 |     | <span class='unexecuted'>            original,</span>
 345 |     | <span class='unexecuted'>            inputPool(),</span>
 346 |     | <span class='unexecuted'>            minAmountPerAuction(),</span>
 347 |     | <span class='unexecuted'>            genesisTime(),</span>
 348 |     | <span class='unexecuted'>            minPositionWidth(),</span>
 349 |     | <span class='unexecuted'>            tickSpread(),</span>
 350 |     | <span class='unexecuted'>            twapLength(),</span>
 351 |     | <span class='unexecuted'>            auctionLength(),</span>
 352 |     | <span class='unexecuted'>            blockTime(),</span>
 353 |     | <span class='unexecuted'>            token0Decimals(),</span>
 354 |     | <span class='unexecuted'>            token1Decimals(),</span>
 355 |     | <span class='unexecuted'>            minAmountLowerPriced()</span>
 356 |     | <span class='neutral'>        );</span>
 357 |     | <span class='neutral'>    }</span>
 358 |     | <span class='neutral'></span>
 359 |     | <span class='unexecuted'>    function priceBounds(</span>
 360 |     | <span class='neutral'>        int16 tickSpacing</span>
 361 |     | <span class='unexecuted'>    ) external pure returns (uint160, uint160) {</span>
 362 |     | <span class='unexecuted'>        return ConstantProduct.priceBounds(tickSpacing);</span>
 363 |     | <span class='neutral'>    }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='unexecuted'>    function _prelock() private {</span>
 366 |     | <span class='unexecuted'>        if (globalState.unlocked == 0) {</span>
 367 |     | <span class='unexecuted'>            globalState = Ticks.initialize(tickMap, pool0, pool1, globalState, immutables());</span>
 368 |     | <span class='neutral'>        }</span>
 369 |     | <span class='unexecuted'>        if (globalState.unlocked == 0) revert WaitUntilEnoughObservations();</span>
 370 |     | <span class='unexecuted'>        if (globalState.unlocked == 2) revert Locked();</span>
 371 |     | <span class='unexecuted'>        globalState.unlocked = 2;</span>
 372 |     | <span class='neutral'>    }</span>
 373 |     | <span class='neutral'></span>
 374 |     | <span class='unexecuted'>    function _postlock() private {</span>
 375 |     | <span class='unexecuted'>        globalState.unlocked = 1;</span>
 376 |     | <span class='neutral'>    }</span>
 377 |     | <span class='neutral'></span>
 378 |     | <span class='unexecuted'>    function _onlyOwner() private view {</span>
 379 |     | <span class='unexecuted'>        if (msg.sender != owner()) revert OwnerOnly();</span>
 380 |     | <span class='neutral'>    }</span>
 381 |     | <span class='neutral'>}</span>
 382 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/CoverPoolFactory.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./CoverPool.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./external/solady/LibClone.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./interfaces/structs/CoverPoolStructs.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./interfaces/ICoverPoolFactory.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./base/events/CoverPoolFactoryEvents.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./utils/CoverPoolErrors.sol&#39;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>contract CoverPoolFactory is </span>
  12 |     | <span class='neutral'>    ICoverPoolFactory,</span>
  13 |     | <span class='neutral'>    CoverPoolFactoryEvents,</span>
  14 |     | <span class='neutral'>    CoverPoolFactoryErrors,</span>
  15 |     | <span class='neutral'>    CoverPoolStructs</span>
  16 |     | <span class='neutral'>{</span>
  17 |     | <span class='neutral'>    using LibClone for address;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>    address immutable public owner;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    constructor(</span>
  22 |     | <span class='neutral'>        address _owner</span>
  23 |     | <span class='neutral'>    ) {</span>
  24 |     | <span class='unexecuted'>        owner = _owner;</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>    function createCoverPool(</span>
  28 |     | <span class='neutral'>        CoverPoolParams memory params</span>
  29 |     | <span class='unexecuted'>    ) external override returns (address pool) {</span>
  30 |     | <span class='neutral'>        // validate token pair</span>
  31 |     | <span class='unexecuted'>        if (params.tokenIn == params.tokenOut || params.tokenIn == address(0) || params.tokenOut == address(0)) {</span>
  32 |     | <span class='unexecuted'>            revert InvalidTokenAddress();</span>
  33 |     | <span class='neutral'>        }</span>
  34 |     | <span class='unexecuted'>        CoverImmutables memory constants;</span>
  35 |     | <span class='unexecuted'>        constants.owner = owner;</span>
  36 |     | <span class='neutral'>        // sort tokens by address</span>
  37 |     | <span class='unexecuted'>        constants.token0 = params.tokenIn &lt; params.tokenOut ? params.tokenIn : params.tokenOut;</span>
  38 |     | <span class='unexecuted'>        constants.token1 = params.tokenIn &lt; params.tokenOut ? params.tokenOut : params.tokenIn;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>        // validate erc20 decimals</span>
  41 |     | <span class='unexecuted'>        {</span>
  42 |     | <span class='unexecuted'>            uint8 token0Decimals = ERC20(constants.token0).decimals();</span>
  43 |     | <span class='unexecuted'>            uint8 token1Decimals = ERC20(constants.token1).decimals();</span>
  44 |     | <span class='unexecuted'>            if (token0Decimals &gt; 18 || token1Decimals &gt; 18</span>
  45 |     | <span class='unexecuted'>            || token0Decimals &lt; 6 || token1Decimals &lt; 6) {</span>
  46 |     | <span class='unexecuted'>                revert InvalidTokenDecimals();</span>
  47 |     | <span class='neutral'>            }</span>
  48 |     | <span class='unexecuted'>            constants.token0Decimals = token0Decimals;</span>
  49 |     | <span class='unexecuted'>            constants.token1Decimals = token1Decimals;</span>
  50 |     | <span class='neutral'>        }</span>
  51 |     | <span class='neutral'>    </span>
  52 |     | <span class='neutral'>        // get twap source</span>
  53 |     | <span class='unexecuted'>        {</span>
  54 |     | <span class='unexecuted'>            (</span>
  55 |     | <span class='unexecuted'>                address poolImpl,</span>
  56 |     | <span class='unexecuted'>                address twapSource</span>
  57 |     | <span class='unexecuted'>            ) = ICoverPoolManager(owner).poolTypes(params.poolType);</span>
  58 |     | <span class='unexecuted'>            if (poolImpl == address(0) || twapSource == address(0)) revert PoolTypeNotFound();</span>
  59 |     | <span class='unexecuted'>            constants.poolImpl = poolImpl;</span>
  60 |     | <span class='unexecuted'>            constants.source = ITwapSource(twapSource);</span>
  61 |     | <span class='neutral'>        }</span>
  62 |     | <span class='neutral'>        // get volatility tier config</span>
  63 |     | <span class='unexecuted'>        {</span>
  64 |     | <span class='unexecuted'>            VolatilityTier memory config = ICoverPoolManager(owner).volatilityTiers(</span>
  65 |     | <span class='unexecuted'>                params.poolType,</span>
  66 |     | <span class='unexecuted'>                params.feeTier,</span>
  67 |     | <span class='unexecuted'>                params.tickSpread,</span>
  68 |     | <span class='unexecuted'>                params.twapLength</span>
  69 |     | <span class='neutral'>            );</span>
  70 |     | <span class='unexecuted'>            if (config.auctionLength == 0) revert VolatilityTierNotSupported();</span>
  71 |     | <span class='unexecuted'>            constants.minAmountPerAuction = config.minAmountPerAuction;</span>
  72 |     | <span class='unexecuted'>            constants.auctionLength = config.auctionLength;</span>
  73 |     | <span class='unexecuted'>            constants.blockTime = config.blockTime;</span>
  74 |     | <span class='unexecuted'>            constants.minPositionWidth = config.minPositionWidth;</span>
  75 |     | <span class='unexecuted'>            constants.minAmountLowerPriced = config.minAmountLowerPriced;</span>
  76 |     | <span class='neutral'>        }</span>
  77 |     | <span class='neutral'>        // record genesis time</span>
  78 |     | <span class='unexecuted'>        constants.tickSpread = params.tickSpread;</span>
  79 |     | <span class='unexecuted'>        constants.twapLength = params.twapLength;</span>
  80 |     | <span class='unexecuted'>        constants.genesisTime   = uint32(block.timestamp);</span>
  81 |     | <span class='neutral'>        // get reference pool</span>
  82 |     | <span class='unexecuted'>        constants.inputPool  = ITwapSource(constants.source).getPool(constants.token0, constants.token1, params.feeTier);</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>        // generate key for pool</span>
  85 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(</span>
  86 |     | <span class='unexecuted'>                                    constants.token0,</span>
  87 |     | <span class='unexecuted'>                                    constants.token1,</span>
  88 |     | <span class='unexecuted'>                                    constants.source,</span>
  89 |     | <span class='unexecuted'>                                    constants.inputPool,</span>
  90 |     | <span class='unexecuted'>                                    constants.tickSpread,</span>
  91 |     | <span class='unexecuted'>                                    constants.twapLength</span>
  92 |     | <span class='neutral'>                                ));</span>
  93 |     | <span class='unexecuted'>        if (coverPools[key] != address(0)) {</span>
  94 |     | <span class='unexecuted'>            revert PoolAlreadyExists();</span>
  95 |     | <span class='neutral'>        }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>        (</span>
  98 |     | <span class='unexecuted'>            constants.bounds.min,</span>
  99 |     | <span class='unexecuted'>            constants.bounds.max</span>
 100 |     | <span class='unexecuted'>        ) = ICoverPool(constants.poolImpl).priceBounds(constants.tickSpread);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>        // launch pool and save address</span>
 103 |     | <span class='unexecuted'>        pool = constants.poolImpl.cloneDeterministic({</span>
 104 |     | <span class='unexecuted'>            salt: key,</span>
 105 |     | <span class='unexecuted'>            data: encodeCover(constants)</span>
 106 |     | <span class='neutral'>        });</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>        coverPools[key] = pool;</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='unexecuted'>        emit PoolCreated(</span>
 111 |     | <span class='unexecuted'>            pool,</span>
 112 |     | <span class='unexecuted'>            address(constants.source),</span>
 113 |     | <span class='unexecuted'>            constants.inputPool,</span>
 114 |     | <span class='unexecuted'>            constants.token0,</span>
 115 |     | <span class='unexecuted'>            constants.token1,</span>
 116 |     | <span class='unexecuted'>            constants.poolImpl,</span>
 117 |     | <span class='unexecuted'>            params.feeTier,</span>
 118 |     | <span class='unexecuted'>            params.tickSpread,</span>
 119 |     | <span class='unexecuted'>            params.twapLength</span>
 120 |     | <span class='neutral'>        );</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>    function getCoverPool(</span>
 124 |     | <span class='neutral'>        CoverPoolParams memory params</span>
 125 |     | <span class='unexecuted'>    ) external view override returns (address) {</span>
 126 |     | <span class='neutral'>        // set lexographical token address ordering</span>
 127 |     | <span class='unexecuted'>        address token0 = params.tokenIn &lt; params.tokenOut ? params.tokenIn : params.tokenOut;</span>
 128 |     | <span class='unexecuted'>        address token1 = params.tokenIn &lt; params.tokenOut ? params.tokenOut : params.tokenIn;</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>        (</span>
 131 |     | <span class='neutral'>            ,</span>
 132 |     | <span class='unexecuted'>            address source</span>
 133 |     | <span class='unexecuted'>        ) = ICoverPoolManager(owner).poolTypes(params.poolType);</span>
 134 |     | <span class='unexecuted'>        address inputPool  = ITwapSource(source).getPool(token0, token1, params.feeTier);</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>        // generate key for pool</span>
 137 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(</span>
 138 |     | <span class='unexecuted'>                                    token0,</span>
 139 |     | <span class='unexecuted'>                                    token1,</span>
 140 |     | <span class='unexecuted'>                                    source,</span>
 141 |     | <span class='unexecuted'>                                    inputPool,</span>
 142 |     | <span class='unexecuted'>                                    params.tickSpread,</span>
 143 |     | <span class='unexecuted'>                                    params.twapLength</span>
 144 |     | <span class='neutral'>                                ));</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>        return coverPools[key];</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='unexecuted'>    function encodeCover(</span>
 150 |     | <span class='neutral'>        CoverImmutables memory constants</span>
 151 |     | <span class='unexecuted'>    ) private pure returns (bytes memory) {</span>
 152 |     | <span class='unexecuted'>        bytes memory value1 = abi.encodePacked(</span>
 153 |     | <span class='unexecuted'>            constants.owner,</span>
 154 |     | <span class='unexecuted'>            constants.token0,</span>
 155 |     | <span class='unexecuted'>            constants.token1,</span>
 156 |     | <span class='unexecuted'>            constants.source,</span>
 157 |     | <span class='unexecuted'>            constants.inputPool,</span>
 158 |     | <span class='unexecuted'>            constants.bounds.min,</span>
 159 |     | <span class='unexecuted'>            constants.bounds.max</span>
 160 |     | <span class='neutral'>        );</span>
 161 |     | <span class='unexecuted'>        bytes memory value2 = abi.encodePacked(</span>
 162 |     | <span class='unexecuted'>            constants.minAmountPerAuction,</span>
 163 |     | <span class='unexecuted'>            constants.genesisTime,</span>
 164 |     | <span class='unexecuted'>            constants.minPositionWidth,</span>
 165 |     | <span class='unexecuted'>            constants.tickSpread,</span>
 166 |     | <span class='unexecuted'>            constants.twapLength,</span>
 167 |     | <span class='unexecuted'>            constants.auctionLength</span>
 168 |     | <span class='neutral'>        );</span>
 169 |     | <span class='unexecuted'>        bytes memory value3 = abi.encodePacked(</span>
 170 |     | <span class='unexecuted'>            constants.blockTime,</span>
 171 |     | <span class='unexecuted'>            constants.token0Decimals,</span>
 172 |     | <span class='unexecuted'>            constants.token1Decimals,</span>
 173 |     | <span class='unexecuted'>            constants.minAmountLowerPriced</span>
 174 |     | <span class='neutral'>        );</span>
 175 |     | <span class='unexecuted'>        return abi.encodePacked(value1, value2, value3);</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'>}</span>
 178 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/base/events/CoverPoolFactoryEvents.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract CoverPoolFactoryEvents {</span>
  5 |     | <span class='neutral'>    event PoolCreated(</span>
  6 |     | <span class='neutral'>        address pool,</span>
  7 |     | <span class='neutral'>        address indexed twapSource,</span>
  8 |     | <span class='neutral'>        address indexed inputPool,</span>
  9 |     | <span class='neutral'>        address token0,</span>
 10 |     | <span class='neutral'>        address token1,</span>
 11 |     | <span class='neutral'>        address indexed poolImpl,</span>
 12 |     | <span class='neutral'>        uint16 fee,</span>
 13 |     | <span class='neutral'>        int16 tickSpread,</span>
 14 |     | <span class='neutral'>        uint16 twapLength</span>
 15 |     | <span class='neutral'>    );</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/base/events/CoverPoolManagerEvents.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract CoverPoolManagerEvents {</span>
  5 |     | <span class='neutral'>    event FactoryChanged(address indexed previousFactory, address indexed newFactory);</span>
  6 |     | <span class='neutral'>    event VolatilityTierEnabled(</span>
  7 |     | <span class='neutral'>        address implAddress,</span>
  8 |     | <span class='neutral'>        uint16  feeTier,</span>
  9 |     | <span class='neutral'>        int16   tickSpread,</span>
 10 |     | <span class='neutral'>        uint16  twapLength,</span>
 11 |     | <span class='neutral'>        uint128 minAmountPerAuction,</span>
 12 |     | <span class='neutral'>        uint16  auctionLength,</span>
 13 |     | <span class='neutral'>        uint16  blockTime,</span>
 14 |     | <span class='neutral'>        uint16  syncFee,</span>
 15 |     | <span class='neutral'>        uint16  fillFee,</span>
 16 |     | <span class='neutral'>        int16   minPositionWidth,</span>
 17 |     | <span class='neutral'>        bool    minLowerPriced</span>
 18 |     | <span class='neutral'>    );</span>
 19 |     | <span class='neutral'>    event PoolTypeEnabled(</span>
 20 |     | <span class='neutral'>        bytes32 poolType,</span>
 21 |     | <span class='neutral'>        address implAddress,</span>
 22 |     | <span class='neutral'>        address sourceAddress,</span>
 23 |     | <span class='neutral'>        address factoryAddress</span>
 24 |     | <span class='neutral'>    );</span>
 25 |     | <span class='neutral'>    event FeeToTransfer(address indexed previousFeeTo, address indexed newFeeTo);</span>
 26 |     | <span class='neutral'>    event OwnerTransfer(address indexed previousOwner, address indexed newOwner);</span>
 27 |     | <span class='neutral'>    event ProtocolFeesModified(</span>
 28 |     | <span class='neutral'>        address[] modifyPools,</span>
 29 |     | <span class='neutral'>        uint16[] syncFees,</span>
 30 |     | <span class='neutral'>        uint16[] fillFees,</span>
 31 |     | <span class='neutral'>        bool[] setFees,</span>
 32 |     | <span class='neutral'>        uint128[] token0Fees,</span>
 33 |     | <span class='neutral'>        uint128[] token1Fees</span>
 34 |     | <span class='neutral'>    );</span>
 35 |     | <span class='neutral'>    event ProtocolFeesCollected(</span>
 36 |     | <span class='neutral'>        address[] collectPools,</span>
 37 |     | <span class='neutral'>        uint128[] token0Fees,</span>
 38 |     | <span class='neutral'>        uint128[] token1Fees</span>
 39 |     | <span class='neutral'>    );</span>
 40 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/base/storage/CoverPoolFactoryStorage.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract CoverPoolFactoryStorage {</span>
  5 |     | <span class='unexecuted'>    mapping(bytes32 =&gt; address) public coverPools;</span>
  6 |     | <span class='neutral'>}</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/base/storage/CoverPoolImmutables.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BSD</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import { Clone } from &quot;../../external/solady/Clone.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract CoverPoolImmutables is Clone {</span>
  7 |     | <span class='unexecuted'>    function owner() public pure returns (address) {</span>
  8 |     | <span class='unexecuted'>        return _getArgAddress(0);</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    function token0() public pure returns (address) {</span>
 12 |     | <span class='unexecuted'>        return _getArgAddress(20);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function token1() public pure returns (address) {</span>
 16 |     | <span class='unexecuted'>        return _getArgAddress(40);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function twapSource() public pure returns (address) {</span>
 20 |     | <span class='unexecuted'>        return _getArgAddress(60);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function inputPool() public pure returns (address) {</span>
 24 |     | <span class='unexecuted'>        return _getArgAddress(80);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function minPrice() public pure returns (uint160) {</span>
 28 |     | <span class='unexecuted'>        return _getArgUint160(100);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function maxPrice() public pure returns (uint160) {</span>
 32 |     | <span class='unexecuted'>        return _getArgUint160(120);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>    function minAmountPerAuction() public pure returns (uint128) {</span>
 36 |     | <span class='unexecuted'>        return _getArgUint128(140);</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>    function genesisTime() public pure returns (uint32) {</span>
 40 |     | <span class='unexecuted'>        return _getArgUint32(156);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>    function minPositionWidth() public pure returns (int16) {</span>
 44 |     | <span class='unexecuted'>        return int16(_getArgUint16(160));</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>    function tickSpread() public pure returns (int16) {</span>
 48 |     | <span class='unexecuted'>        return int16(_getArgUint16(162));</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>    function twapLength() public pure returns (uint16) {</span>
 52 |     | <span class='unexecuted'>        return _getArgUint16(164);</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='unexecuted'>    function auctionLength() public pure returns (uint16) {</span>
 56 |     | <span class='unexecuted'>        return _getArgUint16(166);</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>    function blockTime() public pure returns (uint16) {</span>
 60 |     | <span class='unexecuted'>        return _getArgUint16(168);</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='unexecuted'>    function token0Decimals() public pure returns (uint8) {</span>
 64 |     | <span class='unexecuted'>        return _getArgUint8(170);</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='unexecuted'>    function token1Decimals() public pure returns (uint8) {</span>
 68 |     | <span class='unexecuted'>        return _getArgUint8(171);</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='unexecuted'>    function minAmountLowerPriced() public pure returns (bool) {</span>
 72 |     | <span class='unexecuted'>        return _getArgUint8(172) &gt; 0;</span>
 73 |     | <span class='neutral'>    }</span>
 74 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/base/storage/CoverPoolStorage.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/structs/CoverPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../interfaces/ICoverPoolFactory.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../../utils/CoverPoolErrors.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>abstract contract CoverPoolStorage is CoverPoolStructs, CoverPoolErrors {</span>
  9 |     | <span class='unexecuted'>    GlobalState public globalState;</span>
 10 |     | <span class='unexecuted'>    PoolState public pool0; /// @dev pool with token0 liquidity</span>
 11 |     | <span class='unexecuted'>    PoolState public pool1; /// @dev pool with token1 liquidity</span>
 12 |     | <span class='unexecuted'>    TickMap public tickMap;</span>
 13 |     | <span class='unexecuted'>    mapping(int24 =&gt; Tick) public ticks; /// @dev price ticks with delta values</span>
 14 |     | <span class='unexecuted'>    mapping(uint256 =&gt; CoverPosition) public positions0; //positions with token0 deposited</span>
 15 |     | <span class='unexecuted'>    mapping(uint256 =&gt; CoverPosition) public positions1; //positions with token1 deposited</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/external/openzeppelin/contracts/token/ERC20/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./extensions/IERC20Metadata.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../utils/Context.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Implementation of the {IERC20} interface.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * This implementation is agnostic to the way tokens are created. This means</span>
  14 |     | <span class='neutral'> * that a supply mechanism has to be added in a derived contract using {_mint}.</span>
  15 |     | <span class='neutral'> * For a generic mechanism see {ERC20PresetMinterPauser}.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * TIP: For a detailed writeup see our guide</span>
  18 |     | <span class='neutral'> * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How</span>
  19 |     | <span class='neutral'> * to implement supply mechanisms].</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * We have followed general OpenZeppelin Contracts guidelines: functions revert</span>
  22 |     | <span class='neutral'> * instead returning `false` on failure. This behavior is nonetheless</span>
  23 |     | <span class='neutral'> * conventional and does not conflict with the expectations of ERC20</span>
  24 |     | <span class='neutral'> * applications.</span>
  25 |     | <span class='neutral'> *</span>
  26 |     | <span class='neutral'> * Additionally, an {Approval} event is emitted on calls to {transferFrom}.</span>
  27 |     | <span class='neutral'> * This allows applications to reconstruct the allowance for all accounts just</span>
  28 |     | <span class='neutral'> * by listening to said events. Other implementations of the EIP may not emit</span>
  29 |     | <span class='neutral'> * these events, as it isn&#39;t required by the specification.</span>
  30 |     | <span class='neutral'> *</span>
  31 |     | <span class='neutral'> * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}</span>
  32 |     | <span class='neutral'> * functions have been added to mitigate the well-known issues around setting</span>
  33 |     | <span class='neutral'> * allowances. See {IERC20-approve}.</span>
  34 |     | <span class='neutral'> */</span>
  35 |     | <span class='unexecuted'>contract ERC20 is Context, IERC20, IERC20Metadata {</span>
  36 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    string private _name;</span>
  43 |     | <span class='neutral'>    string private _symbol;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /**</span>
  46 |     | <span class='neutral'>     * @dev Sets the values for {name} and {symbol}.</span>
  47 |     | <span class='neutral'>     *</span>
  48 |     | <span class='neutral'>     * The default value of {decimals} is 18. To select a different value for</span>
  49 |     | <span class='neutral'>     * {decimals} you should overload it.</span>
  50 |     | <span class='neutral'>     *</span>
  51 |     | <span class='neutral'>     * All two of these values are immutable: they can only be set once during</span>
  52 |     | <span class='neutral'>     * construction.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='unexecuted'>    constructor(string memory name_, string memory symbol_) {</span>
  55 |     | <span class='unexecuted'>        _name = name_;</span>
  56 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='unexecuted'>    function name() public view virtual override returns (string memory) {</span>
  63 |     | <span class='unexecuted'>        return _name;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
  68 |     | <span class='neutral'>     * name.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='unexecuted'>    function symbol() public view virtual override returns (string memory) {</span>
  71 |     | <span class='unexecuted'>        return _symbol;</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
  76 |     | <span class='neutral'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
  77 |     | <span class='neutral'>     * be displayed to a user as `5.05` (`505 / 10 ** 2`).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
  80 |     | <span class='neutral'>     * Ether and Wei. This is the value {ERC20} uses, unless this function is</span>
  81 |     | <span class='neutral'>     * overridden;</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='neutral'>     * NOTE: This information is only used for _display_ purposes: it in</span>
  84 |     | <span class='neutral'>     * no way affects any of the arithmetic of the contract, including</span>
  85 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='unexecuted'>    function decimals() public view virtual override returns (uint8) {</span>
  88 |     | <span class='unexecuted'>        return 18;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev See {IERC20-totalSupply}.</span>
  93 |     | <span class='neutral'>     */</span>
  94 |     | <span class='unexecuted'>    function totalSupply() public view virtual override returns (uint256) {</span>
  95 |     | <span class='unexecuted'>        return _totalSupply;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev See {IERC20-balanceOf}.</span>
 100 |     | <span class='neutral'>     */</span>
 101 | *   | <span class='executed'>    function balanceOf(address account) public view virtual override returns (uint256) {</span>
 102 | *   | <span class='executed'>        return _balances[account];</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /**</span>
 106 |     | <span class='neutral'>     * @dev See {IERC20-transfer}.</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * Requirements:</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 111 |     | <span class='neutral'>     * - the caller must have a balance of at least `amount`.</span>
 112 |     | <span class='neutral'>     */</span>
 113 |     | <span class='unexecuted'>    function transfer(address to, uint256 amount) public virtual override returns (bool) {</span>
 114 |     | <span class='unexecuted'>        address owner = _msgSender();</span>
 115 |     | <span class='unexecuted'>        _transfer(owner, to, amount);</span>
 116 |     | <span class='unexecuted'>        return true;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @dev See {IERC20-allowance}.</span>
 121 |     | <span class='neutral'>     */</span>
 122 | *   | <span class='executed'>    function allowance(address owner, address spender) public view virtual override returns (uint256) {</span>
 123 | *   | <span class='executed'>        return _allowances[owner][spender];</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 128 |     | <span class='neutral'>     *</span>
 129 |     | <span class='neutral'>     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on</span>
 130 |     | <span class='neutral'>     * `transferFrom`. This is semantically equivalent to an infinite approval.</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * Requirements:</span>
 133 |     | <span class='neutral'>     *</span>
 134 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 135 |     | <span class='neutral'>     */</span>
 136 | *   | <span class='executed'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
 137 | *   | <span class='executed'>        address owner = _msgSender();</span>
 138 | *   | <span class='executed'>        _approve(owner, spender, amount);</span>
 139 | *   | <span class='executed'>        return true;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @dev See {IERC20-transferFrom}.</span>
 144 |     | <span class='neutral'>     *</span>
 145 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance. This is not</span>
 146 |     | <span class='neutral'>     * required by the EIP. See the note at the beginning of {ERC20}.</span>
 147 |     | <span class='neutral'>     *</span>
 148 |     | <span class='neutral'>     * NOTE: Does not update the allowance if the current allowance</span>
 149 |     | <span class='neutral'>     * is the maximum `uint256`.</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * Requirements:</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * - `from` and `to` cannot be the zero address.</span>
 154 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 155 |     | <span class='neutral'>     * - the caller must have allowance for ``from``&#39;s tokens of at least</span>
 156 |     | <span class='neutral'>     * `amount`.</span>
 157 |     | <span class='neutral'>     */</span>
 158 | *   | <span class='executed'>    function transferFrom(</span>
 159 |     | <span class='neutral'>        address from,</span>
 160 |     | <span class='neutral'>        address to,</span>
 161 |     | <span class='neutral'>        uint256 amount</span>
 162 | *   | <span class='executed'>    ) public virtual override returns (bool) {</span>
 163 | *   | <span class='executed'>        address spender = _msgSender();</span>
 164 | *   | <span class='executed'>        _spendAllowance(from, spender, amount);</span>
 165 | *   | <span class='executed'>        _transfer(from, to, amount);</span>
 166 | *   | <span class='executed'>        return true;</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>    /**</span>
 170 |     | <span class='neutral'>     * @dev Atomically increases the allowance granted to `spender` by the caller.</span>
 171 |     | <span class='neutral'>     *</span>
 172 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 173 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 176 |     | <span class='neutral'>     *</span>
 177 |     | <span class='neutral'>     * Requirements:</span>
 178 |     | <span class='neutral'>     *</span>
 179 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 180 |     | <span class='neutral'>     */</span>
 181 |     | <span class='unexecuted'>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {</span>
 182 |     | <span class='unexecuted'>        address owner = _msgSender();</span>
 183 |     | <span class='unexecuted'>        _approve(owner, spender, allowance(owner, spender) + addedValue);</span>
 184 |     | <span class='unexecuted'>        return true;</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    /**</span>
 188 |     | <span class='neutral'>     * @dev Atomically decreases the allowance granted to `spender` by the caller.</span>
 189 |     | <span class='neutral'>     *</span>
 190 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 191 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 194 |     | <span class='neutral'>     *</span>
 195 |     | <span class='neutral'>     * Requirements:</span>
 196 |     | <span class='neutral'>     *</span>
 197 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 198 |     | <span class='neutral'>     * - `spender` must have allowance for the caller of at least</span>
 199 |     | <span class='neutral'>     * `subtractedValue`.</span>
 200 |     | <span class='neutral'>     */</span>
 201 |     | <span class='unexecuted'>    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {</span>
 202 |     | <span class='unexecuted'>        address owner = _msgSender();</span>
 203 |     | <span class='unexecuted'>        uint256 currentAllowance = allowance(owner, spender);</span>
 204 |     | <span class='unexecuted'>        require(currentAllowance &gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;);</span>
 205 |     | <span class='neutral'>        unchecked {</span>
 206 |     | <span class='unexecuted'>            _approve(owner, spender, currentAllowance - subtractedValue);</span>
 207 |     | <span class='neutral'>        }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='unexecuted'>        return true;</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /**</span>
 213 |     | <span class='neutral'>     * @dev Moves `amount` of tokens from `from` to `to`.</span>
 214 |     | <span class='neutral'>     *</span>
 215 |     | <span class='neutral'>     * This internal function is equivalent to {transfer}, and can be used to</span>
 216 |     | <span class='neutral'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 217 |     | <span class='neutral'>     *</span>
 218 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 219 |     | <span class='neutral'>     *</span>
 220 |     | <span class='neutral'>     * Requirements:</span>
 221 |     | <span class='neutral'>     *</span>
 222 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 223 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 224 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 225 |     | <span class='neutral'>     */</span>
 226 | *   | <span class='executed'>    function _transfer(</span>
 227 |     | <span class='neutral'>        address from,</span>
 228 |     | <span class='neutral'>        address to,</span>
 229 |     | <span class='neutral'>        uint256 amount</span>
 230 | *   | <span class='executed'>    ) internal virtual {</span>
 231 | *   | <span class='executed'>        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span>
 232 | *   | <span class='executed'>        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span>
 233 |     | <span class='neutral'></span>
 234 | *   | <span class='executed'>        _beforeTokenTransfer(from, to, amount);</span>
 235 |     | <span class='neutral'></span>
 236 | *   | <span class='executed'>        uint256 fromBalance = _balances[from];</span>
 237 | *   | <span class='executed'>        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 238 |     | <span class='neutral'>        unchecked {</span>
 239 | *   | <span class='executed'>            _balances[from] = fromBalance - amount;</span>
 240 |     | <span class='neutral'>        }</span>
 241 | *   | <span class='executed'>        _balances[to] += amount;</span>
 242 |     | <span class='neutral'></span>
 243 | *   | <span class='executed'>        emit Transfer(from, to, amount);</span>
 244 |     | <span class='neutral'></span>
 245 | *   | <span class='executed'>        _afterTokenTransfer(from, to, amount);</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    /** @dev Creates `amount` tokens and assigns them to `account`, increasing</span>
 249 |     | <span class='neutral'>     * the total supply.</span>
 250 |     | <span class='neutral'>     *</span>
 251 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 252 |     | <span class='neutral'>     *</span>
 253 |     | <span class='neutral'>     * Requirements:</span>
 254 |     | <span class='neutral'>     *</span>
 255 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 256 |     | <span class='neutral'>     */</span>
 257 | *   | <span class='executed'>    function _mint(address account, uint256 amount) internal virtual {</span>
 258 | *   | <span class='executed'>        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span>
 259 |     | <span class='neutral'></span>
 260 | *   | <span class='executed'>        _beforeTokenTransfer(address(0), account, amount);</span>
 261 |     | <span class='neutral'></span>
 262 | *   | <span class='executed'>        _totalSupply += amount;</span>
 263 | *   | <span class='executed'>        _balances[account] += amount;</span>
 264 | *   | <span class='executed'>        emit Transfer(address(0), account, amount);</span>
 265 |     | <span class='neutral'></span>
 266 | *   | <span class='executed'>        _afterTokenTransfer(address(0), account, amount);</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>    /**</span>
 270 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, reducing the</span>
 271 |     | <span class='neutral'>     * total supply.</span>
 272 |     | <span class='neutral'>     *</span>
 273 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 274 |     | <span class='neutral'>     *</span>
 275 |     | <span class='neutral'>     * Requirements:</span>
 276 |     | <span class='neutral'>     *</span>
 277 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 278 |     | <span class='neutral'>     * - `account` must have at least `amount` tokens.</span>
 279 |     | <span class='neutral'>     */</span>
 280 |     | <span class='unexecuted'>    function _burn(address account, uint256 amount) internal virtual {</span>
 281 |     | <span class='unexecuted'>        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='unexecuted'>        _beforeTokenTransfer(account, address(0), amount);</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='unexecuted'>        uint256 accountBalance = _balances[account];</span>
 286 |     | <span class='unexecuted'>        require(accountBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);</span>
 287 |     | <span class='neutral'>        unchecked {</span>
 288 |     | <span class='unexecuted'>            _balances[account] = accountBalance - amount;</span>
 289 |     | <span class='neutral'>        }</span>
 290 |     | <span class='unexecuted'>        _totalSupply -= amount;</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='unexecuted'>        emit Transfer(account, address(0), amount);</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='unexecuted'>        _afterTokenTransfer(account, address(0), amount);</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    /**</span>
 298 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.</span>
 299 |     | <span class='neutral'>     *</span>
 300 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 301 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 302 |     | <span class='neutral'>     *</span>
 303 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 304 |     | <span class='neutral'>     *</span>
 305 |     | <span class='neutral'>     * Requirements:</span>
 306 |     | <span class='neutral'>     *</span>
 307 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 308 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 309 |     | <span class='neutral'>     */</span>
 310 | *   | <span class='executed'>    function _approve(</span>
 311 |     | <span class='neutral'>        address owner,</span>
 312 |     | <span class='neutral'>        address spender,</span>
 313 |     | <span class='neutral'>        uint256 amount</span>
 314 |     | <span class='neutral'>    ) internal virtual {</span>
 315 | *   | <span class='executed'>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span>
 316 | *   | <span class='executed'>        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span>
 317 |     | <span class='neutral'></span>
 318 | *   | <span class='executed'>        _allowances[owner][spender] = amount;</span>
 319 | *   | <span class='executed'>        emit Approval(owner, spender, amount);</span>
 320 |     | <span class='neutral'>    }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='neutral'>    /**</span>
 323 |     | <span class='neutral'>     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.</span>
 324 |     | <span class='neutral'>     *</span>
 325 |     | <span class='neutral'>     * Does not update the allowance amount in case of infinite allowance.</span>
 326 |     | <span class='neutral'>     * Revert if not enough allowance is available.</span>
 327 |     | <span class='neutral'>     *</span>
 328 |     | <span class='neutral'>     * Might emit an {Approval} event.</span>
 329 |     | <span class='neutral'>     */</span>
 330 | *   | <span class='executed'>    function _spendAllowance(</span>
 331 |     | <span class='neutral'>        address owner,</span>
 332 |     | <span class='neutral'>        address spender,</span>
 333 |     | <span class='neutral'>        uint256 amount</span>
 334 | *   | <span class='executed'>    ) internal virtual {</span>
 335 | *   | <span class='executed'>        uint256 currentAllowance = allowance(owner, spender);</span>
 336 | *   | <span class='executed'>        if (currentAllowance != type(uint256).max) {</span>
 337 | *   | <span class='executed'>            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span>
 338 |     | <span class='neutral'>            unchecked {</span>
 339 | *   | <span class='executed'>                _approve(owner, spender, currentAllowance - amount);</span>
 340 |     | <span class='neutral'>            }</span>
 341 |     | <span class='neutral'>        }</span>
 342 |     | <span class='neutral'>    }</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>    /**</span>
 345 |     | <span class='neutral'>     * @dev Hook that is called before any transfer of tokens. This includes</span>
 346 |     | <span class='neutral'>     * minting and burning.</span>
 347 |     | <span class='neutral'>     *</span>
 348 |     | <span class='neutral'>     * Calling conditions:</span>
 349 |     | <span class='neutral'>     *</span>
 350 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 351 |     | <span class='neutral'>     * will be transferred to `to`.</span>
 352 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens will be minted for `to`.</span>
 353 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens will be burned.</span>
 354 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 355 |     | <span class='neutral'>     *</span>
 356 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 357 |     | <span class='neutral'>     */</span>
 358 | *   | <span class='executed'>    function _beforeTokenTransfer(</span>
 359 |     | <span class='neutral'>        address from,</span>
 360 |     | <span class='neutral'>        address to,</span>
 361 |     | <span class='neutral'>        uint256 amount</span>
 362 |     | <span class='neutral'>    ) internal virtual {}</span>
 363 |     | <span class='neutral'></span>
 364 |     | <span class='neutral'>    /**</span>
 365 |     | <span class='neutral'>     * @dev Hook that is called after any transfer of tokens. This includes</span>
 366 |     | <span class='neutral'>     * minting and burning.</span>
 367 |     | <span class='neutral'>     *</span>
 368 |     | <span class='neutral'>     * Calling conditions:</span>
 369 |     | <span class='neutral'>     *</span>
 370 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 371 |     | <span class='neutral'>     * has been transferred to `to`.</span>
 372 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens have been minted for `to`.</span>
 373 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens have been burned.</span>
 374 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 375 |     | <span class='neutral'>     *</span>
 376 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 377 |     | <span class='neutral'>     */</span>
 378 | *   | <span class='executed'>    function _afterTokenTransfer(</span>
 379 |     | <span class='neutral'>        address from,</span>
 380 |     | <span class='neutral'>        address to,</span>
 381 |     | <span class='neutral'>        uint256 amount</span>
 382 |     | <span class='neutral'>    ) internal virtual {}</span>
 383 |     | <span class='neutral'>}</span>
 384 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/external/openzeppelin/contracts/token/ERC20/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 54 |     | <span class='neutral'>     *</span>
 55 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 56 |     | <span class='neutral'>     *</span>
 57 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 58 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 59 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 60 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 61 |     | <span class='neutral'>     * desired value afterwards:</span>
 62 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /**</span>
 69 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `from` to `to` using the</span>
 70 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 71 |     | <span class='neutral'>     * allowance.</span>
 72 |     | <span class='neutral'>     *</span>
 73 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 74 |     | <span class='neutral'>     *</span>
 75 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 76 |     | <span class='neutral'>     */</span>
 77 |     | <span class='neutral'>    function transferFrom(</span>
 78 |     | <span class='neutral'>        address from,</span>
 79 |     | <span class='neutral'>        address to,</span>
 80 |     | <span class='neutral'>        uint256 amount</span>
 81 |     | <span class='neutral'>    ) external returns (bool);</span>
 82 |     | <span class='neutral'>}</span>
 83 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/external/openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../ERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../../../utils/Context.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @dev Extension of {ERC20} that allows token holders to destroy both their own</span>
 11 |     | <span class='neutral'> * tokens and those that they have an allowance for, in a way that can be</span>
 12 |     | <span class='neutral'> * recognized off-chain (via event analysis).</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='neutral'>abstract contract ERC20Burnable is Context, ERC20 {</span>
 15 |     | <span class='neutral'>    /**</span>
 16 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from the caller.</span>
 17 |     | <span class='neutral'>     *</span>
 18 |     | <span class='neutral'>     * See {ERC20-_burn}.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='unexecuted'>    function burn(uint256 amount) public virtual {</span>
 21 |     | <span class='unexecuted'>        _burn(_msgSender(), amount);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, deducting from the caller&#39;s</span>
 26 |     | <span class='neutral'>     * allowance.</span>
 27 |     | <span class='neutral'>     *</span>
 28 |     | <span class='neutral'>     * See {ERC20-_burn} and {ERC20-allowance}.</span>
 29 |     | <span class='neutral'>     *</span>
 30 |     | <span class='neutral'>     * Requirements:</span>
 31 |     | <span class='neutral'>     *</span>
 32 |     | <span class='neutral'>     * - the caller must have allowance for ``accounts``&#39;s tokens of at least</span>
 33 |     | <span class='neutral'>     * `amount`.</span>
 34 |     | <span class='neutral'>     */</span>
 35 |     | <span class='unexecuted'>    function burnFrom(address account, uint256 amount) public virtual {</span>
 36 |     | <span class='unexecuted'>        _spendAllowance(account, _msgSender(), amount);</span>
 37 |     | <span class='unexecuted'>        _burn(account, amount);</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'>}</span>
 40 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/external/openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)</span>
  3 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {IERC20} from &quot;../IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/**</span>
  8 |     | <span class='neutral'> * @dev Interface for the optional metadata functions from the ERC20 standard.</span>
  9 |     | <span class='neutral'> */</span>
 10 |     | <span class='neutral'>interface IERC20Metadata is IERC20 {</span>
 11 |     | <span class='neutral'>    /**</span>
 12 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
 13 |     | <span class='neutral'>     */</span>
 14 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Returns the symbol of the token.</span>
 18 |     | <span class='neutral'>     */</span>
 19 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    /**</span>
 22 |     | <span class='neutral'>     * @dev Returns the decimals places of the token.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 25 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/external/openzeppelin/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 | *   | <span class='executed'>    function _msgSender() internal view virtual returns (address) {</span>
 18 | *   | <span class='executed'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/external/solady/Clone.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Class with helper read functions for clone with immutable args.</span>
   5 |     | <span class='neutral'>/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Clone.sol)</span>
   6 |     | <span class='neutral'>/// @author Adapted from clones with immutable args by zefram.eth, Saw-mon &amp; Natalie</span>
   7 |     | <span class='neutral'>/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)</span>
   8 |     | <span class='neutral'>abstract contract Clone {</span>
   9 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type bytes.</span>
  10 |     | <span class='neutral'>    function _getArgBytes(uint256 argOffset, uint256 length)</span>
  11 |     | <span class='neutral'>        internal</span>
  12 |     | <span class='neutral'>        pure</span>
  13 |     | <span class='neutral'>        returns (bytes memory arg)</span>
  14 |     | <span class='neutral'>    {</span>
  15 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  16 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  17 |     | <span class='neutral'>        assembly {</span>
  18 |     | <span class='neutral'>            arg := mload(0x40)</span>
  19 |     | <span class='neutral'>            mstore(arg, length) // Store the length.</span>
  20 |     | <span class='neutral'>            calldatacopy(add(arg, 0x20), add(offset, argOffset), length)</span>
  21 |     | <span class='neutral'>            let o := add(add(arg, 0x20), length)</span>
  22 |     | <span class='neutral'>            mstore(o, 0) // Zeroize the slot after the bytes.</span>
  23 |     | <span class='neutral'>            mstore(0x40, add(o, 0x20)) // Allocate the memory.</span>
  24 |     | <span class='neutral'>        }</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type address.</span>
  28 |     | <span class='unexecuted'>    function _getArgAddress(uint256 argOffset) internal pure returns (address arg) {</span>
  29 |     | <span class='unexecuted'>        uint256 offset = _getImmutableArgsOffset();</span>
  30 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  31 |     | <span class='unexecuted'>        assembly {</span>
  32 |     | <span class='unexecuted'>            arg := shr(96, calldataload(add(offset, argOffset)))</span>
  33 |     | <span class='neutral'>        }</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /// @dev Reads a uint256 array stored in the immutable args.</span>
  37 |     | <span class='neutral'>    function _getArgUint256Array(uint256 argOffset, uint256 length)</span>
  38 |     | <span class='neutral'>        internal</span>
  39 |     | <span class='neutral'>        pure</span>
  40 |     | <span class='neutral'>        returns (uint256[] memory arg)</span>
  41 |     | <span class='neutral'>    {</span>
  42 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  43 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  44 |     | <span class='neutral'>        assembly {</span>
  45 |     | <span class='neutral'>            arg := mload(0x40)</span>
  46 |     | <span class='neutral'>            mstore(arg, length) // Store the length.</span>
  47 |     | <span class='neutral'>            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))</span>
  48 |     | <span class='neutral'>            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.</span>
  49 |     | <span class='neutral'>        }</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    /// @dev Reads a bytes32 array stored in the immutable args.</span>
  53 |     | <span class='neutral'>    function _getArgBytes32Array(uint256 argOffset, uint256 length)</span>
  54 |     | <span class='neutral'>        internal</span>
  55 |     | <span class='neutral'>        pure</span>
  56 |     | <span class='neutral'>        returns (bytes32[] memory arg)</span>
  57 |     | <span class='neutral'>    {</span>
  58 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  59 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  60 |     | <span class='neutral'>        assembly {</span>
  61 |     | <span class='neutral'>            arg := mload(0x40)</span>
  62 |     | <span class='neutral'>            mstore(arg, length) // Store the length.</span>
  63 |     | <span class='neutral'>            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))</span>
  64 |     | <span class='neutral'>            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.</span>
  65 |     | <span class='neutral'>        }</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type bytes32.</span>
  69 |     | <span class='neutral'>    function _getArgBytes32(uint256 argOffset) internal pure returns (bytes32 arg) {</span>
  70 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  71 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  72 |     | <span class='neutral'>        assembly {</span>
  73 |     | <span class='neutral'>            arg := calldataload(add(offset, argOffset))</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint256.</span>
  78 |     | <span class='neutral'>    function _getArgUint256(uint256 argOffset) internal pure returns (uint256 arg) {</span>
  79 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  80 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  81 |     | <span class='neutral'>        assembly {</span>
  82 |     | <span class='neutral'>            arg := calldataload(add(offset, argOffset))</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint248.</span>
  87 |     | <span class='neutral'>    function _getArgUint248(uint256 argOffset) internal pure returns (uint248 arg) {</span>
  88 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  89 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  90 |     | <span class='neutral'>        assembly {</span>
  91 |     | <span class='neutral'>            arg := shr(8, calldataload(add(offset, argOffset)))</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint240.</span>
  96 |     | <span class='neutral'>    function _getArgUint240(uint256 argOffset) internal pure returns (uint240 arg) {</span>
  97 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  98 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  99 |     | <span class='neutral'>        assembly {</span>
 100 |     | <span class='neutral'>            arg := shr(16, calldataload(add(offset, argOffset)))</span>
 101 |     | <span class='neutral'>        }</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint232.</span>
 105 |     | <span class='neutral'>    function _getArgUint232(uint256 argOffset) internal pure returns (uint232 arg) {</span>
 106 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 107 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 108 |     | <span class='neutral'>        assembly {</span>
 109 |     | <span class='neutral'>            arg := shr(24, calldataload(add(offset, argOffset)))</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint224.</span>
 114 |     | <span class='neutral'>    function _getArgUint224(uint256 argOffset) internal pure returns (uint224 arg) {</span>
 115 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 116 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 117 |     | <span class='neutral'>        assembly {</span>
 118 |     | <span class='neutral'>            arg := shr(0x20, calldataload(add(offset, argOffset)))</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint216.</span>
 123 |     | <span class='neutral'>    function _getArgUint216(uint256 argOffset) internal pure returns (uint216 arg) {</span>
 124 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 125 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 126 |     | <span class='neutral'>        assembly {</span>
 127 |     | <span class='neutral'>            arg := shr(40, calldataload(add(offset, argOffset)))</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint208.</span>
 132 |     | <span class='neutral'>    function _getArgUint208(uint256 argOffset) internal pure returns (uint208 arg) {</span>
 133 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 134 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 135 |     | <span class='neutral'>        assembly {</span>
 136 |     | <span class='neutral'>            arg := shr(48, calldataload(add(offset, argOffset)))</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint200.</span>
 141 |     | <span class='neutral'>    function _getArgUint200(uint256 argOffset) internal pure returns (uint200 arg) {</span>
 142 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 143 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 144 |     | <span class='neutral'>        assembly {</span>
 145 |     | <span class='neutral'>            arg := shr(56, calldataload(add(offset, argOffset)))</span>
 146 |     | <span class='neutral'>        }</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint192.</span>
 150 |     | <span class='neutral'>    function _getArgUint192(uint256 argOffset) internal pure returns (uint192 arg) {</span>
 151 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 152 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 153 |     | <span class='neutral'>        assembly {</span>
 154 |     | <span class='neutral'>            arg := shr(64, calldataload(add(offset, argOffset)))</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint184.</span>
 159 |     | <span class='neutral'>    function _getArgUint184(uint256 argOffset) internal pure returns (uint184 arg) {</span>
 160 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 161 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 162 |     | <span class='neutral'>        assembly {</span>
 163 |     | <span class='neutral'>            arg := shr(72, calldataload(add(offset, argOffset)))</span>
 164 |     | <span class='neutral'>        }</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint176.</span>
 168 |     | <span class='neutral'>    function _getArgUint176(uint256 argOffset) internal pure returns (uint176 arg) {</span>
 169 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 170 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 171 |     | <span class='neutral'>        assembly {</span>
 172 |     | <span class='neutral'>            arg := shr(80, calldataload(add(offset, argOffset)))</span>
 173 |     | <span class='neutral'>        }</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint168.</span>
 177 |     | <span class='neutral'>    function _getArgUint168(uint256 argOffset) internal pure returns (uint168 arg) {</span>
 178 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 179 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 180 |     | <span class='neutral'>        assembly {</span>
 181 |     | <span class='neutral'>            arg := shr(88, calldataload(add(offset, argOffset)))</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint160.</span>
 186 |     | <span class='unexecuted'>    function _getArgUint160(uint256 argOffset) internal pure returns (uint160 arg) {</span>
 187 |     | <span class='unexecuted'>        uint256 offset = _getImmutableArgsOffset();</span>
 188 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 189 |     | <span class='unexecuted'>        assembly {</span>
 190 |     | <span class='unexecuted'>            arg := shr(96, calldataload(add(offset, argOffset)))</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint152.</span>
 195 |     | <span class='neutral'>    function _getArgUint152(uint256 argOffset) internal pure returns (uint152 arg) {</span>
 196 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 197 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 198 |     | <span class='neutral'>        assembly {</span>
 199 |     | <span class='neutral'>            arg := shr(104, calldataload(add(offset, argOffset)))</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint144.</span>
 204 |     | <span class='neutral'>    function _getArgUint144(uint256 argOffset) internal pure returns (uint144 arg) {</span>
 205 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 206 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 207 |     | <span class='neutral'>        assembly {</span>
 208 |     | <span class='neutral'>            arg := shr(112, calldataload(add(offset, argOffset)))</span>
 209 |     | <span class='neutral'>        }</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint136.</span>
 213 |     | <span class='neutral'>    function _getArgUint136(uint256 argOffset) internal pure returns (uint136 arg) {</span>
 214 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 215 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 216 |     | <span class='neutral'>        assembly {</span>
 217 |     | <span class='neutral'>            arg := shr(120, calldataload(add(offset, argOffset)))</span>
 218 |     | <span class='neutral'>        }</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint128.</span>
 222 |     | <span class='unexecuted'>    function _getArgUint128(uint256 argOffset) internal pure returns (uint128 arg) {</span>
 223 |     | <span class='unexecuted'>        uint256 offset = _getImmutableArgsOffset();</span>
 224 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 225 |     | <span class='unexecuted'>        assembly {</span>
 226 |     | <span class='unexecuted'>            arg := shr(128, calldataload(add(offset, argOffset)))</span>
 227 |     | <span class='neutral'>        }</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint120.</span>
 231 |     | <span class='neutral'>    function _getArgUint120(uint256 argOffset) internal pure returns (uint120 arg) {</span>
 232 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 233 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 234 |     | <span class='neutral'>        assembly {</span>
 235 |     | <span class='neutral'>            arg := shr(136, calldataload(add(offset, argOffset)))</span>
 236 |     | <span class='neutral'>        }</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint112.</span>
 240 |     | <span class='neutral'>    function _getArgUint112(uint256 argOffset) internal pure returns (uint112 arg) {</span>
 241 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 242 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 243 |     | <span class='neutral'>        assembly {</span>
 244 |     | <span class='neutral'>            arg := shr(144, calldataload(add(offset, argOffset)))</span>
 245 |     | <span class='neutral'>        }</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint104.</span>
 249 |     | <span class='neutral'>    function _getArgUint104(uint256 argOffset) internal pure returns (uint104 arg) {</span>
 250 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 251 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 252 |     | <span class='neutral'>        assembly {</span>
 253 |     | <span class='neutral'>            arg := shr(152, calldataload(add(offset, argOffset)))</span>
 254 |     | <span class='neutral'>        }</span>
 255 |     | <span class='neutral'>    }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint96.</span>
 258 |     | <span class='neutral'>    function _getArgUint96(uint256 argOffset) internal pure returns (uint96 arg) {</span>
 259 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 260 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 261 |     | <span class='neutral'>        assembly {</span>
 262 |     | <span class='neutral'>            arg := shr(160, calldataload(add(offset, argOffset)))</span>
 263 |     | <span class='neutral'>        }</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint88.</span>
 267 |     | <span class='neutral'>    function _getArgUint88(uint256 argOffset) internal pure returns (uint88 arg) {</span>
 268 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 269 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 270 |     | <span class='neutral'>        assembly {</span>
 271 |     | <span class='neutral'>            arg := shr(168, calldataload(add(offset, argOffset)))</span>
 272 |     | <span class='neutral'>        }</span>
 273 |     | <span class='neutral'>    }</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint80.</span>
 276 |     | <span class='neutral'>    function _getArgUint80(uint256 argOffset) internal pure returns (uint80 arg) {</span>
 277 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 278 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 279 |     | <span class='neutral'>        assembly {</span>
 280 |     | <span class='neutral'>            arg := shr(176, calldataload(add(offset, argOffset)))</span>
 281 |     | <span class='neutral'>        }</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint72.</span>
 285 |     | <span class='neutral'>    function _getArgUint72(uint256 argOffset) internal pure returns (uint72 arg) {</span>
 286 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 287 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 288 |     | <span class='neutral'>        assembly {</span>
 289 |     | <span class='neutral'>            arg := shr(184, calldataload(add(offset, argOffset)))</span>
 290 |     | <span class='neutral'>        }</span>
 291 |     | <span class='neutral'>    }</span>
 292 |     | <span class='neutral'></span>
 293 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint64.</span>
 294 |     | <span class='neutral'>    function _getArgUint64(uint256 argOffset) internal pure returns (uint64 arg) {</span>
 295 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 296 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 297 |     | <span class='neutral'>        assembly {</span>
 298 |     | <span class='neutral'>            arg := shr(192, calldataload(add(offset, argOffset)))</span>
 299 |     | <span class='neutral'>        }</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint56.</span>
 303 |     | <span class='neutral'>    function _getArgUint56(uint256 argOffset) internal pure returns (uint56 arg) {</span>
 304 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 305 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 306 |     | <span class='neutral'>        assembly {</span>
 307 |     | <span class='neutral'>            arg := shr(200, calldataload(add(offset, argOffset)))</span>
 308 |     | <span class='neutral'>        }</span>
 309 |     | <span class='neutral'>    }</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint48.</span>
 312 |     | <span class='neutral'>    function _getArgUint48(uint256 argOffset) internal pure returns (uint48 arg) {</span>
 313 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 314 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 315 |     | <span class='neutral'>        assembly {</span>
 316 |     | <span class='neutral'>            arg := shr(208, calldataload(add(offset, argOffset)))</span>
 317 |     | <span class='neutral'>        }</span>
 318 |     | <span class='neutral'>    }</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint40.</span>
 321 |     | <span class='neutral'>    function _getArgUint40(uint256 argOffset) internal pure returns (uint40 arg) {</span>
 322 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 323 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 324 |     | <span class='neutral'>        assembly {</span>
 325 |     | <span class='neutral'>            arg := shr(216, calldataload(add(offset, argOffset)))</span>
 326 |     | <span class='neutral'>        }</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint32.</span>
 330 |     | <span class='unexecuted'>    function _getArgUint32(uint256 argOffset) internal pure returns (uint32 arg) {</span>
 331 |     | <span class='unexecuted'>        uint256 offset = _getImmutableArgsOffset();</span>
 332 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 333 |     | <span class='unexecuted'>        assembly {</span>
 334 |     | <span class='unexecuted'>            arg := shr(224, calldataload(add(offset, argOffset)))</span>
 335 |     | <span class='neutral'>        }</span>
 336 |     | <span class='neutral'>    }</span>
 337 |     | <span class='neutral'></span>
 338 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint24.</span>
 339 |     | <span class='neutral'>    function _getArgUint24(uint256 argOffset) internal pure returns (uint24 arg) {</span>
 340 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 341 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 342 |     | <span class='neutral'>        assembly {</span>
 343 |     | <span class='neutral'>            arg := shr(232, calldataload(add(offset, argOffset)))</span>
 344 |     | <span class='neutral'>        }</span>
 345 |     | <span class='neutral'>    }</span>
 346 |     | <span class='neutral'></span>
 347 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint16.</span>
 348 |     | <span class='unexecuted'>    function _getArgUint16(uint256 argOffset) internal pure returns (uint16 arg) {</span>
 349 |     | <span class='unexecuted'>        uint256 offset = _getImmutableArgsOffset();</span>
 350 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 351 |     | <span class='unexecuted'>        assembly {</span>
 352 |     | <span class='unexecuted'>            arg := shr(240, calldataload(add(offset, argOffset)))</span>
 353 |     | <span class='neutral'>        }</span>
 354 |     | <span class='neutral'>    }</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint8.</span>
 357 |     | <span class='unexecuted'>    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {</span>
 358 |     | <span class='unexecuted'>        uint256 offset = _getImmutableArgsOffset();</span>
 359 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 360 |     | <span class='unexecuted'>        assembly {</span>
 361 |     | <span class='unexecuted'>            arg := shr(248, calldataload(add(offset, argOffset)))</span>
 362 |     | <span class='neutral'>        }</span>
 363 |     | <span class='neutral'>    }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>    /// @return offset The offset of the packed immutable args in calldata.</span>
 366 |     | <span class='unexecuted'>    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {</span>
 367 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 368 |     | <span class='neutral'>        assembly {</span>
 369 |     | <span class='unexecuted'>            offset := sub(calldatasize(), shr(240, calldataload(sub(calldatasize(), 2))))</span>
 370 |     | <span class='neutral'>        }</span>
 371 |     | <span class='neutral'>    }</span>
 372 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/external/solady/LibClone.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Minimal proxy library.</span>
   5 |     | <span class='neutral'>/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)</span>
   6 |     | <span class='neutral'>/// @author Minimal proxy by 0age (https://github.com/0age)</span>
   7 |     | <span class='neutral'>/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon &amp; Natalie</span>
   8 |     | <span class='neutral'>/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)</span>
   9 |     | <span class='neutral'>///</span>
  10 |     | <span class='neutral'>/// @dev Minimal proxy:</span>
  11 |     | <span class='neutral'>/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,</span>
  12 |     | <span class='neutral'>/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,</span>
  13 |     | <span class='neutral'>/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.</span>
  14 |     | <span class='neutral'>///</span>
  15 |     | <span class='neutral'>/// @dev Clones with immutable args (CWIA):</span>
  16 |     | <span class='neutral'>/// The implementation of CWIA here implements a `receive()` method that emits the</span>
  17 |     | <span class='neutral'>/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,</span>
  18 |     | <span class='neutral'>/// enabling us to accept hard gas-capped `sends` &amp; `transfers` for maximum backwards</span>
  19 |     | <span class='neutral'>/// composability. The minimal proxy implementation does not offer this feature.</span>
  20 |     | <span class='unexecuted'>library LibClone {</span>
  21 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  22 |     | <span class='neutral'>    /*                       CUSTOM ERRORS                        */</span>
  23 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /// @dev Unable to deploy the clone.</span>
  26 |     | <span class='neutral'>    error DeploymentFailed();</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    /// @dev The salt must start with either the zero address or the caller.</span>
  29 |     | <span class='neutral'>    error SaltDoesNotStartWithCaller();</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  32 |     | <span class='neutral'>    /*                  MINIMAL PROXY OPERATIONS                  */</span>
  33 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /// @dev Deploys a deterministic clone of `implementation`,</span>
  36 |     | <span class='neutral'>    /// using immutable  arguments encoded in `data`, with `salt`.</span>
  37 |     | <span class='unexecuted'>    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)</span>
  38 |     | <span class='neutral'>        internal</span>
  39 |     | <span class='unexecuted'>        returns (address instance)</span>
  40 |     | <span class='neutral'>    {</span>
  41 |     | <span class='unexecuted'>        assembly {</span>
  42 |     | <span class='neutral'>            // Compute the boundaries of the data and cache the memory slots around it.</span>
  43 |     | <span class='unexecuted'>            let mBefore3 := mload(sub(data, 0x60))</span>
  44 |     | <span class='unexecuted'>            let mBefore2 := mload(sub(data, 0x40))</span>
  45 |     | <span class='unexecuted'>            let mBefore1 := mload(sub(data, 0x20))</span>
  46 |     | <span class='unexecuted'>            let dataLength := mload(data)</span>
  47 |     | <span class='unexecuted'>            let dataEnd := add(add(data, 0x20), dataLength)</span>
  48 |     | <span class='unexecuted'>            let mAfter1 := mload(dataEnd)</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>            // +2 bytes for telling how much data there is appended to the call.</span>
  51 |     | <span class='unexecuted'>            let extraLength := add(dataLength, 2)</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>            // Write the bytecode before the data.</span>
  54 |     | <span class='unexecuted'>            mstore(data, 0x5af43d3d93803e606057fd5bf3)</span>
  55 |     | <span class='neutral'>            // Write the address of the implementation.</span>
  56 |     | <span class='unexecuted'>            mstore(sub(data, 0x0d), implementation)</span>
  57 |     | <span class='neutral'>            // Write the rest of the bytecode.</span>
  58 |     | <span class='unexecuted'>            mstore(</span>
  59 |     | <span class='unexecuted'>                sub(data, 0x21),</span>
  60 |     | <span class='unexecuted'>                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)</span>
  61 |     | <span class='neutral'>            )</span>
  62 |     | <span class='neutral'>            // `keccak256(&quot;ReceiveETH(uint256)&quot;)`</span>
  63 |     | <span class='unexecuted'>            mstore(</span>
  64 |     | <span class='unexecuted'>                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff</span>
  65 |     | <span class='neutral'>            )</span>
  66 |     | <span class='unexecuted'>            mstore(</span>
  67 |     | <span class='unexecuted'>                sub(data, 0x5a),</span>
  68 |     | <span class='unexecuted'>                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)</span>
  69 |     | <span class='neutral'>            )</span>
  70 |     | <span class='unexecuted'>            mstore(dataEnd, shl(0xf0, extraLength))</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>            // Create the instance.</span>
  73 |     | <span class='unexecuted'>            instance := create2(0, sub(data, 0x4c), add(extraLength, 0x6c), salt)</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>            // If `instance` is zero, revert.</span>
  76 |     | <span class='unexecuted'>            if iszero(instance) {</span>
  77 |     | <span class='neutral'>                // Store the function selector of `DeploymentFailed()`.</span>
  78 |     | <span class='unexecuted'>                mstore(0x00, 0x30116425)</span>
  79 |     | <span class='neutral'>                // Revert with (offset, size).</span>
  80 |     | <span class='unexecuted'>                revert(0x1c, 0x04)</span>
  81 |     | <span class='neutral'>            }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>            // Restore the overwritten memory surrounding `data`.</span>
  84 |     | <span class='unexecuted'>            mstore(dataEnd, mAfter1)</span>
  85 |     | <span class='unexecuted'>            mstore(data, dataLength)</span>
  86 |     | <span class='unexecuted'>            mstore(sub(data, 0x20), mBefore1)</span>
  87 |     | <span class='unexecuted'>            mstore(sub(data, 0x40), mBefore2)</span>
  88 |     | <span class='unexecuted'>            mstore(sub(data, 0x60), mBefore3)</span>
  89 |     | <span class='neutral'>        }</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    /// @dev Returns the initialization code hash of the clone of `implementation`</span>
  93 |     | <span class='neutral'>    /// using immutable arguments encoded in `data`.</span>
  94 |     | <span class='neutral'>    /// Used for mining vanity addresses with create2crunch.</span>
  95 |     | <span class='neutral'>    function initCodeHash(address implementation, bytes memory data)</span>
  96 |     | <span class='neutral'>        internal</span>
  97 |     | <span class='neutral'>        pure</span>
  98 |     | <span class='neutral'>        returns (bytes32 hash)</span>
  99 |     | <span class='neutral'>    {</span>
 100 |     | <span class='neutral'>        assembly {</span>
 101 |     | <span class='neutral'>            // Compute the boundaries of the data and cache the memory slots around it.</span>
 102 |     | <span class='neutral'>            let mBefore3 := mload(sub(data, 0x60))</span>
 103 |     | <span class='neutral'>            let mBefore2 := mload(sub(data, 0x40))</span>
 104 |     | <span class='neutral'>            let mBefore1 := mload(sub(data, 0x20))</span>
 105 |     | <span class='neutral'>            let dataLength := mload(data)</span>
 106 |     | <span class='neutral'>            let dataEnd := add(add(data, 0x20), dataLength)</span>
 107 |     | <span class='neutral'>            let mAfter1 := mload(dataEnd)</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>            // +2 bytes for telling how much data there is appended to the call.</span>
 110 |     | <span class='neutral'>            let extraLength := add(dataLength, 2)</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>            // Write the bytecode before the data.</span>
 113 |     | <span class='neutral'>            mstore(data, 0x5af43d3d93803e606057fd5bf3)</span>
 114 |     | <span class='neutral'>            // Write the address of the implementation.</span>
 115 |     | <span class='neutral'>            mstore(sub(data, 0x0d), implementation)</span>
 116 |     | <span class='neutral'>            // Write the rest of the bytecode.</span>
 117 |     | <span class='neutral'>            mstore(</span>
 118 |     | <span class='neutral'>                sub(data, 0x21),</span>
 119 |     | <span class='neutral'>                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)</span>
 120 |     | <span class='neutral'>            )</span>
 121 |     | <span class='neutral'>            // `keccak256(&quot;ReceiveETH(uint256)&quot;)`</span>
 122 |     | <span class='neutral'>            mstore(</span>
 123 |     | <span class='neutral'>                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff</span>
 124 |     | <span class='neutral'>            )</span>
 125 |     | <span class='neutral'>            mstore(</span>
 126 |     | <span class='neutral'>                sub(data, 0x5a),</span>
 127 |     | <span class='neutral'>                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)</span>
 128 |     | <span class='neutral'>            )</span>
 129 |     | <span class='neutral'>            mstore(dataEnd, shl(0xf0, extraLength))</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>            // Compute and store the bytecode hash.</span>
 132 |     | <span class='neutral'>            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>            // Restore the overwritten memory surrounding `data`.</span>
 135 |     | <span class='neutral'>            mstore(dataEnd, mAfter1)</span>
 136 |     | <span class='neutral'>            mstore(data, dataLength)</span>
 137 |     | <span class='neutral'>            mstore(sub(data, 0x20), mBefore1)</span>
 138 |     | <span class='neutral'>            mstore(sub(data, 0x40), mBefore2)</span>
 139 |     | <span class='neutral'>            mstore(sub(data, 0x60), mBefore3)</span>
 140 |     | <span class='neutral'>        }</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /// @dev Returns the address of the deterministic clone of</span>
 144 |     | <span class='neutral'>    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.</span>
 145 |     | <span class='neutral'>    function predictDeterministicAddress(</span>
 146 |     | <span class='neutral'>        address implementation,</span>
 147 |     | <span class='neutral'>        bytes memory data,</span>
 148 |     | <span class='neutral'>        bytes32 salt,</span>
 149 |     | <span class='neutral'>        address deployer</span>
 150 |     | <span class='neutral'>    ) internal pure returns (address predicted) {</span>
 151 |     | <span class='neutral'>        bytes32 hash = initCodeHash(implementation, data);</span>
 152 |     | <span class='neutral'>        predicted = predictDeterministicAddress(hash, salt, deployer);</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
 156 |     | <span class='neutral'>    /*                      OTHER OPERATIONS                      */</span>
 157 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    /// @dev Returns the address when a contract with initialization code hash,</span>
 160 |     | <span class='neutral'>    /// `hash`, is deployed with `salt`, by `deployer`.</span>
 161 |     | <span class='neutral'>    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)</span>
 162 |     | <span class='neutral'>        internal</span>
 163 |     | <span class='neutral'>        pure</span>
 164 |     | <span class='neutral'>        returns (address predicted)</span>
 165 |     | <span class='neutral'>    {</span>
 166 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 167 |     | <span class='neutral'>        assembly {</span>
 168 |     | <span class='neutral'>            // Compute and store the bytecode hash.</span>
 169 |     | <span class='neutral'>            mstore8(0x00, 0xff) // Write the prefix.</span>
 170 |     | <span class='neutral'>            mstore(0x35, hash)</span>
 171 |     | <span class='neutral'>            mstore(0x01, shl(96, deployer))</span>
 172 |     | <span class='neutral'>            mstore(0x15, salt)</span>
 173 |     | <span class='neutral'>            predicted := keccak256(0x00, 0x55)</span>
 174 |     | <span class='neutral'>            // Restore the part of the free memory pointer that has been overwritten.</span>
 175 |     | <span class='neutral'>            mstore(0x35, 0)</span>
 176 |     | <span class='neutral'>        }</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    /// @dev Reverts if `salt` does not start with either the zero address or the caller.</span>
 180 |     | <span class='neutral'>    function checkStartsWithCaller(bytes32 salt) internal view {</span>
 181 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 182 |     | <span class='neutral'>        assembly {</span>
 183 |     | <span class='neutral'>            // If the salt does not start with the zero address or the caller.</span>
 184 |     | <span class='neutral'>            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {</span>
 185 |     | <span class='neutral'>                // Store the function selector of `SaltDoesNotStartWithCaller()`.</span>
 186 |     | <span class='neutral'>                mstore(0x00, 0x2f634836)</span>
 187 |     | <span class='neutral'>                // Revert with (offset, size).</span>
 188 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
 189 |     | <span class='neutral'>            }</span>
 190 |     | <span class='neutral'>        }</span>
 191 |     | <span class='neutral'>    }</span>
 192 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/interfaces/ICoverPool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./structs/CoverPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @title ICoverPool</span>
   8 |     | <span class='neutral'> * @author Poolshark</span>
   9 |     | <span class='neutral'> * @notice Defines the basic interface for a Cover Pool.</span>
  10 |     | <span class='neutral'> */</span>
  11 |     | <span class='neutral'>interface ICoverPool is CoverPoolStructs {</span>
  12 |     | <span class='neutral'>    /**</span>
  13 |     | <span class='neutral'>     * @custom:struct MintParams</span>
  14 |     | <span class='neutral'>     */</span>
  15 |     | <span class='neutral'>    struct MintParams {</span>
  16 |     | <span class='neutral'>        /**</span>
  17 |     | <span class='neutral'>         * @custom:field to</span>
  18 |     | <span class='neutral'>         * @notice Address for the receiver of the minted position</span>
  19 |     | <span class='neutral'>         */</span>
  20 |     | <span class='neutral'>        address to;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>        /**</span>
  23 |     | <span class='neutral'>         * @custom:field amount</span>
  24 |     | <span class='neutral'>         * @notice Token amount to be deposited into the minted position</span>
  25 |     | <span class='neutral'>         */</span>
  26 |     | <span class='neutral'>        uint128 amount;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>        /**</span>
  29 |     | <span class='neutral'>         * @custom:field positionId</span>
  30 |     | <span class='neutral'>         * @notice 0 if creating a new position; id of previous if adding liquidity</span>
  31 |     | <span class='neutral'>         */</span>
  32 |     | <span class='neutral'>        uint32 positionId;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>        /**</span>
  35 |     | <span class='neutral'>         * @custom:field lower</span>
  36 |     | <span class='neutral'>         * @notice The lower price tick for the position range</span>
  37 |     | <span class='neutral'>         */</span>
  38 |     | <span class='neutral'>        int24 lower;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>        /**</span>
  41 |     | <span class='neutral'>         * @custom:field upper</span>
  42 |     | <span class='neutral'>         * @notice The upper price tick for the position range</span>
  43 |     | <span class='neutral'>         */</span>
  44 |     | <span class='neutral'>        int24 upper;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>        /**</span>
  47 |     | <span class='neutral'>         * @custom:field zeroForOne</span>
  48 |     | <span class='neutral'>         * @notice True if depositing token0, the first token address in lexographical order</span>
  49 |     | <span class='neutral'>         * @notice False if depositing token1, the second token address in lexographical order </span>
  50 |     | <span class='neutral'>         */</span>
  51 |     | <span class='neutral'>        bool zeroForOne;</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /**</span>
  55 |     | <span class='neutral'>     * @notice Deposits `amountIn` of asset to be auctioned off each time price range is crossed further into.</span>
  56 |     | <span class='neutral'>     * - E.g. User supplies 1 WETH in the range 1500 USDC per WETH to 1400 USDC per WETH</span>
  57 |     | <span class='neutral'>              As latestTick crosses from 1500 USDC per WETH to 1400 USDC per WETH,</span>
  58 |     | <span class='neutral'>              the user&#39;s liquidity within each tick spacing is auctioned off.</span>
  59 |     | <span class='neutral'>     * @dev The position will be shrunk onto the correct side of latestTick.</span>
  60 |     | <span class='neutral'>     * @dev The position will be minted with the `to` address as the owner.</span>
  61 |     | <span class='neutral'>     * @param params The parameters for the function. See MintParams above.</span>
  62 |     | <span class='neutral'>     */</span>
  63 |     | <span class='neutral'>    function mint(</span>
  64 |     | <span class='neutral'>        MintParams memory params</span>
  65 |     | <span class='neutral'>    ) external;</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /**</span>
  68 |     | <span class='neutral'>     * @custom:struct BurnParams</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='neutral'>    struct BurnParams {</span>
  71 |     | <span class='neutral'>        /**</span>
  72 |     | <span class='neutral'>         * @custom:field to</span>
  73 |     | <span class='neutral'>         * @notice Address for the receiver of the collected position amounts</span>
  74 |     | <span class='neutral'>         */</span>
  75 |     | <span class='neutral'>        address to;</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        /**</span>
  78 |     | <span class='neutral'>         * @custom:field burnPercent</span>
  79 |     | <span class='neutral'>         * @notice Percent of the remaining liquidity to be removed</span>
  80 |     | <span class='neutral'>         * @notice 1e38 represents 100%</span>
  81 |     | <span class='neutral'>         * @notice 5e37 represents 50%</span>
  82 |     | <span class='neutral'>         * @notice 1e37 represents 10%</span>
  83 |     | <span class='neutral'>         */</span>
  84 |     | <span class='neutral'>        uint128 burnPercent;</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>        /**</span>
  87 |     | <span class='neutral'>         * @custom:field positionId</span>
  88 |     | <span class='neutral'>         * @notice 0 if creating a new position; id of previous if adding liquidity</span>
  89 |     | <span class='neutral'>         */</span>
  90 |     | <span class='neutral'>        uint32 positionId;</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>        /**</span>
  93 |     | <span class='neutral'>         * @custom:field claim</span>
  94 |     | <span class='neutral'>         * @notice The most recent tick crossed in this range</span>
  95 |     | <span class='neutral'>         * @notice if `zeroForOne` is true, claim tick progresses from upper =&gt; lower</span>
  96 |     | <span class='neutral'>         * @notice if `zeroForOne` is false, claim tick progresses from lower =&gt; upper</span>
  97 |     | <span class='neutral'>         */</span>
  98 |     | <span class='neutral'>        int24 claim;</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>        /**</span>
 101 |     | <span class='neutral'>         * @custom:field zeroForOne</span>
 102 |     | <span class='neutral'>         * @notice True if deposited token0, the first token address in lexographical order</span>
 103 |     | <span class='neutral'>         * @notice False if deposited token1, the second token address in lexographical order </span>
 104 |     | <span class='neutral'>         */</span>
 105 |     | <span class='neutral'>        bool zeroForOne;</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>        /**</span>
 108 |     | <span class='neutral'>         * @custom:field sync</span>
 109 |     | <span class='neutral'>         * @notice True will sync the pool latestTick</span>
 110 |     | <span class='neutral'>         * @notice False will skip syncing latestTick </span>
 111 |     | <span class='neutral'>         */</span>
 112 |     | <span class='neutral'>        bool sync;</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    /**</span>
 116 |     | <span class='neutral'>     * @notice Withdraws the input token and returns any filled and/or unfilled amounts to the &#39;to&#39; address specified. </span>
 117 |     | <span class='neutral'>     * - E.g. User supplies 1 WETH in the range 1500 USDC per WETH to 1400 USDC per WETH</span>
 118 |     | <span class='neutral'>              As latestTick crosses from 1500 USDC per WETH to 1400 USDC per WETH,</span>
 119 |     | <span class='neutral'>              the user&#39;s liquidity within each tick spacing is auctioned off.</span>
 120 |     | <span class='neutral'>     * @dev The position will be shrunk based on the claim tick passed.</span>
 121 |     | <span class='neutral'>     * @dev The position amounts will be returned to the `to` address specified.</span>
 122 |     | <span class='neutral'>     * @dev The `sync` flag can be set to false so users can exit safely without syncing latestTick.</span>
 123 |     | <span class='neutral'>     * @param params The parameters for the function. See BurnParams above.</span>
 124 |     | <span class='neutral'>     */</span>
 125 |     | <span class='neutral'>    function burn(</span>
 126 |     | <span class='neutral'>        BurnParams memory params</span>
 127 |     | <span class='neutral'>    ) external; </span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    /**</span>
 130 |     | <span class='neutral'>     * @notice Swaps `tokenIn` for `tokenOut`. </span>
 131 |     | <span class='neutral'>               `tokenIn` will be `token0` if `zeroForOne` is true.</span>
 132 |     | <span class='neutral'>               `tokenIn` will be `token1` if `zeroForOne` is false.</span>
 133 |     | <span class='neutral'>               The pool price represents token1 per token0.</span>
 134 |     | <span class='neutral'>               The pool price will decrease if `zeroForOne` is true.</span>
 135 |     | <span class='neutral'>               The pool price will increase if `zeroForOne` is false. </span>
 136 |     | <span class='neutral'>     * @param params The parameters for the function. See SwapParams above.</span>
 137 |     | <span class='neutral'>     * @return amount0Delta The amount of token0 spent (negative) or received (positive) by the user</span>
 138 |     | <span class='neutral'>     * @return amount1Delta The amount of token1 spent (negative) or received (positive) by the user</span>
 139 |     | <span class='neutral'>     */</span>
 140 |     | <span class='neutral'>    function swap(</span>
 141 |     | <span class='neutral'>        SwapParams memory params</span>
 142 |     | <span class='neutral'>    ) external returns (</span>
 143 |     | <span class='neutral'>        int256 amount0Delta,</span>
 144 |     | <span class='neutral'>        int256 amount1Delta</span>
 145 |     | <span class='neutral'>    );</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /**</span>
 148 |     | <span class='neutral'>     * @notice Quotes the amount of `tokenIn` for `tokenOut`. </span>
 149 |     | <span class='neutral'>               `tokenIn` will be `token0` if `zeroForOne` is true.</span>
 150 |     | <span class='neutral'>               `tokenIn` will be `token1` if `zeroForOne` is false.</span>
 151 |     | <span class='neutral'>               The pool price represents token1 per token0.</span>
 152 |     | <span class='neutral'>               The pool price will decrease if `zeroForOne` is true.</span>
 153 |     | <span class='neutral'>               The pool price will increase if `zeroForOne` is false. </span>
 154 |     | <span class='neutral'>     * @param params The parameters for the function. See SwapParams above.</span>
 155 |     | <span class='neutral'>     * @return inAmount  The amount of tokenIn to be spent</span>
 156 |     | <span class='neutral'>     * @return outAmount The amount of tokenOut to be received</span>
 157 |     | <span class='neutral'>     * @return priceAfter The Q64.96 square root price after the swap</span>
 158 |     | <span class='neutral'>     */</span>
 159 |     | <span class='neutral'>    function quote(</span>
 160 |     | <span class='neutral'>        QuoteParams memory params</span>
 161 |     | <span class='neutral'>    ) external returns (</span>
 162 |     | <span class='neutral'>        int256 inAmount,</span>
 163 |     | <span class='neutral'>        int256 outAmount,</span>
 164 |     | <span class='neutral'>        uint256 priceAfter</span>
 165 |     | <span class='neutral'>    );</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /**</span>
 168 |     | <span class='neutral'>     * @custom:struct SnapshotParams</span>
 169 |     | <span class='neutral'>     */</span>
 170 |     | <span class='neutral'>    struct SnapshotParams {</span>
 171 |     | <span class='neutral'>        /**</span>
 172 |     | <span class='neutral'>         * @custom:field to</span>
 173 |     | <span class='neutral'>         * @notice Address of the position owner</span>
 174 |     | <span class='neutral'>         */</span>
 175 |     | <span class='neutral'>        address owner;</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>        /**</span>
 178 |     | <span class='neutral'>         * @custom:field positionId</span>
 179 |     | <span class='neutral'>         * @notice id of position</span>
 180 |     | <span class='neutral'>         */</span>
 181 |     | <span class='neutral'>        uint32 positionId;</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>        /**</span>
 184 |     | <span class='neutral'>         * @custom:field burnPercent</span>
 185 |     | <span class='neutral'>         * @notice Percent of the remaining liquidity to be removed</span>
 186 |     | <span class='neutral'>         * @notice 1e38 represents 100%</span>
 187 |     | <span class='neutral'>         * @notice 5e37 represents 50%</span>
 188 |     | <span class='neutral'>         * @notice 1e37 represents 10%</span>
 189 |     | <span class='neutral'>         */</span>
 190 |     | <span class='neutral'>        uint128 burnPercent;</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>        /**</span>
 193 |     | <span class='neutral'>         * @custom:field claim</span>
 194 |     | <span class='neutral'>         * @notice The most recent tick crossed in this range</span>
 195 |     | <span class='neutral'>         * @notice if `zeroForOne` is true, claim tick progresses from upper =&gt; lower</span>
 196 |     | <span class='neutral'>         * @notice if `zeroForOne` is false, claim tick progresses from lower =&gt; upper</span>
 197 |     | <span class='neutral'>         */</span>
 198 |     | <span class='neutral'>        int24 claim;</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>        /**</span>
 201 |     | <span class='neutral'>         * @custom:field zeroForOne</span>
 202 |     | <span class='neutral'>         * @notice True if deposited token0, the first token address in lexographical order</span>
 203 |     | <span class='neutral'>         * @notice False if deposited token1, the second token address in lexographical order </span>
 204 |     | <span class='neutral'>         */</span>
 205 |     | <span class='neutral'>        bool zeroForOne;</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    /**</span>
 209 |     | <span class='neutral'>     * @notice Snapshots the current state of an existing position. </span>
 210 |     | <span class='neutral'>     * @param params The parameters for the function. See SwapParams above.</span>
 211 |     | <span class='neutral'>     * @return position The updated position containing `amountIn` and `amountOut`</span>
 212 |     | <span class='neutral'>     * @dev positions amounts reflected will be collected by the user if `burn` is called</span>
 213 |     | <span class='neutral'>     */</span>
 214 |     | <span class='neutral'>    function snapshot(</span>
 215 |     | <span class='neutral'>        SnapshotParams memory params</span>
 216 |     | <span class='neutral'>    ) external view returns (</span>
 217 |     | <span class='neutral'>        CoverPosition memory position</span>
 218 |     | <span class='neutral'>    );</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>    /**</span>
 221 |     | <span class='neutral'>     * @notice Sets and collect protocol fees from the pool. </span>
 222 |     | <span class='neutral'>     * @param syncFee The new syncFee to be set if `setFees` is true.</span>
 223 |     | <span class='neutral'>     * @param fillFee The new fillFee to be set if `setFees` is true.</span>
 224 |     | <span class='neutral'>     * @return token0Fees The `token0` fees collected.</span>
 225 |     | <span class='neutral'>     * @return token1Fees The `token1` fees collected.</span>
 226 |     | <span class='neutral'>     * @dev `syncFee` is a basis point fee to be paid to users who sync latestTick</span>
 227 |     | <span class='neutral'>     * @dev `fillFee` is a basis point fee to be paid to the protocol for amounts filled</span>
 228 |     | <span class='neutral'>     * @dev All fees are zero by default unless the protocol decides to enable them.</span>
 229 |     | <span class='neutral'>     */</span>
 230 |     | <span class='neutral'>    function fees(</span>
 231 |     | <span class='neutral'>        uint16 syncFee,</span>
 232 |     | <span class='neutral'>        uint16 fillFee,</span>
 233 |     | <span class='neutral'>        bool setFees</span>
 234 |     | <span class='neutral'>    ) external returns (</span>
 235 |     | <span class='neutral'>        uint128 token0Fees,</span>
 236 |     | <span class='neutral'>        uint128 token1Fees</span>
 237 |     | <span class='neutral'>    );</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>    function immutables(</span>
 240 |     | <span class='neutral'>    ) external view returns (</span>
 241 |     | <span class='neutral'>        CoverImmutables memory constants</span>
 242 |     | <span class='neutral'>    );</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>    function priceBounds(</span>
 245 |     | <span class='neutral'>        int16 tickSpacing</span>
 246 |     | <span class='neutral'>    ) external pure returns (</span>
 247 |     | <span class='neutral'>        uint160 minPrice,</span>
 248 |     | <span class='neutral'>        uint160 maxPrice</span>
 249 |     | <span class='neutral'>    );</span>
 250 |     | <span class='neutral'>}</span>
 251 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/interfaces/ICoverPoolFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'>import &#39;../base/storage/CoverPoolFactoryStorage.sol&#39;;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>abstract contract ICoverPoolFactory is CoverPoolFactoryStorage {</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    struct CoverPoolParams {</span>
  8 |     | <span class='neutral'>        bytes32 poolType;</span>
  9 |     | <span class='neutral'>        address tokenIn;</span>
 10 |     | <span class='neutral'>        address tokenOut;</span>
 11 |     | <span class='neutral'>        uint16 feeTier;</span>
 12 |     | <span class='neutral'>        int16  tickSpread;</span>
 13 |     | <span class='neutral'>        uint16 twapLength;</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @notice Creates a new CoverPool.</span>
 18 |     | <span class='neutral'>     * @param params The CoverPoolParams struct referenced above.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='neutral'>    function createCoverPool(</span>
 21 |     | <span class='neutral'>        CoverPoolParams memory params</span>
 22 |     | <span class='neutral'>    ) external virtual returns (address pool);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @notice Fetches an existing CoverPool.</span>
 26 |     | <span class='neutral'>     * @param params The CoverPoolParams struct referenced above.</span>
 27 |     | <span class='neutral'>     */</span>
 28 |     | <span class='neutral'>    function getCoverPool(</span>
 29 |     | <span class='neutral'>        CoverPoolParams memory params</span>
 30 |     | <span class='neutral'>    ) external view virtual returns (address pool);</span>
 31 |     | <span class='neutral'>}</span>
 32 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/interfaces/ICoverPoolManager.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../interfaces/structs/CoverPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @notice CoverPoolManager interface</span>
  7 |     | <span class='neutral'>interface ICoverPoolManager is CoverPoolStructs {</span>
  8 |     | <span class='neutral'>    function owner() external view returns (address);</span>
  9 |     | <span class='neutral'>    function feeTo() external view returns (address);</span>
 10 |     | <span class='neutral'>    function poolTypes(</span>
 11 |     | <span class='neutral'>        bytes32 poolType</span>
 12 |     | <span class='neutral'>    ) external view returns (</span>
 13 |     | <span class='neutral'>        address implAddress,</span>
 14 |     | <span class='neutral'>        address sourceAddress</span>
 15 |     | <span class='neutral'>    );</span>
 16 |     | <span class='neutral'>    function volatilityTiers(</span>
 17 |     | <span class='neutral'>        bytes32 implName,</span>
 18 |     | <span class='neutral'>        uint16 feeTier,</span>
 19 |     | <span class='neutral'>        int16  tickSpread,</span>
 20 |     | <span class='neutral'>        uint16 twapLength</span>
 21 |     | <span class='neutral'>    ) external view returns (</span>
 22 |     | <span class='neutral'>        VolatilityTier memory</span>
 23 |     | <span class='neutral'>    );</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/interfaces/IERC20Minimal.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IERC20Minimal {</span>
  5 |     | <span class='neutral'>    /// @notice Returns the balance of a token</span>
  6 |     | <span class='neutral'>    /// @param account The address for which to look up the balance for</span>
  7 |     | <span class='neutral'>    /// @return amount of tokens held by the account</span>
  8 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
  9 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/interfaces/callbacks/ICoverPoolSwapCallback.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Callback for swaps</span>
  5 |     | <span class='neutral'>/// @notice Any contract that calls the `swap` function must implement this interface.</span>
  6 |     | <span class='neutral'>interface ICoverPoolSwapCallback {</span>
  7 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after executing a swap.</span>
  8 |     | <span class='neutral'>    /// @dev In the implementation you must pay the pool tokens owed for the swap.</span>
  9 |     | <span class='neutral'>    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.</span>
 10 |     | <span class='neutral'>    /// @param amount0Delta The amount of token0 either received by (positive) or sent from (negative) the user.</span>
 11 |     | <span class='neutral'>    /// @param amount1Delta The amount of token1 either received by (positive) or sent from (negative) the user.</span>
 12 |     | <span class='neutral'>    function coverPoolSwapCallback(</span>
 13 |     | <span class='neutral'>        int256 amount0Delta,</span>
 14 |     | <span class='neutral'>        int256 amount1Delta,</span>
 15 |     | <span class='neutral'>        bytes calldata data</span>
 16 |     | <span class='neutral'>    ) external;</span>
 17 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/interfaces/external/uniswap/v3/IUniswapV3Factory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title The interface for the Concentrated Liquidity Pool Factory</span>
  5 |     | <span class='neutral'>interface IUniswapV3Factory {</span>
  6 |     | <span class='neutral'>    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled</span>
  7 |     | <span class='neutral'>    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context</span>
  8 |     | <span class='neutral'>    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee</span>
  9 |     | <span class='neutral'>    /// @return The tick spacing</span>
 10 |     | <span class='neutral'>    function feeTierTickSpacing(uint24 fee) external view returns (int24);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist</span>
 13 |     | <span class='neutral'>    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order</span>
 14 |     | <span class='neutral'>    /// @param tokenA The contract address of either token0 or token1</span>
 15 |     | <span class='neutral'>    /// @param tokenB The contract address of the other token</span>
 16 |     | <span class='neutral'>    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip</span>
 17 |     | <span class='neutral'>    /// @return pool The pool address</span>
 18 |     | <span class='neutral'>    function getPool(</span>
 19 |     | <span class='neutral'>        address tokenA,</span>
 20 |     | <span class='neutral'>        address tokenB,</span>
 21 |     | <span class='neutral'>        uint24 fee</span>
 22 |     | <span class='neutral'>    ) external view returns (address pool);</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/interfaces/external/uniswap/v3/IUniswapV3Pool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IUniswapV3Pool {</span>
  5 |     | <span class='neutral'>    /// @notice This is to be used at hedge pool initialization in case the cardinality is too low for the hedge pool.</span>
  6 |     | <span class='neutral'>    /// @notice Increase the maximum number of price and liquidity observations that this pool will store</span>
  7 |     | <span class='neutral'>    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store</span>
  8 |     | <span class='neutral'>    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function token0() external view returns (address);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function token1() external view returns (address);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function tickSpacing() external view returns (int24);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas</span>
 17 |     | <span class='neutral'>    /// when accessed externally.</span>
 18 |     | <span class='neutral'>    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value</span>
 19 |     | <span class='neutral'>    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.</span>
 20 |     | <span class='neutral'>    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick</span>
 21 |     | <span class='neutral'>    /// boundary.</span>
 22 |     | <span class='neutral'>    /// observationIndex The index of the last oracle observation that was written,</span>
 23 |     | <span class='neutral'>    /// observationCardinality The current maximum number of observations stored in the pool,</span>
 24 |     | <span class='neutral'>    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.</span>
 25 |     | <span class='neutral'>    /// feeProtocol The protocol fee for both tokens of the pool.</span>
 26 |     | <span class='neutral'>    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0</span>
 27 |     | <span class='neutral'>    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.</span>
 28 |     | <span class='neutral'>    /// unlocked Whether the pool is currently locked to reentrancy</span>
 29 |     | <span class='neutral'>    function slot0()</span>
 30 |     | <span class='neutral'>        external</span>
 31 |     | <span class='neutral'>        view</span>
 32 |     | <span class='neutral'>        returns (</span>
 33 |     | <span class='neutral'>            uint160 sqrtPriceX96,</span>
 34 |     | <span class='neutral'>            int24 tick,</span>
 35 |     | <span class='neutral'>            uint16 observationIndex,</span>
 36 |     | <span class='neutral'>            uint16 observationCardinality,</span>
 37 |     | <span class='neutral'>            uint16 observationCardinalityNext,</span>
 38 |     | <span class='neutral'>            uint8 feeProtocol,</span>
 39 |     | <span class='neutral'>            bool unlocked</span>
 40 |     | <span class='neutral'>        );</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in</span>
 43 |     | <span class='neutral'>    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.</span>
 44 |     | <span class='neutral'>    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned</span>
 45 |     | <span class='neutral'>    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp</span>
 46 |     | <span class='neutral'>    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block</span>
 47 |     | <span class='neutral'>    /// timestamp</span>
 48 |     | <span class='neutral'>    function observe(uint32[] calldata secondsAgos)</span>
 49 |     | <span class='neutral'>        external</span>
 50 |     | <span class='neutral'>        view</span>
 51 |     | <span class='neutral'>        returns (</span>
 52 |     | <span class='neutral'>            int56[] memory tickCumulatives,</span>
 53 |     | <span class='neutral'>            uint160[] memory secondsPerLiquidityCumulativeX128s</span>
 54 |     | <span class='neutral'>        );</span>
 55 |     | <span class='neutral'>}</span>
 56 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/interfaces/modules/sources/ITwapSource.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../structs/PoolsharkStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface ITwapSource {</span>
  7 |     | <span class='neutral'>    function initialize(</span>
  8 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
  9 |     | <span class='neutral'>    ) external returns (</span>
 10 |     | <span class='neutral'>        uint8 initializable,</span>
 11 |     | <span class='neutral'>        int24 startingTick</span>
 12 |     | <span class='neutral'>    );</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function calculateAverageTick(</span>
 15 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants,</span>
 16 |     | <span class='neutral'>        int24 latestTick</span>
 17 |     | <span class='neutral'>    ) external view returns (</span>
 18 |     | <span class='neutral'>        int24 averageTick</span>
 19 |     | <span class='neutral'>    );</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function getPool(</span>
 22 |     | <span class='neutral'>        address tokenA,</span>
 23 |     | <span class='neutral'>        address tokenB,</span>
 24 |     | <span class='neutral'>        uint16 feeTier</span>
 25 |     | <span class='neutral'>    ) external view returns (</span>
 26 |     | <span class='neutral'>        address pool</span>
 27 |     | <span class='neutral'>    );</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    function feeTierTickSpacing(</span>
 30 |     | <span class='neutral'>        uint16 feeTier</span>
 31 |     | <span class='neutral'>    ) external view returns (</span>
 32 |     | <span class='neutral'>        int24 tickSpacing</span>
 33 |     | <span class='neutral'>    );</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function factory()</span>
 36 |     | <span class='neutral'>    external view returns (address);</span>
 37 |     | <span class='neutral'>}</span>
 38 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/interfaces/structs/CoverPoolStructs.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./PoolsharkStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../modules/sources/ITwapSource.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>interface CoverPoolStructs is PoolsharkStructs {</span>
   8 |     | <span class='neutral'>    struct GlobalState {</span>
   9 |     | <span class='neutral'>        ProtocolFees protocolFees;</span>
  10 |     | <span class='neutral'>        uint160  latestPrice;      /// @dev price of latestTick</span>
  11 |     | <span class='neutral'>        uint128  liquidityGlobal;</span>
  12 |     | <span class='neutral'>        uint32   lastTime;         /// @dev last block checked</span>
  13 |     | <span class='neutral'>        uint32   auctionStart;     /// @dev last block price reference was updated</span>
  14 |     | <span class='neutral'>        uint32   accumEpoch;       /// @dev number of times this pool has been synced</span>
  15 |     | <span class='neutral'>        uint32   positionIdNext;</span>
  16 |     | <span class='neutral'>        int24    latestTick;       /// @dev latest updated inputPool price tick</span>
  17 |     | <span class='neutral'>        uint16   syncFee;</span>
  18 |     | <span class='neutral'>        uint16   fillFee;</span>
  19 |     | <span class='neutral'>        uint8    unlocked;</span>
  20 |     | <span class='neutral'>    }</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    struct PoolState {</span>
  23 |     | <span class='neutral'>        uint160 price; /// @dev Starting price current</span>
  24 |     | <span class='neutral'>        uint128 liquidity; /// @dev Liquidity currently active</span>
  25 |     | <span class='neutral'>        uint128 amountInDelta; /// @dev Delta for the current tick auction</span>
  26 |     | <span class='neutral'>        uint128 amountInDeltaMaxClaimed;  /// @dev - needed when users claim and don&#39;t burn; should be cleared when users burn liquidity</span>
  27 |     | <span class='neutral'>        uint128 amountOutDeltaMaxClaimed; /// @dev - needed when users claim and don&#39;t burn; should be cleared when users burn liquidity</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    struct TickMap {</span>
  31 |     | <span class='neutral'>        uint256 blocks;                     /// @dev - sets of words</span>
  32 |     | <span class='neutral'>        mapping(uint256 =&gt; uint256) words;  /// @dev - sets to words</span>
  33 |     | <span class='neutral'>        mapping(uint256 =&gt; uint256) ticks;  /// @dev - words to ticks</span>
  34 |     | <span class='neutral'>        mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256))) epochs0; /// @dev - ticks to pool0 epochs</span>
  35 |     | <span class='neutral'>        mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256))) epochs1; /// @dev - ticks to pool1 epochs</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    struct Tick {</span>
  39 |     | <span class='neutral'>        Deltas deltas0;</span>
  40 |     | <span class='neutral'>        Deltas deltas1;                    </span>
  41 |     | <span class='neutral'>        int128 liquidityDelta;</span>
  42 |     | <span class='neutral'>        uint128 amountInDeltaMaxMinus;</span>
  43 |     | <span class='neutral'>        uint128 amountOutDeltaMaxMinus;</span>
  44 |     | <span class='neutral'>        uint128 amountInDeltaMaxStashed;</span>
  45 |     | <span class='neutral'>        uint128 amountOutDeltaMaxStashed;</span>
  46 |     | <span class='neutral'>        bool pool0Stash;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    struct Deltas {</span>
  50 |     | <span class='neutral'>        uint128 amountInDelta;     /// @dev - amount filled</span>
  51 |     | <span class='neutral'>        uint128 amountOutDelta;    /// @dev - amount unfilled</span>
  52 |     | <span class='neutral'>        uint128 amountInDeltaMax;  /// @dev - max filled </span>
  53 |     | <span class='neutral'>        uint128 amountOutDeltaMax; /// @dev - max unfilled</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    struct CoverPosition {</span>
  57 |     | <span class='neutral'>        address owner;</span>
  58 |     | <span class='neutral'>        uint160 claimPriceLast;    /// @dev - highest price claimed at</span>
  59 |     | <span class='neutral'>        uint128 liquidity;         /// @dev - expected amount to be used not actual</span>
  60 |     | <span class='neutral'>        uint128 amountIn;          /// @dev - token amount already claimed; balance</span>
  61 |     | <span class='neutral'>        uint128 amountOut;         /// @dev - necessary for non-custodial positions</span>
  62 |     | <span class='neutral'>        uint32  accumEpochLast;    /// @dev - last epoch this position was updated at</span>
  63 |     | <span class='neutral'>        int24 lower;</span>
  64 |     | <span class='neutral'>        int24 upper;</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    struct VolatilityTier {</span>
  68 |     | <span class='neutral'>        uint128 minAmountPerAuction; // based on 18 decimals and then converted based on token decimals</span>
  69 |     | <span class='neutral'>        uint16  auctionLength;</span>
  70 |     | <span class='neutral'>        uint16  blockTime; // average block time where 1e3 is 1 second</span>
  71 |     | <span class='neutral'>        uint16  syncFee;</span>
  72 |     | <span class='neutral'>        uint16  fillFee;</span>
  73 |     | <span class='neutral'>        int16   minPositionWidth;</span>
  74 |     | <span class='neutral'>        bool    minAmountLowerPriced;</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    struct ProtocolFees {</span>
  78 |     | <span class='neutral'>        uint128 token0;</span>
  79 |     | <span class='neutral'>        uint128 token1;</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    struct SyncFees {</span>
  83 |     | <span class='neutral'>        uint128 token0;</span>
  84 |     | <span class='neutral'>        uint128 token1;</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    struct CollectParams {</span>
  88 |     | <span class='neutral'>        SyncFees syncFees;</span>
  89 |     | <span class='neutral'>        address to;</span>
  90 |     | <span class='neutral'>        uint32 positionId;</span>
  91 |     | <span class='neutral'>        int24 lower;</span>
  92 |     | <span class='neutral'>        int24 claim;</span>
  93 |     | <span class='neutral'>        int24 upper;</span>
  94 |     | <span class='neutral'>        bool zeroForOne;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    struct SizeParams {</span>
  98 |     | <span class='neutral'>        uint256 priceLower;</span>
  99 |     | <span class='neutral'>        uint256 priceUpper;</span>
 100 |     | <span class='neutral'>        uint128 liquidityAmount;</span>
 101 |     | <span class='neutral'>        bool zeroForOne;</span>
 102 |     | <span class='neutral'>        int24 latestTick;</span>
 103 |     | <span class='neutral'>        uint24 auctionCount;</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    struct AddParams {</span>
 107 |     | <span class='neutral'>        address to;</span>
 108 |     | <span class='neutral'>        uint128 amount;</span>
 109 |     | <span class='neutral'>        uint128 amountIn;</span>
 110 |     | <span class='neutral'>        uint32 positionId;</span>
 111 |     | <span class='neutral'>        int24 lower;</span>
 112 |     | <span class='neutral'>        int24 upper;</span>
 113 |     | <span class='neutral'>        bool zeroForOne;</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    struct RemoveParams {</span>
 117 |     | <span class='neutral'>        address owner;</span>
 118 |     | <span class='neutral'>        address to;</span>
 119 |     | <span class='neutral'>        uint128 amount;</span>
 120 |     | <span class='neutral'>        uint32 positionId;</span>
 121 |     | <span class='neutral'>        int24 lower;</span>
 122 |     | <span class='neutral'>        int24 upper;</span>
 123 |     | <span class='neutral'>        bool zeroForOne;</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    struct UpdateParams {</span>
 127 |     | <span class='neutral'>        address owner;</span>
 128 |     | <span class='neutral'>        address to;</span>
 129 |     | <span class='neutral'>        uint128 amount;</span>
 130 |     | <span class='neutral'>        uint32 positionId;</span>
 131 |     | <span class='neutral'>        int24 lower;</span>
 132 |     | <span class='neutral'>        int24 upper;</span>
 133 |     | <span class='neutral'>        int24 claim;</span>
 134 |     | <span class='neutral'>        bool zeroForOne;</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    struct MintCache {</span>
 138 |     | <span class='neutral'>        GlobalState state;</span>
 139 |     | <span class='neutral'>        CoverPosition position;</span>
 140 |     | <span class='neutral'>        CoverImmutables constants;</span>
 141 |     | <span class='neutral'>        SyncFees syncFees;</span>
 142 |     | <span class='neutral'>        PoolState pool0;</span>
 143 |     | <span class='neutral'>        PoolState pool1;</span>
 144 |     | <span class='neutral'>        uint256 liquidityMinted;</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    struct BurnCache {</span>
 148 |     | <span class='neutral'>        GlobalState state;</span>
 149 |     | <span class='neutral'>        CoverPosition position;</span>
 150 |     | <span class='neutral'>        CoverImmutables constants;</span>
 151 |     | <span class='neutral'>        SyncFees syncFees;</span>
 152 |     | <span class='neutral'>        PoolState pool0;</span>
 153 |     | <span class='neutral'>        PoolState pool1;</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    struct SwapCache {</span>
 157 |     | <span class='neutral'>        GlobalState state;</span>
 158 |     | <span class='neutral'>        SyncFees syncFees;</span>
 159 |     | <span class='neutral'>        CoverImmutables constants;</span>
 160 |     | <span class='neutral'>        PoolState pool0;</span>
 161 |     | <span class='neutral'>        PoolState pool1;</span>
 162 |     | <span class='neutral'>        uint256 price;</span>
 163 |     | <span class='neutral'>        uint256 liquidity;</span>
 164 |     | <span class='neutral'>        uint256 amountLeft;</span>
 165 |     | <span class='neutral'>        uint256 input;</span>
 166 |     | <span class='neutral'>        uint256 output;</span>
 167 |     | <span class='neutral'>        uint256 amountBoosted;</span>
 168 |     | <span class='neutral'>        uint256 auctionDepth;</span>
 169 |     | <span class='neutral'>        uint256 auctionBoost;</span>
 170 |     | <span class='neutral'>        uint256 amountInDelta;</span>
 171 |     | <span class='neutral'>        int256 amount0Delta;</span>
 172 |     | <span class='neutral'>        int256 amount1Delta;</span>
 173 |     | <span class='neutral'>        bool exactIn;</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    struct CoverPositionCache {</span>
 177 |     | <span class='neutral'>        CoverPosition position;</span>
 178 |     | <span class='neutral'>        Deltas deltas;</span>
 179 |     | <span class='neutral'>        uint160 priceLower;</span>
 180 |     | <span class='neutral'>        uint160 priceUpper;</span>
 181 |     | <span class='neutral'>        uint256 priceAverage;</span>
 182 |     | <span class='neutral'>        uint256 liquidityMinted;</span>
 183 |     | <span class='neutral'>        int24 requiredStart;</span>
 184 |     | <span class='neutral'>        uint24 auctionCount;</span>
 185 |     | <span class='neutral'>        bool denomTokenIn;</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    struct UpdatePositionCache {</span>
 189 |     | <span class='neutral'>        Deltas deltas;</span>
 190 |     | <span class='neutral'>        Deltas finalDeltas;</span>
 191 |     | <span class='neutral'>        PoolState pool;</span>
 192 |     | <span class='neutral'>        uint256 amountInFilledMax;    // considers the range covered by each update</span>
 193 |     | <span class='neutral'>        uint256 amountOutUnfilledMax; // considers the range covered by each update</span>
 194 |     | <span class='neutral'>        Tick claimTick;</span>
 195 |     | <span class='neutral'>        Tick finalTick;</span>
 196 |     | <span class='neutral'>        CoverPosition position;</span>
 197 |     | <span class='neutral'>        uint160 priceLower;</span>
 198 |     | <span class='neutral'>        uint160 priceClaim;</span>
 199 |     | <span class='neutral'>        uint160 priceUpper;</span>
 200 |     | <span class='neutral'>        uint160 priceSpread;</span>
 201 |     | <span class='neutral'>        bool earlyReturn;</span>
 202 |     | <span class='neutral'>        bool removeLower;</span>
 203 |     | <span class='neutral'>        bool removeUpper;</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    struct AccumulateCache {</span>
 207 |     | <span class='neutral'>        Deltas deltas0;</span>
 208 |     | <span class='neutral'>        Deltas deltas1;</span>
 209 |     | <span class='neutral'>        SyncFees syncFees;</span>
 210 |     | <span class='neutral'>        int24 newLatestTick;</span>
 211 |     | <span class='neutral'>        int24 nextTickToCross0;</span>
 212 |     | <span class='neutral'>        int24 nextTickToCross1;</span>
 213 |     | <span class='neutral'>        int24 nextTickToAccum0;</span>
 214 |     | <span class='neutral'>        int24 nextTickToAccum1;</span>
 215 |     | <span class='neutral'>        int24 stopTick0;</span>
 216 |     | <span class='neutral'>        int24 stopTick1;</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>    struct AccumulateParams {</span>
 220 |     | <span class='neutral'>        Deltas deltas;</span>
 221 |     | <span class='neutral'>        Tick crossTick;</span>
 222 |     | <span class='neutral'>        Tick accumTick;</span>
 223 |     | <span class='neutral'>        bool updateAccumDeltas;</span>
 224 |     | <span class='neutral'>        bool isPool0;</span>
 225 |     | <span class='neutral'>    }</span>
 226 |     | <span class='neutral'>}</span>
 227 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/interfaces/structs/PoolsharkStructs.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../modules/sources/ITwapSource.sol&#39;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>interface PoolsharkStructs {</span>
   7 |     | <span class='neutral'>    struct LimitImmutables {</span>
   8 |     | <span class='neutral'>        address owner;</span>
   9 |     | <span class='neutral'>        address poolImpl;</span>
  10 |     | <span class='neutral'>        address factory;</span>
  11 |     | <span class='neutral'>        PriceBounds bounds;</span>
  12 |     | <span class='neutral'>        address token0;</span>
  13 |     | <span class='neutral'>        address token1;</span>
  14 |     | <span class='neutral'>        address poolToken;</span>
  15 |     | <span class='neutral'>        uint32 genesisTime;</span>
  16 |     | <span class='neutral'>        int16 tickSpacing;</span>
  17 |     | <span class='neutral'>        uint16 swapFee;</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    struct CoverImmutables {</span>
  21 |     | <span class='neutral'>        ITwapSource source;</span>
  22 |     | <span class='neutral'>        PriceBounds bounds;</span>
  23 |     | <span class='neutral'>        address owner;</span>
  24 |     | <span class='neutral'>        address token0;</span>
  25 |     | <span class='neutral'>        address token1;</span>
  26 |     | <span class='neutral'>        address poolImpl;</span>
  27 |     | <span class='neutral'>        address inputPool;</span>
  28 |     | <span class='neutral'>        uint128 minAmountPerAuction;</span>
  29 |     | <span class='neutral'>        uint32 genesisTime;</span>
  30 |     | <span class='neutral'>        int16  minPositionWidth;</span>
  31 |     | <span class='neutral'>        int16  tickSpread;</span>
  32 |     | <span class='neutral'>        uint16 twapLength;</span>
  33 |     | <span class='neutral'>        uint16 auctionLength;</span>
  34 |     | <span class='neutral'>        uint16 blockTime;</span>
  35 |     | <span class='neutral'>        uint8 token0Decimals;</span>
  36 |     | <span class='neutral'>        uint8 token1Decimals;</span>
  37 |     | <span class='neutral'>        bool minAmountLowerPriced;</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    struct PriceBounds {</span>
  41 |     | <span class='neutral'>        uint160 min;</span>
  42 |     | <span class='neutral'>        uint160 max;</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    struct QuoteResults {</span>
  46 |     | <span class='neutral'>        address pool;</span>
  47 |     | <span class='neutral'>        int256 amountIn;</span>
  48 |     | <span class='neutral'>        int256 amountOut;</span>
  49 |     | <span class='neutral'>        uint160 priceAfter;</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    /**</span>
  53 |     | <span class='neutral'>     * @custom:struct QuoteParams</span>
  54 |     | <span class='neutral'>     */</span>
  55 |     | <span class='neutral'>    struct QuoteParams {</span>
  56 |     | <span class='neutral'>        /**</span>
  57 |     | <span class='neutral'>         * @custom:field priceLimit</span>
  58 |     | <span class='neutral'>         * @dev The Q64.96 square root price at which to stop swapping.</span>
  59 |     | <span class='neutral'>         */</span>
  60 |     | <span class='neutral'>        uint160 priceLimit;</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>        /**</span>
  63 |     | <span class='neutral'>         * @custom:field amount</span>
  64 |     | <span class='neutral'>         * @dev The exact input amount if exactIn = true</span>
  65 |     | <span class='neutral'>         * @dev The exact output amount if exactIn = false.</span>
  66 |     | <span class='neutral'>         */</span>
  67 |     | <span class='neutral'>        uint128 amount;</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>        /**</span>
  70 |     | <span class='neutral'>         * @custom:field zeroForOne</span>
  71 |     | <span class='neutral'>         * @notice True if amount is an input amount.</span>
  72 |     | <span class='neutral'>         * @notice False if amount is an output amount. </span>
  73 |     | <span class='neutral'>         */</span>
  74 |     | <span class='neutral'>        bool exactIn;</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        /**</span>
  77 |     | <span class='neutral'>         * @custom:field zeroForOne</span>
  78 |     | <span class='neutral'>         * @notice True if swapping token0 for token1.</span>
  79 |     | <span class='neutral'>         * @notice False if swapping in token1 for token0. </span>
  80 |     | <span class='neutral'>         */</span>
  81 |     | <span class='neutral'>        bool zeroForOne;</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    /**</span>
  85 |     | <span class='neutral'>     * @custom:struct SwapParams</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='neutral'>    struct SwapParams {</span>
  88 |     | <span class='neutral'>        /**</span>
  89 |     | <span class='neutral'>         * @custom:field to</span>
  90 |     | <span class='neutral'>         * @notice Address for the receiver of the swap output</span>
  91 |     | <span class='neutral'>         */</span>
  92 |     | <span class='neutral'>        address to;</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>        /**</span>
  95 |     | <span class='neutral'>         * @custom:field priceLimit</span>
  96 |     | <span class='neutral'>         * @dev The Q64.96 square root price at which to stop swapping.</span>
  97 |     | <span class='neutral'>         */</span>
  98 |     | <span class='neutral'>        uint160 priceLimit;</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>        /**</span>
 101 |     | <span class='neutral'>         * @custom:field amount</span>
 102 |     | <span class='neutral'>         * @dev The exact input amount if exactIn = true</span>
 103 |     | <span class='neutral'>         * @dev The exact output amount if exactIn = false.</span>
 104 |     | <span class='neutral'>         */</span>
 105 |     | <span class='neutral'>        uint128 amount;</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>        /**</span>
 108 |     | <span class='neutral'>         * @custom:field zeroForOne</span>
 109 |     | <span class='neutral'>         * @notice True if amount is an input amount.</span>
 110 |     | <span class='neutral'>         * @notice False if amount is an output amount. </span>
 111 |     | <span class='neutral'>         */</span>
 112 |     | <span class='neutral'>        bool exactIn;</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>        /**</span>
 115 |     | <span class='neutral'>         * @custom:field zeroForOne</span>
 116 |     | <span class='neutral'>         * @notice True if swapping token0 for token1.</span>
 117 |     | <span class='neutral'>         * @notice False if swapping in token1 for token0. </span>
 118 |     | <span class='neutral'>         */</span>
 119 |     | <span class='neutral'>        bool zeroForOne;</span>
 120 |     | <span class='neutral'>        </span>
 121 |     | <span class='neutral'>        /**</span>
 122 |     | <span class='neutral'>         * @custom:field callbackData</span>
 123 |     | <span class='neutral'>         * @notice Data to be passed through to the swap callback. </span>
 124 |     | <span class='neutral'>         */</span>
 125 |     | <span class='neutral'>         bytes callbackData;</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/libraries/Claims.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./Deltas.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../interfaces/structs/CoverPoolStructs.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./EpochMap.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./TickMap.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./utils/String.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>library Claims {</span>
  11 |     | <span class='unexecuted'>    function validate(</span>
  12 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
  13 |     | <span class='neutral'>        CoverPoolStructs.GlobalState memory state,</span>
  14 |     | <span class='neutral'>        CoverPoolStructs.PoolState memory pool,</span>
  15 |     | <span class='neutral'>        CoverPoolStructs.UpdateParams memory params,</span>
  16 |     | <span class='neutral'>        CoverPoolStructs.UpdatePositionCache memory cache,</span>
  17 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
  18 |     | <span class='neutral'>    ) internal view returns (</span>
  19 |     | <span class='unexecuted'>        CoverPoolStructs.UpdateParams memory,</span>
  20 |     | <span class='unexecuted'>        CoverPoolStructs.UpdatePositionCache memory</span>
  21 |     | <span class='neutral'>    ) {</span>
  22 |     | <span class='neutral'>        // validate position liquidity</span>
  23 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
  24 |     | <span class='unexecuted'>            cache.earlyReturn = true;</span>
  25 |     | <span class='unexecuted'>            return (params, cache);</span>
  26 |     | <span class='neutral'>        }</span>
  27 |     | <span class='unexecuted'>        if (params.amount &gt; cache.position.liquidity) require (false, &#39;NotEnoughPositionLiquidity()&#39;);</span>
  28 |     | <span class='neutral'>        // if the position has not been crossed into at all</span>
  29 |     | <span class='unexecuted'>        else if (params.zeroForOne ? params.claim == params.upper </span>
  30 |     | <span class='unexecuted'>                                        &amp;&amp; EpochMap.get(params.upper, params.zeroForOne, tickMap, constants) &lt;= cache.position.accumEpochLast</span>
  31 |     | <span class='unexecuted'>                                     : params.claim == params.lower </span>
  32 |     | <span class='unexecuted'>                                        &amp;&amp; EpochMap.get(params.lower, params.zeroForOne, tickMap, constants) &lt;= cache.position.accumEpochLast</span>
  33 |     | <span class='neutral'>        ) {</span>
  34 |     | <span class='unexecuted'>            cache.earlyReturn = true;</span>
  35 |     | <span class='unexecuted'>            return (params, cache);</span>
  36 |     | <span class='neutral'>        }</span>
  37 |     | <span class='neutral'>        // early return if no update and amount burned is 0</span>
  38 |     | <span class='unexecuted'>        if (</span>
  39 |     | <span class='unexecuted'>            (</span>
  40 |     | <span class='unexecuted'>                params.zeroForOne</span>
  41 |     | <span class='unexecuted'>                    ? params.claim == params.upper &amp;&amp; cache.priceUpper != pool.price</span>
  42 |     | <span class='unexecuted'>                    : params.claim == params.lower &amp;&amp; cache.priceLower != pool.price /// @dev - if pool price is start tick, set claimPriceLast to next tick crossed</span>
  43 |     | <span class='unexecuted'>            ) &amp;&amp; params.claim == state.latestTick</span>
  44 |     | <span class='unexecuted'>        ) { if (params.amount == 0 &amp;&amp; cache.position.claimPriceLast == pool.price) {</span>
  45 |     | <span class='unexecuted'>                cache.earlyReturn = true;</span>
  46 |     | <span class='unexecuted'>                return (params, cache);</span>
  47 |     | <span class='neutral'>            } </span>
  48 |     | <span class='neutral'>        } /// @dev - nothing to update if pool price hasn&#39;t moved</span>
  49 |     | <span class='neutral'>        </span>
  50 |     | <span class='neutral'>        // claim tick sanity checks</span>
  51 |     | <span class='unexecuted'>        else if (</span>
  52 |     | <span class='neutral'>            // claim tick is on a prior tick</span>
  53 |     | <span class='unexecuted'>            cache.position.claimPriceLast &gt; 0 &amp;&amp;</span>
  54 |     | <span class='unexecuted'>            (params.zeroForOne</span>
  55 |     | <span class='unexecuted'>                    ? cache.position.claimPriceLast &lt; cache.priceClaim</span>
  56 |     | <span class='unexecuted'>                    : cache.position.claimPriceLast &gt; cache.priceClaim</span>
  57 |     | <span class='unexecuted'>            ) &amp;&amp; params.claim != state.latestTick</span>
  58 |     | <span class='unexecuted'>        ) require (false, &#39;InvalidClaimTick()&#39;); /// @dev - wrong claim tick</span>
  59 |     | <span class='unexecuted'>        if (params.claim &lt; params.lower || params.claim &gt; params.upper) require (false, &#39;InvalidClaimTick()&#39;);</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>        uint32 claimTickEpoch = EpochMap.get(params.claim, params.zeroForOne, tickMap, constants);</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>        // validate claim tick</span>
  64 |     | <span class='unexecuted'>        if (params.claim == (params.zeroForOne ? params.lower : params.upper)) {</span>
  65 |     | <span class='unexecuted'>             if (claimTickEpoch &lt;= cache.position.accumEpochLast)</span>
  66 |     | <span class='unexecuted'>                require (false, &#39;WrongTickClaimedAt()&#39;);</span>
  67 |     | <span class='neutral'>        } else {</span>
  68 |     | <span class='neutral'>            // check end tick </span>
  69 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
  70 |     | <span class='unexecuted'>                uint32 endTickAccumEpoch = EpochMap.get(cache.position.lower, params.zeroForOne, tickMap, constants);</span>
  71 |     | <span class='unexecuted'>                if (endTickAccumEpoch &gt; cache.position.accumEpochLast) {</span>
  72 |     | <span class='neutral'>                    // set claim to final tick</span>
  73 |     | <span class='unexecuted'>                    params.claim = cache.position.lower;</span>
  74 |     | <span class='unexecuted'>                    cache.priceClaim = cache.priceLower;</span>
  75 |     | <span class='unexecuted'>                    cache.claimTick = cache.finalTick;</span>
  76 |     | <span class='neutral'>                    // force user to remove all liquidity</span>
  77 |     | <span class='unexecuted'>                    params.amount = cache.position.liquidity;</span>
  78 |     | <span class='unexecuted'>                } else {</span>
  79 |     | <span class='unexecuted'>                    int24 claimTickNext = TickMap.previous(params.claim, tickMap, constants);</span>
  80 |     | <span class='unexecuted'>                    uint32 claimTickNextEpoch = EpochMap.get(claimTickNext, params.zeroForOne, tickMap, constants);</span>
  81 |     | <span class='neutral'>                    ///@dev - next accumEpoch should not be greater</span>
  82 |     | <span class='unexecuted'>                    if (claimTickNextEpoch &gt; cache.position.accumEpochLast) {</span>
  83 |     | <span class='unexecuted'>                        require (false, &#39;WrongTickClaimedAt()&#39;);</span>
  84 |     | <span class='neutral'>                    }</span>
  85 |     | <span class='neutral'>                }</span>
  86 |     | <span class='unexecuted'>            } else {</span>
  87 |     | <span class='unexecuted'>                uint32 endTickAccumEpoch = EpochMap.get(cache.position.upper, params.zeroForOne, tickMap, constants);</span>
  88 |     | <span class='unexecuted'>                if (endTickAccumEpoch &gt; cache.position.accumEpochLast) {</span>
  89 |     | <span class='neutral'>                    // set claim to final tick</span>
  90 |     | <span class='unexecuted'>                    params.claim = cache.position.upper;</span>
  91 |     | <span class='unexecuted'>                    cache.priceClaim = cache.priceUpper;</span>
  92 |     | <span class='unexecuted'>                    cache.claimTick = cache.finalTick;</span>
  93 |     | <span class='neutral'>                    // force user to remove all liquidity</span>
  94 |     | <span class='unexecuted'>                    params.amount = cache.position.liquidity;</span>
  95 |     | <span class='unexecuted'>                } else {</span>
  96 |     | <span class='unexecuted'>                    int24 claimTickNext = TickMap.next(params.claim, tickMap, constants);</span>
  97 |     | <span class='unexecuted'>                    uint32 claimTickNextEpoch = EpochMap.get(claimTickNext, params.zeroForOne, tickMap, constants);</span>
  98 |     | <span class='neutral'>                    ///@dev - next accumEpoch should not be greater</span>
  99 |     | <span class='unexecuted'>                    if (claimTickNextEpoch &gt; cache.position.accumEpochLast) {</span>
 100 |     | <span class='unexecuted'>                        require (false, &#39;WrongTickClaimedAt()&#39;);</span>
 101 |     | <span class='neutral'>                    }</span>
 102 |     | <span class='neutral'>                }</span>
 103 |     | <span class='neutral'>            }</span>
 104 |     | <span class='neutral'>        }</span>
 105 |     | <span class='unexecuted'>        if (params.claim != params.upper &amp;&amp; params.claim != params.lower) {</span>
 106 |     | <span class='neutral'>            // check accumEpochLast on claim tick</span>
 107 |     | <span class='unexecuted'>            if (claimTickEpoch &lt;= cache.position.accumEpochLast)</span>
 108 |     | <span class='unexecuted'>                require (false, &#39;WrongTickClaimedAt()&#39;);</span>
 109 |     | <span class='neutral'>            /// @dev - user cannot add liquidity if auction is active; checked for in Positions.validate()</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='unexecuted'>        return (params, cache);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>    function getDeltas(</span>
 115 |     | <span class='neutral'>        CoverPoolStructs.UpdatePositionCache memory cache,</span>
 116 |     | <span class='neutral'>        CoverPoolStructs.UpdateParams memory params</span>
 117 |     | <span class='neutral'>    ) internal pure returns (</span>
 118 |     | <span class='unexecuted'>        CoverPoolStructs.UpdatePositionCache memory</span>
 119 |     | <span class='neutral'>    ) {</span>
 120 |     | <span class='neutral'>        // transfer deltas into cache</span>
 121 |     | <span class='unexecuted'>        if (params.claim == (params.zeroForOne ? params.lower : params.upper)) {</span>
 122 |     | <span class='unexecuted'>            (cache.claimTick, cache.deltas) = Deltas.from(cache.claimTick, cache.deltas, params.zeroForOne);</span>
 123 |     | <span class='unexecuted'>        } else {</span>
 124 |     | <span class='neutral'>            /// @dev - deltas are applied once per each tick claimed at</span>
 125 |     | <span class='neutral'>            /// @dev - deltas should never be applied if position is not crossed into</span>
 126 |     | <span class='neutral'>            // check if tick already claimed at</span>
 127 |     | <span class='unexecuted'>            bool transferDeltas = (cache.position.claimPriceLast == 0</span>
 128 |     | <span class='unexecuted'>                               &amp;&amp; (params.claim != (params.zeroForOne ? params.upper : params.lower)))</span>
 129 |     | <span class='unexecuted'>                               || (params.zeroForOne ? cache.position.claimPriceLast &gt; cache.priceClaim</span>
 130 |     | <span class='unexecuted'>                                                     : cache.position.claimPriceLast &lt; cache.priceClaim &amp;&amp; cache.position.claimPriceLast != 0);</span>
 131 |     | <span class='unexecuted'>            if (transferDeltas) {</span>
 132 |     | <span class='unexecuted'>                (cache.claimTick, cache.deltas) = Deltas.unstash(cache.claimTick, cache.deltas, params.zeroForOne);</span>
 133 |     | <span class='neutral'>            }</span>
 134 |     | <span class='neutral'>        } /// @dev - deltas transfer from claim tick are replaced after applying changes</span>
 135 |     | <span class='unexecuted'>        return cache;</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>    function applyDeltas(</span>
 139 |     | <span class='neutral'>        CoverPoolStructs.GlobalState memory state,</span>
 140 |     | <span class='neutral'>        CoverPoolStructs.UpdatePositionCache memory cache,</span>
 141 |     | <span class='neutral'>        CoverPoolStructs.UpdateParams memory params</span>
 142 |     | <span class='neutral'>    ) internal pure returns (</span>
 143 |     | <span class='unexecuted'>        CoverPoolStructs.UpdatePositionCache memory</span>
 144 |     | <span class='neutral'>    ) {</span>
 145 |     | <span class='unexecuted'>        uint256 percentInDelta; uint256 percentOutDelta;</span>
 146 |     | <span class='unexecuted'>        if(cache.deltas.amountInDeltaMax &gt; 0) {</span>
 147 |     | <span class='unexecuted'>            percentInDelta = uint256(cache.amountInFilledMax) * 1e38 / uint256(cache.deltas.amountInDeltaMax);</span>
 148 |     | <span class='unexecuted'>            percentInDelta = percentInDelta &gt; 1e38 ? 1e38 : percentInDelta;</span>
 149 |     | <span class='unexecuted'>            if (cache.deltas.amountOutDeltaMax &gt; 0) {</span>
 150 |     | <span class='unexecuted'>                percentOutDelta = uint256(cache.amountOutUnfilledMax) * 1e38 / uint256(cache.deltas.amountOutDeltaMax);</span>
 151 |     | <span class='unexecuted'>                percentOutDelta = percentOutDelta &gt; 1e38 ? 1e38 : percentOutDelta;</span>
 152 |     | <span class='neutral'>            }</span>
 153 |     | <span class='neutral'>        }</span>
 154 |     | <span class='unexecuted'>        (cache.deltas, cache.finalDeltas) = Deltas.transfer(cache.deltas, cache.finalDeltas, percentInDelta, percentOutDelta);</span>
 155 |     | <span class='unexecuted'>        (cache.deltas, cache.finalDeltas) = Deltas.transferMax(cache.deltas, cache.finalDeltas, percentInDelta, percentOutDelta);</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='unexecuted'>        uint128 fillFeeAmount = cache.finalDeltas.amountInDelta * state.fillFee / 1e6;</span>
 158 |     | <span class='unexecuted'>        if (params.zeroForOne) {</span>
 159 |     | <span class='unexecuted'>            state.protocolFees.token1 += fillFeeAmount;</span>
 160 |     | <span class='neutral'>        } else {</span>
 161 |     | <span class='unexecuted'>            state.protocolFees.token0 += fillFeeAmount;</span>
 162 |     | <span class='neutral'>        }</span>
 163 |     | <span class='unexecuted'>        cache.finalDeltas.amountInDelta -= fillFeeAmount;</span>
 164 |     | <span class='unexecuted'>        cache.position.amountIn  += cache.finalDeltas.amountInDelta;</span>
 165 |     | <span class='unexecuted'>        cache.position.amountOut += cache.finalDeltas.amountOutDelta;</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='unexecuted'>        if (params.claim != (params.zeroForOne ? params.lower : params.upper)) {</span>
 168 |     | <span class='neutral'>            // burn deltas on final tick of position</span>
 169 |     | <span class='unexecuted'>            cache.finalTick = Deltas.burnMaxMinus(cache.finalTick, cache.finalDeltas);</span>
 170 |     | <span class='neutral'>            // update deltas on claim tick</span>
 171 |     | <span class='unexecuted'>            if (params.claim == (params.zeroForOne ? params.upper : params.lower)) {</span>
 172 |     | <span class='unexecuted'>                (cache.deltas, cache.claimTick) = Deltas.to(cache.deltas, cache.claimTick, params.zeroForOne);</span>
 173 |     | <span class='neutral'>            } else {</span>
 174 |     | <span class='unexecuted'>                (cache.deltas, cache.claimTick) = Deltas.stash(cache.deltas, cache.claimTick, params.zeroForOne);</span>
 175 |     | <span class='neutral'>            }</span>
 176 |     | <span class='neutral'>        } else {</span>
 177 |     | <span class='unexecuted'>            (cache.deltas, cache.claimTick) = Deltas.to(cache.deltas, cache.claimTick, params.zeroForOne);</span>
 178 |     | <span class='neutral'>        }</span>
 179 |     | <span class='unexecuted'>        return cache;</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    /// @dev - calculate claim portion of partially claimed previous auction</span>
 183 |     | <span class='unexecuted'>    function section1(</span>
 184 |     | <span class='neutral'>        CoverPoolStructs.UpdatePositionCache memory cache,</span>
 185 |     | <span class='neutral'>        CoverPoolStructs.UpdateParams memory params,</span>
 186 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
 187 |     | <span class='neutral'>    ) internal pure returns (</span>
 188 |     | <span class='unexecuted'>        CoverPoolStructs.UpdatePositionCache memory</span>
 189 |     | <span class='neutral'>    ) {</span>
 190 |     | <span class='neutral'>        // delta check complete - update CPL for new position</span>
 191 |     | <span class='unexecuted'>        if(cache.position.claimPriceLast == 0) {</span>
 192 |     | <span class='unexecuted'>            cache.position.claimPriceLast = (params.zeroForOne ? cache.priceUpper </span>
 193 |     | <span class='unexecuted'>                                                               : cache.priceLower);</span>
 194 |     | <span class='unexecuted'>        } else if (params.zeroForOne ? (cache.position.claimPriceLast != cache.priceUpper</span>
 195 |     | <span class='unexecuted'>                                        &amp;&amp; cache.position.claimPriceLast &gt; cache.priceClaim)</span>
 196 |     | <span class='unexecuted'>                                     : (cache.position.claimPriceLast != cache.priceLower</span>
 197 |     | <span class='unexecuted'>                                        &amp;&amp; cache.position.claimPriceLast &lt; cache.priceClaim))</span>
 198 |     | <span class='neutral'>        {</span>
 199 |     | <span class='neutral'>            // section 1 - complete previous auction claim</span>
 200 |     | <span class='unexecuted'>            {</span>
 201 |     | <span class='neutral'>                // amounts claimed on this update</span>
 202 |     | <span class='unexecuted'>                uint128 amountInFilledMax; uint128 amountOutUnfilledMax;</span>
 203 |     | <span class='unexecuted'>                (</span>
 204 |     | <span class='neutral'>                    amountInFilledMax,</span>
 205 |     | <span class='neutral'>                    amountOutUnfilledMax</span>
 206 |     | <span class='unexecuted'>                ) = Deltas.maxAuction(</span>
 207 |     | <span class='unexecuted'>                    cache.position.liquidity,</span>
 208 |     | <span class='unexecuted'>                    cache.position.claimPriceLast,</span>
 209 |     | <span class='unexecuted'>                    params.zeroForOne ? cache.priceUpper</span>
 210 |     | <span class='unexecuted'>                                      : cache.priceLower,</span>
 211 |     | <span class='unexecuted'>                    params.zeroForOne</span>
 212 |     | <span class='neutral'>                );</span>
 213 |     | <span class='unexecuted'>                cache.amountInFilledMax    += amountInFilledMax;</span>
 214 |     | <span class='unexecuted'>                cache.amountOutUnfilledMax += amountOutUnfilledMax;</span>
 215 |     | <span class='neutral'>            }</span>
 216 |     | <span class='neutral'>            // move price to next tick in sequence for section 2</span>
 217 |     | <span class='unexecuted'>            cache.position.claimPriceLast  = params.zeroForOne ? ConstantProduct.getPriceAtTick(params.upper - constants.tickSpread, constants)</span>
 218 |     | <span class='unexecuted'>                                                               : ConstantProduct.getPriceAtTick(params.lower + constants.tickSpread, constants);</span>
 219 |     | <span class='neutral'>        }</span>
 220 |     | <span class='unexecuted'>        return cache;</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    /// @dev - calculate claim from position start up to claim tick</span>
 224 |     | <span class='unexecuted'>    function section2(</span>
 225 |     | <span class='neutral'>        CoverPoolStructs.UpdatePositionCache memory cache,</span>
 226 |     | <span class='neutral'>        CoverPoolStructs.UpdateParams memory params</span>
 227 |     | <span class='neutral'>    ) internal pure returns (</span>
 228 |     | <span class='unexecuted'>        CoverPoolStructs.UpdatePositionCache memory</span>
 229 |     | <span class='neutral'>    ) {</span>
 230 |     | <span class='neutral'>        // section 2 - position start up to claim tick</span>
 231 |     | <span class='unexecuted'>        if (params.zeroForOne ? cache.priceClaim &lt; cache.position.claimPriceLast </span>
 232 |     | <span class='unexecuted'>                              : cache.priceClaim &gt; cache.position.claimPriceLast) {</span>
 233 |     | <span class='neutral'>            // calculate if we at least cover one full tick</span>
 234 |     | <span class='unexecuted'>            uint128 amountInFilledMax; uint128 amountOutUnfilledMax;</span>
 235 |     | <span class='unexecuted'>            (</span>
 236 |     | <span class='neutral'>                amountInFilledMax,</span>
 237 |     | <span class='neutral'>                amountOutUnfilledMax</span>
 238 |     | <span class='unexecuted'>            ) = Deltas.maxRoundUp(</span>
 239 |     | <span class='unexecuted'>                cache.position.liquidity,</span>
 240 |     | <span class='unexecuted'>                cache.position.claimPriceLast,</span>
 241 |     | <span class='unexecuted'>                cache.priceClaim,</span>
 242 |     | <span class='unexecuted'>                params.zeroForOne</span>
 243 |     | <span class='neutral'>            );</span>
 244 |     | <span class='unexecuted'>            cache.amountInFilledMax += amountInFilledMax;</span>
 245 |     | <span class='unexecuted'>            cache.amountOutUnfilledMax += amountOutUnfilledMax;</span>
 246 |     | <span class='neutral'>        }</span>
 247 |     | <span class='unexecuted'>        return cache;</span>
 248 |     | <span class='neutral'>    }</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>    /// @dev - calculate claim from current auction unfilled section</span>
 251 |     | <span class='unexecuted'>    function section3(</span>
 252 |     | <span class='neutral'>        CoverPoolStructs.UpdatePositionCache memory cache,</span>
 253 |     | <span class='neutral'>        CoverPoolStructs.UpdateParams memory params,</span>
 254 |     | <span class='neutral'>        CoverPoolStructs.PoolState memory pool</span>
 255 |     | <span class='neutral'>    ) internal pure returns (</span>
 256 |     | <span class='unexecuted'>        CoverPoolStructs.UpdatePositionCache memory</span>
 257 |     | <span class='neutral'>    ) {</span>
 258 |     | <span class='neutral'>        // section 3 - current auction unfilled section</span>
 259 |     | <span class='unexecuted'>        if (params.amount &gt; 0) {</span>
 260 |     | <span class='neutral'>            // remove if burn</span>
 261 |     | <span class='unexecuted'>            uint128 amountOutRemoved = uint128(</span>
 262 |     | <span class='unexecuted'>                params.zeroForOne</span>
 263 |     | <span class='unexecuted'>                    ? ConstantProduct.getDx(params.amount, pool.price, cache.priceClaim, false)</span>
 264 |     | <span class='unexecuted'>                    : ConstantProduct.getDy(params.amount, cache.priceClaim, pool.price, false)</span>
 265 |     | <span class='neutral'>            );</span>
 266 |     | <span class='unexecuted'>            uint128 amountInOmitted = uint128(</span>
 267 |     | <span class='unexecuted'>                params.zeroForOne</span>
 268 |     | <span class='unexecuted'>                    ? ConstantProduct.getDy(params.amount, pool.price, cache.priceClaim, false)</span>
 269 |     | <span class='unexecuted'>                    : ConstantProduct.getDx(params.amount, cache.priceClaim, pool.price, false)</span>
 270 |     | <span class='neutral'>            );</span>
 271 |     | <span class='neutral'>            // add to position</span>
 272 |     | <span class='unexecuted'>            cache.position.amountOut += amountOutRemoved;</span>
 273 |     | <span class='neutral'>            // modify max deltas to be burned</span>
 274 |     | <span class='unexecuted'>            cache.finalDeltas.amountInDeltaMax  += amountInOmitted;</span>
 275 |     | <span class='unexecuted'>            cache.finalDeltas.amountOutDeltaMax += amountOutRemoved;</span>
 276 |     | <span class='neutral'>        }</span>
 277 |     | <span class='unexecuted'>        return cache;</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    /// @dev - calculate claim from position start up to claim tick</span>
 281 |     | <span class='unexecuted'>    function section4(</span>
 282 |     | <span class='neutral'>        CoverPoolStructs.UpdatePositionCache memory cache,</span>
 283 |     | <span class='neutral'>        CoverPoolStructs.UpdateParams memory params,</span>
 284 |     | <span class='neutral'>        CoverPoolStructs.PoolState memory pool</span>
 285 |     | <span class='neutral'>    ) internal pure returns (</span>
 286 |     | <span class='unexecuted'>        CoverPoolStructs.UpdatePositionCache memory</span>
 287 |     | <span class='neutral'>    ) {</span>
 288 |     | <span class='neutral'>        // section 4 - current auction filled section</span>
 289 |     | <span class='unexecuted'>        {</span>
 290 |     | <span class='neutral'>            // amounts claimed on this update</span>
 291 |     | <span class='unexecuted'>            uint128 amountInFilledMax; uint128 amountOutUnfilledMax;</span>
 292 |     | <span class='unexecuted'>            (</span>
 293 |     | <span class='neutral'>                amountInFilledMax,</span>
 294 |     | <span class='neutral'>                amountOutUnfilledMax</span>
 295 |     | <span class='unexecuted'>            ) = Deltas.maxAuction(</span>
 296 |     | <span class='unexecuted'>                cache.position.liquidity,</span>
 297 |     | <span class='unexecuted'>                (params.zeroForOne ? cache.position.claimPriceLast &lt; cache.priceClaim</span>
 298 |     | <span class='unexecuted'>                                    : cache.position.claimPriceLast &gt; cache.priceClaim) </span>
 299 |     | <span class='unexecuted'>                                        ? cache.position.claimPriceLast </span>
 300 |     | <span class='unexecuted'>                                        : cache.priceSpread,</span>
 301 |     | <span class='unexecuted'>                pool.price,</span>
 302 |     | <span class='unexecuted'>                params.zeroForOne</span>
 303 |     | <span class='neutral'>            );</span>
 304 |     | <span class='unexecuted'>            uint256 poolAmountInDeltaChange = uint256(cache.position.liquidity) * 1e38 </span>
 305 |     | <span class='unexecuted'>                                                / uint256(pool.liquidity) * uint256(pool.amountInDelta) / 1e38;   </span>
 306 |     | <span class='neutral'>            </span>
 307 |     | <span class='unexecuted'>            cache.position.amountIn += uint128(poolAmountInDeltaChange);</span>
 308 |     | <span class='unexecuted'>            pool.amountInDelta -= uint128(poolAmountInDeltaChange); //CHANGE POOL TO MEMORY</span>
 309 |     | <span class='unexecuted'>            cache.finalDeltas.amountInDeltaMax += amountInFilledMax;</span>
 310 |     | <span class='unexecuted'>            cache.finalDeltas.amountOutDeltaMax += amountOutUnfilledMax;</span>
 311 |     | <span class='neutral'>            /// @dev - record how much delta max was claimed</span>
 312 |     | <span class='unexecuted'>            if (params.amount &lt; cache.position.liquidity) {</span>
 313 |     | <span class='unexecuted'>                (</span>
 314 |     | <span class='neutral'>                    amountInFilledMax,</span>
 315 |     | <span class='neutral'>                    amountOutUnfilledMax</span>
 316 |     | <span class='unexecuted'>                ) = Deltas.maxAuction(</span>
 317 |     | <span class='unexecuted'>                    cache.position.liquidity - params.amount,</span>
 318 |     | <span class='unexecuted'>                    (params.zeroForOne ? cache.position.claimPriceLast &lt; cache.priceClaim</span>
 319 |     | <span class='unexecuted'>                                    : cache.position.claimPriceLast &gt; cache.priceClaim) </span>
 320 |     | <span class='unexecuted'>                                            ? cache.position.claimPriceLast </span>
 321 |     | <span class='unexecuted'>                                            : cache.priceSpread,</span>
 322 |     | <span class='unexecuted'>                    pool.price,</span>
 323 |     | <span class='unexecuted'>                    params.zeroForOne</span>
 324 |     | <span class='neutral'>                );</span>
 325 |     | <span class='unexecuted'>                pool.amountInDeltaMaxClaimed  += amountInFilledMax;</span>
 326 |     | <span class='unexecuted'>                pool.amountOutDeltaMaxClaimed += amountOutUnfilledMax;</span>
 327 |     | <span class='neutral'>            }</span>
 328 |     | <span class='neutral'>        }</span>
 329 |     | <span class='unexecuted'>        if (params.amount &gt; 0 /// @ dev - if removing L and second claim on same tick</span>
 330 |     | <span class='unexecuted'>            &amp;&amp; (params.zeroForOne ? cache.position.claimPriceLast &lt; cache.priceClaim</span>
 331 |     | <span class='unexecuted'>                                    : cache.position.claimPriceLast &gt; cache.priceClaim)) {</span>
 332 |     | <span class='neutral'>                // reduce delta max claimed based on liquidity removed</span>
 333 |     | <span class='unexecuted'>                pool = Deltas.burnMaxPool(pool, cache, params);</span>
 334 |     | <span class='neutral'>        }</span>
 335 |     | <span class='neutral'>        // modify claim price for section 5</span>
 336 |     | <span class='unexecuted'>        cache.priceClaim = cache.priceSpread;</span>
 337 |     | <span class='neutral'>        // save pool changes to cache</span>
 338 |     | <span class='unexecuted'>        cache.pool = pool;</span>
 339 |     | <span class='unexecuted'>        return cache;</span>
 340 |     | <span class='neutral'>    }</span>
 341 |     | <span class='neutral'></span>
 342 |     | <span class='neutral'>    /// @dev - calculate claim from position start up to claim tick</span>
 343 |     | <span class='unexecuted'>    function section5(</span>
 344 |     | <span class='neutral'>        CoverPoolStructs.UpdatePositionCache memory cache,</span>
 345 |     | <span class='neutral'>        CoverPoolStructs.UpdateParams memory params</span>
 346 |     | <span class='neutral'>    ) internal pure returns (</span>
 347 |     | <span class='unexecuted'>        CoverPoolStructs.UpdatePositionCache memory</span>
 348 |     | <span class='neutral'>    ) {</span>
 349 |     | <span class='neutral'>        // section 5 - burned liquidity past claim tick</span>
 350 |     | <span class='unexecuted'>        {</span>
 351 |     | <span class='unexecuted'>            uint160 endPrice = params.zeroForOne ? cache.priceLower</span>
 352 |     | <span class='unexecuted'>                                                 : cache.priceUpper;</span>
 353 |     | <span class='unexecuted'>            if (params.amount &gt; 0 &amp;&amp; cache.priceClaim != endPrice) {</span>
 354 |     | <span class='neutral'>                // update max deltas based on liquidity removed</span>
 355 |     | <span class='unexecuted'>                uint128 amountInOmitted; uint128 amountOutRemoved;</span>
 356 |     | <span class='unexecuted'>                (</span>
 357 |     | <span class='neutral'>                    amountInOmitted,</span>
 358 |     | <span class='neutral'>                    amountOutRemoved</span>
 359 |     | <span class='unexecuted'>                ) = Deltas.max(</span>
 360 |     | <span class='unexecuted'>                    params.amount,</span>
 361 |     | <span class='unexecuted'>                    cache.priceClaim,</span>
 362 |     | <span class='unexecuted'>                    endPrice,</span>
 363 |     | <span class='unexecuted'>                    params.zeroForOne</span>
 364 |     | <span class='neutral'>                );</span>
 365 |     | <span class='unexecuted'>                cache.position.amountOut += amountOutRemoved;</span>
 366 |     | <span class='neutral'>                /// @auditor - we don&#39;t add to cache.amountInFilledMax and cache.amountOutUnfilledMax </span>
 367 |     | <span class='neutral'>                ///            since this section of the curve is not reflected in the deltas</span>
 368 |     | <span class='unexecuted'>                if (params.claim != (params.zeroForOne ? params.lower : params.upper)) {</span>
 369 |     | <span class='unexecuted'>                    cache.finalDeltas.amountInDeltaMax += amountInOmitted;</span>
 370 |     | <span class='unexecuted'>                    cache.finalDeltas.amountOutDeltaMax += amountOutRemoved;</span>
 371 |     | <span class='neutral'>                }      </span>
 372 |     | <span class='neutral'>            }</span>
 373 |     | <span class='neutral'>        }</span>
 374 |     | <span class='unexecuted'>        return cache;</span>
 375 |     | <span class='neutral'>    }</span>
 376 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/libraries/Deltas.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../interfaces/structs/CoverPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./math/ConstantProduct.sol&#39;;</span>
   6 |     | <span class='unexecuted'>library Deltas {</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='unexecuted'>    function max(</span>
   9 |     | <span class='neutral'>        uint128 liquidity,</span>
  10 |     | <span class='neutral'>        uint160 priceStart,</span>
  11 |     | <span class='neutral'>        uint160 priceEnd,</span>
  12 |     | <span class='neutral'>        bool   isPool0</span>
  13 |     | <span class='neutral'>    ) internal pure returns (</span>
  14 |     | <span class='unexecuted'>        uint128 amountInDeltaMax,</span>
  15 |     | <span class='unexecuted'>        uint128 amountOutDeltaMax</span>
  16 |     | <span class='neutral'>    ) {</span>
  17 |     | <span class='unexecuted'>        amountInDeltaMax = uint128(</span>
  18 |     | <span class='unexecuted'>            isPool0</span>
  19 |     | <span class='unexecuted'>                ? ConstantProduct.getDy(</span>
  20 |     | <span class='unexecuted'>                    liquidity,</span>
  21 |     | <span class='unexecuted'>                    priceEnd,</span>
  22 |     | <span class='unexecuted'>                    priceStart,</span>
  23 |     | <span class='unexecuted'>                    false</span>
  24 |     | <span class='neutral'>                )</span>
  25 |     | <span class='unexecuted'>                : ConstantProduct.getDx(</span>
  26 |     | <span class='unexecuted'>                    liquidity,</span>
  27 |     | <span class='unexecuted'>                    priceStart,</span>
  28 |     | <span class='unexecuted'>                    priceEnd,</span>
  29 |     | <span class='unexecuted'>                    false</span>
  30 |     | <span class='neutral'>                )</span>
  31 |     | <span class='neutral'>        );</span>
  32 |     | <span class='unexecuted'>        amountOutDeltaMax = uint128(</span>
  33 |     | <span class='unexecuted'>            isPool0</span>
  34 |     | <span class='unexecuted'>                ? ConstantProduct.getDx(</span>
  35 |     | <span class='unexecuted'>                    liquidity,</span>
  36 |     | <span class='unexecuted'>                    priceEnd,</span>
  37 |     | <span class='unexecuted'>                    priceStart,</span>
  38 |     | <span class='unexecuted'>                    false</span>
  39 |     | <span class='neutral'>                )</span>
  40 |     | <span class='unexecuted'>                : ConstantProduct.getDy(</span>
  41 |     | <span class='unexecuted'>                    liquidity,</span>
  42 |     | <span class='unexecuted'>                    priceStart,</span>
  43 |     | <span class='unexecuted'>                    priceEnd,</span>
  44 |     | <span class='unexecuted'>                    false</span>
  45 |     | <span class='neutral'>                )</span>
  46 |     | <span class='neutral'>        );</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    function maxRoundUp(</span>
  50 |     | <span class='neutral'>        uint128 liquidity,</span>
  51 |     | <span class='neutral'>        uint160 priceStart,</span>
  52 |     | <span class='neutral'>        uint160 priceEnd,</span>
  53 |     | <span class='neutral'>        bool   isPool0</span>
  54 |     | <span class='neutral'>    ) internal pure returns (</span>
  55 |     | <span class='unexecuted'>        uint128 amountInDeltaMax,</span>
  56 |     | <span class='unexecuted'>        uint128 amountOutDeltaMax</span>
  57 |     | <span class='neutral'>    ) {</span>
  58 |     | <span class='unexecuted'>        amountInDeltaMax = uint128(</span>
  59 |     | <span class='unexecuted'>            isPool0</span>
  60 |     | <span class='unexecuted'>                ? ConstantProduct.getDy(</span>
  61 |     | <span class='unexecuted'>                    liquidity,</span>
  62 |     | <span class='unexecuted'>                    priceEnd,</span>
  63 |     | <span class='unexecuted'>                    priceStart,</span>
  64 |     | <span class='unexecuted'>                    true</span>
  65 |     | <span class='neutral'>                )</span>
  66 |     | <span class='unexecuted'>                : ConstantProduct.getDx(</span>
  67 |     | <span class='unexecuted'>                    liquidity,</span>
  68 |     | <span class='unexecuted'>                    priceStart,</span>
  69 |     | <span class='unexecuted'>                    priceEnd,</span>
  70 |     | <span class='unexecuted'>                    true</span>
  71 |     | <span class='neutral'>                )</span>
  72 |     | <span class='neutral'>        );</span>
  73 |     | <span class='unexecuted'>        amountOutDeltaMax = uint128(</span>
  74 |     | <span class='unexecuted'>            isPool0</span>
  75 |     | <span class='unexecuted'>                ? ConstantProduct.getDx(</span>
  76 |     | <span class='unexecuted'>                    liquidity,</span>
  77 |     | <span class='unexecuted'>                    priceEnd,</span>
  78 |     | <span class='unexecuted'>                    priceStart,</span>
  79 |     | <span class='unexecuted'>                    true</span>
  80 |     | <span class='neutral'>                )</span>
  81 |     | <span class='unexecuted'>                : ConstantProduct.getDy(</span>
  82 |     | <span class='unexecuted'>                    liquidity,</span>
  83 |     | <span class='unexecuted'>                    priceStart,</span>
  84 |     | <span class='unexecuted'>                    priceEnd,</span>
  85 |     | <span class='unexecuted'>                    true</span>
  86 |     | <span class='neutral'>                )</span>
  87 |     | <span class='neutral'>        );</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>    function maxAuction(</span>
  91 |     | <span class='neutral'>        uint128 liquidity,</span>
  92 |     | <span class='neutral'>        uint160 priceStart,</span>
  93 |     | <span class='neutral'>        uint160 priceEnd,</span>
  94 |     | <span class='neutral'>        bool isPool0</span>
  95 |     | <span class='neutral'>    ) internal pure returns (</span>
  96 |     | <span class='unexecuted'>        uint128 amountInDeltaMax,</span>
  97 |     | <span class='unexecuted'>        uint128 amountOutDeltaMax</span>
  98 |     | <span class='neutral'>    ) {</span>
  99 |     | <span class='unexecuted'>        amountInDeltaMax = uint128(</span>
 100 |     | <span class='unexecuted'>            isPool0</span>
 101 |     | <span class='unexecuted'>                ? ConstantProduct.getDy(</span>
 102 |     | <span class='unexecuted'>                    liquidity,</span>
 103 |     | <span class='unexecuted'>                    priceStart,</span>
 104 |     | <span class='unexecuted'>                    priceEnd,</span>
 105 |     | <span class='unexecuted'>                    true</span>
 106 |     | <span class='neutral'>                )</span>
 107 |     | <span class='unexecuted'>                : ConstantProduct.getDx(</span>
 108 |     | <span class='unexecuted'>                    liquidity,</span>
 109 |     | <span class='unexecuted'>                    priceEnd,</span>
 110 |     | <span class='unexecuted'>                    priceStart,</span>
 111 |     | <span class='unexecuted'>                    true</span>
 112 |     | <span class='neutral'>                )</span>
 113 |     | <span class='neutral'>        );</span>
 114 |     | <span class='unexecuted'>        amountOutDeltaMax = uint128(</span>
 115 |     | <span class='unexecuted'>            isPool0</span>
 116 |     | <span class='unexecuted'>                ? ConstantProduct.getDx(</span>
 117 |     | <span class='unexecuted'>                    liquidity,</span>
 118 |     | <span class='unexecuted'>                    priceStart,</span>
 119 |     | <span class='unexecuted'>                    priceEnd,</span>
 120 |     | <span class='unexecuted'>                    true</span>
 121 |     | <span class='neutral'>                )</span>
 122 |     | <span class='unexecuted'>                : ConstantProduct.getDy(</span>
 123 |     | <span class='unexecuted'>                    liquidity,</span>
 124 |     | <span class='unexecuted'>                    priceEnd,</span>
 125 |     | <span class='unexecuted'>                    priceStart,</span>
 126 |     | <span class='unexecuted'>                    true</span>
 127 |     | <span class='neutral'>                )</span>
 128 |     | <span class='neutral'>        );</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>    function transfer(</span>
 132 |     | <span class='neutral'>        CoverPoolStructs.Deltas memory fromDeltas,</span>
 133 |     | <span class='neutral'>        CoverPoolStructs.Deltas memory toDeltas,</span>
 134 |     | <span class='neutral'>        uint256 percentInTransfer,</span>
 135 |     | <span class='neutral'>        uint256 percentOutTransfer</span>
 136 |     | <span class='neutral'>    ) internal pure returns (</span>
 137 |     | <span class='unexecuted'>        CoverPoolStructs.Deltas memory,</span>
 138 |     | <span class='unexecuted'>        CoverPoolStructs.Deltas memory</span>
 139 |     | <span class='neutral'>    ) {</span>
 140 |     | <span class='unexecuted'>        {</span>
 141 |     | <span class='unexecuted'>            uint128 amountInDeltaChange = uint128(uint256(fromDeltas.amountInDelta) * percentInTransfer / 1e38);</span>
 142 |     | <span class='unexecuted'>            if (amountInDeltaChange &lt; fromDeltas.amountInDelta ) {</span>
 143 |     | <span class='unexecuted'>                fromDeltas.amountInDelta -= amountInDeltaChange;</span>
 144 |     | <span class='unexecuted'>                toDeltas.amountInDelta += amountInDeltaChange;</span>
 145 |     | <span class='neutral'>            } else {</span>
 146 |     | <span class='unexecuted'>                toDeltas.amountInDelta += fromDeltas.amountInDelta;</span>
 147 |     | <span class='unexecuted'>                fromDeltas.amountInDelta = 0;</span>
 148 |     | <span class='neutral'>            }</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='unexecuted'>        {</span>
 151 |     | <span class='unexecuted'>            uint128 amountOutDeltaChange = uint128(uint256(fromDeltas.amountOutDelta) * percentOutTransfer / 1e38);</span>
 152 |     | <span class='unexecuted'>            if (amountOutDeltaChange &lt; fromDeltas.amountOutDelta ) {</span>
 153 |     | <span class='unexecuted'>                fromDeltas.amountOutDelta -= amountOutDeltaChange;</span>
 154 |     | <span class='unexecuted'>                toDeltas.amountOutDelta += amountOutDeltaChange;</span>
 155 |     | <span class='neutral'>            } else {</span>
 156 |     | <span class='unexecuted'>                toDeltas.amountOutDelta += fromDeltas.amountOutDelta;</span>
 157 |     | <span class='unexecuted'>                fromDeltas.amountOutDelta = 0;</span>
 158 |     | <span class='neutral'>            }</span>
 159 |     | <span class='neutral'>        }</span>
 160 |     | <span class='unexecuted'>        return (fromDeltas, toDeltas);</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='unexecuted'>    function transferMax(</span>
 164 |     | <span class='neutral'>        CoverPoolStructs.Deltas memory fromDeltas,</span>
 165 |     | <span class='neutral'>        CoverPoolStructs.Deltas memory toDeltas,</span>
 166 |     | <span class='neutral'>        uint256 percentInTransfer,</span>
 167 |     | <span class='neutral'>        uint256 percentOutTransfer</span>
 168 |     | <span class='neutral'>    ) internal pure returns (</span>
 169 |     | <span class='unexecuted'>        CoverPoolStructs.Deltas memory,</span>
 170 |     | <span class='unexecuted'>        CoverPoolStructs.Deltas memory</span>
 171 |     | <span class='neutral'>    ) {</span>
 172 |     | <span class='unexecuted'>        {</span>
 173 |     | <span class='unexecuted'>            uint128 amountInDeltaMaxChange = uint128(uint256(fromDeltas.amountInDeltaMax) * percentInTransfer / 1e38);</span>
 174 |     | <span class='unexecuted'>            if (fromDeltas.amountInDeltaMax &gt; amountInDeltaMaxChange) {</span>
 175 |     | <span class='unexecuted'>                fromDeltas.amountInDeltaMax -= amountInDeltaMaxChange;</span>
 176 |     | <span class='unexecuted'>                toDeltas.amountInDeltaMax += amountInDeltaMaxChange;</span>
 177 |     | <span class='neutral'>            } else {</span>
 178 |     | <span class='unexecuted'>                toDeltas.amountInDeltaMax += fromDeltas.amountInDeltaMax;</span>
 179 |     | <span class='unexecuted'>                fromDeltas.amountInDeltaMax = 0;</span>
 180 |     | <span class='neutral'>            }</span>
 181 |     | <span class='neutral'>        }</span>
 182 |     | <span class='unexecuted'>        {</span>
 183 |     | <span class='unexecuted'>            uint128 amountOutDeltaMaxChange = uint128(uint256(fromDeltas.amountOutDeltaMax) * percentOutTransfer / 1e38);</span>
 184 |     | <span class='unexecuted'>            if (fromDeltas.amountOutDeltaMax &gt; amountOutDeltaMaxChange) {</span>
 185 |     | <span class='unexecuted'>                fromDeltas.amountOutDeltaMax -= amountOutDeltaMaxChange;</span>
 186 |     | <span class='unexecuted'>                toDeltas.amountOutDeltaMax   += amountOutDeltaMaxChange;</span>
 187 |     | <span class='neutral'>            } else {</span>
 188 |     | <span class='unexecuted'>                toDeltas.amountOutDeltaMax += fromDeltas.amountOutDeltaMax;</span>
 189 |     | <span class='unexecuted'>                fromDeltas.amountOutDeltaMax = 0;</span>
 190 |     | <span class='neutral'>            }</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='unexecuted'>        return (fromDeltas, toDeltas);</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='unexecuted'>    function burnMaxCache(</span>
 196 |     | <span class='neutral'>        CoverPoolStructs.Deltas memory fromDeltas,</span>
 197 |     | <span class='neutral'>        CoverPoolStructs.Tick memory burnTick</span>
 198 |     | <span class='neutral'>    ) internal pure returns (</span>
 199 |     | <span class='unexecuted'>        CoverPoolStructs.Deltas memory</span>
 200 |     | <span class='neutral'>    ) {</span>
 201 |     | <span class='unexecuted'>        fromDeltas.amountInDeltaMax -= (fromDeltas.amountInDeltaMax </span>
 202 |     | <span class='unexecuted'>                                         &lt; burnTick.amountInDeltaMaxMinus) ? fromDeltas.amountInDeltaMax</span>
 203 |     | <span class='unexecuted'>                                                                           : burnTick.amountInDeltaMaxMinus;</span>
 204 |     | <span class='unexecuted'>        if (fromDeltas.amountInDeltaMax == 1) {</span>
 205 |     | <span class='unexecuted'>            fromDeltas.amountInDeltaMax = 0; // handle rounding issues</span>
 206 |     | <span class='neutral'>        }</span>
 207 |     | <span class='unexecuted'>        fromDeltas.amountOutDeltaMax -= (fromDeltas.amountOutDeltaMax </span>
 208 |     | <span class='unexecuted'>                                          &lt; burnTick.amountOutDeltaMaxMinus) ? fromDeltas.amountOutDeltaMax</span>
 209 |     | <span class='unexecuted'>                                                                             : burnTick.amountOutDeltaMaxMinus;</span>
 210 |     | <span class='unexecuted'>        return fromDeltas;</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='unexecuted'>    function burnMaxMinus(</span>
 214 |     | <span class='neutral'>        CoverPoolStructs.Tick memory fromTick,</span>
 215 |     | <span class='neutral'>        CoverPoolStructs.Deltas memory burnDeltas</span>
 216 |     | <span class='neutral'>    ) internal pure returns (</span>
 217 |     | <span class='unexecuted'>        CoverPoolStructs.Tick memory</span>
 218 |     | <span class='neutral'>    ) {</span>
 219 |     | <span class='unexecuted'>        fromTick.amountInDeltaMaxMinus -= (fromTick.amountInDeltaMaxMinus</span>
 220 |     | <span class='unexecuted'>                                            &lt; burnDeltas.amountInDeltaMax) ? fromTick.amountInDeltaMaxMinus</span>
 221 |     | <span class='unexecuted'>                                                                           : burnDeltas.amountInDeltaMax;</span>
 222 |     | <span class='unexecuted'>        if (fromTick.amountInDeltaMaxMinus == 1) {</span>
 223 |     | <span class='unexecuted'>            fromTick.amountInDeltaMaxMinus = 0; // handle rounding issues</span>
 224 |     | <span class='neutral'>        }</span>
 225 |     | <span class='unexecuted'>        fromTick.amountOutDeltaMaxMinus -= (fromTick.amountOutDeltaMaxMinus </span>
 226 |     | <span class='unexecuted'>                                             &lt; burnDeltas.amountOutDeltaMax) ? fromTick.amountOutDeltaMaxMinus</span>
 227 |     | <span class='unexecuted'>                                                                                  : burnDeltas.amountOutDeltaMax;</span>
 228 |     | <span class='unexecuted'>        return fromTick;</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='unexecuted'>    function burnMaxPool(</span>
 232 |     | <span class='neutral'>        CoverPoolStructs.PoolState memory pool,</span>
 233 |     | <span class='neutral'>        CoverPoolStructs.UpdatePositionCache memory cache,</span>
 234 |     | <span class='neutral'>        CoverPoolStructs.UpdateParams memory params</span>
 235 |     | <span class='neutral'>    ) internal pure returns (</span>
 236 |     | <span class='unexecuted'>        CoverPoolStructs.PoolState memory</span>
 237 |     | <span class='neutral'>    )</span>
 238 |     | <span class='neutral'>    {</span>
 239 |     | <span class='unexecuted'>        uint128 amountInMaxClaimedBefore; uint128 amountOutMaxClaimedBefore;</span>
 240 |     | <span class='unexecuted'>        (</span>
 241 |     | <span class='neutral'>            amountInMaxClaimedBefore,</span>
 242 |     | <span class='neutral'>            amountOutMaxClaimedBefore</span>
 243 |     | <span class='unexecuted'>        ) = maxAuction(</span>
 244 |     | <span class='unexecuted'>            params.amount,</span>
 245 |     | <span class='unexecuted'>            cache.priceSpread,</span>
 246 |     | <span class='unexecuted'>            cache.position.claimPriceLast,</span>
 247 |     | <span class='unexecuted'>            params.zeroForOne</span>
 248 |     | <span class='neutral'>        );</span>
 249 |     | <span class='unexecuted'>        pool.amountInDeltaMaxClaimed  -= pool.amountInDeltaMaxClaimed &gt; amountInMaxClaimedBefore ? amountInMaxClaimedBefore</span>
 250 |     | <span class='unexecuted'>                                                                                                 : pool.amountInDeltaMaxClaimed;</span>
 251 |     | <span class='unexecuted'>        pool.amountOutDeltaMaxClaimed -= pool.amountOutDeltaMaxClaimed &gt; amountOutMaxClaimedBefore ? amountOutMaxClaimedBefore</span>
 252 |     | <span class='unexecuted'>                                                                                                   : pool.amountOutDeltaMaxClaimed;</span>
 253 |     | <span class='unexecuted'>        return pool;</span>
 254 |     | <span class='neutral'>    }</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>    struct FromLocals {</span>
 257 |     | <span class='neutral'>        CoverPoolStructs.Deltas fromDeltas;</span>
 258 |     | <span class='neutral'>        uint256 percentOnTick;</span>
 259 |     | <span class='neutral'>        uint128 amountInDeltaChange;</span>
 260 |     | <span class='neutral'>        uint128 amountOutDeltaChange;</span>
 261 |     | <span class='neutral'>    }</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='unexecuted'>    function from(</span>
 264 |     | <span class='neutral'>        CoverPoolStructs.Tick memory fromTick,</span>
 265 |     | <span class='neutral'>        CoverPoolStructs.Deltas memory toDeltas,</span>
 266 |     | <span class='neutral'>        bool isPool0</span>
 267 |     | <span class='neutral'>    ) internal pure returns (</span>
 268 |     | <span class='unexecuted'>        CoverPoolStructs.Tick memory,</span>
 269 |     | <span class='unexecuted'>        CoverPoolStructs.Deltas memory</span>
 270 |     | <span class='neutral'>    ) {</span>
 271 |     | <span class='unexecuted'>        FromLocals memory locals;</span>
 272 |     | <span class='unexecuted'>        locals.fromDeltas = isPool0 ? fromTick.deltas0 </span>
 273 |     | <span class='unexecuted'>                                    : fromTick.deltas1;</span>
 274 |     | <span class='unexecuted'>        locals.percentOnTick = uint256(locals.fromDeltas.amountInDeltaMax) * 1e38 / (uint256(locals.fromDeltas.amountInDeltaMax) + uint256(fromTick.amountInDeltaMaxStashed));</span>
 275 |     | <span class='neutral'>        {</span>
 276 |     | <span class='unexecuted'>            locals.amountInDeltaChange = uint128(uint256(locals.fromDeltas.amountInDelta) * locals.percentOnTick / 1e38);</span>
 277 |     | <span class='unexecuted'>            locals.fromDeltas.amountInDelta -= locals.amountInDeltaChange;</span>
 278 |     | <span class='unexecuted'>            toDeltas.amountInDelta += locals.amountInDeltaChange;</span>
 279 |     | <span class='unexecuted'>            toDeltas.amountInDeltaMax += locals.fromDeltas.amountInDeltaMax;</span>
 280 |     | <span class='unexecuted'>            locals.fromDeltas.amountInDeltaMax = 0;</span>
 281 |     | <span class='neutral'>        }</span>
 282 |     | <span class='unexecuted'>        locals.percentOnTick = uint256(locals.fromDeltas.amountOutDeltaMax) * 1e38 / (uint256(locals.fromDeltas.amountOutDeltaMax) + uint256(fromTick.amountOutDeltaMaxStashed));</span>
 283 |     | <span class='neutral'>        {</span>
 284 |     | <span class='unexecuted'>            locals.amountOutDeltaChange = uint128(uint256(locals.fromDeltas.amountOutDelta) * locals.percentOnTick / 1e38);</span>
 285 |     | <span class='unexecuted'>            locals.fromDeltas.amountOutDelta -= locals.amountOutDeltaChange;</span>
 286 |     | <span class='unexecuted'>            toDeltas.amountOutDelta += locals.amountOutDeltaChange;</span>
 287 |     | <span class='unexecuted'>            toDeltas.amountOutDeltaMax += locals.fromDeltas.amountOutDeltaMax;</span>
 288 |     | <span class='unexecuted'>            locals.fromDeltas.amountOutDeltaMax = 0;</span>
 289 |     | <span class='neutral'>        }</span>
 290 |     | <span class='unexecuted'>        if (isPool0) {</span>
 291 |     | <span class='unexecuted'>            fromTick.deltas0 = locals.fromDeltas;</span>
 292 |     | <span class='neutral'>        } else {</span>
 293 |     | <span class='unexecuted'>            fromTick.deltas1 = locals.fromDeltas;</span>
 294 |     | <span class='neutral'>        }</span>
 295 |     | <span class='unexecuted'>        return (fromTick, toDeltas);</span>
 296 |     | <span class='neutral'>    }</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='unexecuted'>    function to(</span>
 299 |     | <span class='neutral'>        CoverPoolStructs.Deltas memory fromDeltas,</span>
 300 |     | <span class='neutral'>        CoverPoolStructs.Tick memory toTick,</span>
 301 |     | <span class='neutral'>        bool isPool0</span>
 302 |     | <span class='neutral'>    ) internal pure returns (</span>
 303 |     | <span class='unexecuted'>        CoverPoolStructs.Deltas memory,</span>
 304 |     | <span class='unexecuted'>        CoverPoolStructs.Tick memory</span>
 305 |     | <span class='neutral'>    ) {</span>
 306 |     | <span class='unexecuted'>        CoverPoolStructs.Deltas memory toDeltas = isPool0 ? toTick.deltas0 </span>
 307 |     | <span class='unexecuted'>                                                          : toTick.deltas1;</span>
 308 |     | <span class='unexecuted'>        toDeltas.amountInDelta     += fromDeltas.amountInDelta;</span>
 309 |     | <span class='unexecuted'>        toDeltas.amountInDeltaMax  += fromDeltas.amountInDeltaMax;</span>
 310 |     | <span class='unexecuted'>        toDeltas.amountOutDelta    += fromDeltas.amountOutDelta;</span>
 311 |     | <span class='unexecuted'>        toDeltas.amountOutDeltaMax += fromDeltas.amountOutDeltaMax;</span>
 312 |     | <span class='unexecuted'>        if (isPool0) {</span>
 313 |     | <span class='unexecuted'>            toTick.deltas0 = toDeltas;</span>
 314 |     | <span class='neutral'>        } else {</span>
 315 |     | <span class='unexecuted'>            toTick.deltas1 = toDeltas;</span>
 316 |     | <span class='neutral'>        }</span>
 317 |     | <span class='unexecuted'>        fromDeltas = CoverPoolStructs.Deltas(0,0,0,0);</span>
 318 |     | <span class='unexecuted'>        return (fromDeltas, toTick);</span>
 319 |     | <span class='neutral'>    }</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='unexecuted'>    function stash(</span>
 322 |     | <span class='neutral'>        CoverPoolStructs.Deltas memory fromDeltas,</span>
 323 |     | <span class='neutral'>        CoverPoolStructs.Tick memory toTick,</span>
 324 |     | <span class='neutral'>        bool isPool0</span>
 325 |     | <span class='neutral'>    ) internal pure returns (</span>
 326 |     | <span class='unexecuted'>        CoverPoolStructs.Deltas memory,</span>
 327 |     | <span class='unexecuted'>        CoverPoolStructs.Tick memory</span>
 328 |     | <span class='neutral'>    ) {</span>
 329 |     | <span class='unexecuted'>        CoverPoolStructs.Deltas memory toDeltas = isPool0 ? toTick.deltas0 </span>
 330 |     | <span class='unexecuted'>                                                          : toTick.deltas1;</span>
 331 |     | <span class='neutral'>        // store deltas on tick</span>
 332 |     | <span class='unexecuted'>        toDeltas.amountInDelta     += fromDeltas.amountInDelta;</span>
 333 |     | <span class='unexecuted'>        toDeltas.amountOutDelta    += fromDeltas.amountOutDelta;</span>
 334 |     | <span class='neutral'>        // store delta maxes on stashed deltas</span>
 335 |     | <span class='unexecuted'>        toTick.amountInDeltaMaxStashed  += fromDeltas.amountInDeltaMax;</span>
 336 |     | <span class='unexecuted'>        toTick.amountOutDeltaMaxStashed += fromDeltas.amountOutDeltaMax;</span>
 337 |     | <span class='unexecuted'>        if (isPool0) {</span>
 338 |     | <span class='unexecuted'>            toTick.deltas0 = toDeltas;</span>
 339 |     | <span class='unexecuted'>            toTick.pool0Stash = true;</span>
 340 |     | <span class='neutral'>        } else {</span>
 341 |     | <span class='unexecuted'>            toTick.deltas1 = toDeltas;</span>
 342 |     | <span class='unexecuted'>            toTick.pool0Stash = false;</span>
 343 |     | <span class='neutral'>        }</span>
 344 |     | <span class='unexecuted'>        fromDeltas = CoverPoolStructs.Deltas(0,0,0,0);</span>
 345 |     | <span class='unexecuted'>        return (fromDeltas, toTick);</span>
 346 |     | <span class='neutral'>    }</span>
 347 |     | <span class='neutral'></span>
 348 |     | <span class='neutral'>    struct UnstashLocals {</span>
 349 |     | <span class='neutral'>        CoverPoolStructs.Deltas fromDeltas;</span>
 350 |     | <span class='neutral'>        uint256 totalDeltaMax;</span>
 351 |     | <span class='neutral'>        uint256 percentStashed;</span>
 352 |     | <span class='neutral'>        uint128 amountInDeltaChange;</span>
 353 |     | <span class='neutral'>        uint128 amountOutDeltaChange;</span>
 354 |     | <span class='neutral'>    }</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='unexecuted'>    function unstash(</span>
 357 |     | <span class='neutral'>        CoverPoolStructs.Tick memory fromTick,</span>
 358 |     | <span class='neutral'>        CoverPoolStructs.Deltas memory toDeltas,</span>
 359 |     | <span class='neutral'>        bool isPool0</span>
 360 |     | <span class='neutral'>    ) internal pure returns (</span>
 361 |     | <span class='unexecuted'>        CoverPoolStructs.Tick memory,</span>
 362 |     | <span class='unexecuted'>        CoverPoolStructs.Deltas memory</span>
 363 |     | <span class='neutral'>    ) {</span>
 364 |     | <span class='unexecuted'>        toDeltas.amountInDeltaMax  += fromTick.amountInDeltaMaxStashed;</span>
 365 |     | <span class='unexecuted'>        toDeltas.amountOutDeltaMax += fromTick.amountOutDeltaMaxStashed;</span>
 366 |     | <span class='neutral'></span>
 367 |     | <span class='unexecuted'>        UnstashLocals memory locals;</span>
 368 |     | <span class='unexecuted'>        locals.fromDeltas = isPool0 ? fromTick.deltas0 : fromTick.deltas1;</span>
 369 |     | <span class='unexecuted'>        locals.totalDeltaMax = uint256(fromTick.amountInDeltaMaxStashed) + uint256(locals.fromDeltas.amountInDeltaMax);</span>
 370 |     | <span class='neutral'>        </span>
 371 |     | <span class='unexecuted'>        if (locals.totalDeltaMax &gt; 0) {</span>
 372 |     | <span class='unexecuted'>            locals.percentStashed = uint256(fromTick.amountInDeltaMaxStashed) * 1e38 / locals.totalDeltaMax;</span>
 373 |     | <span class='unexecuted'>            locals.amountInDeltaChange = uint128(uint256(locals.fromDeltas.amountInDelta) * locals.percentStashed / 1e38);</span>
 374 |     | <span class='unexecuted'>            locals.fromDeltas.amountInDelta -= locals.amountInDeltaChange;</span>
 375 |     | <span class='unexecuted'>            toDeltas.amountInDelta += locals.amountInDeltaChange;</span>
 376 |     | <span class='neutral'>        }</span>
 377 |     | <span class='neutral'>        </span>
 378 |     | <span class='unexecuted'>        locals.totalDeltaMax = uint256(fromTick.amountOutDeltaMaxStashed) + uint256(locals.fromDeltas.amountOutDeltaMax);</span>
 379 |     | <span class='neutral'>        </span>
 380 |     | <span class='unexecuted'>        if (locals.totalDeltaMax &gt; 0) {</span>
 381 |     | <span class='unexecuted'>            locals.percentStashed = uint256(fromTick.amountOutDeltaMaxStashed) * 1e38 / locals.totalDeltaMax;</span>
 382 |     | <span class='unexecuted'>            locals.amountOutDeltaChange = uint128(uint256(locals.fromDeltas.amountOutDelta) * locals.percentStashed / 1e38);</span>
 383 |     | <span class='unexecuted'>            locals.fromDeltas.amountOutDelta -= locals.amountOutDeltaChange;</span>
 384 |     | <span class='unexecuted'>            toDeltas.amountOutDelta += locals.amountOutDeltaChange;</span>
 385 |     | <span class='neutral'>        }</span>
 386 |     | <span class='unexecuted'>        if (isPool0) {</span>
 387 |     | <span class='unexecuted'>            fromTick.deltas0 = locals.fromDeltas;</span>
 388 |     | <span class='neutral'>        } else {</span>
 389 |     | <span class='unexecuted'>            fromTick.deltas1 = locals.fromDeltas;</span>
 390 |     | <span class='neutral'>        }</span>
 391 |     | <span class='unexecuted'>        fromTick.amountInDeltaMaxStashed = 0;</span>
 392 |     | <span class='unexecuted'>        fromTick.amountOutDeltaMaxStashed = 0;</span>
 393 |     | <span class='neutral'></span>
 394 |     | <span class='unexecuted'>        return (fromTick, toDeltas);</span>
 395 |     | <span class='neutral'>    }</span>
 396 |     | <span class='neutral'></span>
 397 |     | <span class='unexecuted'>    function update(</span>
 398 |     | <span class='neutral'>        CoverPoolStructs.Tick memory tick,</span>
 399 |     | <span class='neutral'>        uint128 amount,</span>
 400 |     | <span class='neutral'>        uint160 priceLower,</span>
 401 |     | <span class='neutral'>        uint160 priceUpper,</span>
 402 |     | <span class='neutral'>        bool   isPool0,</span>
 403 |     | <span class='neutral'>        bool   isAdded</span>
 404 |     | <span class='neutral'>    ) internal pure returns (</span>
 405 |     | <span class='unexecuted'>        CoverPoolStructs.Tick memory,</span>
 406 |     | <span class='unexecuted'>        CoverPoolStructs.Deltas memory</span>
 407 |     | <span class='neutral'>    ) {</span>
 408 |     | <span class='neutral'>        // update max deltas</span>
 409 |     | <span class='unexecuted'>        uint128 amountInDeltaMax; uint128 amountOutDeltaMax;</span>
 410 |     | <span class='unexecuted'>        if (isPool0) {</span>
 411 |     | <span class='unexecuted'>            (</span>
 412 |     | <span class='neutral'>                amountInDeltaMax,</span>
 413 |     | <span class='neutral'>                amountOutDeltaMax</span>
 414 |     | <span class='unexecuted'>            ) = max(amount, priceUpper, priceLower, true);</span>
 415 |     | <span class='neutral'>        } else {</span>
 416 |     | <span class='unexecuted'>            (</span>
 417 |     | <span class='neutral'>                amountInDeltaMax,</span>
 418 |     | <span class='neutral'>                amountOutDeltaMax</span>
 419 |     | <span class='unexecuted'>            ) = max(amount, priceLower, priceUpper, false);</span>
 420 |     | <span class='neutral'>        }</span>
 421 |     | <span class='unexecuted'>        if (isAdded) {</span>
 422 |     | <span class='unexecuted'>            tick.amountInDeltaMaxMinus  += amountInDeltaMax;</span>
 423 |     | <span class='unexecuted'>            tick.amountOutDeltaMaxMinus += amountOutDeltaMax;</span>
 424 |     | <span class='neutral'>        } else {</span>
 425 |     | <span class='unexecuted'>            tick.amountInDeltaMaxMinus  -= tick.amountInDeltaMaxMinus  &gt; amountInDeltaMax ? amountInDeltaMax</span>
 426 |     | <span class='unexecuted'>                                                                                          : tick.amountInDeltaMaxMinus;</span>
 427 |     | <span class='unexecuted'>            tick.amountOutDeltaMaxMinus -= tick.amountOutDeltaMaxMinus &gt; amountOutDeltaMax ? amountOutDeltaMax                                                                           : tick.amountOutDeltaMaxMinus;</span>
 428 |     | <span class='neutral'>        }</span>
 429 |     | <span class='unexecuted'>        return (tick, CoverPoolStructs.Deltas(0,0,amountInDeltaMax, amountOutDeltaMax));</span>
 430 |     | <span class='neutral'>    }</span>
 431 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/libraries/EpochMap.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./math/ConstantProduct.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../interfaces/structs/CoverPoolStructs.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library EpochMap {</span>
  8 |     | <span class='unexecuted'>    function set(</span>
  9 |     | <span class='neutral'>        int24  tick,</span>
 10 |     | <span class='neutral'>        uint256 epoch,</span>
 11 |     | <span class='neutral'>        bool zeroForOne,</span>
 12 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
 13 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
 14 |     | <span class='unexecuted'>    ) internal {</span>
 15 |     | <span class='unexecuted'>        (</span>
 16 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
 17 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
 18 |     | <span class='unexecuted'>            uint256 blockIndex,</span>
 19 |     | <span class='unexecuted'>            uint256 volumeIndex</span>
 20 |     | <span class='unexecuted'>        ) = getIndices(tick, constants);</span>
 21 |     | <span class='neutral'>        // assert epoch isn&#39;t bigger than max uint32</span>
 22 |     | <span class='unexecuted'>        uint256 epochValue = zeroForOne ? tickMap.epochs0[volumeIndex][blockIndex][wordIndex]</span>
 23 |     | <span class='unexecuted'>                                        : tickMap.epochs1[volumeIndex][blockIndex][wordIndex];</span>
 24 |     | <span class='neutral'>        // clear previous value</span>
 25 |     | <span class='unexecuted'>        epochValue &amp;=  ~(((1 &lt;&lt; 9) - 1) &lt;&lt; ((tickIndex &amp; 0x7) * 32));</span>
 26 |     | <span class='neutral'>        // add new value to word</span>
 27 |     | <span class='unexecuted'>        epochValue |= epoch &lt;&lt; ((tickIndex &amp; 0x7) * 32);</span>
 28 |     | <span class='neutral'>        // store word in map</span>
 29 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 30 |     | <span class='unexecuted'>            tickMap.epochs0[volumeIndex][blockIndex][wordIndex] = epochValue;</span>
 31 |     | <span class='neutral'>        } else {</span>
 32 |     | <span class='unexecuted'>            tickMap.epochs1[volumeIndex][blockIndex][wordIndex] = epochValue;</span>
 33 |     | <span class='neutral'>        }</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='unexecuted'>    function get(</span>
 37 |     | <span class='neutral'>        int24 tick,</span>
 38 |     | <span class='neutral'>        bool zeroForOne,</span>
 39 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
 40 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
 41 |     | <span class='neutral'>    ) internal view returns (</span>
 42 |     | <span class='unexecuted'>        uint32 epoch</span>
 43 |     | <span class='neutral'>    ) {</span>
 44 |     | <span class='unexecuted'>        (</span>
 45 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
 46 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
 47 |     | <span class='unexecuted'>            uint256 blockIndex,</span>
 48 |     | <span class='unexecuted'>            uint256 volumeIndex</span>
 49 |     | <span class='unexecuted'>        ) = getIndices(tick, constants);</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>        uint256 epochValue = zeroForOne ? tickMap.epochs0[volumeIndex][blockIndex][wordIndex]</span>
 52 |     | <span class='unexecuted'>                                        : tickMap.epochs1[volumeIndex][blockIndex][wordIndex];</span>
 53 |     | <span class='neutral'>        // right shift so first 8 bits are epoch value</span>
 54 |     | <span class='unexecuted'>        epochValue &gt;&gt;= ((tickIndex &amp; 0x7) * 32);</span>
 55 |     | <span class='neutral'>        // clear other bits</span>
 56 |     | <span class='unexecuted'>        epochValue &amp;= ((1 &lt;&lt; 32) - 1);</span>
 57 |     | <span class='unexecuted'>        return uint32(epochValue);</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='unexecuted'>    function getIndices(</span>
 61 |     | <span class='neutral'>        int24 tick,</span>
 62 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
 63 |     | <span class='neutral'>    ) public pure returns (</span>
 64 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
 65 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
 66 |     | <span class='unexecuted'>            uint256 blockIndex,</span>
 67 |     | <span class='unexecuted'>            uint256 volumeIndex</span>
 68 |     | <span class='neutral'>        )</span>
 69 |     | <span class='neutral'>    {</span>
 70 |     | <span class='neutral'>        unchecked {</span>
 71 |     | <span class='unexecuted'>            if (tick &gt; ConstantProduct.maxTick(constants.tickSpread)) require (false, &#39;TickIndexOverflow()&#39;);</span>
 72 |     | <span class='unexecuted'>            if (tick &lt; ConstantProduct.minTick(constants.tickSpread)) require (false, &#39;TickIndexUnderflow()&#39;);</span>
 73 |     | <span class='unexecuted'>            if (tick % constants.tickSpread != 0) require (false, &#39;TickIndexInvalid()&#39;);</span>
 74 |     | <span class='unexecuted'>            tickIndex = uint256(int256((tick - ConstantProduct.minTick(constants.tickSpread))) / constants.tickSpread);</span>
 75 |     | <span class='unexecuted'>            wordIndex = tickIndex &gt;&gt; 3;        // 2^3 epochs per word</span>
 76 |     | <span class='unexecuted'>            blockIndex = tickIndex &gt;&gt; 11;      // 2^8 words per block</span>
 77 |     | <span class='unexecuted'>            volumeIndex = tickIndex &gt;&gt; 19;     // 2^8 blocks per volume</span>
 78 |     | <span class='unexecuted'>            if (blockIndex &gt; 1023) require (false, &#39;BlockIndexOverflow()&#39;);</span>
 79 |     | <span class='neutral'>        }</span>
 80 |     | <span class='neutral'>    }</span>
 81 |     | <span class='neutral'></span>
 82 |     | <span class='neutral'>    function _tick (</span>
 83 |     | <span class='neutral'>        uint256 tickIndex,</span>
 84 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
 85 |     | <span class='neutral'>    ) internal pure returns (</span>
 86 |     | <span class='neutral'>        int24 tick</span>
 87 |     | <span class='neutral'>    ) {</span>
 88 |     | <span class='neutral'>        unchecked {</span>
 89 |     | <span class='neutral'>            if (tickIndex &gt; uint24(ConstantProduct.maxTick(constants.tickSpread) * 2)) require (false, &#39;TickIndexOverflow()&#39;);</span>
 90 |     | <span class='neutral'>            tick = int24(int256(tickIndex) * int256(constants.tickSpread) + ConstantProduct.maxTick(constants.tickSpread));</span>
 91 |     | <span class='neutral'>        }</span>
 92 |     | <span class='neutral'>    }</span>
 93 |     | <span class='neutral'>}</span>
 94 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/libraries/Epochs.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../interfaces/modules/sources/ITwapSource.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../interfaces/structs/CoverPoolStructs.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./Deltas.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./Ticks.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./TickMap.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./EpochMap.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../test/echidna/EchidnaAssertions.sol&#39;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='unexecuted'>library Epochs {</span>
  13 |     | <span class='neutral'>    event Sync(</span>
  14 |     | <span class='neutral'>        uint160 pool0Price,</span>
  15 |     | <span class='neutral'>        uint160 pool1Price,</span>
  16 |     | <span class='neutral'>        uint128 pool0Liquidity,</span>
  17 |     | <span class='neutral'>        uint128 pool1Liquidity,</span>
  18 |     | <span class='neutral'>        uint32 auctionStart,</span>
  19 |     | <span class='neutral'>        uint32 accumEpoch,</span>
  20 |     | <span class='neutral'>        int24 oldLatestTick,</span>
  21 |     | <span class='neutral'>        int24 newLatestTick</span>
  22 |     | <span class='neutral'>    );</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    event FinalDeltasAccumulated(</span>
  25 |     | <span class='neutral'>        uint128 amountInDelta,</span>
  26 |     | <span class='neutral'>        uint128 amountOutDelta,</span>
  27 |     | <span class='neutral'>        uint32 accumEpoch,</span>
  28 |     | <span class='neutral'>        int24 accumTick,</span>
  29 |     | <span class='neutral'>        bool isPool0</span>
  30 |     | <span class='neutral'>    );</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    event StashDeltasCleared(</span>
  33 |     | <span class='neutral'>        int24 stashTick,</span>
  34 |     | <span class='neutral'>        bool isPool0</span>
  35 |     | <span class='neutral'>    );</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    event StashDeltasAccumulated(</span>
  38 |     | <span class='neutral'>        uint128 amountInDelta,</span>
  39 |     | <span class='neutral'>        uint128 amountOutDelta,</span>
  40 |     | <span class='neutral'>        uint128 amountInDeltaMaxStashed,</span>
  41 |     | <span class='neutral'>        uint128 amountOutDeltaMaxStashed,</span>
  42 |     | <span class='neutral'>        uint32 accumEpoch,</span>
  43 |     | <span class='neutral'>        int24 stashTick,</span>
  44 |     | <span class='neutral'>        bool isPool0</span>
  45 |     | <span class='neutral'>    );</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    event SyncFeesCollected(</span>
  48 |     | <span class='neutral'>        address collector,</span>
  49 |     | <span class='neutral'>        uint128 token0Amount,</span>
  50 |     | <span class='neutral'>        uint128 token1Amount</span>
  51 |     | <span class='neutral'>    );</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>    function simulateSync(</span>
  54 |     | <span class='neutral'>        mapping(int24 =&gt; CoverPoolStructs.Tick) storage ticks,</span>
  55 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
  56 |     | <span class='neutral'>        CoverPoolStructs.PoolState memory pool0,</span>
  57 |     | <span class='neutral'>        CoverPoolStructs.PoolState memory pool1,</span>
  58 |     | <span class='neutral'>        CoverPoolStructs.GlobalState memory state,</span>
  59 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
  60 |     | <span class='neutral'>    ) internal returns (</span>
  61 |     | <span class='unexecuted'>        CoverPoolStructs.GlobalState memory,</span>
  62 |     | <span class='unexecuted'>        CoverPoolStructs.SyncFees memory,</span>
  63 |     | <span class='unexecuted'>        CoverPoolStructs.PoolState memory,</span>
  64 |     | <span class='unexecuted'>        CoverPoolStructs.PoolState memory</span>
  65 |     | <span class='neutral'>    ) {</span>
  66 |     | <span class='unexecuted'>        CoverPoolStructs.AccumulateCache memory cache;</span>
  67 |     | <span class='unexecuted'>        {</span>
  68 |     | <span class='unexecuted'>            bool earlyReturn;</span>
  69 |     | <span class='unexecuted'>            (cache.newLatestTick, earlyReturn) = _syncTick(state, constants);</span>
  70 |     | <span class='neutral'>            // assert tick is within bounds</span>
  71 |     | <span class='unexecuted'>            EchidnaAssertions.assertTickDivisibleByTickSpacing(cache.newLatestTick, constants.tickSpread);</span>
  72 |     | <span class='unexecuted'>            EchidnaAssertions.assertTickWithinBounds(</span>
  73 |     | <span class='unexecuted'>                cache.newLatestTick,</span>
  74 |     | <span class='unexecuted'>                ConstantProduct.minTick(constants.tickSpread) + constants.tickSpread,</span>
  75 |     | <span class='unexecuted'>                ConstantProduct.maxTick(constants.tickSpread) - constants.tickSpread</span>
  76 |     | <span class='neutral'>            );</span>
  77 |     | <span class='unexecuted'>            if (earlyReturn) {</span>
  78 |     | <span class='unexecuted'>                return (state, CoverPoolStructs.SyncFees(0, 0), pool0, pool1);</span>
  79 |     | <span class='neutral'>            }</span>
  80 |     | <span class='neutral'>            // else we have a TWAP update</span>
  81 |     | <span class='neutral'>        }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>        // setup cache</span>
  84 |     | <span class='unexecuted'>        cache = CoverPoolStructs.AccumulateCache({</span>
  85 |     | <span class='unexecuted'>            deltas0: CoverPoolStructs.Deltas(0, 0, 0, 0), // deltas for pool0</span>
  86 |     | <span class='unexecuted'>            deltas1: CoverPoolStructs.Deltas(0, 0, 0, 0),  // deltas for pool1</span>
  87 |     | <span class='unexecuted'>            syncFees: CoverPoolStructs.SyncFees(0, 0),</span>
  88 |     | <span class='unexecuted'>            newLatestTick: cache.newLatestTick,</span>
  89 |     | <span class='unexecuted'>            nextTickToCross0: state.latestTick, // above</span>
  90 |     | <span class='unexecuted'>            nextTickToCross1: state.latestTick, // below</span>
  91 |     | <span class='unexecuted'>            nextTickToAccum0: TickMap.previous(state.latestTick, tickMap, constants), // below</span>
  92 |     | <span class='unexecuted'>            nextTickToAccum1: TickMap.next(state.latestTick, tickMap, constants),     // above</span>
  93 |     | <span class='unexecuted'>            stopTick0: (cache.newLatestTick &gt; state.latestTick) // where we do stop for pool0 sync</span>
  94 |     | <span class='unexecuted'>                ? state.latestTick - constants.tickSpread</span>
  95 |     | <span class='unexecuted'>                : cache.newLatestTick, </span>
  96 |     | <span class='unexecuted'>            stopTick1: (cache.newLatestTick &gt; state.latestTick) // where we do stop for pool1 sync</span>
  97 |     | <span class='unexecuted'>                ? cache.newLatestTick</span>
  98 |     | <span class='unexecuted'>                : state.latestTick + constants.tickSpread</span>
  99 |     | <span class='neutral'>        });</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>        while (true) {</span>
 102 |     | <span class='neutral'>            // rollover and calculate sync fees</span>
 103 |     | <span class='unexecuted'>            (cache, pool0) = _rollover(state, cache, pool0, constants, true);</span>
 104 |     | <span class='neutral'>            // keep looping until accumulation reaches stopTick0 </span>
 105 |     | <span class='unexecuted'>            if (cache.nextTickToAccum0 &gt;= cache.stopTick0) {</span>
 106 |     | <span class='unexecuted'>                (pool0.liquidity, cache.nextTickToCross0, cache.nextTickToAccum0) = _cross(</span>
 107 |     | <span class='unexecuted'>                    ticks[cache.nextTickToAccum0].liquidityDelta,</span>
 108 |     | <span class='unexecuted'>                    tickMap,</span>
 109 |     | <span class='unexecuted'>                    constants,</span>
 110 |     | <span class='unexecuted'>                    cache.nextTickToCross0,</span>
 111 |     | <span class='unexecuted'>                    cache.nextTickToAccum0,</span>
 112 |     | <span class='unexecuted'>                    pool0.liquidity,</span>
 113 |     | <span class='unexecuted'>                    true</span>
 114 |     | <span class='neutral'>                );</span>
 115 |     | <span class='unexecuted'>            } else break;</span>
 116 |     | <span class='neutral'>        }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>        while (true) {</span>
 119 |     | <span class='unexecuted'>            (cache, pool1) = _rollover(state, cache, pool1, constants, false);</span>
 120 |     | <span class='neutral'>            // keep looping until accumulation reaches stopTick1 </span>
 121 |     | <span class='unexecuted'>            if (cache.nextTickToAccum1 &lt;= cache.stopTick1) {</span>
 122 |     | <span class='unexecuted'>                (pool1.liquidity, cache.nextTickToCross1, cache.nextTickToAccum1) = _cross(</span>
 123 |     | <span class='unexecuted'>                    ticks[cache.nextTickToAccum1].liquidityDelta,</span>
 124 |     | <span class='unexecuted'>                    tickMap,</span>
 125 |     | <span class='unexecuted'>                    constants,</span>
 126 |     | <span class='unexecuted'>                    cache.nextTickToCross1,</span>
 127 |     | <span class='unexecuted'>                    cache.nextTickToAccum1,</span>
 128 |     | <span class='unexecuted'>                    pool1.liquidity,</span>
 129 |     | <span class='unexecuted'>                    false</span>
 130 |     | <span class='neutral'>                );</span>
 131 |     | <span class='unexecuted'>            } else break;</span>
 132 |     | <span class='neutral'>        }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>        // update ending pool price for fully filled auction</span>
 135 |     | <span class='unexecuted'>        state.latestPrice = ConstantProduct.getPriceAtTick(cache.newLatestTick, constants);</span>
 136 |     | <span class='neutral'>        </span>
 137 |     | <span class='neutral'>        // set pool price and liquidity</span>
 138 |     | <span class='unexecuted'>        if (cache.newLatestTick &gt; state.latestTick) {</span>
 139 |     | <span class='unexecuted'>            pool0.liquidity = 0;</span>
 140 |     | <span class='unexecuted'>            pool0.price = state.latestPrice;</span>
 141 |     | <span class='unexecuted'>            pool1.price = ConstantProduct.getPriceAtTick(cache.newLatestTick + constants.tickSpread, constants);</span>
 142 |     | <span class='neutral'>        } else {</span>
 143 |     | <span class='unexecuted'>            pool1.liquidity = 0;</span>
 144 |     | <span class='unexecuted'>            pool0.price = ConstantProduct.getPriceAtTick(cache.newLatestTick - constants.tickSpread, constants);</span>
 145 |     | <span class='unexecuted'>            pool1.price = state.latestPrice;</span>
 146 |     | <span class='neutral'>        }</span>
 147 |     | <span class='neutral'>        </span>
 148 |     | <span class='neutral'>        // set auction start as an offset of the pool genesis block</span>
 149 |     | <span class='unexecuted'>        state.auctionStart = uint32(block.timestamp) - constants.genesisTime;</span>
 150 |     | <span class='unexecuted'>        state.latestTick = cache.newLatestTick;</span>
 151 |     | <span class='neutral'>    </span>
 152 |     | <span class='unexecuted'>        return (state, cache.syncFees, pool0, pool1);</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='unexecuted'>    function syncLatest(</span>
 156 |     | <span class='neutral'>        mapping(int24 =&gt; CoverPoolStructs.Tick) storage ticks,</span>
 157 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
 158 |     | <span class='neutral'>        CoverPoolStructs.PoolState memory pool0,</span>
 159 |     | <span class='neutral'>        CoverPoolStructs.PoolState memory pool1,</span>
 160 |     | <span class='neutral'>        CoverPoolStructs.GlobalState memory state,</span>
 161 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
 162 |     | <span class='neutral'>    ) internal returns (</span>
 163 |     | <span class='unexecuted'>        CoverPoolStructs.GlobalState memory,</span>
 164 |     | <span class='unexecuted'>        CoverPoolStructs.SyncFees memory,</span>
 165 |     | <span class='unexecuted'>        CoverPoolStructs.PoolState memory,</span>
 166 |     | <span class='unexecuted'>        CoverPoolStructs.PoolState memory</span>
 167 |     | <span class='neutral'>    )</span>
 168 |     | <span class='neutral'>    {</span>
 169 |     | <span class='unexecuted'>        CoverPoolStructs.AccumulateCache memory cache;</span>
 170 |     | <span class='unexecuted'>        {</span>
 171 |     | <span class='unexecuted'>            bool earlyReturn;</span>
 172 |     | <span class='unexecuted'>            (cache.newLatestTick, earlyReturn) = _syncTick(state, constants);</span>
 173 |     | <span class='unexecuted'>            if (earlyReturn) {</span>
 174 |     | <span class='unexecuted'>                return (state, CoverPoolStructs.SyncFees(0,0), pool0, pool1);</span>
 175 |     | <span class='neutral'>            }</span>
 176 |     | <span class='neutral'>            // else we have a TWAP update</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>        // increase epoch counter</span>
 180 |     | <span class='unexecuted'>        state.accumEpoch += 1;</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>        // setup cache</span>
 183 |     | <span class='unexecuted'>        cache = CoverPoolStructs.AccumulateCache({</span>
 184 |     | <span class='unexecuted'>            deltas0: CoverPoolStructs.Deltas(0, 0, 0, 0), // deltas for pool0</span>
 185 |     | <span class='unexecuted'>            deltas1: CoverPoolStructs.Deltas(0, 0, 0, 0),  // deltas for pool1</span>
 186 |     | <span class='unexecuted'>            syncFees: CoverPoolStructs.SyncFees(0,0),</span>
 187 |     | <span class='unexecuted'>            newLatestTick: cache.newLatestTick,</span>
 188 |     | <span class='unexecuted'>            nextTickToCross0: state.latestTick, // above</span>
 189 |     | <span class='unexecuted'>            nextTickToCross1: state.latestTick, // below</span>
 190 |     | <span class='unexecuted'>            nextTickToAccum0: TickMap.previous(state.latestTick, tickMap, constants), // below</span>
 191 |     | <span class='unexecuted'>            nextTickToAccum1: TickMap.next(state.latestTick, tickMap, constants),     // above</span>
 192 |     | <span class='unexecuted'>            stopTick0: (cache.newLatestTick &gt; state.latestTick) // where we do stop for pool0 sync</span>
 193 |     | <span class='unexecuted'>                ? state.latestTick - constants.tickSpread</span>
 194 |     | <span class='unexecuted'>                : cache.newLatestTick, </span>
 195 |     | <span class='unexecuted'>            stopTick1: (cache.newLatestTick &gt; state.latestTick) // where we do stop for pool1 sync</span>
 196 |     | <span class='unexecuted'>                ? cache.newLatestTick</span>
 197 |     | <span class='unexecuted'>                : state.latestTick + constants.tickSpread</span>
 198 |     | <span class='neutral'>        });</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='unexecuted'>        while (true) {</span>
 201 |     | <span class='unexecuted'>            EchidnaAssertions.assertInfiniteLoop0(cache.nextTickToCross0, cache.nextTickToAccum0);</span>
 202 |     | <span class='neutral'>            // get values from current auction</span>
 203 |     | <span class='unexecuted'>            (cache, pool0) = _rollover(state, cache, pool0, constants, true);</span>
 204 |     | <span class='unexecuted'>            if (cache.nextTickToAccum0 &gt; cache.stopTick0 </span>
 205 |     | <span class='unexecuted'>                 &amp;&amp; ticks[cache.nextTickToAccum0].amountInDeltaMaxMinus &gt; 0) {</span>
 206 |     | <span class='unexecuted'>                EpochMap.set(cache.nextTickToAccum0, state.accumEpoch, true, tickMap, constants);</span>
 207 |     | <span class='neutral'>            }</span>
 208 |     | <span class='neutral'>            // accumulate to next tick</span>
 209 |     | <span class='unexecuted'>            CoverPoolStructs.AccumulateParams memory params = CoverPoolStructs.AccumulateParams({</span>
 210 |     | <span class='unexecuted'>                deltas: cache.deltas0,</span>
 211 |     | <span class='unexecuted'>                crossTick: ticks[cache.nextTickToCross0],</span>
 212 |     | <span class='unexecuted'>                accumTick: ticks[cache.nextTickToAccum0],</span>
 213 |     | <span class='unexecuted'>                updateAccumDeltas: cache.newLatestTick &gt; state.latestTick                // check twap move up or down</span>
 214 |     | <span class='unexecuted'>                                            ? cache.nextTickToAccum0 == cache.stopTick0  // move up - true at stop tick</span>
 215 |     | <span class='unexecuted'>                                            : cache.nextTickToAccum0 &gt;= cache.stopTick0, // move down - at or above stop tick</span>
 216 |     | <span class='unexecuted'>                isPool0: true</span>
 217 |     | <span class='neutral'>            });</span>
 218 |     | <span class='unexecuted'>            params = _accumulate(</span>
 219 |     | <span class='unexecuted'>                cache,</span>
 220 |     | <span class='unexecuted'>                params,</span>
 221 |     | <span class='unexecuted'>                state</span>
 222 |     | <span class='neutral'>            );</span>
 223 |     | <span class='neutral'>            /// @dev - deltas in cache updated after _accumulate</span>
 224 |     | <span class='unexecuted'>            cache.deltas0 = params.deltas;</span>
 225 |     | <span class='unexecuted'>            ticks[cache.nextTickToAccum0] = params.accumTick;</span>
 226 |     | <span class='unexecuted'>            Ticks.cleanup(</span>
 227 |     | <span class='unexecuted'>               ticks,</span>
 228 |     | <span class='unexecuted'>               tickMap,</span>
 229 |     | <span class='unexecuted'>               constants,</span>
 230 |     | <span class='unexecuted'>               params.crossTick,</span>
 231 |     | <span class='unexecuted'>               cache.nextTickToCross0</span>
 232 |     | <span class='neutral'>            );</span>
 233 |     | <span class='neutral'>    </span>
 234 |     | <span class='neutral'>            // keep looping until accumulation reaches stopTick0 </span>
 235 |     | <span class='unexecuted'>            if (cache.nextTickToAccum0 &gt;= cache.stopTick0) {</span>
 236 |     | <span class='unexecuted'>                (pool0.liquidity, cache.nextTickToCross0, cache.nextTickToAccum0) = _cross(</span>
 237 |     | <span class='unexecuted'>                    ticks[cache.nextTickToAccum0].liquidityDelta,</span>
 238 |     | <span class='unexecuted'>                    tickMap,</span>
 239 |     | <span class='unexecuted'>                    constants,</span>
 240 |     | <span class='unexecuted'>                    cache.nextTickToCross0,</span>
 241 |     | <span class='unexecuted'>                    cache.nextTickToAccum0,</span>
 242 |     | <span class='unexecuted'>                    pool0.liquidity,</span>
 243 |     | <span class='unexecuted'>                    true</span>
 244 |     | <span class='neutral'>                );</span>
 245 |     | <span class='unexecuted'>            } else break;</span>
 246 |     | <span class='neutral'>        }</span>
 247 |     | <span class='neutral'>        // pool0 checkpoint</span>
 248 |     | <span class='unexecuted'>        {</span>
 249 |     | <span class='neutral'>            // create stopTick0 if necessary</span>
 250 |     | <span class='unexecuted'>            if (cache.nextTickToAccum0 != cache.stopTick0) {</span>
 251 |     | <span class='unexecuted'>                TickMap.set(cache.stopTick0, tickMap, constants);</span>
 252 |     | <span class='neutral'>            }</span>
 253 |     | <span class='unexecuted'>            CoverPoolStructs.Tick memory stopTick0 = ticks[cache.stopTick0];</span>
 254 |     | <span class='neutral'>            // checkpoint at stopTick0</span>
 255 |     | <span class='unexecuted'>            (stopTick0) = _stash(</span>
 256 |     | <span class='unexecuted'>                stopTick0,</span>
 257 |     | <span class='unexecuted'>                cache,</span>
 258 |     | <span class='unexecuted'>                state,</span>
 259 |     | <span class='unexecuted'>                pool0.liquidity,</span>
 260 |     | <span class='unexecuted'>                true</span>
 261 |     | <span class='neutral'>            );</span>
 262 |     | <span class='unexecuted'>            EpochMap.set(cache.stopTick0, state.accumEpoch, true, tickMap, constants);</span>
 263 |     | <span class='unexecuted'>            ticks[cache.stopTick0] = stopTick0;</span>
 264 |     | <span class='neutral'>        }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='unexecuted'>        while (true) {</span>
 267 |     | <span class='neutral'>            // rollover deltas pool1</span>
 268 |     | <span class='unexecuted'>            (cache, pool1) = _rollover(state, cache, pool1, constants, false);</span>
 269 |     | <span class='neutral'>            // accumulate deltas pool1</span>
 270 |     | <span class='unexecuted'>            if (cache.nextTickToAccum1 &lt; cache.stopTick1 </span>
 271 |     | <span class='unexecuted'>                 &amp;&amp; ticks[cache.nextTickToAccum1].amountInDeltaMaxMinus &gt; 0) {</span>
 272 |     | <span class='unexecuted'>                EpochMap.set(cache.nextTickToAccum1, state.accumEpoch, false, tickMap, constants);</span>
 273 |     | <span class='neutral'>            }</span>
 274 |     | <span class='unexecuted'>            {</span>
 275 |     | <span class='unexecuted'>                CoverPoolStructs.AccumulateParams memory params = CoverPoolStructs.AccumulateParams({</span>
 276 |     | <span class='unexecuted'>                    deltas: cache.deltas1,</span>
 277 |     | <span class='unexecuted'>                    crossTick: ticks[cache.nextTickToCross1],</span>
 278 |     | <span class='unexecuted'>                    accumTick: ticks[cache.nextTickToAccum1],</span>
 279 |     | <span class='unexecuted'>                    updateAccumDeltas: cache.newLatestTick &gt; state.latestTick                   // check twap move up or down</span>
 280 |     | <span class='unexecuted'>                                                ? cache.nextTickToAccum1 &lt;= cache.stopTick1     // move up - below or at</span>
 281 |     | <span class='unexecuted'>                                                : cache.nextTickToAccum1 == cache.stopTick1,    // move down - at</span>
 282 |     | <span class='unexecuted'>                    isPool0: false</span>
 283 |     | <span class='neutral'>                });</span>
 284 |     | <span class='unexecuted'>                params = _accumulate(</span>
 285 |     | <span class='unexecuted'>                    cache,</span>
 286 |     | <span class='unexecuted'>                    params,</span>
 287 |     | <span class='unexecuted'>                    state</span>
 288 |     | <span class='neutral'>                );</span>
 289 |     | <span class='neutral'>                /// @dev - deltas in cache updated after _accumulate</span>
 290 |     | <span class='unexecuted'>                cache.deltas1 = params.deltas;</span>
 291 |     | <span class='unexecuted'>                ticks[cache.nextTickToAccum1] = params.accumTick;</span>
 292 |     | <span class='unexecuted'>                Ticks.cleanup(</span>
 293 |     | <span class='unexecuted'>                    ticks,</span>
 294 |     | <span class='unexecuted'>                    tickMap,</span>
 295 |     | <span class='unexecuted'>                    constants,</span>
 296 |     | <span class='unexecuted'>                    params.crossTick,</span>
 297 |     | <span class='unexecuted'>                    cache.nextTickToCross1</span>
 298 |     | <span class='neutral'>                );</span>
 299 |     | <span class='neutral'>            }</span>
 300 |     | <span class='neutral'>            // keep looping until accumulation reaches stopTick1 </span>
 301 |     | <span class='unexecuted'>            if (cache.nextTickToAccum1 &lt;= cache.stopTick1) {</span>
 302 |     | <span class='unexecuted'>                (pool1.liquidity, cache.nextTickToCross1, cache.nextTickToAccum1) = _cross(</span>
 303 |     | <span class='unexecuted'>                    ticks[cache.nextTickToAccum1].liquidityDelta,</span>
 304 |     | <span class='unexecuted'>                    tickMap,</span>
 305 |     | <span class='unexecuted'>                    constants,</span>
 306 |     | <span class='unexecuted'>                    cache.nextTickToCross1,</span>
 307 |     | <span class='unexecuted'>                    cache.nextTickToAccum1,</span>
 308 |     | <span class='unexecuted'>                    pool1.liquidity,</span>
 309 |     | <span class='unexecuted'>                    false</span>
 310 |     | <span class='neutral'>                );</span>
 311 |     | <span class='unexecuted'>            } else break;</span>
 312 |     | <span class='neutral'>        }</span>
 313 |     | <span class='neutral'>        // pool1 checkpoint</span>
 314 |     | <span class='unexecuted'>        {</span>
 315 |     | <span class='neutral'>            // create stopTick1 if necessary</span>
 316 |     | <span class='unexecuted'>            if (cache.nextTickToAccum1 != cache.stopTick1) {</span>
 317 |     | <span class='unexecuted'>                TickMap.set(cache.stopTick1, tickMap, constants);</span>
 318 |     | <span class='neutral'>            }</span>
 319 |     | <span class='unexecuted'>            CoverPoolStructs.Tick memory stopTick1 = ticks[cache.stopTick1];</span>
 320 |     | <span class='neutral'>            // update deltas on stopTick</span>
 321 |     | <span class='unexecuted'>            (stopTick1) = _stash(</span>
 322 |     | <span class='unexecuted'>                stopTick1,</span>
 323 |     | <span class='unexecuted'>                cache,</span>
 324 |     | <span class='unexecuted'>                state,</span>
 325 |     | <span class='unexecuted'>                pool1.liquidity,</span>
 326 |     | <span class='unexecuted'>                false</span>
 327 |     | <span class='neutral'>            );</span>
 328 |     | <span class='unexecuted'>            ticks[cache.stopTick1] = stopTick1;</span>
 329 |     | <span class='unexecuted'>            EpochMap.set(cache.stopTick1, state.accumEpoch, false, tickMap, constants);</span>
 330 |     | <span class='neutral'>        }</span>
 331 |     | <span class='neutral'>        // update ending pool price for fully filled auction</span>
 332 |     | <span class='unexecuted'>        state.latestPrice = ConstantProduct.getPriceAtTick(cache.newLatestTick, constants);</span>
 333 |     | <span class='neutral'>        </span>
 334 |     | <span class='neutral'>        // set pool price and liquidity</span>
 335 |     | <span class='unexecuted'>        if (cache.newLatestTick &gt; state.latestTick) {</span>
 336 |     | <span class='unexecuted'>            pool0.liquidity = 0;</span>
 337 |     | <span class='unexecuted'>            pool0.price = state.latestPrice;</span>
 338 |     | <span class='unexecuted'>            pool1.price = ConstantProduct.getPriceAtTick(cache.newLatestTick + constants.tickSpread, constants);</span>
 339 |     | <span class='neutral'>        } else {</span>
 340 |     | <span class='unexecuted'>            pool1.liquidity = 0;</span>
 341 |     | <span class='unexecuted'>            pool0.price = ConstantProduct.getPriceAtTick(cache.newLatestTick - constants.tickSpread, constants);</span>
 342 |     | <span class='unexecuted'>            pool1.price = state.latestPrice;</span>
 343 |     | <span class='neutral'>        }</span>
 344 |     | <span class='neutral'>        </span>
 345 |     | <span class='neutral'>        // set auction start as an offset of the pool genesis block</span>
 346 |     | <span class='unexecuted'>        state.auctionStart = uint32(block.timestamp) - constants.genesisTime;</span>
 347 |     | <span class='neutral'></span>
 348 |     | <span class='neutral'>        // emit sync event</span>
 349 |     | <span class='unexecuted'>        emit Sync(pool0.price, pool1.price, pool0.liquidity, pool1.liquidity, state.auctionStart, state.accumEpoch, state.latestTick, cache.newLatestTick);</span>
 350 |     | <span class='neutral'>        </span>
 351 |     | <span class='neutral'>        // update latestTick</span>
 352 |     | <span class='unexecuted'>        state.latestTick = cache.newLatestTick;</span>
 353 |     | <span class='neutral'></span>
 354 |     | <span class='unexecuted'>        if (cache.syncFees.token0 &gt; 0 || cache.syncFees.token1 &gt; 0) {</span>
 355 |     | <span class='unexecuted'>            emit SyncFeesCollected(msg.sender, cache.syncFees.token0, cache.syncFees.token1);</span>
 356 |     | <span class='neutral'>        }</span>
 357 |     | <span class='neutral'>    </span>
 358 |     | <span class='unexecuted'>        return (state, cache.syncFees, pool0, pool1);</span>
 359 |     | <span class='neutral'>    }</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='unexecuted'>    function _syncTick(</span>
 362 |     | <span class='neutral'>        CoverPoolStructs.GlobalState memory state,</span>
 363 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
 364 |     | <span class='neutral'>    ) internal view returns(</span>
 365 |     | <span class='unexecuted'>        int24 newLatestTick,</span>
 366 |     | <span class='unexecuted'>        bool</span>
 367 |     | <span class='neutral'>    ) {</span>
 368 |     | <span class='neutral'>        // update last block checked</span>
 369 |     | <span class='unexecuted'>        if(state.lastTime == uint32(block.timestamp) - constants.genesisTime) {</span>
 370 |     | <span class='unexecuted'>            return (state.latestTick, true);</span>
 371 |     | <span class='neutral'>        }</span>
 372 |     | <span class='unexecuted'>        state.lastTime = uint32(block.timestamp) - constants.genesisTime;</span>
 373 |     | <span class='neutral'>        // check auctions elapsed</span>
 374 |     | <span class='unexecuted'>        uint32 timeElapsed = state.lastTime - state.auctionStart;</span>
 375 |     | <span class='unexecuted'>        int32 auctionsElapsed = int32(timeElapsed / constants.auctionLength) - 1; /// @dev - subtract 1 for 3/4 twapLength check</span>
 376 |     | <span class='neutral'>        // if 3/4 of twapLength or auctionLength has passed allow for latestTick move</span>
 377 |     | <span class='unexecuted'>        if (timeElapsed &gt; 3 * constants.twapLength / 4 ||</span>
 378 |     | <span class='unexecuted'>            timeElapsed &gt; constants.auctionLength) auctionsElapsed += 1;</span>
 379 |     | <span class='neutral'></span>
 380 |     | <span class='unexecuted'>        if (auctionsElapsed &lt; 1) {</span>
 381 |     | <span class='unexecuted'>            return (state.latestTick, true);</span>
 382 |     | <span class='neutral'>        }</span>
 383 |     | <span class='unexecuted'>        newLatestTick = constants.source.calculateAverageTick(constants, state.latestTick);</span>
 384 |     | <span class='neutral'>        /// @dev - shift up/down one quartile to put pool ahead of TWAP</span>
 385 |     | <span class='unexecuted'>        if (newLatestTick &gt; state.latestTick)</span>
 386 |     | <span class='unexecuted'>             newLatestTick += constants.tickSpread / 4;</span>
 387 |     | <span class='unexecuted'>        else if (newLatestTick &lt;= state.latestTick - 3 * constants.tickSpread / 4)</span>
 388 |     | <span class='unexecuted'>             newLatestTick -= constants.tickSpread / 4;</span>
 389 |     | <span class='unexecuted'>        newLatestTick = newLatestTick / constants.tickSpread * constants.tickSpread; // even multiple of tickSpread</span>
 390 |     | <span class='unexecuted'>        if (newLatestTick == state.latestTick) {</span>
 391 |     | <span class='unexecuted'>            return (state.latestTick, true);</span>
 392 |     | <span class='neutral'>        }</span>
 393 |     | <span class='neutral'></span>
 394 |     | <span class='neutral'>        // rate-limiting tick move</span>
 395 |     | <span class='unexecuted'>        int24 maxLatestTickMove = int24(constants.tickSpread * auctionsElapsed);</span>
 396 |     | <span class='neutral'></span>
 397 |     | <span class='neutral'>        /// @dev - latestTick can only move based on auctionsElapsed </span>
 398 |     | <span class='unexecuted'>        if (newLatestTick &gt; state.latestTick) {</span>
 399 |     | <span class='unexecuted'>            if (newLatestTick - state.latestTick &gt; maxLatestTickMove)</span>
 400 |     | <span class='unexecuted'>                newLatestTick = state.latestTick + maxLatestTickMove;</span>
 401 |     | <span class='neutral'>        } else {</span>
 402 |     | <span class='unexecuted'>            if (state.latestTick - newLatestTick &gt; maxLatestTickMove)</span>
 403 |     | <span class='unexecuted'>                newLatestTick = state.latestTick - maxLatestTickMove;</span>
 404 |     | <span class='neutral'>        }</span>
 405 |     | <span class='neutral'></span>
 406 |     | <span class='unexecuted'>        return (newLatestTick, false);</span>
 407 |     | <span class='neutral'>    }</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='unexecuted'>    function _rollover(</span>
 410 |     | <span class='neutral'>        CoverPoolStructs.GlobalState memory state,</span>
 411 |     | <span class='neutral'>        CoverPoolStructs.AccumulateCache memory cache,</span>
 412 |     | <span class='neutral'>        CoverPoolStructs.PoolState memory pool,</span>
 413 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants,</span>
 414 |     | <span class='neutral'>        bool isPool0</span>
 415 |     | <span class='neutral'>    ) internal pure returns (</span>
 416 |     | <span class='unexecuted'>        CoverPoolStructs.AccumulateCache memory,</span>
 417 |     | <span class='unexecuted'>        CoverPoolStructs.PoolState memory</span>
 418 |     | <span class='neutral'>    ) {</span>
 419 |     | <span class='unexecuted'>        if (pool.liquidity == 0) {</span>
 420 |     | <span class='unexecuted'>            return (cache, pool);</span>
 421 |     | <span class='neutral'>        }</span>
 422 |     | <span class='unexecuted'>        uint160 crossPrice; uint160 accumPrice; uint160 currentPrice;</span>
 423 |     | <span class='unexecuted'>        if (isPool0) {</span>
 424 |     | <span class='unexecuted'>            crossPrice = ConstantProduct.getPriceAtTick(cache.nextTickToCross0, constants);</span>
 425 |     | <span class='unexecuted'>            int24 nextTickToAccum = (cache.nextTickToAccum0 &lt; cache.stopTick0)</span>
 426 |     | <span class='unexecuted'>                                        ? cache.stopTick0</span>
 427 |     | <span class='unexecuted'>                                        : cache.nextTickToAccum0;</span>
 428 |     | <span class='unexecuted'>            accumPrice = ConstantProduct.getPriceAtTick(nextTickToAccum, constants);</span>
 429 |     | <span class='neutral'>            // check for multiple auction skips</span>
 430 |     | <span class='unexecuted'>            if (cache.nextTickToCross0 == state.latestTick &amp;&amp; cache.nextTickToCross0 - nextTickToAccum &gt; constants.tickSpread) {</span>
 431 |     | <span class='unexecuted'>                uint160 spreadPrice = ConstantProduct.getPriceAtTick(cache.nextTickToCross0 - constants.tickSpread, constants);</span>
 432 |     | <span class='neutral'>                /// @dev - amountOutDeltaMax accounted for down below</span>
 433 |     | <span class='unexecuted'>                cache.deltas0.amountOutDelta += uint128(ConstantProduct.getDx(pool.liquidity, accumPrice, spreadPrice, false));</span>
 434 |     | <span class='neutral'>            }</span>
 435 |     | <span class='unexecuted'>            currentPrice = pool.price;</span>
 436 |     | <span class='neutral'>            // if pool.price the bounds set currentPrice to start of auction</span>
 437 |     | <span class='unexecuted'>            if (!(pool.price &gt; accumPrice &amp;&amp; pool.price &lt; crossPrice)) currentPrice = accumPrice;</span>
 438 |     | <span class='neutral'>            // if auction is current and fully filled =&gt; set currentPrice to crossPrice</span>
 439 |     | <span class='unexecuted'>            if (state.latestTick == cache.nextTickToCross0 &amp;&amp; crossPrice == pool.price) currentPrice = crossPrice;</span>
 440 |     | <span class='unexecuted'>        } else {</span>
 441 |     | <span class='unexecuted'>            crossPrice = ConstantProduct.getPriceAtTick(cache.nextTickToCross1, constants);</span>
 442 |     | <span class='unexecuted'>            int24 nextTickToAccum = (cache.nextTickToAccum1 &gt; cache.stopTick1)</span>
 443 |     | <span class='unexecuted'>                                        ? cache.stopTick1</span>
 444 |     | <span class='unexecuted'>                                        : cache.nextTickToAccum1;</span>
 445 |     | <span class='unexecuted'>            accumPrice = ConstantProduct.getPriceAtTick(nextTickToAccum, constants);</span>
 446 |     | <span class='neutral'>            // check for multiple auction skips</span>
 447 |     | <span class='unexecuted'>            if (cache.nextTickToCross1 == state.latestTick &amp;&amp; nextTickToAccum - cache.nextTickToCross1 &gt; constants.tickSpread) {</span>
 448 |     | <span class='unexecuted'>                uint160 spreadPrice = ConstantProduct.getPriceAtTick(cache.nextTickToCross1 + constants.tickSpread, constants);</span>
 449 |     | <span class='neutral'>                /// @dev - DeltaMax values accounted for down below</span>
 450 |     | <span class='unexecuted'>                cache.deltas1.amountOutDelta += uint128(ConstantProduct.getDy(pool.liquidity, spreadPrice, accumPrice, false));</span>
 451 |     | <span class='neutral'>            }</span>
 452 |     | <span class='unexecuted'>            currentPrice = pool.price;</span>
 453 |     | <span class='unexecuted'>            if (!(pool.price &lt; accumPrice &amp;&amp; pool.price &gt; crossPrice)) currentPrice = accumPrice;</span>
 454 |     | <span class='unexecuted'>            if (state.latestTick == cache.nextTickToCross1 &amp;&amp; crossPrice == pool.price) currentPrice = crossPrice;</span>
 455 |     | <span class='neutral'>        }</span>
 456 |     | <span class='neutral'></span>
 457 |     | <span class='neutral'>        //handle liquidity rollover</span>
 458 |     | <span class='unexecuted'>        if (isPool0) {</span>
 459 |     | <span class='unexecuted'>            {</span>
 460 |     | <span class='neutral'>                // amountIn pool did not receive</span>
 461 |     | <span class='unexecuted'>                uint128 amountInDelta;</span>
 462 |     | <span class='unexecuted'>                uint128 amountInDeltaMax  = uint128(ConstantProduct.getDy(pool.liquidity, accumPrice, crossPrice, false));</span>
 463 |     | <span class='unexecuted'>                amountInDelta       = pool.amountInDelta;</span>
 464 |     | <span class='unexecuted'>                amountInDeltaMax   -= (amountInDeltaMax &lt; pool.amountInDeltaMaxClaimed) ? amountInDeltaMax </span>
 465 |     | <span class='unexecuted'>                                                                                        : pool.amountInDeltaMaxClaimed;</span>
 466 |     | <span class='unexecuted'>                pool.amountInDelta  = 0;</span>
 467 |     | <span class='unexecuted'>                pool.amountInDeltaMaxClaimed = 0;</span>
 468 |     | <span class='neutral'></span>
 469 |     | <span class='neutral'>                // update cache in deltas</span>
 470 |     | <span class='unexecuted'>                cache.deltas0.amountInDelta     += amountInDelta;</span>
 471 |     | <span class='unexecuted'>                cache.deltas0.amountInDeltaMax  += amountInDeltaMax;</span>
 472 |     | <span class='neutral'>            }</span>
 473 |     | <span class='unexecuted'>            {</span>
 474 |     | <span class='neutral'>                // amountOut pool has leftover</span>
 475 |     | <span class='unexecuted'>                uint128 amountOutDelta    = uint128(ConstantProduct.getDx(pool.liquidity, currentPrice, crossPrice, false));</span>
 476 |     | <span class='unexecuted'>                uint128 amountOutDeltaMax = uint128(ConstantProduct.getDx(pool.liquidity, accumPrice, crossPrice, false));</span>
 477 |     | <span class='unexecuted'>                amountOutDeltaMax -= (amountOutDeltaMax &lt; pool.amountOutDeltaMaxClaimed) ? amountOutDeltaMax</span>
 478 |     | <span class='unexecuted'>                                                                                        : pool.amountOutDeltaMaxClaimed;</span>
 479 |     | <span class='unexecuted'>                pool.amountOutDeltaMaxClaimed = 0;</span>
 480 |     | <span class='neutral'></span>
 481 |     | <span class='neutral'>                // calculate sync fee</span>
 482 |     | <span class='unexecuted'>                uint128 syncFeeAmount = state.syncFee * amountOutDelta / 1e6;</span>
 483 |     | <span class='unexecuted'>                cache.syncFees.token0 += syncFeeAmount;</span>
 484 |     | <span class='unexecuted'>                amountOutDelta -= syncFeeAmount;</span>
 485 |     | <span class='neutral'></span>
 486 |     | <span class='neutral'>                // update cache out deltas</span>
 487 |     | <span class='unexecuted'>                cache.deltas0.amountOutDelta    += amountOutDelta;</span>
 488 |     | <span class='unexecuted'>                cache.deltas0.amountOutDeltaMax += amountOutDeltaMax;</span>
 489 |     | <span class='neutral'>            }</span>
 490 |     | <span class='neutral'>        } else {</span>
 491 |     | <span class='unexecuted'>            {</span>
 492 |     | <span class='neutral'>                // amountIn pool did not receive</span>
 493 |     | <span class='unexecuted'>                uint128 amountInDelta;</span>
 494 |     | <span class='unexecuted'>                uint128 amountInDeltaMax = uint128(ConstantProduct.getDx(pool.liquidity, crossPrice, accumPrice, false));</span>
 495 |     | <span class='unexecuted'>                amountInDelta       = pool.amountInDelta;</span>
 496 |     | <span class='unexecuted'>                amountInDeltaMax   -= (amountInDeltaMax &lt; pool.amountInDeltaMaxClaimed) ? amountInDeltaMax </span>
 497 |     | <span class='unexecuted'>                                                                                        : pool.amountInDeltaMaxClaimed;</span>
 498 |     | <span class='unexecuted'>                pool.amountInDelta  = 0;</span>
 499 |     | <span class='unexecuted'>                pool.amountInDeltaMaxClaimed = 0;</span>
 500 |     | <span class='neutral'></span>
 501 |     | <span class='neutral'>                // update cache in deltas</span>
 502 |     | <span class='unexecuted'>                cache.deltas1.amountInDelta     += amountInDelta;</span>
 503 |     | <span class='unexecuted'>                cache.deltas1.amountInDeltaMax  += amountInDeltaMax;</span>
 504 |     | <span class='neutral'>            }</span>
 505 |     | <span class='unexecuted'>            {</span>
 506 |     | <span class='neutral'>                // amountOut pool has leftover</span>
 507 |     | <span class='unexecuted'>                uint128 amountOutDelta    = uint128(ConstantProduct.getDy(pool.liquidity, crossPrice, currentPrice, false));</span>
 508 |     | <span class='unexecuted'>                uint128 amountOutDeltaMax = uint128(ConstantProduct.getDy(pool.liquidity, crossPrice, accumPrice, false));</span>
 509 |     | <span class='unexecuted'>                amountOutDeltaMax -= (amountOutDeltaMax &lt; pool.amountOutDeltaMaxClaimed) ? amountOutDeltaMax</span>
 510 |     | <span class='unexecuted'>                                                                                        : pool.amountOutDeltaMaxClaimed;</span>
 511 |     | <span class='unexecuted'>                pool.amountOutDeltaMaxClaimed = 0;</span>
 512 |     | <span class='neutral'></span>
 513 |     | <span class='neutral'>                // calculate sync fee</span>
 514 |     | <span class='unexecuted'>                uint128 syncFeeAmount = state.syncFee * amountOutDelta / 1e6;</span>
 515 |     | <span class='unexecuted'>                cache.syncFees.token1 += syncFeeAmount;</span>
 516 |     | <span class='unexecuted'>                amountOutDelta -= syncFeeAmount;    </span>
 517 |     | <span class='neutral'></span>
 518 |     | <span class='neutral'>                // update cache out deltas</span>
 519 |     | <span class='unexecuted'>                cache.deltas1.amountOutDelta    += amountOutDelta;</span>
 520 |     | <span class='unexecuted'>                cache.deltas1.amountOutDeltaMax += amountOutDeltaMax;</span>
 521 |     | <span class='neutral'>            }</span>
 522 |     | <span class='neutral'>        }</span>
 523 |     | <span class='unexecuted'>        return (cache, pool);</span>
 524 |     | <span class='neutral'>    }</span>
 525 |     | <span class='neutral'></span>
 526 |     | <span class='unexecuted'>    function _accumulate(</span>
 527 |     | <span class='neutral'>        CoverPoolStructs.AccumulateCache memory cache,</span>
 528 |     | <span class='neutral'>        CoverPoolStructs.AccumulateParams memory params,</span>
 529 |     | <span class='neutral'>        CoverPoolStructs.GlobalState memory state</span>
 530 |     | <span class='neutral'>    ) internal returns (</span>
 531 |     | <span class='unexecuted'>        CoverPoolStructs.AccumulateParams memory</span>
 532 |     | <span class='neutral'>    ) {</span>
 533 |     | <span class='unexecuted'>        if (params.isPool0 == params.crossTick.pool0Stash &amp;&amp;</span>
 534 |     | <span class='unexecuted'>                params.crossTick.amountInDeltaMaxStashed &gt; 0) {</span>
 535 |     | <span class='neutral'>            /// @dev - else we migrate carry deltas onto cache</span>
 536 |     | <span class='neutral'>            // add carry amounts to cache</span>
 537 |     | <span class='unexecuted'>            (params.crossTick, params.deltas) = Deltas.unstash(params.crossTick, params.deltas, params.isPool0);</span>
 538 |     | <span class='neutral'>            // clear out stash</span>
 539 |     | <span class='unexecuted'>            params.crossTick.amountInDeltaMaxStashed  = 0;</span>
 540 |     | <span class='unexecuted'>            params.crossTick.amountOutDeltaMaxStashed = 0;</span>
 541 |     | <span class='unexecuted'>            emit StashDeltasCleared(</span>
 542 |     | <span class='unexecuted'>                params.isPool0 ? cache.nextTickToCross0 : cache.nextTickToCross1,</span>
 543 |     | <span class='unexecuted'>                params.isPool0</span>
 544 |     | <span class='neutral'>            );</span>
 545 |     | <span class='neutral'>        }</span>
 546 |     | <span class='unexecuted'>        if (params.updateAccumDeltas) {</span>
 547 |     | <span class='neutral'>            // migrate carry deltas from cache to accum tick</span>
 548 |     | <span class='unexecuted'>            CoverPoolStructs.Deltas memory accumDeltas = params.isPool0 ? params.accumTick.deltas0</span>
 549 |     | <span class='unexecuted'>                                                                        : params.accumTick.deltas1;</span>
 550 |     | <span class='unexecuted'>            if (params.accumTick.amountInDeltaMaxMinus &gt; 0) {</span>
 551 |     | <span class='neutral'>                // calculate percent of deltas left on tick</span>
 552 |     | <span class='unexecuted'>                if (params.deltas.amountInDeltaMax &gt; 0 &amp;&amp; params.deltas.amountOutDeltaMax &gt; 0) {</span>
 553 |     | <span class='neutral'>                    /// @dev - during mint it is ensured both of these values will be nonzero</span>
 554 |     | <span class='unexecuted'>                    uint256 percentInOnTick  = uint256(params.accumTick.amountInDeltaMaxMinus)  * 1e38 / (params.deltas.amountInDeltaMax);</span>
 555 |     | <span class='unexecuted'>                    uint256 percentOutOnTick = uint256(params.accumTick.amountOutDeltaMaxMinus) * 1e38 / (params.deltas.amountOutDeltaMax);</span>
 556 |     | <span class='neutral'>                    // transfer deltas to the accum tick</span>
 557 |     | <span class='unexecuted'>                    (params.deltas, accumDeltas) = Deltas.transfer(params.deltas, accumDeltas, percentInOnTick, percentOutOnTick);</span>
 558 |     | <span class='neutral'>                    </span>
 559 |     | <span class='neutral'>                    // burn tick deltas maxes from cache</span>
 560 |     | <span class='unexecuted'>                    params.deltas = Deltas.burnMaxCache(params.deltas, params.accumTick);</span>
 561 |     | <span class='neutral'>                    </span>
 562 |     | <span class='neutral'>                    // empty delta max minuses into delta max</span>
 563 |     | <span class='unexecuted'>                    accumDeltas.amountInDeltaMax  += params.accumTick.amountInDeltaMaxMinus;</span>
 564 |     | <span class='unexecuted'>                    accumDeltas.amountOutDeltaMax += params.accumTick.amountOutDeltaMaxMinus;</span>
 565 |     | <span class='neutral'></span>
 566 |     | <span class='unexecuted'>                    emit FinalDeltasAccumulated(</span>
 567 |     | <span class='unexecuted'>                        accumDeltas.amountInDelta,</span>
 568 |     | <span class='unexecuted'>                        accumDeltas.amountOutDelta,</span>
 569 |     | <span class='unexecuted'>                        state.accumEpoch,</span>
 570 |     | <span class='unexecuted'>                        params.isPool0 ? cache.nextTickToAccum0 : cache.nextTickToAccum1,</span>
 571 |     | <span class='unexecuted'>                        params.isPool0</span>
 572 |     | <span class='neutral'>                    );</span>
 573 |     | <span class='neutral'>                } else {</span>
 574 |     | <span class='unexecuted'>                    emit FinalDeltasAccumulated(</span>
 575 |     | <span class='unexecuted'>                        0,0,0,</span>
 576 |     | <span class='unexecuted'>                        params.isPool0 ? cache.nextTickToAccum0 : cache.nextTickToAccum1,</span>
 577 |     | <span class='unexecuted'>                        params.isPool0</span>
 578 |     | <span class='neutral'>                    );</span>
 579 |     | <span class='neutral'>                }</span>
 580 |     | <span class='neutral'></span>
 581 |     | <span class='neutral'>                // clear out delta max minus and save on tick</span>
 582 |     | <span class='unexecuted'>                params.accumTick.amountInDeltaMaxMinus  = 0;</span>
 583 |     | <span class='unexecuted'>                if (params.isPool0) {</span>
 584 |     | <span class='unexecuted'>                    params.accumTick.deltas0 = accumDeltas;</span>
 585 |     | <span class='neutral'>                } else {</span>
 586 |     | <span class='unexecuted'>                    params.accumTick.deltas1 = accumDeltas;</span>
 587 |     | <span class='neutral'>                }</span>
 588 |     | <span class='neutral'></span>
 589 |     | <span class='unexecuted'>                emit FinalDeltasAccumulated(</span>
 590 |     | <span class='unexecuted'>                    accumDeltas.amountInDelta,</span>
 591 |     | <span class='unexecuted'>                    accumDeltas.amountOutDelta,</span>
 592 |     | <span class='unexecuted'>                    state.accumEpoch,</span>
 593 |     | <span class='unexecuted'>                    params.isPool0 ? cache.nextTickToAccum0 : cache.nextTickToAccum1,</span>
 594 |     | <span class='unexecuted'>                    params.isPool0</span>
 595 |     | <span class='neutral'>                );</span>
 596 |     | <span class='neutral'>            }</span>
 597 |     | <span class='neutral'>            // clear out delta max in either case</span>
 598 |     | <span class='unexecuted'>            params.accumTick.amountOutDeltaMaxMinus = 0;</span>
 599 |     | <span class='neutral'>        }</span>
 600 |     | <span class='neutral'>        // remove all liquidity</span>
 601 |     | <span class='unexecuted'>        params.crossTick.liquidityDelta = 0;</span>
 602 |     | <span class='neutral'></span>
 603 |     | <span class='unexecuted'>        return params;</span>
 604 |     | <span class='neutral'>    }</span>
 605 |     | <span class='neutral'></span>
 606 |     | <span class='neutral'>    //maybe call ticks on msg.sender to get tick</span>
 607 |     | <span class='unexecuted'>    function _cross(</span>
 608 |     | <span class='neutral'>        int128 liquidityDelta,</span>
 609 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
 610 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants,</span>
 611 |     | <span class='neutral'>        int24 nextTickToCross,</span>
 612 |     | <span class='neutral'>        int24 nextTickToAccum,</span>
 613 |     | <span class='neutral'>        uint128 currentLiquidity,</span>
 614 |     | <span class='neutral'>        bool zeroForOne</span>
 615 |     | <span class='neutral'>    ) internal returns (</span>
 616 |     | <span class='unexecuted'>        uint128,</span>
 617 |     | <span class='unexecuted'>        int24,</span>
 618 |     | <span class='unexecuted'>        int24</span>
 619 |     | <span class='neutral'>    )</span>
 620 |     | <span class='neutral'>    {</span>
 621 |     | <span class='unexecuted'>        nextTickToCross = nextTickToAccum;</span>
 622 |     | <span class='neutral'></span>
 623 |     | <span class='unexecuted'>        if (liquidityDelta &gt; 0) {</span>
 624 |     | <span class='unexecuted'>            EchidnaAssertions.assertLiquidityOverflows(currentLiquidity, uint128(liquidityDelta), &quot;EP-1&quot;);</span>
 625 |     | <span class='unexecuted'>            currentLiquidity += uint128(liquidityDelta);</span>
 626 |     | <span class='neutral'>        } else {</span>
 627 |     | <span class='unexecuted'>            EchidnaAssertions.assertLiquidityUnderflows(currentLiquidity, uint128(-liquidityDelta), &quot;TKS-1&quot;);</span>
 628 |     | <span class='unexecuted'>            currentLiquidity -= uint128(-liquidityDelta);</span>
 629 |     | <span class='neutral'>        }</span>
 630 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 631 |     | <span class='unexecuted'>            nextTickToAccum = TickMap.previous(nextTickToAccum, tickMap, constants);</span>
 632 |     | <span class='neutral'>        } else {</span>
 633 |     | <span class='unexecuted'>            nextTickToAccum = TickMap.next(nextTickToAccum, tickMap, constants);</span>
 634 |     | <span class='neutral'>        }</span>
 635 |     | <span class='unexecuted'>        return (currentLiquidity, nextTickToCross, nextTickToAccum);</span>
 636 |     | <span class='neutral'>    }</span>
 637 |     | <span class='neutral'></span>
 638 |     | <span class='unexecuted'>    function _stash(</span>
 639 |     | <span class='neutral'>        CoverPoolStructs.Tick memory stashTick,</span>
 640 |     | <span class='neutral'>        CoverPoolStructs.AccumulateCache memory cache,</span>
 641 |     | <span class='neutral'>        CoverPoolStructs.GlobalState memory state,</span>
 642 |     | <span class='neutral'>        uint128 currentLiquidity,</span>
 643 |     | <span class='neutral'>        bool isPool0</span>
 644 |     | <span class='unexecuted'>    ) internal returns (CoverPoolStructs.Tick memory) {</span>
 645 |     | <span class='neutral'>        // return since there is nothing to update</span>
 646 |     | <span class='unexecuted'>        if (currentLiquidity == 0) return (stashTick);</span>
 647 |     | <span class='neutral'>        // handle deltas</span>
 648 |     | <span class='unexecuted'>        CoverPoolStructs.Deltas memory deltas = isPool0 ? cache.deltas0 : cache.deltas1;</span>
 649 |     | <span class='unexecuted'>        emit StashDeltasAccumulated(</span>
 650 |     | <span class='unexecuted'>            deltas.amountInDelta,</span>
 651 |     | <span class='unexecuted'>            deltas.amountOutDelta,</span>
 652 |     | <span class='unexecuted'>            deltas.amountInDeltaMax,</span>
 653 |     | <span class='unexecuted'>            deltas.amountOutDeltaMax,</span>
 654 |     | <span class='unexecuted'>            state.accumEpoch,</span>
 655 |     | <span class='unexecuted'>            isPool0 ? cache.stopTick0 : cache.stopTick1,</span>
 656 |     | <span class='unexecuted'>            isPool0</span>
 657 |     | <span class='neutral'>        );</span>
 658 |     | <span class='unexecuted'>        if (deltas.amountInDeltaMax &gt; 0) {</span>
 659 |     | <span class='unexecuted'>            (deltas, stashTick) = Deltas.stash(deltas, stashTick, isPool0);</span>
 660 |     | <span class='neutral'>        }</span>
 661 |     | <span class='unexecuted'>        stashTick.liquidityDelta += int128(currentLiquidity);</span>
 662 |     | <span class='unexecuted'>        return (stashTick);</span>
 663 |     | <span class='neutral'>    }</span>
 664 |     | <span class='neutral'>}</span>
 665 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/libraries/Positions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./Ticks.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./Deltas.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../interfaces/structs/CoverPoolStructs.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../interfaces/ICoverPool.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./math/OverflowMath.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./Claims.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./EpochMap.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;../test/echidna/EchidnaAssertions.sol&#39;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>/// @notice Position management library for ranged liquidity.</span>
  14 |     | <span class='unexecuted'>library Positions {</span>
  15 |     | <span class='unexecuted'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    event Mint(</span>
  18 |     | <span class='neutral'>        address indexed to,</span>
  19 |     | <span class='neutral'>        int24 lower,</span>
  20 |     | <span class='neutral'>        int24 upper,</span>
  21 |     | <span class='neutral'>        bool zeroForOne,</span>
  22 |     | <span class='neutral'>        uint32 positionId,</span>
  23 |     | <span class='neutral'>        uint32 epochLast,</span>
  24 |     | <span class='neutral'>        uint128 amountIn,</span>
  25 |     | <span class='neutral'>        uint128 liquidityMinted,</span>
  26 |     | <span class='neutral'>        uint128 amountInDeltaMaxMinted,</span>
  27 |     | <span class='neutral'>        uint128 amountOutDeltaMaxMinted</span>
  28 |     | <span class='neutral'>    );</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    event Burn(</span>
  31 |     | <span class='neutral'>        address indexed to,</span>
  32 |     | <span class='neutral'>        uint32 positionId,</span>
  33 |     | <span class='neutral'>        int24 claim,</span>
  34 |     | <span class='neutral'>        bool zeroForOne,</span>
  35 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
  36 |     | <span class='neutral'>        uint128 tokenInClaimed,</span>
  37 |     | <span class='neutral'>        uint128 tokenOutClaimed,</span>
  38 |     | <span class='neutral'>        uint128 tokenOutBurned,</span>
  39 |     | <span class='neutral'>        uint128 amountInDeltaMaxStashedBurned,</span>
  40 |     | <span class='neutral'>        uint128 amountOutDeltaMaxStashedBurned,</span>
  41 |     | <span class='neutral'>        uint128 amountInDeltaMaxBurned,</span>
  42 |     | <span class='neutral'>        uint128 amountOutDeltaMaxBurned,</span>
  43 |     | <span class='neutral'>        uint160 claimPriceLast</span>
  44 |     | <span class='neutral'>    );</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    error SimulateMint(int24 lower, int24 upper, bool positionCreated);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>    function resize(</span>
  49 |     | <span class='neutral'>        CoverPoolStructs.CoverPosition memory position,</span>
  50 |     | <span class='neutral'>        ICoverPool.MintParams memory params,</span>
  51 |     | <span class='neutral'>        CoverPoolStructs.GlobalState memory state,</span>
  52 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
  53 |     | <span class='neutral'>    ) internal pure returns (</span>
  54 |     | <span class='unexecuted'>        ICoverPool.MintParams memory,</span>
  55 |     | <span class='unexecuted'>        uint256</span>
  56 |     | <span class='neutral'>    )</span>
  57 |     | <span class='neutral'>    {</span>
  58 |     | <span class='unexecuted'>        ConstantProduct.checkTicks(params.lower, params.upper, constants.tickSpread);</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>        CoverPoolStructs.CoverPositionCache memory cache = CoverPoolStructs.CoverPositionCache({</span>
  61 |     | <span class='unexecuted'>            position: position,</span>
  62 |     | <span class='unexecuted'>            deltas: CoverPoolStructs.Deltas(0,0,0,0),</span>
  63 |     | <span class='unexecuted'>            requiredStart: params.zeroForOne ? state.latestTick - int24(constants.tickSpread) * constants.minPositionWidth</span>
  64 |     | <span class='unexecuted'>                                             : state.latestTick + int24(constants.tickSpread) * constants.minPositionWidth,</span>
  65 |     | <span class='unexecuted'>            auctionCount: uint24((params.upper - params.lower) / constants.tickSpread),</span>
  66 |     | <span class='unexecuted'>            priceLower: ConstantProduct.getPriceAtTick(params.lower, constants),</span>
  67 |     | <span class='unexecuted'>            priceUpper: ConstantProduct.getPriceAtTick(params.upper, constants),</span>
  68 |     | <span class='unexecuted'>            priceAverage: 0,</span>
  69 |     | <span class='unexecuted'>            liquidityMinted: 0,</span>
  70 |     | <span class='unexecuted'>            denomTokenIn: true</span>
  71 |     | <span class='neutral'>        });</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>        // cannot mint empty position</span>
  74 |     | <span class='unexecuted'>        if (params.amount == 0) require (false, &#39;PositionAmountZero()&#39;);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        // enforce safety window</span>
  77 |     | <span class='unexecuted'>        if (params.zeroForOne) {    </span>
  78 |     | <span class='unexecuted'>            if (params.lower &gt;= cache.requiredStart) require (false, &#39;PositionInsideSafetyWindow()&#39;); </span>
  79 |     | <span class='neutral'>        } else {</span>
  80 |     | <span class='unexecuted'>            if (params.upper &lt;= cache.requiredStart) require (false, &#39;PositionInsideSafetyWindow()&#39;);</span>
  81 |     | <span class='neutral'>        }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        cache.liquidityMinted = ConstantProduct.getLiquidityForAmounts(</span>
  84 |     | <span class='unexecuted'>            cache.priceLower,</span>
  85 |     | <span class='unexecuted'>            cache.priceUpper,</span>
  86 |     | <span class='unexecuted'>            params.zeroForOne ? cache.priceLower : cache.priceUpper,</span>
  87 |     | <span class='unexecuted'>            params.zeroForOne ? 0 : uint256(params.amount),</span>
  88 |     | <span class='unexecuted'>            params.zeroForOne ? uint256(params.amount) : 0</span>
  89 |     | <span class='neutral'>        );</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>        // handle partial mints</span>
  92 |     | <span class='unexecuted'>        if (params.zeroForOne) {</span>
  93 |     | <span class='unexecuted'>            if (params.upper &gt; cache.requiredStart) {</span>
  94 |     | <span class='unexecuted'>                params.upper = cache.requiredStart;</span>
  95 |     | <span class='unexecuted'>                uint256 priceNewUpper = ConstantProduct.getPriceAtTick(params.upper, constants);</span>
  96 |     | <span class='unexecuted'>                params.amount -= uint128(</span>
  97 |     | <span class='unexecuted'>                    ConstantProduct.getDx(cache.liquidityMinted, priceNewUpper, cache.priceUpper, false)</span>
  98 |     | <span class='neutral'>                );</span>
  99 |     | <span class='unexecuted'>                cache.priceUpper = uint160(priceNewUpper);</span>
 100 |     | <span class='neutral'>            }</span>
 101 |     | <span class='neutral'>            // update auction count</span>
 102 |     | <span class='unexecuted'>            cache.auctionCount = uint24((params.upper - params.lower) / constants.tickSpread);</span>
 103 |     | <span class='unexecuted'>            if (cache.auctionCount == 0) require (false, &#39;InvalidPositionWidth()&#39;);</span>
 104 |     | <span class='neutral'>        } else {</span>
 105 |     | <span class='unexecuted'>            if (params.lower &lt; cache.requiredStart) {</span>
 106 |     | <span class='unexecuted'>                params.lower = cache.requiredStart;</span>
 107 |     | <span class='unexecuted'>                uint256 priceNewLower = ConstantProduct.getPriceAtTick(params.lower, constants);</span>
 108 |     | <span class='unexecuted'>                params.amount -= uint128(</span>
 109 |     | <span class='unexecuted'>                    ConstantProduct.getDy(cache.liquidityMinted, cache.priceLower, priceNewLower, false)</span>
 110 |     | <span class='neutral'>                );</span>
 111 |     | <span class='unexecuted'>                cache.priceLower = uint160(priceNewLower);</span>
 112 |     | <span class='neutral'>            }</span>
 113 |     | <span class='neutral'>            // update auction count</span>
 114 |     | <span class='unexecuted'>            cache.auctionCount = uint24((params.upper - params.lower) / constants.tickSpread);</span>
 115 |     | <span class='unexecuted'>            if (cache.auctionCount == 0) require (false, &#39;InvalidPositionWidth()&#39;);</span>
 116 |     | <span class='neutral'>        }</span>
 117 |     | <span class='neutral'>        // enforce minimum position width</span>
 118 |     | <span class='unexecuted'>        if (cache.auctionCount &lt; uint16(constants.minPositionWidth)) require (false, &#39;InvalidPositionWidth()&#39;);</span>
 119 |     | <span class='unexecuted'>        if (cache.liquidityMinted &gt; uint128(type(int128).max)) require (false, &#39;LiquidityOverflow()&#39;);</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>        // enforce minimum amount per auction</span>
 122 |     | <span class='unexecuted'>        _size(</span>
 123 |     | <span class='unexecuted'>            CoverPoolStructs.SizeParams(</span>
 124 |     | <span class='unexecuted'>                cache.priceLower,</span>
 125 |     | <span class='unexecuted'>                cache.priceUpper,</span>
 126 |     | <span class='unexecuted'>                uint128(position.liquidity + cache.liquidityMinted),</span>
 127 |     | <span class='unexecuted'>                params.zeroForOne,</span>
 128 |     | <span class='unexecuted'>                state.latestTick,</span>
 129 |     | <span class='unexecuted'>                cache.auctionCount</span>
 130 |     | <span class='neutral'>            ),</span>
 131 |     | <span class='unexecuted'>            constants</span>
 132 |     | <span class='neutral'>        );</span>
 133 |     | <span class='neutral'> </span>
 134 |     | <span class='unexecuted'>        return (</span>
 135 |     | <span class='unexecuted'>            params,</span>
 136 |     | <span class='unexecuted'>            cache.liquidityMinted</span>
 137 |     | <span class='neutral'>        );</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>    function add(</span>
 141 |     | <span class='neutral'>       CoverPoolStructs.CoverPosition memory position,</span>
 142 |     | <span class='neutral'>        mapping(int24 =&gt; CoverPoolStructs.Tick) storage ticks,</span>
 143 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
 144 |     | <span class='neutral'>        CoverPoolStructs.GlobalState memory state,</span>
 145 |     | <span class='neutral'>        CoverPoolStructs.AddParams memory params,</span>
 146 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
 147 |     | <span class='neutral'>    ) internal returns (</span>
 148 |     | <span class='unexecuted'>        CoverPoolStructs.GlobalState memory,</span>
 149 |     | <span class='unexecuted'>        CoverPoolStructs.CoverPosition memory</span>
 150 |     | <span class='neutral'>    ) {</span>
 151 |     | <span class='unexecuted'>        if (params.amount == 0) return (state, position);</span>
 152 |     | <span class='neutral'>        // initialize cache</span>
 153 |     | <span class='unexecuted'>        CoverPoolStructs.CoverPositionCache memory cache = CoverPoolStructs.CoverPositionCache({</span>
 154 |     | <span class='unexecuted'>            position: position,</span>
 155 |     | <span class='unexecuted'>            deltas: CoverPoolStructs.Deltas(0,0,0,0),</span>
 156 |     | <span class='unexecuted'>            requiredStart: 0,</span>
 157 |     | <span class='unexecuted'>            auctionCount: 0,</span>
 158 |     | <span class='unexecuted'>            priceLower: ConstantProduct.getPriceAtTick(params.lower, constants),</span>
 159 |     | <span class='unexecuted'>            priceUpper: ConstantProduct.getPriceAtTick(params.upper, constants),</span>
 160 |     | <span class='unexecuted'>            priceAverage: 0,</span>
 161 |     | <span class='unexecuted'>            liquidityMinted: 0,</span>
 162 |     | <span class='unexecuted'>            denomTokenIn: true</span>
 163 |     | <span class='neutral'>        });</span>
 164 |     | <span class='neutral'>        /// call if claim != lower and liquidity being added</span>
 165 |     | <span class='neutral'>        /// initialize new position</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
 168 |     | <span class='unexecuted'>            cache.position.accumEpochLast = state.accumEpoch;</span>
 169 |     | <span class='neutral'>        } else {</span>
 170 |     | <span class='neutral'>            // safety check in case we somehow get here</span>
 171 |     | <span class='unexecuted'>            if (</span>
 172 |     | <span class='unexecuted'>                params.zeroForOne</span>
 173 |     | <span class='unexecuted'>                    ? state.latestTick &lt; params.upper ||</span>
 174 |     | <span class='unexecuted'>                        EpochMap.get(TickMap.previous(params.upper, tickMap, constants), params.zeroForOne, tickMap, constants)</span>
 175 |     | <span class='unexecuted'>                            &gt; cache.position.accumEpochLast</span>
 176 |     | <span class='unexecuted'>                    : state.latestTick &gt; params.lower ||</span>
 177 |     | <span class='unexecuted'>                        EpochMap.get(TickMap.next(params.lower, tickMap, constants), params.zeroForOne, tickMap, constants)</span>
 178 |     | <span class='unexecuted'>                            &gt; cache.position.accumEpochLast</span>
 179 |     | <span class='neutral'>            ) {</span>
 180 |     | <span class='unexecuted'>                require (false, string.concat(&#39;UpdatePositionFirstAt(&#39;, String.from(params.lower), &#39;, &#39;, String.from(params.upper), &#39;)&#39;));</span>
 181 |     | <span class='neutral'>            }</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'>        </span>
 184 |     | <span class='neutral'>        // add liquidity to ticks</span>
 185 |     | <span class='unexecuted'>        Ticks.insert(</span>
 186 |     | <span class='unexecuted'>            ticks,</span>
 187 |     | <span class='unexecuted'>            tickMap,</span>
 188 |     | <span class='unexecuted'>            state,</span>
 189 |     | <span class='unexecuted'>            constants,</span>
 190 |     | <span class='unexecuted'>            params.lower,</span>
 191 |     | <span class='unexecuted'>            params.upper,</span>
 192 |     | <span class='unexecuted'>            uint128(params.amount),</span>
 193 |     | <span class='unexecuted'>            params.zeroForOne</span>
 194 |     | <span class='neutral'>        );</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>        // update liquidity global</span>
 197 |     | <span class='unexecuted'>        state.liquidityGlobal += params.amount;</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='unexecuted'>        {</span>
 200 |     | <span class='neutral'>            // update max deltas</span>
 201 |     | <span class='unexecuted'>            CoverPoolStructs.Tick memory finalTick = ticks[params.zeroForOne ? params.lower : params.upper];</span>
 202 |     | <span class='unexecuted'>            (finalTick, cache.deltas) = Deltas.update(finalTick, params.amount, cache.priceLower, cache.priceUpper, params.zeroForOne, true);</span>
 203 |     | <span class='unexecuted'>            ticks[params.zeroForOne ? params.lower : params.upper] = finalTick;</span>
 204 |     | <span class='neutral'>            // revert if either max delta is zero</span>
 205 |     | <span class='unexecuted'>            if (cache.deltas.amountInDeltaMax == 0) {</span>
 206 |     | <span class='neutral'>                // require(false, &#39;AmountInDeltaIsZero()&#39;);</span>
 207 |     | <span class='unexecuted'>                bool posCreated = false;</span>
 208 |     | <span class='unexecuted'>                revert SimulateMint(params.lower, params.upper, posCreated);</span>
 209 |     | <span class='unexecuted'>            } else if (cache.deltas.amountOutDeltaMax == 0) {</span>
 210 |     | <span class='neutral'>                // require(false, &#39;AmountOutDeltaIsZero()&#39;);</span>
 211 |     | <span class='unexecuted'>                bool posCreated = false;</span>
 212 |     | <span class='unexecuted'>                revert SimulateMint(params.lower, params.upper, posCreated);</span>
 213 |     | <span class='neutral'>            }</span>
 214 |     | <span class='neutral'>        }</span>
 215 |     | <span class='unexecuted'>        cache.position.liquidity += uint128(params.amount);</span>
 216 |     | <span class='unexecuted'>        emit Mint(</span>
 217 |     | <span class='unexecuted'>            params.to,</span>
 218 |     | <span class='unexecuted'>            params.lower,</span>
 219 |     | <span class='unexecuted'>            params.upper,</span>
 220 |     | <span class='unexecuted'>            params.zeroForOne,</span>
 221 |     | <span class='unexecuted'>            params.positionId,</span>
 222 |     | <span class='unexecuted'>            state.accumEpoch,</span>
 223 |     | <span class='unexecuted'>            params.amountIn,</span>
 224 |     | <span class='unexecuted'>            params.amount,</span>
 225 |     | <span class='unexecuted'>            cache.deltas.amountInDeltaMax,</span>
 226 |     | <span class='unexecuted'>            cache.deltas.amountOutDeltaMax</span>
 227 |     | <span class='neutral'>        );</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='unexecuted'>        return (state, cache.position);</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='unexecuted'>    function remove(</span>
 233 |     | <span class='neutral'>        mapping(uint256 =&gt; CoverPoolStructs.CoverPosition)</span>
 234 |     | <span class='neutral'>            storage positions,</span>
 235 |     | <span class='neutral'>        mapping(int24 =&gt; CoverPoolStructs.Tick) storage ticks,</span>
 236 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
 237 |     | <span class='neutral'>        CoverPoolStructs.GlobalState memory state,</span>
 238 |     | <span class='neutral'>        CoverPoolStructs.RemoveParams memory params,</span>
 239 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
 240 |     | <span class='unexecuted'>    ) internal returns (uint128, CoverPoolStructs.GlobalState memory) {</span>
 241 |     | <span class='neutral'>        // validate burn percentage</span>
 242 |     | <span class='unexecuted'>        if (params.amount &gt; 1e38) require (false, &#39;InvalidBurnPercentage()&#39;);</span>
 243 |     | <span class='neutral'>        // initialize cache</span>
 244 |     | <span class='unexecuted'>        CoverPoolStructs.CoverPositionCache memory cache = CoverPoolStructs.CoverPositionCache({</span>
 245 |     | <span class='unexecuted'>            position: positions[params.positionId],</span>
 246 |     | <span class='unexecuted'>            deltas: CoverPoolStructs.Deltas(0,0,0,0),</span>
 247 |     | <span class='unexecuted'>            requiredStart: params.zeroForOne ? state.latestTick - int24(constants.tickSpread) * constants.minPositionWidth</span>
 248 |     | <span class='unexecuted'>                                             : state.latestTick + int24(constants.tickSpread) * constants.minPositionWidth,</span>
 249 |     | <span class='unexecuted'>            auctionCount: uint24((params.upper - params.lower) / constants.tickSpread),</span>
 250 |     | <span class='unexecuted'>            priceLower: ConstantProduct.getPriceAtTick(params.lower, constants),</span>
 251 |     | <span class='unexecuted'>            priceUpper: ConstantProduct.getPriceAtTick(params.upper, constants),</span>
 252 |     | <span class='unexecuted'>            priceAverage: 0,</span>
 253 |     | <span class='unexecuted'>            liquidityMinted: 0,</span>
 254 |     | <span class='unexecuted'>            denomTokenIn: true</span>
 255 |     | <span class='neutral'>        });</span>
 256 |     | <span class='neutral'>        // convert percentage to liquidity amount</span>
 257 |     | <span class='unexecuted'>        params.amount = _convert(cache.position.liquidity, params.amount);</span>
 258 |     | <span class='neutral'>        // early return if no liquidity to remove</span>
 259 |     | <span class='unexecuted'>        if (params.amount == 0) return (0, state);</span>
 260 |     | <span class='unexecuted'>        if (params.amount &gt; cache.position.liquidity) {</span>
 261 |     | <span class='unexecuted'>            EchidnaAssertions.assertLiquidityUnderflows(cache.position.liquidity, params.amount, &#39;PS-1&#39;);</span>
 262 |     | <span class='unexecuted'>            require (false, &#39;NotEnoughPositionLiquidity()&#39;);</span>
 263 |     | <span class='neutral'>        } else {</span>
 264 |     | <span class='unexecuted'>            _size(</span>
 265 |     | <span class='unexecuted'>                CoverPoolStructs.SizeParams(</span>
 266 |     | <span class='unexecuted'>                    cache.priceLower,</span>
 267 |     | <span class='unexecuted'>                    cache.priceUpper,</span>
 268 |     | <span class='unexecuted'>                    cache.position.liquidity - params.amount,</span>
 269 |     | <span class='unexecuted'>                    params.zeroForOne,</span>
 270 |     | <span class='unexecuted'>                    state.latestTick,</span>
 271 |     | <span class='unexecuted'>                    cache.auctionCount</span>
 272 |     | <span class='neutral'>                ),</span>
 273 |     | <span class='unexecuted'>                constants</span>
 274 |     | <span class='neutral'>            );</span>
 275 |     | <span class='neutral'>            /// @dev - validate needed in case user passes in wrong tick</span>
 276 |     | <span class='unexecuted'>            if (</span>
 277 |     | <span class='unexecuted'>                params.zeroForOne</span>
 278 |     | <span class='unexecuted'>                    ? state.latestTick &lt; params.upper ||</span>
 279 |     | <span class='unexecuted'>                        EpochMap.get(TickMap.previous(params.upper, tickMap, constants), params.zeroForOne, tickMap, constants)</span>
 280 |     | <span class='unexecuted'>                            &gt; cache.position.accumEpochLast</span>
 281 |     | <span class='unexecuted'>                    : state.latestTick &gt; params.lower ||</span>
 282 |     | <span class='unexecuted'>                        EpochMap.get(TickMap.next(params.lower, tickMap, constants), params.zeroForOne, tickMap, constants)</span>
 283 |     | <span class='unexecuted'>                            &gt; cache.position.accumEpochLast</span>
 284 |     | <span class='neutral'>            ) {</span>
 285 |     | <span class='unexecuted'>                require (false, &#39;WrongTickClaimedAt()&#39;);</span>
 286 |     | <span class='neutral'>            }</span>
 287 |     | <span class='neutral'>        }</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='unexecuted'>        Ticks.remove(</span>
 290 |     | <span class='unexecuted'>            ticks,</span>
 291 |     | <span class='unexecuted'>            tickMap,</span>
 292 |     | <span class='unexecuted'>            constants,</span>
 293 |     | <span class='unexecuted'>            params.lower,</span>
 294 |     | <span class='unexecuted'>            params.upper,</span>
 295 |     | <span class='unexecuted'>            params.amount,</span>
 296 |     | <span class='unexecuted'>            params.zeroForOne,</span>
 297 |     | <span class='unexecuted'>            true,</span>
 298 |     | <span class='unexecuted'>            true</span>
 299 |     | <span class='neutral'>        );</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='neutral'>        // update liquidity global</span>
 302 |     | <span class='unexecuted'>        EchidnaAssertions.assertLiquidityGlobalUnderflows(state.liquidityGlobal, params.amount, &#39;PS-2&#39;);</span>
 303 |     | <span class='unexecuted'>        state.liquidityGlobal -= params.amount;</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='unexecuted'>        {</span>
 306 |     | <span class='neutral'>            // update max deltas</span>
 307 |     | <span class='unexecuted'>            CoverPoolStructs.Tick memory finalTick = ticks[params.zeroForOne ? params.lower : params.upper];</span>
 308 |     | <span class='unexecuted'>            (finalTick, cache.deltas) = Deltas.update(finalTick, params.amount, cache.priceLower, cache.priceUpper, params.zeroForOne, false);</span>
 309 |     | <span class='unexecuted'>            ticks[params.zeroForOne ? params.lower : params.upper] = finalTick;</span>
 310 |     | <span class='neutral'>        }</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='unexecuted'>        cache.position.amountOut += uint128(</span>
 313 |     | <span class='unexecuted'>            params.zeroForOne</span>
 314 |     | <span class='unexecuted'>                ? ConstantProduct.getDx(params.amount, cache.priceLower, cache.priceUpper, false)</span>
 315 |     | <span class='unexecuted'>                : ConstantProduct.getDy(params.amount, cache.priceLower, cache.priceUpper, false)</span>
 316 |     | <span class='neutral'>        );</span>
 317 |     | <span class='unexecuted'>        cache.position.liquidity -= uint128(params.amount);</span>
 318 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
 319 |     | <span class='unexecuted'>            cache.position.owner = address(0);</span>
 320 |     | <span class='unexecuted'>            cache.position.lower = 0;</span>
 321 |     | <span class='unexecuted'>            cache.position.upper = 0;</span>
 322 |     | <span class='neutral'>        }</span>
 323 |     | <span class='unexecuted'>        positions[params.positionId] = cache.position;</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='unexecuted'>        if (params.amount &gt; 0) {</span>
 326 |     | <span class='unexecuted'>            emit Burn(</span>
 327 |     | <span class='unexecuted'>                    params.to,</span>
 328 |     | <span class='unexecuted'>                    params.positionId,</span>
 329 |     | <span class='unexecuted'>                    params.zeroForOne ? params.upper : params.lower,</span>
 330 |     | <span class='unexecuted'>                    params.zeroForOne,</span>
 331 |     | <span class='unexecuted'>                    params.amount,</span>
 332 |     | <span class='unexecuted'>                    0, 0,</span>
 333 |     | <span class='unexecuted'>                    cache.position.amountOut,</span>
 334 |     | <span class='unexecuted'>                    0, 0,</span>
 335 |     | <span class='unexecuted'>                    cache.deltas.amountInDeltaMax,</span>
 336 |     | <span class='unexecuted'>                    cache.deltas.amountOutDeltaMax,</span>
 337 |     | <span class='unexecuted'>                    cache.position.claimPriceLast</span>
 338 |     | <span class='neutral'>            );</span>
 339 |     | <span class='neutral'>        }</span>
 340 |     | <span class='unexecuted'>        return (params.amount, state);</span>
 341 |     | <span class='neutral'>    }</span>
 342 |     | <span class='neutral'></span>
 343 |     | <span class='unexecuted'>    function update(</span>
 344 |     | <span class='neutral'>        mapping(uint256 =&gt; CoverPoolStructs.CoverPosition)</span>
 345 |     | <span class='neutral'>            storage positions,</span>
 346 |     | <span class='neutral'>        mapping(int24 =&gt; CoverPoolStructs.Tick) storage ticks,</span>
 347 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
 348 |     | <span class='neutral'>        CoverPoolStructs.GlobalState memory state,</span>
 349 |     | <span class='neutral'>        CoverPoolStructs.PoolState memory pool,</span>
 350 |     | <span class='neutral'>        CoverPoolStructs.UpdateParams memory params,</span>
 351 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
 352 |     | <span class='neutral'>    ) internal returns (</span>
 353 |     | <span class='unexecuted'>            CoverPoolStructs.GlobalState memory,</span>
 354 |     | <span class='unexecuted'>            CoverPoolStructs.PoolState memory,</span>
 355 |     | <span class='unexecuted'>            int24</span>
 356 |     | <span class='neutral'>        )</span>
 357 |     | <span class='neutral'>    {</span>
 358 |     | <span class='unexecuted'>        CoverPoolStructs.UpdatePositionCache memory cache;</span>
 359 |     | <span class='unexecuted'>        (</span>
 360 |     | <span class='neutral'>            params,</span>
 361 |     | <span class='neutral'>            cache,</span>
 362 |     | <span class='neutral'>            state</span>
 363 |     | <span class='unexecuted'>        ) = _deltas(</span>
 364 |     | <span class='unexecuted'>            positions,</span>
 365 |     | <span class='unexecuted'>            ticks,</span>
 366 |     | <span class='unexecuted'>            tickMap,</span>
 367 |     | <span class='unexecuted'>            state,</span>
 368 |     | <span class='unexecuted'>            pool,</span>
 369 |     | <span class='unexecuted'>            params,</span>
 370 |     | <span class='unexecuted'>            constants</span>
 371 |     | <span class='neutral'>        );</span>
 372 |     | <span class='neutral'></span>
 373 |     | <span class='unexecuted'>        if (cache.earlyReturn)</span>
 374 |     | <span class='unexecuted'>            return (state, pool, params.claim);</span>
 375 |     | <span class='neutral'></span>
 376 |     | <span class='unexecuted'>        pool.amountInDelta = cache.pool.amountInDelta;</span>
 377 |     | <span class='unexecuted'>        pool.amountInDeltaMaxClaimed  = cache.pool.amountInDeltaMaxClaimed;</span>
 378 |     | <span class='unexecuted'>        pool.amountOutDeltaMaxClaimed = cache.pool.amountOutDeltaMaxClaimed;</span>
 379 |     | <span class='neutral'></span>
 380 |     | <span class='neutral'>        // save claim tick</span>
 381 |     | <span class='unexecuted'>        ticks[params.claim] = cache.claimTick;</span>
 382 |     | <span class='unexecuted'>        if (params.claim != (params.zeroForOne ? params.lower : params.upper))</span>
 383 |     | <span class='unexecuted'>            ticks[params.zeroForOne ? params.lower : params.upper] = cache.finalTick;</span>
 384 |     | <span class='neutral'>        </span>
 385 |     | <span class='neutral'>        // update pool liquidity</span>
 386 |     | <span class='unexecuted'>        if (state.latestTick == params.claim</span>
 387 |     | <span class='unexecuted'>            &amp;&amp; params.claim != (params.zeroForOne ? params.lower : params.upper)</span>
 388 |     | <span class='neutral'>        ) {</span>
 389 |     | <span class='unexecuted'>            EchidnaAssertions.assertLiquidityUnderflows(pool.liquidity, params.amount, &#39;PS-3&#39;);</span>
 390 |     | <span class='unexecuted'>            pool.liquidity -= params.amount;</span>
 391 |     | <span class='neutral'>        } </span>
 392 |     | <span class='neutral'>        </span>
 393 |     | <span class='unexecuted'>        if (params.amount &gt; 0) {</span>
 394 |     | <span class='unexecuted'>            if (params.claim == (params.zeroForOne ? params.lower : params.upper)) {</span>
 395 |     | <span class='neutral'>                // only remove once if final tick of position</span>
 396 |     | <span class='unexecuted'>                cache.removeLower = false;</span>
 397 |     | <span class='unexecuted'>                cache.removeUpper = false;</span>
 398 |     | <span class='neutral'>            } else {</span>
 399 |     | <span class='unexecuted'>                params.zeroForOne ? cache.removeUpper = true </span>
 400 |     | <span class='unexecuted'>                                  : cache.removeLower = true;</span>
 401 |     | <span class='neutral'>            }</span>
 402 |     | <span class='unexecuted'>            Ticks.remove(</span>
 403 |     | <span class='unexecuted'>                ticks,</span>
 404 |     | <span class='unexecuted'>                tickMap,</span>
 405 |     | <span class='unexecuted'>                constants,</span>
 406 |     | <span class='unexecuted'>                params.zeroForOne ? params.lower : params.claim,</span>
 407 |     | <span class='unexecuted'>                params.zeroForOne ? params.claim : params.upper,</span>
 408 |     | <span class='unexecuted'>                params.amount,</span>
 409 |     | <span class='unexecuted'>                params.zeroForOne,</span>
 410 |     | <span class='unexecuted'>                cache.removeLower,</span>
 411 |     | <span class='unexecuted'>                cache.removeUpper</span>
 412 |     | <span class='neutral'>            );</span>
 413 |     | <span class='neutral'>            // update position liquidity</span>
 414 |     | <span class='unexecuted'>            EchidnaAssertions.assertLiquidityUnderflows(cache.position.liquidity, params.amount, &#39;PS-4&#39;);</span>
 415 |     | <span class='unexecuted'>            cache.position.liquidity -= uint128(params.amount);</span>
 416 |     | <span class='neutral'>            // update global liquidity</span>
 417 |     | <span class='unexecuted'>            EchidnaAssertions.assertLiquidityGlobalUnderflows(state.liquidityGlobal, params.amount, &#39;PS-5&#39;);</span>
 418 |     | <span class='unexecuted'>            state.liquidityGlobal -= params.amount;</span>
 419 |     | <span class='neutral'>        }</span>
 420 |     | <span class='neutral'></span>
 421 |     | <span class='unexecuted'>        (</span>
 422 |     | <span class='neutral'>            cache,</span>
 423 |     | <span class='neutral'>            params</span>
 424 |     | <span class='unexecuted'>        ) = _checkpoint(state, pool, params, constants, cache);</span>
 425 |     | <span class='neutral'></span>
 426 |     | <span class='neutral'>        // clear out old position</span>
 427 |     | <span class='unexecuted'>        if (params.zeroForOne ? params.claim != params.upper </span>
 428 |     | <span class='unexecuted'>                              : params.claim != params.lower) {</span>
 429 |     | <span class='neutral'>            /// @dev - this also clears out position end claims</span>
 430 |     | <span class='unexecuted'>            if (params.zeroForOne ? params.claim == params.lower </span>
 431 |     | <span class='unexecuted'>                                  : params.claim == params.upper) {</span>
 432 |     | <span class='neutral'>                // subtract remaining position liquidity out from global</span>
 433 |     | <span class='unexecuted'>                EchidnaAssertions.assertLiquidityGlobalUnderflows(state.liquidityGlobal, cache.position.liquidity, &#39;PS-6&#39;);</span>
 434 |     | <span class='unexecuted'>                state.liquidityGlobal -= cache.position.liquidity;</span>
 435 |     | <span class='unexecuted'>                cache.position.liquidity = 0;</span>
 436 |     | <span class='neutral'>            }</span>
 437 |     | <span class='neutral'>            //TODO: unnecessary delete for pre-final tick claim</span>
 438 |     | <span class='unexecuted'>            delete positions[params.positionId];</span>
 439 |     | <span class='neutral'>        }</span>
 440 |     | <span class='neutral'>        // clear position values</span>
 441 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
 442 |     | <span class='unexecuted'>            cache.position.owner = address(0);</span>
 443 |     | <span class='unexecuted'>            cache.position.lower = 0;</span>
 444 |     | <span class='unexecuted'>            cache.position.upper = 0;</span>
 445 |     | <span class='unexecuted'>            cache.position.accumEpochLast = 0;</span>
 446 |     | <span class='unexecuted'>            cache.position.claimPriceLast = 0;</span>
 447 |     | <span class='neutral'>        }</span>
 448 |     | <span class='neutral'>        // update position bounds</span>
 449 |     | <span class='unexecuted'>        if (params.zeroForOne) {</span>
 450 |     | <span class='unexecuted'>            cache.position.upper = params.claim;</span>
 451 |     | <span class='neutral'>        } else {</span>
 452 |     | <span class='unexecuted'>            cache.position.lower = params.claim;</span>
 453 |     | <span class='neutral'>        }</span>
 454 |     | <span class='unexecuted'>        positions[params.positionId] = cache.position;</span>
 455 |     | <span class='neutral'>        </span>
 456 |     | <span class='unexecuted'>        emit Burn(</span>
 457 |     | <span class='unexecuted'>            params.to,</span>
 458 |     | <span class='unexecuted'>            params.positionId,</span>
 459 |     | <span class='unexecuted'>            params.claim,</span>
 460 |     | <span class='unexecuted'>            params.zeroForOne,</span>
 461 |     | <span class='unexecuted'>            params.amount,</span>
 462 |     | <span class='unexecuted'>            cache.position.amountIn,</span>
 463 |     | <span class='unexecuted'>            cache.finalDeltas.amountOutDelta,</span>
 464 |     | <span class='unexecuted'>            cache.position.amountOut - cache.finalDeltas.amountOutDelta,</span>
 465 |     | <span class='unexecuted'>            uint128(cache.amountInFilledMax),</span>
 466 |     | <span class='unexecuted'>            uint128(cache.amountOutUnfilledMax),</span>
 467 |     | <span class='unexecuted'>            cache.finalDeltas.amountInDeltaMax,</span>
 468 |     | <span class='unexecuted'>            cache.finalDeltas.amountOutDeltaMax,</span>
 469 |     | <span class='unexecuted'>            cache.position.claimPriceLast</span>
 470 |     | <span class='neutral'>        );</span>
 471 |     | <span class='neutral'>        // return cached position in memory and transfer out</span>
 472 |     | <span class='unexecuted'>        return (state, pool, params.claim);</span>
 473 |     | <span class='neutral'>    }</span>
 474 |     | <span class='neutral'></span>
 475 |     | <span class='unexecuted'>    function snapshot(</span>
 476 |     | <span class='neutral'>        mapping(uint256 =&gt; CoverPoolStructs.CoverPosition)</span>
 477 |     | <span class='neutral'>            storage positions,</span>
 478 |     | <span class='neutral'>        mapping(int24 =&gt; CoverPoolStructs.Tick) storage ticks,</span>
 479 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
 480 |     | <span class='neutral'>        CoverPoolStructs.GlobalState memory state,</span>
 481 |     | <span class='neutral'>        CoverPoolStructs.PoolState memory pool,</span>
 482 |     | <span class='neutral'>        CoverPoolStructs.UpdateParams memory params,</span>
 483 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
 484 |     | <span class='neutral'>    ) internal view returns (</span>
 485 |     | <span class='unexecuted'>        CoverPoolStructs.CoverPosition memory</span>
 486 |     | <span class='neutral'>    ) {</span>
 487 |     | <span class='unexecuted'>        CoverPoolStructs.UpdatePositionCache memory cache;</span>
 488 |     | <span class='unexecuted'>        (</span>
 489 |     | <span class='neutral'>            params,</span>
 490 |     | <span class='neutral'>            cache,</span>
 491 |     | <span class='neutral'>            state</span>
 492 |     | <span class='unexecuted'>        ) = _deltas(</span>
 493 |     | <span class='unexecuted'>            positions,</span>
 494 |     | <span class='unexecuted'>            ticks,</span>
 495 |     | <span class='unexecuted'>            tickMap,</span>
 496 |     | <span class='unexecuted'>            state,</span>
 497 |     | <span class='unexecuted'>            pool,</span>
 498 |     | <span class='unexecuted'>            params,</span>
 499 |     | <span class='unexecuted'>            constants</span>
 500 |     | <span class='neutral'>        );</span>
 501 |     | <span class='neutral'></span>
 502 |     | <span class='unexecuted'>        if (cache.earlyReturn) {</span>
 503 |     | <span class='unexecuted'>            if (params.amount &gt; 0)</span>
 504 |     | <span class='unexecuted'>                cache.position.amountOut += uint128(</span>
 505 |     | <span class='unexecuted'>                    params.zeroForOne</span>
 506 |     | <span class='unexecuted'>                        ? ConstantProduct.getDx(params.amount, cache.priceLower, cache.priceUpper, false)</span>
 507 |     | <span class='unexecuted'>                        : ConstantProduct.getDy(params.amount, cache.priceLower, cache.priceUpper, false)</span>
 508 |     | <span class='neutral'>                );</span>
 509 |     | <span class='unexecuted'>            return cache.position;</span>
 510 |     | <span class='neutral'>        }</span>
 511 |     | <span class='neutral'></span>
 512 |     | <span class='unexecuted'>        if (params.amount &gt; 0) {</span>
 513 |     | <span class='unexecuted'>            cache.position.liquidity -= uint128(params.amount);</span>
 514 |     | <span class='neutral'>        }</span>
 515 |     | <span class='neutral'>        // checkpoint claimPriceLast</span>
 516 |     | <span class='unexecuted'>        (</span>
 517 |     | <span class='neutral'>            cache,</span>
 518 |     | <span class='neutral'>            params</span>
 519 |     | <span class='unexecuted'>        ) = _checkpoint(state, pool, params, constants, cache);</span>
 520 |     | <span class='neutral'>        </span>
 521 |     | <span class='neutral'>        // clear position values if empty</span>
 522 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
 523 |     | <span class='unexecuted'>            cache.position.accumEpochLast = 0;</span>
 524 |     | <span class='unexecuted'>            cache.position.claimPriceLast = 0;</span>
 525 |     | <span class='neutral'>        }    </span>
 526 |     | <span class='unexecuted'>        return cache.position;</span>
 527 |     | <span class='neutral'>    }</span>
 528 |     | <span class='neutral'></span>
 529 |     | <span class='unexecuted'>    function _convert(</span>
 530 |     | <span class='neutral'>        uint128 liquidity,</span>
 531 |     | <span class='neutral'>        uint128 percent</span>
 532 |     | <span class='neutral'>    ) internal pure returns (</span>
 533 |     | <span class='unexecuted'>        uint128</span>
 534 |     | <span class='neutral'>    ) {</span>
 535 |     | <span class='neutral'>        // convert percentage to liquidity amount</span>
 536 |     | <span class='neutral'>        //TODO: just set to 100%</span>
 537 |     | <span class='unexecuted'>        if (percent &gt; 1e38) require (false, &#39;InvalidBurnPercentage()&#39;);</span>
 538 |     | <span class='unexecuted'>        if (liquidity == 0 &amp;&amp; percent &gt; 0) require (false, &#39;NotEnoughPositionLiquidity()&#39;);</span>
 539 |     | <span class='unexecuted'>        return uint128(uint256(liquidity) * uint256(percent) / 1e38);</span>
 540 |     | <span class='neutral'>    }</span>
 541 |     | <span class='neutral'></span>
 542 |     | <span class='unexecuted'>    function _deltas(</span>
 543 |     | <span class='neutral'>        mapping(uint256 =&gt; CoverPoolStructs.CoverPosition)</span>
 544 |     | <span class='neutral'>            storage positions,</span>
 545 |     | <span class='neutral'>        mapping(int24 =&gt; CoverPoolStructs.Tick) storage ticks,</span>
 546 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
 547 |     | <span class='neutral'>        CoverPoolStructs.GlobalState memory state,</span>
 548 |     | <span class='neutral'>        CoverPoolStructs.PoolState memory pool,</span>
 549 |     | <span class='neutral'>        CoverPoolStructs.UpdateParams memory params,</span>
 550 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
 551 |     | <span class='neutral'>    ) internal view returns (</span>
 552 |     | <span class='unexecuted'>        CoverPoolStructs.UpdateParams memory,</span>
 553 |     | <span class='unexecuted'>        CoverPoolStructs.UpdatePositionCache memory,</span>
 554 |     | <span class='unexecuted'>        CoverPoolStructs.GlobalState memory</span>
 555 |     | <span class='neutral'>    ) {</span>
 556 |     | <span class='unexecuted'>        CoverPoolStructs.UpdatePositionCache memory cache;</span>
 557 |     | <span class='unexecuted'>        cache.position = positions[params.positionId];</span>
 558 |     | <span class='unexecuted'>        params.lower = cache.position.lower;</span>
 559 |     | <span class='unexecuted'>        params.upper = cache.position.upper;</span>
 560 |     | <span class='unexecuted'>        cache = CoverPoolStructs.UpdatePositionCache({</span>
 561 |     | <span class='unexecuted'>            position: cache.position,</span>
 562 |     | <span class='unexecuted'>            pool: pool,</span>
 563 |     | <span class='unexecuted'>            priceLower: ConstantProduct.getPriceAtTick(params.lower, constants),</span>
 564 |     | <span class='unexecuted'>            priceClaim: ConstantProduct.getPriceAtTick(params.claim, constants),</span>
 565 |     | <span class='unexecuted'>            priceUpper: ConstantProduct.getPriceAtTick(params.upper, constants),</span>
 566 |     | <span class='unexecuted'>            priceSpread: 0,</span>
 567 |     | <span class='unexecuted'>            amountInFilledMax: 0,</span>
 568 |     | <span class='unexecuted'>            amountOutUnfilledMax: 0,</span>
 569 |     | <span class='unexecuted'>            claimTick: ticks[params.claim],</span>
 570 |     | <span class='unexecuted'>            finalTick: ticks[params.zeroForOne ? params.lower : params.upper],</span>
 571 |     | <span class='unexecuted'>            earlyReturn: false,</span>
 572 |     | <span class='unexecuted'>            removeLower: true,</span>
 573 |     | <span class='unexecuted'>            removeUpper: true,</span>
 574 |     | <span class='unexecuted'>            deltas: CoverPoolStructs.Deltas(0,0,0,0),</span>
 575 |     | <span class='unexecuted'>            finalDeltas: CoverPoolStructs.Deltas(0,0,0,0)</span>
 576 |     | <span class='neutral'>        });</span>
 577 |     | <span class='unexecuted'>        if (params.claim == (params.zeroForOne ? params.lower : params.upper)) {</span>
 578 |     | <span class='unexecuted'>            params.amount = 1e38;</span>
 579 |     | <span class='neutral'>        }</span>
 580 |     | <span class='unexecuted'>        params.amount = _convert(cache.position.liquidity, params.amount);</span>
 581 |     | <span class='neutral'></span>
 582 |     | <span class='neutral'>        // check claim is valid</span>
 583 |     | <span class='unexecuted'>        (params, cache) = Claims.validate(</span>
 584 |     | <span class='unexecuted'>            tickMap,</span>
 585 |     | <span class='unexecuted'>            state,</span>
 586 |     | <span class='unexecuted'>            cache.pool,</span>
 587 |     | <span class='unexecuted'>            params,</span>
 588 |     | <span class='unexecuted'>            cache,</span>
 589 |     | <span class='unexecuted'>            constants</span>
 590 |     | <span class='neutral'>        );</span>
 591 |     | <span class='unexecuted'>        if (cache.earlyReturn) {</span>
 592 |     | <span class='unexecuted'>            return (params, cache, state);</span>
 593 |     | <span class='neutral'>        }</span>
 594 |     | <span class='unexecuted'>        cache.priceSpread = ConstantProduct.getPriceAtTick(params.zeroForOne ? params.claim - constants.tickSpread </span>
 595 |     | <span class='unexecuted'>                                                                             : params.claim + constants.tickSpread,</span>
 596 |     | <span class='unexecuted'>                                                           constants);</span>
 597 |     | <span class='unexecuted'>        if (params.amount &gt; 0)</span>
 598 |     | <span class='unexecuted'>            _size(</span>
 599 |     | <span class='unexecuted'>                CoverPoolStructs.SizeParams(</span>
 600 |     | <span class='unexecuted'>                    cache.priceLower,</span>
 601 |     | <span class='unexecuted'>                    cache.priceUpper,</span>
 602 |     | <span class='unexecuted'>                    cache.position.liquidity - params.amount,</span>
 603 |     | <span class='unexecuted'>                    params.zeroForOne,</span>
 604 |     | <span class='unexecuted'>                    state.latestTick,</span>
 605 |     | <span class='unexecuted'>                    uint24((params.upper - params.lower) / constants.tickSpread)</span>
 606 |     | <span class='neutral'>                ),</span>
 607 |     | <span class='unexecuted'>                constants</span>
 608 |     | <span class='neutral'>            );</span>
 609 |     | <span class='neutral'>        // get deltas from claim tick</span>
 610 |     | <span class='unexecuted'>        cache = Claims.getDeltas(cache, params);</span>
 611 |     | <span class='neutral'>        /// @dev - section 1 =&gt; position start - previous auction</span>
 612 |     | <span class='unexecuted'>        cache = Claims.section1(cache, params, constants);</span>
 613 |     | <span class='neutral'>        /// @dev - section 2 =&gt; position start -&gt; claim tick</span>
 614 |     | <span class='unexecuted'>        cache = Claims.section2(cache, params);</span>
 615 |     | <span class='neutral'>        // check if auction in progress </span>
 616 |     | <span class='unexecuted'>        if (params.claim == state.latestTick </span>
 617 |     | <span class='unexecuted'>            &amp;&amp; params.claim != (params.zeroForOne ? params.lower : params.upper)) {</span>
 618 |     | <span class='neutral'>            /// @dev - section 3 =&gt; claim tick - unfilled section</span>
 619 |     | <span class='unexecuted'>            cache = Claims.section3(cache, params, cache.pool);</span>
 620 |     | <span class='neutral'>            /// @dev - section 4 =&gt; claim tick - filled section</span>
 621 |     | <span class='unexecuted'>            cache = Claims.section4(cache, params, cache.pool);</span>
 622 |     | <span class='neutral'>        }</span>
 623 |     | <span class='neutral'>        /// @dev - section 5 =&gt; claim tick -&gt; position end</span>
 624 |     | <span class='unexecuted'>        cache = Claims.section5(cache, params);</span>
 625 |     | <span class='neutral'>        // adjust position amounts based on deltas</span>
 626 |     | <span class='unexecuted'>        cache = Claims.applyDeltas(state, cache, params);</span>
 627 |     | <span class='neutral'></span>
 628 |     | <span class='unexecuted'>        return (params, cache, state);</span>
 629 |     | <span class='neutral'>    }</span>
 630 |     | <span class='neutral'></span>
 631 |     | <span class='unexecuted'>    function _size(</span>
 632 |     | <span class='neutral'>        CoverPoolStructs.SizeParams memory params,</span>
 633 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
 634 |     | <span class='neutral'>    ) internal pure  </span>
 635 |     | <span class='unexecuted'>    {</span>
 636 |     | <span class='neutral'>        // early return if 100% of position burned</span>
 637 |     | <span class='unexecuted'>        if (constants.minAmountPerAuction == 0) return;</span>
 638 |     | <span class='unexecuted'>        if (params.liquidityAmount == 0 || params.auctionCount == 0) return;</span>
 639 |     | <span class='neutral'>        // set minAmountPerAuction based on token decimals</span>
 640 |     | <span class='unexecuted'>        uint256 minAmountPerAuction; bool denomTokenIn;</span>
 641 |     | <span class='unexecuted'>        if (params.latestTick &gt; 0) {</span>
 642 |     | <span class='unexecuted'>            if (constants.minAmountLowerPriced) {</span>
 643 |     | <span class='neutral'>                // token1 is the lower priced token</span>
 644 |     | <span class='unexecuted'>                denomTokenIn = !params.zeroForOne;</span>
 645 |     | <span class='unexecuted'>                minAmountPerAuction = constants.minAmountPerAuction / 10**(18 - constants.token1Decimals);</span>
 646 |     | <span class='neutral'>            } else {</span>
 647 |     | <span class='neutral'>                // token0 is the higher priced token</span>
 648 |     | <span class='unexecuted'>                denomTokenIn = params.zeroForOne;</span>
 649 |     | <span class='unexecuted'>                minAmountPerAuction = constants.minAmountPerAuction / 10**(18 - constants.token0Decimals);</span>
 650 |     | <span class='neutral'>            }</span>
 651 |     | <span class='neutral'>        } else {</span>
 652 |     | <span class='unexecuted'>            if (constants.minAmountLowerPriced) {</span>
 653 |     | <span class='neutral'>                // token0 is the lower priced token</span>
 654 |     | <span class='unexecuted'>                denomTokenIn = params.zeroForOne;</span>
 655 |     | <span class='unexecuted'>                minAmountPerAuction = constants.minAmountPerAuction / 10**(18 - constants.token0Decimals);</span>
 656 |     | <span class='neutral'>            } else {</span>
 657 |     | <span class='neutral'>                // token1 is the higher priced token</span>
 658 |     | <span class='unexecuted'>                denomTokenIn = !params.zeroForOne;</span>
 659 |     | <span class='unexecuted'>                minAmountPerAuction = constants.minAmountPerAuction / 10**(18 - constants.token1Decimals);</span>
 660 |     | <span class='neutral'>            }</span>
 661 |     | <span class='neutral'>        }</span>
 662 |     | <span class='unexecuted'>        if (params.zeroForOne) {</span>
 663 |     | <span class='neutral'>            //calculate amount in the position currently</span>
 664 |     | <span class='unexecuted'>            uint128 amount = uint128(ConstantProduct.getDx(</span>
 665 |     | <span class='unexecuted'>                params.liquidityAmount,</span>
 666 |     | <span class='unexecuted'>                params.priceLower,</span>
 667 |     | <span class='unexecuted'>                params.priceUpper,</span>
 668 |     | <span class='unexecuted'>                false</span>
 669 |     | <span class='neutral'>            ));</span>
 670 |     | <span class='unexecuted'>            if (denomTokenIn) {</span>
 671 |     | <span class='unexecuted'>                if (amount / params.auctionCount &lt; minAmountPerAuction)</span>
 672 |     | <span class='unexecuted'>                    require (false, &#39;PositionAuctionAmountTooSmall()&#39;);</span>
 673 |     | <span class='unexecuted'>            } else {</span>
 674 |     | <span class='neutral'>                // denominate in incoming token</span>
 675 |     | <span class='unexecuted'>                uint256 priceAverage = (params.priceUpper + params.priceLower) / 2;</span>
 676 |     | <span class='unexecuted'>                uint256 convertedAmount = amount * priceAverage / Q96 </span>
 677 |     | <span class='unexecuted'>                                                 * priceAverage / Q96; // convert by squaring price</span>
 678 |     | <span class='unexecuted'>                if (convertedAmount / params.auctionCount &lt; minAmountPerAuction) </span>
 679 |     | <span class='unexecuted'>                    require (false, &#39;PositionAuctionAmountTooSmall()&#39;);</span>
 680 |     | <span class='neutral'>            }</span>
 681 |     | <span class='unexecuted'>        } else {</span>
 682 |     | <span class='unexecuted'>            uint128 amount = uint128(ConstantProduct.getDy(</span>
 683 |     | <span class='unexecuted'>                params.liquidityAmount,</span>
 684 |     | <span class='unexecuted'>                params.priceLower,</span>
 685 |     | <span class='unexecuted'>                params.priceUpper,</span>
 686 |     | <span class='unexecuted'>                false</span>
 687 |     | <span class='neutral'>            ));</span>
 688 |     | <span class='unexecuted'>            if (denomTokenIn) {</span>
 689 |     | <span class='neutral'>                // denominate in token1</span>
 690 |     | <span class='neutral'>                // calculate amount in position currently</span>
 691 |     | <span class='unexecuted'>                if (amount / params.auctionCount &lt; minAmountPerAuction) </span>
 692 |     | <span class='unexecuted'>                    require (false, &#39;PositionAuctionAmountTooSmall()&#39;);</span>
 693 |     | <span class='unexecuted'>            } else {</span>
 694 |     | <span class='neutral'>                // denominate in token0</span>
 695 |     | <span class='unexecuted'>                uint256 priceAverage = (params.priceUpper + params.priceLower) / 2;</span>
 696 |     | <span class='unexecuted'>                uint256 convertedAmount = amount * Q96 / priceAverage </span>
 697 |     | <span class='unexecuted'>                                                 * Q96 / priceAverage; // convert by squaring price</span>
 698 |     | <span class='unexecuted'>                if (convertedAmount / params.auctionCount &lt; minAmountPerAuction) </span>
 699 |     | <span class='unexecuted'>                    require (false, &#39;PositionAuctionAmountTooSmall()&#39;);</span>
 700 |     | <span class='neutral'>            }</span>
 701 |     | <span class='neutral'>        }</span>
 702 |     | <span class='neutral'>    }</span>
 703 |     | <span class='neutral'></span>
 704 |     | <span class='unexecuted'>    function _checkpoint(</span>
 705 |     | <span class='neutral'>        CoverPoolStructs.GlobalState memory state,</span>
 706 |     | <span class='neutral'>        CoverPoolStructs.PoolState memory pool,</span>
 707 |     | <span class='neutral'>        CoverPoolStructs.UpdateParams memory params,</span>
 708 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants,</span>
 709 |     | <span class='neutral'>        CoverPoolStructs.UpdatePositionCache memory cache</span>
 710 |     | <span class='neutral'>    ) internal pure returns (</span>
 711 |     | <span class='unexecuted'>        CoverPoolStructs.UpdatePositionCache memory,</span>
 712 |     | <span class='unexecuted'>        CoverPoolStructs.UpdateParams memory</span>
 713 |     | <span class='neutral'>    ) {</span>
 714 |     | <span class='neutral'>        // update claimPriceLast</span>
 715 |     | <span class='unexecuted'>        cache.priceClaim = ConstantProduct.getPriceAtTick(params.claim, constants);</span>
 716 |     | <span class='unexecuted'>        cache.position.claimPriceLast = (params.claim == state.latestTick)</span>
 717 |     | <span class='unexecuted'>            ? pool.price</span>
 718 |     | <span class='unexecuted'>            : cache.priceClaim;</span>
 719 |     | <span class='neutral'>        /// @dev - if tick 0% filled, set CPL to latestTick</span>
 720 |     | <span class='unexecuted'>        if (pool.price == cache.priceSpread) cache.position.claimPriceLast = cache.priceClaim;</span>
 721 |     | <span class='neutral'>        /// @dev - if tick 100% filled, set CPL to next tick to unlock</span>
 722 |     | <span class='unexecuted'>        if (pool.price == cache.priceClaim &amp;&amp; params.claim == state.latestTick){</span>
 723 |     | <span class='unexecuted'>            cache.position.claimPriceLast = cache.priceSpread;</span>
 724 |     | <span class='neutral'>            // set claim tick to claim + tickSpread</span>
 725 |     | <span class='unexecuted'>            params.claim = params.zeroForOne ? params.claim - constants.tickSpread</span>
 726 |     | <span class='unexecuted'>                                             : params.claim + constants.tickSpread;</span>
 727 |     | <span class='neutral'>        }</span>
 728 |     | <span class='unexecuted'>        return (cache, params);</span>
 729 |     | <span class='neutral'>    }</span>
 730 |     | <span class='neutral'>}</span>
 731 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/libraries/TickMap.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../interfaces/structs/CoverPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./math/ConstantProduct.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='unexecuted'>library TickMap {</span>
   8 |     | <span class='unexecuted'>    function set(</span>
   9 |     | <span class='neutral'>        int24 tick,</span>
  10 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
  11 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
  12 |     | <span class='neutral'>    ) internal returns (</span>
  13 |     | <span class='unexecuted'>        bool exists</span>
  14 |     | <span class='neutral'>    )    </span>
  15 |     | <span class='neutral'>    {</span>
  16 |     | <span class='unexecuted'>        (</span>
  17 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  18 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  19 |     | <span class='unexecuted'>            uint256 blockIndex</span>
  20 |     | <span class='unexecuted'>        ) = getIndices(tick, constants);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>        // check if bit is already set</span>
  23 |     | <span class='unexecuted'>        uint256 word = tickMap.ticks[wordIndex] | 1 &lt;&lt; (tickIndex &amp; 0xFF);</span>
  24 |     | <span class='unexecuted'>        if (word == tickMap.ticks[wordIndex]) {</span>
  25 |     | <span class='unexecuted'>            return true;</span>
  26 |     | <span class='neutral'>        }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>        tickMap.ticks[wordIndex]     = word; </span>
  29 |     | <span class='unexecuted'>        tickMap.words[blockIndex]   |= 1 &lt;&lt; (wordIndex &amp; 0xFF); // same as modulus 255</span>
  30 |     | <span class='unexecuted'>        tickMap.blocks              |= 1 &lt;&lt; blockIndex;</span>
  31 |     | <span class='unexecuted'>        return false;</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>    function unset(</span>
  35 |     | <span class='neutral'>        int24 tick,</span>
  36 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
  37 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
  38 |     | <span class='unexecuted'>    ) internal {</span>
  39 |     | <span class='unexecuted'>        (</span>
  40 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  41 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  42 |     | <span class='unexecuted'>            uint256 blockIndex</span>
  43 |     | <span class='unexecuted'>        ) = getIndices(tick, constants);</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>        tickMap.ticks[wordIndex] &amp;= ~(1 &lt;&lt; (tickIndex &amp; 0xFF));</span>
  46 |     | <span class='unexecuted'>        if (tickMap.ticks[wordIndex] == 0) {</span>
  47 |     | <span class='unexecuted'>            tickMap.words[blockIndex] &amp;= ~(1 &lt;&lt; (wordIndex &amp; 0xFF));</span>
  48 |     | <span class='unexecuted'>            if (tickMap.words[blockIndex] == 0) {</span>
  49 |     | <span class='unexecuted'>                tickMap.blocks &amp;= ~(1 &lt;&lt; blockIndex);</span>
  50 |     | <span class='neutral'>            }</span>
  51 |     | <span class='neutral'>        }</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>    function previous(</span>
  55 |     | <span class='neutral'>        int24 tick,</span>
  56 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
  57 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
  58 |     | <span class='neutral'>    ) internal view returns (</span>
  59 |     | <span class='unexecuted'>        int24 previousTick</span>
  60 |     | <span class='neutral'>    ) {</span>
  61 |     | <span class='unexecuted'>        unchecked {</span>
  62 |     | <span class='unexecuted'>            (</span>
  63 |     | <span class='unexecuted'>              uint256 tickIndex,</span>
  64 |     | <span class='unexecuted'>              uint256 wordIndex,</span>
  65 |     | <span class='unexecuted'>              uint256 blockIndex</span>
  66 |     | <span class='unexecuted'>            ) = getIndices(tick, constants);</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>            uint256 word = tickMap.ticks[wordIndex] &amp; ((1 &lt;&lt; (tickIndex &amp; 0xFF)) - 1);</span>
  69 |     | <span class='unexecuted'>            if (word == 0) {</span>
  70 |     | <span class='unexecuted'>                uint256 block_ = tickMap.words[blockIndex] &amp; ((1 &lt;&lt; (wordIndex &amp; 0xFF)) - 1);</span>
  71 |     | <span class='unexecuted'>                if (block_ == 0) {</span>
  72 |     | <span class='unexecuted'>                    uint256 blockMap = tickMap.blocks &amp; ((1 &lt;&lt; blockIndex) - 1);</span>
  73 |     | <span class='unexecuted'>                    if (blockMap == 0) return tick;</span>
  74 |     | <span class='unexecuted'>                    blockIndex = _msb(blockMap);</span>
  75 |     | <span class='unexecuted'>                    block_ = tickMap.words[blockIndex];</span>
  76 |     | <span class='neutral'>                }</span>
  77 |     | <span class='unexecuted'>                wordIndex = (blockIndex &lt;&lt; 8) | _msb(block_);</span>
  78 |     | <span class='unexecuted'>                word = tickMap.ticks[wordIndex];</span>
  79 |     | <span class='neutral'>            }</span>
  80 |     | <span class='unexecuted'>            previousTick = _tick((wordIndex &lt;&lt; 8) | _msb(word), constants);</span>
  81 |     | <span class='neutral'>        }</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>    function next(</span>
  85 |     | <span class='neutral'>        int24 tick,</span>
  86 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
  87 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
  88 |     | <span class='neutral'>    ) internal view returns (</span>
  89 |     | <span class='unexecuted'>        int24 nextTick</span>
  90 |     | <span class='neutral'>    ) {</span>
  91 |     | <span class='unexecuted'>        unchecked {</span>
  92 |     | <span class='unexecuted'>            (</span>
  93 |     | <span class='unexecuted'>              uint256 tickIndex,</span>
  94 |     | <span class='unexecuted'>              uint256 wordIndex,</span>
  95 |     | <span class='unexecuted'>              uint256 blockIndex</span>
  96 |     | <span class='unexecuted'>            ) = getIndices(tick, constants);</span>
  97 |     | <span class='unexecuted'>            uint256 word;</span>
  98 |     | <span class='unexecuted'>            if ((tickIndex &amp; 0xFF) != 255) {</span>
  99 |     | <span class='unexecuted'>                word = tickMap.ticks[wordIndex] &amp; ~((1 &lt;&lt; ((tickIndex &amp; 0xFF) + 1)) - 1);</span>
 100 |     | <span class='neutral'>            }</span>
 101 |     | <span class='unexecuted'>            if (word == 0) {</span>
 102 |     | <span class='unexecuted'>                uint256 block_;</span>
 103 |     | <span class='unexecuted'>                if ((blockIndex &amp; 0xFF) != 255) {</span>
 104 |     | <span class='unexecuted'>                    block_ = tickMap.words[blockIndex] &amp; ~((1 &lt;&lt; ((wordIndex &amp; 0xFF) + 1)) - 1);</span>
 105 |     | <span class='neutral'>                }</span>
 106 |     | <span class='unexecuted'>                if (block_ == 0) {</span>
 107 |     | <span class='unexecuted'>                    uint256 blockMap = tickMap.blocks &amp; ~((1 &lt;&lt; blockIndex + 1) - 1);</span>
 108 |     | <span class='unexecuted'>                    if (blockMap == 0) return tick;</span>
 109 |     | <span class='unexecuted'>                    blockIndex = _lsb(blockMap);</span>
 110 |     | <span class='unexecuted'>                    block_ = tickMap.words[blockIndex];</span>
 111 |     | <span class='neutral'>                }</span>
 112 |     | <span class='unexecuted'>                wordIndex = (blockIndex &lt;&lt; 8) | _lsb(block_);</span>
 113 |     | <span class='unexecuted'>                word = tickMap.ticks[wordIndex];</span>
 114 |     | <span class='neutral'>            }</span>
 115 |     | <span class='unexecuted'>            nextTick = _tick((wordIndex &lt;&lt; 8) | _lsb(word), constants);</span>
 116 |     | <span class='neutral'>        }</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='unexecuted'>    function getIndices(</span>
 120 |     | <span class='neutral'>        int24 tick,</span>
 121 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
 122 |     | <span class='neutral'>    ) public pure returns (</span>
 123 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
 124 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
 125 |     | <span class='unexecuted'>            uint256 blockIndex</span>
 126 |     | <span class='neutral'>        )</span>
 127 |     | <span class='neutral'>    {</span>
 128 |     | <span class='neutral'>        unchecked {</span>
 129 |     | <span class='unexecuted'>            if (tick &gt; ConstantProduct.maxTick(constants.tickSpread)) require (false, &#39;TickIndexOverflow()&#39;);</span>
 130 |     | <span class='unexecuted'>            if (tick &lt; ConstantProduct.minTick(constants.tickSpread)) require (false, &#39;TickIndexUnderflow()&#39;);</span>
 131 |     | <span class='unexecuted'>            if (tick % constants.tickSpread != 0) require (false, &#39;TickIndexInvalid()&#39;);</span>
 132 |     | <span class='unexecuted'>            tickIndex = uint256(int256((tick - ConstantProduct.minTick(constants.tickSpread))) / constants.tickSpread);</span>
 133 |     | <span class='unexecuted'>            wordIndex = tickIndex &gt;&gt; 8;   // 2^8 ticks per word</span>
 134 |     | <span class='unexecuted'>            blockIndex = tickIndex &gt;&gt; 16; // 2^8 words per block</span>
 135 |     | <span class='unexecuted'>            if (blockIndex &gt; 255) require (false, &#39;BlockIndexOverflow()&#39;);</span>
 136 |     | <span class='neutral'>        }</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>    function _tick (</span>
 140 |     | <span class='neutral'>        uint256 tickIndex,</span>
 141 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
 142 |     | <span class='neutral'>    ) internal pure returns (</span>
 143 |     | <span class='unexecuted'>        int24 tick</span>
 144 |     | <span class='neutral'>    ) {</span>
 145 |     | <span class='neutral'>        unchecked {</span>
 146 |     | <span class='unexecuted'>            if (tickIndex &gt; uint24(ConstantProduct.maxTick(constants.tickSpread) * 2)) require (false, &#39;TickIndexOverflow()&#39;);</span>
 147 |     | <span class='unexecuted'>            tick = int24(int256(tickIndex) * int256(constants.tickSpread) + ConstantProduct.minTick(constants.tickSpread));</span>
 148 |     | <span class='neutral'>        }</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='unexecuted'>    function _msb(</span>
 152 |     | <span class='neutral'>        uint256 x</span>
 153 |     | <span class='neutral'>    ) internal pure returns (</span>
 154 |     | <span class='unexecuted'>        uint8 r</span>
 155 |     | <span class='neutral'>    ) {</span>
 156 |     | <span class='neutral'>        unchecked {</span>
 157 |     | <span class='unexecuted'>            assert(x &gt; 0);</span>
 158 |     | <span class='unexecuted'>            if (x &gt;= 0x100000000000000000000000000000000) {</span>
 159 |     | <span class='unexecuted'>                x &gt;&gt;= 128;</span>
 160 |     | <span class='unexecuted'>                r += 128;</span>
 161 |     | <span class='neutral'>            }</span>
 162 |     | <span class='unexecuted'>            if (x &gt;= 0x10000000000000000) {</span>
 163 |     | <span class='unexecuted'>                x &gt;&gt;= 64;</span>
 164 |     | <span class='unexecuted'>                r += 64;</span>
 165 |     | <span class='neutral'>            }</span>
 166 |     | <span class='unexecuted'>            if (x &gt;= 0x100000000) {</span>
 167 |     | <span class='unexecuted'>                x &gt;&gt;= 32;</span>
 168 |     | <span class='unexecuted'>                r += 32;</span>
 169 |     | <span class='neutral'>            }</span>
 170 |     | <span class='unexecuted'>            if (x &gt;= 0x10000) {</span>
 171 |     | <span class='unexecuted'>                x &gt;&gt;= 16;</span>
 172 |     | <span class='unexecuted'>                r += 16;</span>
 173 |     | <span class='neutral'>            }</span>
 174 |     | <span class='unexecuted'>            if (x &gt;= 0x100) {</span>
 175 |     | <span class='unexecuted'>                x &gt;&gt;= 8;</span>
 176 |     | <span class='unexecuted'>                r += 8;</span>
 177 |     | <span class='neutral'>            }</span>
 178 |     | <span class='unexecuted'>            if (x &gt;= 0x10) {</span>
 179 |     | <span class='unexecuted'>                x &gt;&gt;= 4;</span>
 180 |     | <span class='unexecuted'>                r += 4;</span>
 181 |     | <span class='neutral'>            }</span>
 182 |     | <span class='unexecuted'>            if (x &gt;= 0x4) {</span>
 183 |     | <span class='unexecuted'>                x &gt;&gt;= 2;</span>
 184 |     | <span class='unexecuted'>                r += 2;</span>
 185 |     | <span class='neutral'>            }</span>
 186 |     | <span class='unexecuted'>            if (x &gt;= 0x2) r += 1;</span>
 187 |     | <span class='neutral'>        }</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='unexecuted'>    function _lsb(</span>
 191 |     | <span class='neutral'>        uint256 x</span>
 192 |     | <span class='neutral'>    ) internal pure returns (</span>
 193 |     | <span class='unexecuted'>        uint8 r</span>
 194 |     | <span class='neutral'>    ) {</span>
 195 |     | <span class='neutral'>        unchecked {</span>
 196 |     | <span class='unexecuted'>            assert(x &gt; 0); // if x is 0 return 0</span>
 197 |     | <span class='unexecuted'>            r = 255;</span>
 198 |     | <span class='unexecuted'>            if (x &amp; type(uint128).max &gt; 0) {</span>
 199 |     | <span class='unexecuted'>                r -= 128;</span>
 200 |     | <span class='neutral'>            } else {</span>
 201 |     | <span class='unexecuted'>                x &gt;&gt;= 128;</span>
 202 |     | <span class='neutral'>            }</span>
 203 |     | <span class='unexecuted'>            if (x &amp; type(uint64).max &gt; 0) {</span>
 204 |     | <span class='unexecuted'>                r -= 64;</span>
 205 |     | <span class='neutral'>            } else {</span>
 206 |     | <span class='unexecuted'>                x &gt;&gt;= 64;</span>
 207 |     | <span class='neutral'>            }</span>
 208 |     | <span class='unexecuted'>            if (x &amp; type(uint32).max &gt; 0) {</span>
 209 |     | <span class='unexecuted'>                r -= 32;</span>
 210 |     | <span class='neutral'>            } else {</span>
 211 |     | <span class='unexecuted'>                x &gt;&gt;= 32;</span>
 212 |     | <span class='neutral'>            }</span>
 213 |     | <span class='unexecuted'>            if (x &amp; type(uint16).max &gt; 0) {</span>
 214 |     | <span class='unexecuted'>                r -= 16;</span>
 215 |     | <span class='neutral'>            } else {</span>
 216 |     | <span class='unexecuted'>                x &gt;&gt;= 16;</span>
 217 |     | <span class='neutral'>            }</span>
 218 |     | <span class='unexecuted'>            if (x &amp; type(uint8).max &gt; 0) {</span>
 219 |     | <span class='unexecuted'>                r -= 8;</span>
 220 |     | <span class='neutral'>            } else {</span>
 221 |     | <span class='unexecuted'>                x &gt;&gt;= 8;</span>
 222 |     | <span class='neutral'>            }</span>
 223 |     | <span class='unexecuted'>            if (x &amp; 0xf &gt; 0) {</span>
 224 |     | <span class='unexecuted'>                r -= 4;</span>
 225 |     | <span class='neutral'>            } else {</span>
 226 |     | <span class='unexecuted'>                x &gt;&gt;= 4;</span>
 227 |     | <span class='neutral'>            }</span>
 228 |     | <span class='unexecuted'>            if (x &amp; 0x3 &gt; 0) {</span>
 229 |     | <span class='unexecuted'>                r -= 2;</span>
 230 |     | <span class='neutral'>            } else {</span>
 231 |     | <span class='unexecuted'>                x &gt;&gt;= 2;</span>
 232 |     | <span class='neutral'>            }</span>
 233 |     | <span class='unexecuted'>            if (x &amp; 0x1 &gt; 0) r -= 1;</span>
 234 |     | <span class='neutral'>        }</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'>    </span>
 237 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/libraries/Ticks.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../interfaces/structs/CoverPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../utils/CoverPoolErrors.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./math/OverflowMath.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../interfaces/modules/sources/ITwapSource.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./TickMap.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../test/echidna/EchidnaAssertions.sol&#39;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/// @notice Tick management library for ranged liquidity.</span>
  12 |     | <span class='unexecuted'>library Ticks {</span>
  13 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    event Initialize(</span>
  16 |     | <span class='neutral'>        int24 minTick,</span>
  17 |     | <span class='neutral'>        int24 maxTick,</span>
  18 |     | <span class='neutral'>        int24 latestTick,</span>
  19 |     | <span class='neutral'>        uint32 genesisTime,</span>
  20 |     | <span class='neutral'>        uint32 auctionStart,</span>
  21 |     | <span class='neutral'>        uint160 pool0Price,</span>
  22 |     | <span class='neutral'>        uint160 pool1Price</span>
  23 |     | <span class='neutral'>    );</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    function quote(</span>
  26 |     | <span class='neutral'>        bool zeroForOne,</span>
  27 |     | <span class='neutral'>        uint160 priceLimit,</span>
  28 |     | <span class='neutral'>        CoverPoolStructs.GlobalState memory state,</span>
  29 |     | <span class='neutral'>        CoverPoolStructs.SwapCache memory cache,</span>
  30 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
  31 |     | <span class='unexecuted'>    ) internal pure returns (CoverPoolStructs.SwapCache memory) {</span>
  32 |     | <span class='unexecuted'>        if ((zeroForOne ? priceLimit &gt;= cache.price</span>
  33 |     | <span class='unexecuted'>                        : priceLimit &lt;= cache.price) ||</span>
  34 |     | <span class='unexecuted'>            (cache.liquidity == 0))</span>
  35 |     | <span class='neutral'>        {</span>
  36 |     | <span class='unexecuted'>            return cache;</span>
  37 |     | <span class='neutral'>        }</span>
  38 |     | <span class='unexecuted'>        uint256 nextPrice = state.latestPrice;</span>
  39 |     | <span class='neutral'>        // determine input boost from tick auction</span>
  40 |     | <span class='unexecuted'>        cache.auctionBoost = ((cache.auctionDepth &lt;= constants.auctionLength) ? cache.auctionDepth</span>
  41 |     | <span class='unexecuted'>                                                                              : constants.auctionLength</span>
  42 |     | <span class='unexecuted'>                             ) * 1e14 / constants.auctionLength * uint16(constants.tickSpread);</span>
  43 |     | <span class='unexecuted'>        cache.amountBoosted = cache.amountLeft * (1e18 + cache.auctionBoost) / 1e18;</span>
  44 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
  45 |     | <span class='neutral'>            // trade token 0 (x) for token 1 (y)</span>
  46 |     | <span class='neutral'>            // price decreases</span>
  47 |     | <span class='unexecuted'>            if (priceLimit &gt; nextPrice) {</span>
  48 |     | <span class='neutral'>                // stop at price limit</span>
  49 |     | <span class='unexecuted'>                nextPrice = priceLimit;</span>
  50 |     | <span class='neutral'>            }</span>
  51 |     | <span class='unexecuted'>            uint256 amountMax = cache.exactIn ? ConstantProduct.getDx(cache.liquidity, nextPrice, cache.price, true)</span>
  52 |     | <span class='unexecuted'>                                              : ConstantProduct.getDy(cache.liquidity, nextPrice, cache.price, false);</span>
  53 |     | <span class='neutral'>            // check if all input is used</span>
  54 |     | <span class='unexecuted'>            if (cache.amountBoosted &lt;= amountMax) {</span>
  55 |     | <span class='neutral'>                // calculate price after swap</span>
  56 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
  57 |     | <span class='unexecuted'>                    uint256 newPrice = ConstantProduct.getNewPrice(cache.price, cache.liquidity, cache.amountBoosted, zeroForOne, cache.exactIn);</span>
  58 |     | <span class='unexecuted'>                    cache.input = cache.amountLeft;</span>
  59 |     | <span class='unexecuted'>                    cache.output += ConstantProduct.getDy(cache.liquidity, newPrice, cache.price, false);</span>
  60 |     | <span class='unexecuted'>                    cache.price = newPrice;</span>
  61 |     | <span class='unexecuted'>                    cache.amountLeft = 0;</span>
  62 |     | <span class='neutral'>                }</span>
  63 |     | <span class='unexecuted'>            } else if (amountMax &gt; 0) {</span>
  64 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
  65 |     | <span class='unexecuted'>                    cache.input = amountMax * (1e18 - cache.auctionBoost) / 1e18; /// @dev - convert back to input amount</span>
  66 |     | <span class='unexecuted'>                    cache.output = ConstantProduct.getDy(cache.liquidity, nextPrice, cache.price, false);</span>
  67 |     | <span class='unexecuted'>                    cache.price = nextPrice;</span>
  68 |     | <span class='unexecuted'>                    cache.amountLeft -= cache.input;</span>
  69 |     | <span class='neutral'>                }</span>
  70 |     | <span class='neutral'>            }</span>
  71 |     | <span class='unexecuted'>        } else {</span>
  72 |     | <span class='neutral'>            // price increases</span>
  73 |     | <span class='unexecuted'>            if (priceLimit &lt; nextPrice) {</span>
  74 |     | <span class='neutral'>                // stop at price limit</span>
  75 |     | <span class='unexecuted'>                nextPrice = priceLimit;</span>
  76 |     | <span class='neutral'>            }</span>
  77 |     | <span class='unexecuted'>            uint256 amountMax = cache.exactIn ? ConstantProduct.getDy(cache.liquidity, uint256(cache.price), nextPrice, true)</span>
  78 |     | <span class='unexecuted'>                                              : ConstantProduct.getDx(cache.liquidity, uint256(cache.price), nextPrice, false);</span>
  79 |     | <span class='unexecuted'>            if (cache.amountBoosted &lt;= amountMax) {</span>
  80 |     | <span class='neutral'>                // calculate price after swap</span>
  81 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
  82 |     | <span class='unexecuted'>                    uint256 newPrice = ConstantProduct.getNewPrice(cache.price, cache.liquidity, cache.amountBoosted, zeroForOne, cache.exactIn);</span>
  83 |     | <span class='unexecuted'>                    cache.input = cache.amountLeft;</span>
  84 |     | <span class='unexecuted'>                    cache.output += ConstantProduct.getDx(cache.liquidity, cache.price, newPrice, false);</span>
  85 |     | <span class='unexecuted'>                    cache.price = newPrice;</span>
  86 |     | <span class='unexecuted'>                    cache.amountLeft = 0;</span>
  87 |     | <span class='neutral'>                }</span>
  88 |     | <span class='unexecuted'>            } else if (amountMax &gt; 0) {</span>
  89 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
  90 |     | <span class='unexecuted'>                    cache.input = amountMax * (1e18 - cache.auctionBoost) / 1e18; </span>
  91 |     | <span class='unexecuted'>                    cache.output = ConstantProduct.getDx(cache.liquidity, cache.price, nextPrice, false);</span>
  92 |     | <span class='unexecuted'>                    cache.price = nextPrice;</span>
  93 |     | <span class='unexecuted'>                    cache.amountLeft -= cache.input;</span>
  94 |     | <span class='neutral'>                }</span>
  95 |     | <span class='neutral'>            }</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='unexecuted'>        cache.amountInDelta = cache.input;</span>
  98 |     | <span class='unexecuted'>        return cache;</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>    function initialize(</span>
 102 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
 103 |     | <span class='neutral'>        CoverPoolStructs.PoolState storage pool0,</span>
 104 |     | <span class='neutral'>        CoverPoolStructs.PoolState storage pool1,</span>
 105 |     | <span class='neutral'>        CoverPoolStructs.GlobalState memory state,</span>
 106 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants </span>
 107 |     | <span class='unexecuted'>    ) internal returns (CoverPoolStructs.GlobalState memory) {</span>
 108 |     | <span class='unexecuted'>        if (state.unlocked == 0) {</span>
 109 |     | <span class='unexecuted'>            (state.unlocked, state.latestTick) = constants.source.initialize(constants);</span>
 110 |     | <span class='unexecuted'>            if (state.unlocked == 1) {</span>
 111 |     | <span class='neutral'>                // initialize state</span>
 112 |     | <span class='unexecuted'>                state.latestTick = (state.latestTick / int24(constants.tickSpread)) * int24(constants.tickSpread);</span>
 113 |     | <span class='unexecuted'>                state.latestPrice = ConstantProduct.getPriceAtTick(state.latestTick, constants);</span>
 114 |     | <span class='unexecuted'>                state.auctionStart = uint32(block.timestamp - constants.genesisTime);</span>
 115 |     | <span class='unexecuted'>                state.accumEpoch = 1;</span>
 116 |     | <span class='unexecuted'>                state.positionIdNext = 1;</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>                // initialize ticks</span>
 119 |     | <span class='unexecuted'>                TickMap.set(ConstantProduct.minTick(constants.tickSpread), tickMap, constants);</span>
 120 |     | <span class='unexecuted'>                TickMap.set(ConstantProduct.maxTick(constants.tickSpread), tickMap, constants);</span>
 121 |     | <span class='unexecuted'>                TickMap.set(state.latestTick, tickMap, constants);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>                // initialize price</span>
 124 |     | <span class='unexecuted'>                pool0.price = ConstantProduct.getPriceAtTick(state.latestTick - constants.tickSpread, constants);</span>
 125 |     | <span class='unexecuted'>                pool1.price = ConstantProduct.getPriceAtTick(state.latestTick + constants.tickSpread, constants);</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>                // assert tick is within bounds</span>
 128 |     | <span class='unexecuted'>                EchidnaAssertions.assertTickDivisibleByTickSpacing(state.latestTick, constants.tickSpread);</span>
 129 |     | <span class='unexecuted'>                EchidnaAssertions.assertTickWithinBounds(</span>
 130 |     | <span class='unexecuted'>                    state.latestTick,</span>
 131 |     | <span class='unexecuted'>                    ConstantProduct.minTick(constants.tickSpread) + constants.tickSpread,</span>
 132 |     | <span class='unexecuted'>                    ConstantProduct.maxTick(constants.tickSpread) - constants.tickSpread</span>
 133 |     | <span class='neutral'>                );</span>
 134 |     | <span class='neutral'>            </span>
 135 |     | <span class='unexecuted'>                emit Initialize(</span>
 136 |     | <span class='unexecuted'>                    ConstantProduct.minTick(constants.tickSpread),</span>
 137 |     | <span class='unexecuted'>                    ConstantProduct.maxTick(constants.tickSpread),</span>
 138 |     | <span class='unexecuted'>                    state.latestTick,</span>
 139 |     | <span class='unexecuted'>                    constants.genesisTime,</span>
 140 |     | <span class='unexecuted'>                    state.auctionStart,</span>
 141 |     | <span class='unexecuted'>                    pool0.price,</span>
 142 |     | <span class='unexecuted'>                    pool1.price</span>
 143 |     | <span class='neutral'>                );</span>
 144 |     | <span class='neutral'>            }</span>
 145 |     | <span class='neutral'>        }</span>
 146 |     | <span class='unexecuted'>        return state;</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='unexecuted'>    function insert(</span>
 150 |     | <span class='neutral'>        mapping(int24 =&gt; CoverPoolStructs.Tick) storage ticks,</span>
 151 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
 152 |     | <span class='neutral'>        CoverPoolStructs.GlobalState memory state,</span>
 153 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants,</span>
 154 |     | <span class='neutral'>        int24 lower,</span>
 155 |     | <span class='neutral'>        int24 upper,</span>
 156 |     | <span class='neutral'>        uint128 amount,</span>
 157 |     | <span class='neutral'>        bool isPool0</span>
 158 |     | <span class='unexecuted'>    ) internal {</span>
 159 |     | <span class='neutral'>        /// @dev - validation of ticks is in Positions.validate</span>
 160 |     | <span class='unexecuted'>        if (amount &gt; uint128(type(int128).max)) require (false, &#39;LiquidityOverflow()&#39;);</span>
 161 |     | <span class='unexecuted'>        if ((uint128(type(int128).max) - state.liquidityGlobal) &lt; amount)</span>
 162 |     | <span class='unexecuted'>            require (false, &#39;LiquidityOverflow()&#39;);</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>        // load ticks into memory to reduce reads/writes</span>
 165 |     | <span class='unexecuted'>        CoverPoolStructs.Tick memory tickLower = ticks[lower];</span>
 166 |     | <span class='unexecuted'>        CoverPoolStructs.Tick memory tickUpper = ticks[upper];</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>        // sets bit in map</span>
 169 |     | <span class='unexecuted'>        TickMap.set(lower, tickMap, constants);</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>        // updates liquidity values</span>
 172 |     | <span class='unexecuted'>        if (isPool0) {</span>
 173 |     | <span class='unexecuted'>            tickLower.liquidityDelta -= int128(amount);</span>
 174 |     | <span class='neutral'>        } else {</span>
 175 |     | <span class='unexecuted'>            tickLower.liquidityDelta += int128(amount);</span>
 176 |     | <span class='neutral'>        }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>        TickMap.set(upper, tickMap, constants);</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='unexecuted'>        if (isPool0) {</span>
 181 |     | <span class='unexecuted'>            tickUpper.liquidityDelta += int128(amount);</span>
 182 |     | <span class='neutral'>        } else {</span>
 183 |     | <span class='unexecuted'>            tickUpper.liquidityDelta -= int128(amount);</span>
 184 |     | <span class='neutral'>        }</span>
 185 |     | <span class='unexecuted'>        ticks[lower] = tickLower;</span>
 186 |     | <span class='unexecuted'>        ticks[upper] = tickUpper;</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='unexecuted'>    function remove(</span>
 190 |     | <span class='neutral'>        mapping(int24 =&gt; CoverPoolStructs.Tick) storage ticks,</span>
 191 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
 192 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants,</span>
 193 |     | <span class='neutral'>        int24 lower,</span>
 194 |     | <span class='neutral'>        int24 upper,</span>
 195 |     | <span class='neutral'>        uint128 amount,</span>
 196 |     | <span class='neutral'>        bool isPool0,</span>
 197 |     | <span class='neutral'>        bool removeLower,</span>
 198 |     | <span class='neutral'>        bool removeUpper</span>
 199 |     | <span class='neutral'>    ) internal {</span>
 200 |     | <span class='unexecuted'>        {</span>
 201 |     | <span class='unexecuted'>            CoverPoolStructs.Tick memory tickLower = ticks[lower];</span>
 202 |     | <span class='unexecuted'>            if (removeLower) {</span>
 203 |     | <span class='unexecuted'>                if (isPool0) {</span>
 204 |     | <span class='unexecuted'>                    tickLower.liquidityDelta += int128(amount);</span>
 205 |     | <span class='neutral'>                } else {</span>
 206 |     | <span class='unexecuted'>                    tickLower.liquidityDelta -= int128(amount);</span>
 207 |     | <span class='neutral'>                }</span>
 208 |     | <span class='unexecuted'>                ticks[lower] = tickLower;</span>
 209 |     | <span class='neutral'>            }</span>
 210 |     | <span class='unexecuted'>            if (lower != ConstantProduct.minTick(constants.tickSpread)) {</span>
 211 |     | <span class='unexecuted'>                cleanup(ticks, tickMap, constants, tickLower, lower);</span>
 212 |     | <span class='neutral'>            }</span>
 213 |     | <span class='neutral'>        }</span>
 214 |     | <span class='unexecuted'>        {</span>
 215 |     | <span class='unexecuted'>            CoverPoolStructs.Tick memory tickUpper = ticks[upper];</span>
 216 |     | <span class='unexecuted'>            if (removeUpper) {</span>
 217 |     | <span class='unexecuted'>                if (isPool0) {</span>
 218 |     | <span class='unexecuted'>                    tickUpper.liquidityDelta -= int128(amount);</span>
 219 |     | <span class='neutral'>                } else {</span>
 220 |     | <span class='unexecuted'>                    tickUpper.liquidityDelta += int128(amount);</span>
 221 |     | <span class='neutral'>                }</span>
 222 |     | <span class='unexecuted'>                ticks[upper] = tickUpper;</span>
 223 |     | <span class='neutral'>            }</span>
 224 |     | <span class='unexecuted'>            if (upper != ConstantProduct.maxTick(constants.tickSpread)) {</span>
 225 |     | <span class='unexecuted'>                cleanup(ticks, tickMap, constants, tickUpper, upper);</span>
 226 |     | <span class='neutral'>            }</span>
 227 |     | <span class='neutral'>        }</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='unexecuted'>    function cleanup(</span>
 231 |     | <span class='neutral'>        mapping(int24 =&gt; CoverPoolStructs.Tick) storage ticks,</span>
 232 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
 233 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants,</span>
 234 |     | <span class='neutral'>        CoverPoolStructs.Tick memory tick,</span>
 235 |     | <span class='neutral'>        int24 tickIndex</span>
 236 |     | <span class='neutral'>    ) internal {</span>
 237 |     | <span class='unexecuted'>        if (!_empty(tick)){</span>
 238 |     | <span class='neutral'>            // if one of the values is 0 clear out both</span>
 239 |     | <span class='unexecuted'>            if (tick.amountInDeltaMaxMinus == 0 || tick.amountOutDeltaMaxMinus == 0) {</span>
 240 |     | <span class='unexecuted'>                tick.amountInDeltaMaxMinus = 0;</span>
 241 |     | <span class='unexecuted'>                tick.amountOutDeltaMaxMinus = 0;</span>
 242 |     | <span class='neutral'>            }</span>
 243 |     | <span class='unexecuted'>            if (tick.amountInDeltaMaxStashed == 0 || tick.amountOutDeltaMaxStashed == 0) {</span>
 244 |     | <span class='unexecuted'>                tick.amountInDeltaMaxStashed = 0;</span>
 245 |     | <span class='unexecuted'>                tick.amountOutDeltaMaxStashed = 0;</span>
 246 |     | <span class='neutral'>            }</span>
 247 |     | <span class='unexecuted'>            if (_inactive(tick)) {</span>
 248 |     | <span class='neutral'>                // zero out all values for safety</span>
 249 |     | <span class='unexecuted'>                tick.amountInDeltaMaxMinus = 0;</span>
 250 |     | <span class='unexecuted'>                tick.amountOutDeltaMaxMinus = 0;</span>
 251 |     | <span class='unexecuted'>                tick.amountInDeltaMaxStashed = 0;</span>
 252 |     | <span class='unexecuted'>                tick.amountOutDeltaMaxStashed = 0;</span>
 253 |     | <span class='unexecuted'>                TickMap.unset(tickIndex, tickMap, constants);</span>
 254 |     | <span class='neutral'>            }</span>
 255 |     | <span class='neutral'>        }</span>
 256 |     | <span class='unexecuted'>        if (_empty(tick)) {</span>
 257 |     | <span class='unexecuted'>            TickMap.unset(tickIndex, tickMap, constants);</span>
 258 |     | <span class='unexecuted'>            delete ticks[tickIndex];</span>
 259 |     | <span class='neutral'>        } else {</span>
 260 |     | <span class='unexecuted'>            ticks[tickIndex] = tick;</span>
 261 |     | <span class='neutral'>        }</span>
 262 |     | <span class='neutral'>    }</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='unexecuted'>    function _inactive(</span>
 265 |     | <span class='neutral'>        CoverPoolStructs.Tick memory tick</span>
 266 |     | <span class='neutral'>    ) internal pure returns (</span>
 267 |     | <span class='unexecuted'>        bool</span>
 268 |     | <span class='neutral'>    ) {</span>
 269 |     | <span class='unexecuted'>        if (tick.amountInDeltaMaxStashed &gt; 0 &amp;&amp; tick.amountOutDeltaMaxStashed &gt; 0) {</span>
 270 |     | <span class='unexecuted'>            return false;</span>
 271 |     | <span class='unexecuted'>        } else if (tick.amountInDeltaMaxMinus &gt; 0 &amp;&amp; tick.amountOutDeltaMaxMinus &gt; 0){</span>
 272 |     | <span class='unexecuted'>            return false;</span>
 273 |     | <span class='unexecuted'>        } else if (tick.liquidityDelta != 0) {</span>
 274 |     | <span class='unexecuted'>            return false;</span>
 275 |     | <span class='neutral'>        }</span>
 276 |     | <span class='unexecuted'>        return true;</span>
 277 |     | <span class='neutral'>    }</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='unexecuted'>    function _empty(</span>
 280 |     | <span class='neutral'>        CoverPoolStructs.Tick memory tick</span>
 281 |     | <span class='neutral'>    ) internal pure returns (</span>
 282 |     | <span class='unexecuted'>        bool</span>
 283 |     | <span class='neutral'>    ) {</span>
 284 |     | <span class='unexecuted'>        if (tick.amountInDeltaMaxStashed &gt; 0 &amp;&amp; tick.amountOutDeltaMaxStashed &gt; 0) {</span>
 285 |     | <span class='unexecuted'>            return false;</span>
 286 |     | <span class='unexecuted'>        } else if (tick.amountInDeltaMaxMinus &gt; 0 &amp;&amp; tick.amountOutDeltaMaxMinus &gt; 0){</span>
 287 |     | <span class='unexecuted'>            return false;</span>
 288 |     | <span class='unexecuted'>        } else if (tick.liquidityDelta != 0) {</span>
 289 |     | <span class='unexecuted'>            return false;</span>
 290 |     | <span class='unexecuted'>        } else if (tick.deltas0.amountInDeltaMax &gt; 0 &amp;&amp; tick.deltas0.amountOutDeltaMax &gt; 0) {</span>
 291 |     | <span class='unexecuted'>            return false;</span>
 292 |     | <span class='unexecuted'>        } else if (tick.deltas1.amountInDeltaMax &gt; 0 &amp;&amp; tick.deltas1.amountOutDeltaMax &gt; 0) {</span>
 293 |     | <span class='unexecuted'>            return false;</span>
 294 |     | <span class='neutral'>        }</span>
 295 |     | <span class='unexecuted'>        return true;</span>
 296 |     | <span class='neutral'>    }</span>
 297 |     | <span class='neutral'>}</span>
 298 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/libraries/math/ConstantProduct.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./OverflowMath.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/structs/CoverPoolStructs.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/// @notice Math library that facilitates ranged liquidity calculations.</span>
   8 |     | <span class='unexecuted'>library ConstantProduct {</span>
   9 |     | <span class='unexecuted'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    struct PriceBounds {</span>
  12 |     | <span class='neutral'>        uint160 min;</span>
  13 |     | <span class='neutral'>        uint160 max;</span>
  14 |     | <span class='neutral'>    }</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
  17 |     | <span class='neutral'>    ///////////////////////// DYDX MATH /////////////////////////</span>
  18 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    function getDy(</span>
  21 |     | <span class='neutral'>        uint256 liquidity,</span>
  22 |     | <span class='neutral'>        uint256 priceLower,</span>
  23 |     | <span class='neutral'>        uint256 priceUpper,</span>
  24 |     | <span class='neutral'>        bool roundUp</span>
  25 |     | <span class='unexecuted'>    ) internal pure returns (uint256 dy) {</span>
  26 |     | <span class='neutral'>        unchecked {</span>
  27 |     | <span class='unexecuted'>            if (liquidity == 0) return 0;</span>
  28 |     | <span class='unexecuted'>            if (roundUp) {</span>
  29 |     | <span class='unexecuted'>                dy = OverflowMath.mulDivRoundingUp(liquidity, priceUpper - priceLower, Q96);</span>
  30 |     | <span class='neutral'>            } else {</span>
  31 |     | <span class='unexecuted'>                dy = OverflowMath.mulDiv(liquidity, priceUpper - priceLower, Q96);</span>
  32 |     | <span class='neutral'>            }</span>
  33 |     | <span class='neutral'>        }</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    function getDx(</span>
  37 |     | <span class='neutral'>        uint256 liquidity,</span>
  38 |     | <span class='neutral'>        uint256 priceLower,</span>
  39 |     | <span class='neutral'>        uint256 priceUpper,</span>
  40 |     | <span class='neutral'>        bool roundUp</span>
  41 |     | <span class='unexecuted'>    ) internal pure returns (uint256 dx) {</span>
  42 |     | <span class='neutral'>        unchecked {</span>
  43 |     | <span class='unexecuted'>            if (liquidity == 0) return 0;</span>
  44 |     | <span class='unexecuted'>            if (roundUp) {</span>
  45 |     | <span class='unexecuted'>                dx = OverflowMath.divRoundingUp(</span>
  46 |     | <span class='unexecuted'>                        OverflowMath.mulDivRoundingUp(</span>
  47 |     | <span class='unexecuted'>                            liquidity &lt;&lt; 96, </span>
  48 |     | <span class='unexecuted'>                            priceUpper - priceLower,</span>
  49 |     | <span class='unexecuted'>                            priceUpper</span>
  50 |     | <span class='neutral'>                        ),</span>
  51 |     | <span class='unexecuted'>                        priceLower</span>
  52 |     | <span class='neutral'>                );</span>
  53 |     | <span class='neutral'>            } else {</span>
  54 |     | <span class='unexecuted'>                dx = OverflowMath.mulDiv(</span>
  55 |     | <span class='unexecuted'>                        liquidity &lt;&lt; 96,</span>
  56 |     | <span class='unexecuted'>                        priceUpper - priceLower,</span>
  57 |     | <span class='unexecuted'>                        priceUpper</span>
  58 |     | <span class='unexecuted'>                ) / priceLower;</span>
  59 |     | <span class='neutral'>            }</span>
  60 |     | <span class='neutral'>        }</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>    function getLiquidityForAmounts(</span>
  64 |     | <span class='neutral'>        uint256 priceLower,</span>
  65 |     | <span class='neutral'>        uint256 priceUpper,</span>
  66 |     | <span class='neutral'>        uint256 currentPrice,</span>
  67 |     | <span class='neutral'>        uint256 dy,</span>
  68 |     | <span class='neutral'>        uint256 dx</span>
  69 |     | <span class='unexecuted'>    ) internal pure returns (uint256 liquidity) {</span>
  70 |     | <span class='neutral'>        unchecked {</span>
  71 |     | <span class='unexecuted'>            if (priceUpper &lt;= currentPrice) {</span>
  72 |     | <span class='unexecuted'>                liquidity = OverflowMath.mulDiv(dy, Q96, priceUpper - priceLower);</span>
  73 |     | <span class='unexecuted'>            } else if (currentPrice &lt;= priceLower) {</span>
  74 |     | <span class='unexecuted'>                liquidity = OverflowMath.mulDiv(</span>
  75 |     | <span class='unexecuted'>                    dx,</span>
  76 |     | <span class='unexecuted'>                    OverflowMath.mulDiv(priceLower, priceUpper, Q96),</span>
  77 |     | <span class='unexecuted'>                    priceUpper - priceLower</span>
  78 |     | <span class='neutral'>                );</span>
  79 |     | <span class='unexecuted'>            } else {</span>
  80 |     | <span class='unexecuted'>                uint256 liquidity0 = OverflowMath.mulDiv(</span>
  81 |     | <span class='unexecuted'>                    dx,</span>
  82 |     | <span class='unexecuted'>                    OverflowMath.mulDiv(priceUpper, currentPrice, Q96),</span>
  83 |     | <span class='unexecuted'>                    priceUpper - currentPrice</span>
  84 |     | <span class='neutral'>                );</span>
  85 |     | <span class='unexecuted'>                uint256 liquidity1 = OverflowMath.mulDiv(dy, Q96, currentPrice - priceLower);</span>
  86 |     | <span class='unexecuted'>                liquidity = liquidity0 &lt; liquidity1 ? liquidity0 : liquidity1;</span>
  87 |     | <span class='neutral'>            }</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    function getAmountsForLiquidity(</span>
  92 |     | <span class='neutral'>        uint256 priceLower,</span>
  93 |     | <span class='neutral'>        uint256 priceUpper,</span>
  94 |     | <span class='neutral'>        uint256 currentPrice,</span>
  95 |     | <span class='neutral'>        uint256 liquidityAmount,</span>
  96 |     | <span class='neutral'>        bool roundUp</span>
  97 |     | <span class='neutral'>    ) internal pure returns (uint128 token0amount, uint128 token1amount) {</span>
  98 |     | <span class='neutral'>        if (priceUpper &lt;= currentPrice) {</span>
  99 |     | <span class='neutral'>            token1amount = uint128(getDy(liquidityAmount, priceLower, priceUpper, roundUp));</span>
 100 |     | <span class='neutral'>        } else if (currentPrice &lt;= priceLower) {</span>
 101 |     | <span class='neutral'>            token0amount = uint128(getDx(liquidityAmount, priceLower, priceUpper, roundUp));</span>
 102 |     | <span class='neutral'>        } else {</span>
 103 |     | <span class='neutral'>            token0amount = uint128(getDx(liquidityAmount, currentPrice, priceUpper, roundUp));</span>
 104 |     | <span class='neutral'>            token1amount = uint128(getDy(liquidityAmount, priceLower, currentPrice, roundUp));</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'>        if (token0amount &gt; uint128(type(int128).max)) require(false, &#39;AmountsOutOfBounds()&#39;);</span>
 107 |     | <span class='neutral'>        if (token1amount &gt; uint128(type(int128).max)) require(false, &#39;AmountsOutOfBounds()&#39;);</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='unexecuted'>    function getNewPrice(</span>
 111 |     | <span class='neutral'>        uint256 price,</span>
 112 |     | <span class='neutral'>        uint256 liquidity,</span>
 113 |     | <span class='neutral'>        uint256 amount,</span>
 114 |     | <span class='neutral'>        bool zeroForOne,</span>
 115 |     | <span class='neutral'>        bool exactIn</span>
 116 |     | <span class='neutral'>    ) internal pure returns (</span>
 117 |     | <span class='unexecuted'>        uint256 newPrice</span>
 118 |     | <span class='neutral'>    ) {</span>
 119 |     | <span class='unexecuted'>        if (exactIn) {</span>
 120 |     | <span class='unexecuted'>            if (zeroForOne) {</span>
 121 |     | <span class='unexecuted'>                uint256 liquidityPadded = liquidity &lt;&lt; 96;</span>
 122 |     | <span class='unexecuted'>                newPrice = OverflowMath.mulDivRoundingUp(</span>
 123 |     | <span class='unexecuted'>                        liquidityPadded,</span>
 124 |     | <span class='unexecuted'>                        price,</span>
 125 |     | <span class='unexecuted'>                        liquidityPadded + price * amount</span>
 126 |     | <span class='neutral'>                    );</span>
 127 |     | <span class='neutral'>            } else {</span>
 128 |     | <span class='unexecuted'>                newPrice = price + (amount &lt;&lt; 96) / liquidity;</span>
 129 |     | <span class='neutral'>            }</span>
 130 |     | <span class='neutral'>        } else {</span>
 131 |     | <span class='unexecuted'>            if (zeroForOne) {</span>
 132 |     | <span class='unexecuted'>                newPrice = price - </span>
 133 |     | <span class='unexecuted'>                        OverflowMath.divRoundingUp(amount &lt;&lt; 96, liquidity);</span>
 134 |     | <span class='unexecuted'>            } else {</span>
 135 |     | <span class='unexecuted'>                uint256 liquidityPadded = uint256(liquidity) &lt;&lt; 96;</span>
 136 |     | <span class='unexecuted'>                newPrice = OverflowMath.mulDivRoundingUp(</span>
 137 |     | <span class='unexecuted'>                        liquidityPadded, </span>
 138 |     | <span class='unexecuted'>                        price,</span>
 139 |     | <span class='unexecuted'>                        liquidityPadded - uint256(price) * amount</span>
 140 |     | <span class='neutral'>                );</span>
 141 |     | <span class='neutral'>            }</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='neutral'>    }</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>    function getPrice(</span>
 146 |     | <span class='neutral'>        uint256 sqrtPrice</span>
 147 |     | <span class='neutral'>    ) internal pure returns (uint256 price) {</span>
 148 |     | <span class='neutral'>        if (sqrtPrice &gt;= 2 ** 48)</span>
 149 |     | <span class='neutral'>            price = OverflowMath.mulDiv(sqrtPrice, sqrtPrice, 2 ** 96);</span>
 150 |     | <span class='neutral'>        else</span>
 151 |     | <span class='neutral'>            price = sqrtPrice;</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
 155 |     | <span class='neutral'>    ///////////////////////// TICK MATH /////////////////////////</span>
 156 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
 157 |     | <span class='neutral'></span>
 158 | *   | <span class='executed'>    int24 internal constant MIN_TICK = -887272;   /// @dev - tick for price of 2^-128</span>
 159 | *   | <span class='executed'>    int24 internal constant MAX_TICK = -MIN_TICK; /// @dev - tick for price of 2^128</span>
 160 |     | <span class='neutral'></span>
 161 | *   | <span class='executed'>    function minTick(</span>
 162 |     | <span class='neutral'>        int16 tickSpacing</span>
 163 |     | <span class='neutral'>    ) internal pure returns (</span>
 164 | *   | <span class='executed'>        int24 tick</span>
 165 |     | <span class='neutral'>    ) {</span>
 166 | *   | <span class='executed'>        return MIN_TICK / tickSpacing * tickSpacing;</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 | *   | <span class='executed'>    function maxTick(</span>
 170 |     | <span class='neutral'>        int16 tickSpacing</span>
 171 |     | <span class='neutral'>    ) internal pure returns (</span>
 172 | *   | <span class='executed'>        int24 tick</span>
 173 |     | <span class='neutral'>    ) {</span>
 174 | *   | <span class='executed'>        return MAX_TICK / tickSpacing * tickSpacing;</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='unexecuted'>    function priceBounds(</span>
 178 |     | <span class='neutral'>        int16 tickSpacing</span>
 179 |     | <span class='neutral'>    ) internal pure returns (</span>
 180 |     | <span class='unexecuted'>        uint160,</span>
 181 |     | <span class='unexecuted'>        uint160</span>
 182 |     | <span class='neutral'>    ) {</span>
 183 |     | <span class='unexecuted'>        return (minPrice(tickSpacing), maxPrice(tickSpacing));</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='unexecuted'>    function minPrice(</span>
 187 |     | <span class='neutral'>        int16 tickSpacing</span>
 188 |     | <span class='neutral'>    ) internal pure returns (</span>
 189 |     | <span class='unexecuted'>        uint160 price</span>
 190 |     | <span class='neutral'>    ) {</span>
 191 |     | <span class='unexecuted'>        PoolsharkStructs.CoverImmutables  memory constants;</span>
 192 |     | <span class='unexecuted'>        constants.tickSpread = tickSpacing;</span>
 193 |     | <span class='unexecuted'>        return getPriceAtTick(minTick(tickSpacing), constants);</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='unexecuted'>    function maxPrice(</span>
 197 |     | <span class='neutral'>        int16 tickSpacing</span>
 198 |     | <span class='neutral'>    ) internal pure returns (</span>
 199 |     | <span class='unexecuted'>        uint160 price</span>
 200 |     | <span class='neutral'>    ) {</span>
 201 |     | <span class='unexecuted'>        PoolsharkStructs.CoverImmutables  memory constants;</span>
 202 |     | <span class='unexecuted'>        constants.tickSpread = tickSpacing;</span>
 203 |     | <span class='unexecuted'>        return getPriceAtTick(maxTick(tickSpacing), constants);</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='unexecuted'>    function checkTicks(</span>
 207 |     | <span class='neutral'>        int24 lower,</span>
 208 |     | <span class='neutral'>        int24 upper,</span>
 209 |     | <span class='neutral'>        int16 tickSpacing</span>
 210 |     | <span class='neutral'>    ) internal pure</span>
 211 |     | <span class='neutral'>    {</span>
 212 |     | <span class='unexecuted'>        if (lower &lt; minTick(tickSpacing)) require (false, &#39;LowerTickOutOfBounds()&#39;);</span>
 213 |     | <span class='unexecuted'>        if (upper &gt; maxTick(tickSpacing)) require (false, &#39;UpperTickOutOfBounds()&#39;);</span>
 214 |     | <span class='unexecuted'>        if (lower % tickSpacing != 0) require (false, &#39;LowerTickOutsideTickSpacing()&#39;);</span>
 215 |     | <span class='unexecuted'>        if (upper % tickSpacing != 0) require (false, &#39;UpperTickOutsideTickSpacing()&#39;);</span>
 216 |     | <span class='unexecuted'>        if (lower &gt;= upper) require (false, &#39;LowerUpperTickOrderInvalid()&#39;);</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>    function checkPrice(</span>
 220 |     | <span class='neutral'>        uint160 price,</span>
 221 |     | <span class='neutral'>        PriceBounds memory bounds</span>
 222 |     | <span class='neutral'>    ) internal pure {</span>
 223 |     | <span class='neutral'>        if (price &lt; bounds.min || price &gt;= bounds.max) require (false, &#39;PriceOutOfBounds()&#39;);</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    /// @notice Calculates sqrt(1.0001^tick) * 2^96.</span>
 227 |     | <span class='neutral'>    /// @dev Throws if |tick| &gt; max tick.</span>
 228 |     | <span class='neutral'>    /// @param tick The input tick for the above formula.</span>
 229 |     | <span class='neutral'>    /// @return price Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)</span>
 230 |     | <span class='neutral'>    /// at the given tick.</span>
 231 |     | <span class='unexecuted'>    function getPriceAtTick(</span>
 232 |     | <span class='neutral'>        int24 tick,</span>
 233 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
 234 |     | <span class='neutral'>    ) internal pure returns (</span>
 235 |     | <span class='unexecuted'>        uint160 price</span>
 236 |     | <span class='unexecuted'>    ) {</span>
 237 |     | <span class='unexecuted'>        uint256 absTick = tick &lt; 0 ? uint256(-int256(tick)) : uint256(int256(tick));</span>
 238 |     | <span class='unexecuted'>        if (absTick &gt; uint256(uint24(maxTick(constants.tickSpread)))) require (false, &#39;TickOutOfBounds()&#39;);</span>
 239 |     | <span class='unexecuted'>        unchecked {</span>
 240 |     | <span class='unexecuted'>            uint256 ratio = absTick &amp; 0x1 != 0</span>
 241 |     | <span class='unexecuted'>                ? 0xfffcb933bd6fad37aa2d162d1a594001</span>
 242 |     | <span class='unexecuted'>                : 0x100000000000000000000000000000000;</span>
 243 |     | <span class='unexecuted'>            if (absTick &amp; 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) &gt;&gt; 128;</span>
 244 |     | <span class='unexecuted'>            if (absTick &amp; 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) &gt;&gt; 128;</span>
 245 |     | <span class='unexecuted'>            if (absTick &amp; 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) &gt;&gt; 128;</span>
 246 |     | <span class='unexecuted'>            if (absTick &amp; 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) &gt;&gt; 128;</span>
 247 |     | <span class='unexecuted'>            if (absTick &amp; 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) &gt;&gt; 128;</span>
 248 |     | <span class='unexecuted'>            if (absTick &amp; 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) &gt;&gt; 128;</span>
 249 |     | <span class='unexecuted'>            if (absTick &amp; 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) &gt;&gt; 128;</span>
 250 |     | <span class='unexecuted'>            if (absTick &amp; 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) &gt;&gt; 128;</span>
 251 |     | <span class='unexecuted'>            if (absTick &amp; 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) &gt;&gt; 128;</span>
 252 |     | <span class='unexecuted'>            if (absTick &amp; 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) &gt;&gt; 128;</span>
 253 |     | <span class='unexecuted'>            if (absTick &amp; 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) &gt;&gt; 128;</span>
 254 |     | <span class='unexecuted'>            if (absTick &amp; 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) &gt;&gt; 128;</span>
 255 |     | <span class='unexecuted'>            if (absTick &amp; 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) &gt;&gt; 128;</span>
 256 |     | <span class='unexecuted'>            if (absTick &amp; 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) &gt;&gt; 128;</span>
 257 |     | <span class='unexecuted'>            if (absTick &amp; 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) &gt;&gt; 128;</span>
 258 |     | <span class='unexecuted'>            if (absTick &amp; 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) &gt;&gt; 128;</span>
 259 |     | <span class='unexecuted'>            if (absTick &amp; 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) &gt;&gt; 128;</span>
 260 |     | <span class='unexecuted'>            if (absTick &amp; 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) &gt;&gt; 128;</span>
 261 |     | <span class='unexecuted'>            if (absTick &amp; 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) &gt;&gt; 128;</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='unexecuted'>            if (tick &gt; 0) ratio = type(uint256).max / ratio;</span>
 264 |     | <span class='neutral'>            // This divides by 1&lt;&lt;32 rounding up to go from a Q128.128 to a Q128.96.</span>
 265 |     | <span class='neutral'>            // We then downcast because we know the result always fits within 160 bits due to our tick input constraint.</span>
 266 |     | <span class='neutral'>            // We round up in the division so getTickAtPrice of the output price is always consistent.</span>
 267 |     | <span class='unexecuted'>            price = uint160((ratio &gt;&gt; 32) + (ratio % (1 &lt;&lt; 32) == 0 ? 0 : 1));</span>
 268 |     | <span class='neutral'>        }</span>
 269 |     | <span class='neutral'>    }</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) &lt;= ratio.</span>
 272 |     | <span class='neutral'>    /// @param price The sqrt ratio for which to compute the tick as a Q64.96.</span>
 273 |     | <span class='neutral'>    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio.</span>
 274 |     | <span class='neutral'>    function getTickAtPrice(</span>
 275 |     | <span class='neutral'>        uint160 price,</span>
 276 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables  memory constants</span>
 277 |     | <span class='neutral'>    ) internal pure returns (int24 tick) {</span>
 278 |     | <span class='neutral'>        // Second inequality must be &lt; because the price can never reach the price at the max tick.</span>
 279 |     | <span class='neutral'>        if (price &lt; constants.bounds.min || price &gt; constants.bounds.max)</span>
 280 |     | <span class='neutral'>            require (false, &#39;PriceOutOfBounds()&#39;);</span>
 281 |     | <span class='neutral'>        uint256 ratio = uint256(price) &lt;&lt; 32;</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>        uint256 r = ratio;</span>
 284 |     | <span class='neutral'>        uint256 msb = 0;</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>        assembly {</span>
 287 |     | <span class='neutral'>            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))</span>
 288 |     | <span class='neutral'>            msb := or(msb, f)</span>
 289 |     | <span class='neutral'>            r := shr(f, r)</span>
 290 |     | <span class='neutral'>        }</span>
 291 |     | <span class='neutral'>        assembly {</span>
 292 |     | <span class='neutral'>            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))</span>
 293 |     | <span class='neutral'>            msb := or(msb, f)</span>
 294 |     | <span class='neutral'>            r := shr(f, r)</span>
 295 |     | <span class='neutral'>        }</span>
 296 |     | <span class='neutral'>        assembly {</span>
 297 |     | <span class='neutral'>            let f := shl(5, gt(r, 0xFFFFFFFF))</span>
 298 |     | <span class='neutral'>            msb := or(msb, f)</span>
 299 |     | <span class='neutral'>            r := shr(f, r)</span>
 300 |     | <span class='neutral'>        }</span>
 301 |     | <span class='neutral'>        assembly {</span>
 302 |     | <span class='neutral'>            let f := shl(4, gt(r, 0xFFFF))</span>
 303 |     | <span class='neutral'>            msb := or(msb, f)</span>
 304 |     | <span class='neutral'>            r := shr(f, r)</span>
 305 |     | <span class='neutral'>        }</span>
 306 |     | <span class='neutral'>        assembly {</span>
 307 |     | <span class='neutral'>            let f := shl(3, gt(r, 0xFF))</span>
 308 |     | <span class='neutral'>            msb := or(msb, f)</span>
 309 |     | <span class='neutral'>            r := shr(f, r)</span>
 310 |     | <span class='neutral'>        }</span>
 311 |     | <span class='neutral'>        assembly {</span>
 312 |     | <span class='neutral'>            let f := shl(2, gt(r, 0xF))</span>
 313 |     | <span class='neutral'>            msb := or(msb, f)</span>
 314 |     | <span class='neutral'>            r := shr(f, r)</span>
 315 |     | <span class='neutral'>        }</span>
 316 |     | <span class='neutral'>        assembly {</span>
 317 |     | <span class='neutral'>            let f := shl(1, gt(r, 0x3))</span>
 318 |     | <span class='neutral'>            msb := or(msb, f)</span>
 319 |     | <span class='neutral'>            r := shr(f, r)</span>
 320 |     | <span class='neutral'>        }</span>
 321 |     | <span class='neutral'>        assembly {</span>
 322 |     | <span class='neutral'>            let f := gt(r, 0x1)</span>
 323 |     | <span class='neutral'>            msb := or(msb, f)</span>
 324 |     | <span class='neutral'>        }</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='neutral'>        if (msb &gt;= 128) r = ratio &gt;&gt; (msb - 127);</span>
 327 |     | <span class='neutral'>        else r = ratio &lt;&lt; (127 - msb);</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='neutral'>        int256 log_2 = (int256(msb) - 128) &lt;&lt; 64;</span>
 330 |     | <span class='neutral'></span>
 331 |     | <span class='neutral'>        assembly {</span>
 332 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 333 |     | <span class='neutral'>            let f := shr(128, r)</span>
 334 |     | <span class='neutral'>            log_2 := or(log_2, shl(63, f))</span>
 335 |     | <span class='neutral'>            r := shr(f, r)</span>
 336 |     | <span class='neutral'>        }</span>
 337 |     | <span class='neutral'>        assembly {</span>
 338 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 339 |     | <span class='neutral'>            let f := shr(128, r)</span>
 340 |     | <span class='neutral'>            log_2 := or(log_2, shl(62, f))</span>
 341 |     | <span class='neutral'>            r := shr(f, r)</span>
 342 |     | <span class='neutral'>        }</span>
 343 |     | <span class='neutral'>        assembly {</span>
 344 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 345 |     | <span class='neutral'>            let f := shr(128, r)</span>
 346 |     | <span class='neutral'>            log_2 := or(log_2, shl(61, f))</span>
 347 |     | <span class='neutral'>            r := shr(f, r)</span>
 348 |     | <span class='neutral'>        }</span>
 349 |     | <span class='neutral'>        assembly {</span>
 350 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 351 |     | <span class='neutral'>            let f := shr(128, r)</span>
 352 |     | <span class='neutral'>            log_2 := or(log_2, shl(60, f))</span>
 353 |     | <span class='neutral'>            r := shr(f, r)</span>
 354 |     | <span class='neutral'>        }</span>
 355 |     | <span class='neutral'>        assembly {</span>
 356 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 357 |     | <span class='neutral'>            let f := shr(128, r)</span>
 358 |     | <span class='neutral'>            log_2 := or(log_2, shl(59, f))</span>
 359 |     | <span class='neutral'>            r := shr(f, r)</span>
 360 |     | <span class='neutral'>        }</span>
 361 |     | <span class='neutral'>        assembly {</span>
 362 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 363 |     | <span class='neutral'>            let f := shr(128, r)</span>
 364 |     | <span class='neutral'>            log_2 := or(log_2, shl(58, f))</span>
 365 |     | <span class='neutral'>            r := shr(f, r)</span>
 366 |     | <span class='neutral'>        }</span>
 367 |     | <span class='neutral'>        assembly {</span>
 368 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 369 |     | <span class='neutral'>            let f := shr(128, r)</span>
 370 |     | <span class='neutral'>            log_2 := or(log_2, shl(57, f))</span>
 371 |     | <span class='neutral'>            r := shr(f, r)</span>
 372 |     | <span class='neutral'>        }</span>
 373 |     | <span class='neutral'>        assembly {</span>
 374 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 375 |     | <span class='neutral'>            let f := shr(128, r)</span>
 376 |     | <span class='neutral'>            log_2 := or(log_2, shl(56, f))</span>
 377 |     | <span class='neutral'>            r := shr(f, r)</span>
 378 |     | <span class='neutral'>        }</span>
 379 |     | <span class='neutral'>        assembly {</span>
 380 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 381 |     | <span class='neutral'>            let f := shr(128, r)</span>
 382 |     | <span class='neutral'>            log_2 := or(log_2, shl(55, f))</span>
 383 |     | <span class='neutral'>            r := shr(f, r)</span>
 384 |     | <span class='neutral'>        }</span>
 385 |     | <span class='neutral'>        assembly {</span>
 386 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 387 |     | <span class='neutral'>            let f := shr(128, r)</span>
 388 |     | <span class='neutral'>            log_2 := or(log_2, shl(54, f))</span>
 389 |     | <span class='neutral'>            r := shr(f, r)</span>
 390 |     | <span class='neutral'>        }</span>
 391 |     | <span class='neutral'>        assembly {</span>
 392 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 393 |     | <span class='neutral'>            let f := shr(128, r)</span>
 394 |     | <span class='neutral'>            log_2 := or(log_2, shl(53, f))</span>
 395 |     | <span class='neutral'>            r := shr(f, r)</span>
 396 |     | <span class='neutral'>        }</span>
 397 |     | <span class='neutral'>        assembly {</span>
 398 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 399 |     | <span class='neutral'>            let f := shr(128, r)</span>
 400 |     | <span class='neutral'>            log_2 := or(log_2, shl(52, f))</span>
 401 |     | <span class='neutral'>            r := shr(f, r)</span>
 402 |     | <span class='neutral'>        }</span>
 403 |     | <span class='neutral'>        assembly {</span>
 404 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 405 |     | <span class='neutral'>            let f := shr(128, r)</span>
 406 |     | <span class='neutral'>            log_2 := or(log_2, shl(51, f))</span>
 407 |     | <span class='neutral'>            r := shr(f, r)</span>
 408 |     | <span class='neutral'>        }</span>
 409 |     | <span class='neutral'>        assembly {</span>
 410 |     | <span class='neutral'>            r := shr(127, mul(r, r))</span>
 411 |     | <span class='neutral'>            let f := shr(128, r)</span>
 412 |     | <span class='neutral'>            log_2 := or(log_2, shl(50, f))</span>
 413 |     | <span class='neutral'>        }</span>
 414 |     | <span class='neutral'></span>
 415 |     | <span class='neutral'>        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number</span>
 416 |     | <span class='neutral'></span>
 417 |     | <span class='neutral'>        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) &gt;&gt; 128);</span>
 418 |     | <span class='neutral'>        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) &gt;&gt; 128);</span>
 419 |     | <span class='neutral'></span>
 420 |     | <span class='neutral'>        tick = tickLow == tickHi ? tickLow : getPriceAtTick(tickHi, constants) &lt;= price</span>
 421 |     | <span class='neutral'>            ? tickHi</span>
 422 |     | <span class='neutral'>            : tickLow;</span>
 423 |     | <span class='neutral'>    }</span>
 424 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/libraries/math/OverflowMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Math library that facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision.</span>
   5 |     | <span class='unexecuted'>library OverflowMath {</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>    // @dev no underflow or overflow checks</span>
   8 |     | <span class='unexecuted'>    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
   9 |     | <span class='neutral'>        assembly {</span>
  10 |     | <span class='unexecuted'>            z := add(div(x, y), gt(mod(x, y), 0))</span>
  11 |     | <span class='neutral'>        }</span>
  12 |     | <span class='neutral'>    }</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    /// @notice Calculates floor(abdenominator) with full precision - throws if result overflows an uint256 or denominator == 0.</span>
  15 |     | <span class='neutral'>    /// @param a The multiplicand.</span>
  16 |     | <span class='neutral'>    /// @param b The multiplier.</span>
  17 |     | <span class='neutral'>    /// @param denominator The divisor.</span>
  18 |     | <span class='neutral'>    /// @return result The 256-bit result.</span>
  19 |     | <span class='neutral'>    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.</span>
  20 |     | <span class='unexecuted'>    function mulDiv(</span>
  21 |     | <span class='neutral'>        uint256 a,</span>
  22 |     | <span class='neutral'>        uint256 b,</span>
  23 |     | <span class='neutral'>        uint256 denominator</span>
  24 |     | <span class='unexecuted'>    ) internal pure returns (uint256 result) {</span>
  25 |     | <span class='neutral'>        unchecked {</span>
  26 |     | <span class='neutral'>            // 512-bit multiply [prod1 prod0] = a * b.</span>
  27 |     | <span class='neutral'>            // Compute the product mod 2**256 and mod 2**256 - 1,</span>
  28 |     | <span class='neutral'>            // then use the Chinese Remainder Theorem to reconstruct</span>
  29 |     | <span class='neutral'>            // the 512 bit result. The result is stored in two 256</span>
  30 |     | <span class='neutral'>            // variables such that product = prod1 * 2**256 + prod0.</span>
  31 |     | <span class='unexecuted'>            uint256 prod0; // Least significant 256 bits of the product.</span>
  32 |     | <span class='unexecuted'>            uint256 prod1; // Most significant 256 bits of the product.</span>
  33 |     | <span class='unexecuted'>            assembly {</span>
  34 |     | <span class='unexecuted'>                let mm := mulmod(a, b, not(0))</span>
  35 |     | <span class='unexecuted'>                prod0 := mul(a, b)</span>
  36 |     | <span class='unexecuted'>                prod1 := sub(sub(mm, prod0), lt(mm, prod0))</span>
  37 |     | <span class='neutral'>            }</span>
  38 |     | <span class='neutral'>            // Handle non-overflow cases, 256 by 256 division.</span>
  39 |     | <span class='unexecuted'>            if (prod1 == 0) {</span>
  40 |     | <span class='unexecuted'>                require(denominator &gt; 0);</span>
  41 |     | <span class='neutral'>                assembly {</span>
  42 |     | <span class='unexecuted'>                    result := div(prod0, denominator)</span>
  43 |     | <span class='neutral'>                }</span>
  44 |     | <span class='unexecuted'>                return result;</span>
  45 |     | <span class='neutral'>            }</span>
  46 |     | <span class='neutral'>            // Make sure the result is less than 2**256 -</span>
  47 |     | <span class='neutral'>            // also prevents denominator == 0.</span>
  48 |     | <span class='unexecuted'>            require(denominator &gt; prod1);</span>
  49 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  50 |     | <span class='neutral'>            // 512 by 256 division.</span>
  51 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  52 |     | <span class='neutral'>            // Make division exact by subtracting the remainder from [prod1 prod0] -</span>
  53 |     | <span class='neutral'>            // compute remainder using mulmod.</span>
  54 |     | <span class='unexecuted'>            uint256 remainder;</span>
  55 |     | <span class='neutral'>            assembly {</span>
  56 |     | <span class='unexecuted'>                remainder := mulmod(a, b, denominator)</span>
  57 |     | <span class='neutral'>            }</span>
  58 |     | <span class='neutral'>            // Subtract 256 bit number from 512 bit number.</span>
  59 |     | <span class='neutral'>            assembly {</span>
  60 |     | <span class='unexecuted'>                prod1 := sub(prod1, gt(remainder, prod0))</span>
  61 |     | <span class='unexecuted'>                prod0 := sub(prod0, remainder)</span>
  62 |     | <span class='neutral'>            }</span>
  63 |     | <span class='neutral'>            // Factor powers of two out of denominator -</span>
  64 |     | <span class='neutral'>            // compute largest power of two divisor of denominator</span>
  65 |     | <span class='neutral'>            // (always &gt;= 1).</span>
  66 |     | <span class='unexecuted'>            uint256 twos = uint256(-int256(denominator)) &amp; denominator;</span>
  67 |     | <span class='neutral'>            // Divide denominator by power of two.</span>
  68 |     | <span class='neutral'>            assembly {</span>
  69 |     | <span class='unexecuted'>                denominator := div(denominator, twos)</span>
  70 |     | <span class='neutral'>            }</span>
  71 |     | <span class='neutral'>            // Divide [prod1 prod0] by the factors of two.</span>
  72 |     | <span class='neutral'>            assembly {</span>
  73 |     | <span class='unexecuted'>                prod0 := div(prod0, twos)</span>
  74 |     | <span class='neutral'>            }</span>
  75 |     | <span class='neutral'>            // Shift in bits from prod1 into prod0. For this we need</span>
  76 |     | <span class='neutral'>            // to flip `twos` such that it is 2**256 / twos -</span>
  77 |     | <span class='neutral'>            // if twos is zero, then it becomes one.</span>
  78 |     | <span class='neutral'>            assembly {</span>
  79 |     | <span class='unexecuted'>                twos := add(div(sub(0, twos), twos), 1)</span>
  80 |     | <span class='neutral'>            }</span>
  81 |     | <span class='unexecuted'>            prod0 |= prod1 * twos;</span>
  82 |     | <span class='neutral'>            // Invert denominator mod 2**256 -</span>
  83 |     | <span class='neutral'>            // now that denominator is an odd number, it has an inverse</span>
  84 |     | <span class='neutral'>            // modulo 2**256 such that denominator * inv = 1 mod 2**256.</span>
  85 |     | <span class='neutral'>            // Compute the inverse by starting with a seed that is correct</span>
  86 |     | <span class='neutral'>            // for four bits. That is, denominator * inv = 1 mod 2**4.</span>
  87 |     | <span class='unexecuted'>            uint256 inv = (3 * denominator) ^ 2;</span>
  88 |     | <span class='neutral'>            // Now use Newton-Raphson iteration to improve the precision.</span>
  89 |     | <span class='neutral'>            // Thanks to Hensel&#39;s lifting lemma, this also works in modular</span>
  90 |     | <span class='neutral'>            // arithmetic, doubling the correct bits in each step.</span>
  91 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**8.</span>
  92 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**16.</span>
  93 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**32.</span>
  94 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**64.</span>
  95 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**128.</span>
  96 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**256.</span>
  97 |     | <span class='neutral'>            // Because the division is now exact we can divide by multiplying</span>
  98 |     | <span class='neutral'>            // with the modular inverse of denominator. This will give us the</span>
  99 |     | <span class='neutral'>            // correct result modulo 2**256. Since the precoditions guarantee</span>
 100 |     | <span class='neutral'>            // that the outcome is less than 2**256, this is the final result.</span>
 101 |     | <span class='neutral'>            // We don&#39;t need to compute the high bits of the result and prod1</span>
 102 |     | <span class='neutral'>            // is no longer required.</span>
 103 |     | <span class='unexecuted'>            result = prod0 * inv;</span>
 104 |     | <span class='unexecuted'>            return result;</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @notice Calculates ceil(abdenominator) with full precision - throws if result overflows an uint256 or denominator == 0.</span>
 109 |     | <span class='neutral'>    /// @param a The multiplicand.</span>
 110 |     | <span class='neutral'>    /// @param b The multiplier.</span>
 111 |     | <span class='neutral'>    /// @param denominator The divisor.</span>
 112 |     | <span class='neutral'>    /// @return result The 256-bit result.</span>
 113 |     | <span class='unexecuted'>    function mulDivRoundingUp(</span>
 114 |     | <span class='neutral'>        uint256 a,</span>
 115 |     | <span class='neutral'>        uint256 b,</span>
 116 |     | <span class='neutral'>        uint256 denominator</span>
 117 |     | <span class='unexecuted'>    ) internal pure returns (uint256 result) {</span>
 118 |     | <span class='unexecuted'>        result = mulDiv(a, b, denominator);</span>
 119 |     | <span class='neutral'>        unchecked {</span>
 120 |     | <span class='unexecuted'>            if (mulmod(a, b, denominator) != 0) {</span>
 121 |     | <span class='unexecuted'>                if (result &gt;= type(uint256).max) require (false, &#39;MaxUintExceeded()&#39;);</span>
 122 |     | <span class='unexecuted'>                result++;</span>
 123 |     | <span class='neutral'>            }</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'>}</span>
 127 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/libraries/pool/BurnCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/structs/CoverPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../Positions.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../utils/Collect.sol&#39;;</span>
   7 |     | <span class='neutral'></span>
   8 | *   | <span class='executed'>library BurnCall {</span>
   9 |     | <span class='neutral'>    event Burn(</span>
  10 |     | <span class='neutral'>        address indexed to,</span>
  11 |     | <span class='neutral'>        int24 lower,</span>
  12 |     | <span class='neutral'>        int24 upper,</span>
  13 |     | <span class='neutral'>        int24 claim,</span>
  14 |     | <span class='neutral'>        bool zeroForOne,</span>
  15 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
  16 |     | <span class='neutral'>        uint128 tokenInClaimed,</span>
  17 |     | <span class='neutral'>        uint128 tokenOutClaimed,</span>
  18 |     | <span class='neutral'>        uint128 tokenOutBurned,</span>
  19 |     | <span class='neutral'>        uint128 amountInDeltaMaxStashedBurned,</span>
  20 |     | <span class='neutral'>        uint128 amountOutDeltaMaxStashedBurned,</span>
  21 |     | <span class='neutral'>        uint128 amountInDeltaMaxBurned,</span>
  22 |     | <span class='neutral'>        uint128 amountOutDeltaMaxBurned,</span>
  23 |     | <span class='neutral'>        uint160 claimPriceLast</span>
  24 |     | <span class='neutral'>    );</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    error SimulateBurn(int24 lower, int24 upper, bool positionExists);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>    function perform(</span>
  29 |     | <span class='neutral'>        ICoverPool.BurnParams memory params,</span>
  30 |     | <span class='neutral'>        CoverPoolStructs.BurnCache memory cache,</span>
  31 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
  32 |     | <span class='neutral'>        mapping(int24 =&gt; CoverPoolStructs.Tick) storage ticks,</span>
  33 |     | <span class='neutral'>        mapping(uint256 =&gt; CoverPoolStructs.CoverPosition)</span>
  34 |     | <span class='neutral'>            storage positions</span>
  35 |     | <span class='unexecuted'>    ) internal returns (CoverPoolStructs.BurnCache memory) {</span>
  36 |     | <span class='unexecuted'>        cache.position = positions[params.positionId];</span>
  37 |     | <span class='unexecuted'>        if (cache.position.owner != msg.sender) {</span>
  38 |     | <span class='unexecuted'>            require(false, &#39;PositionNotFound()&#39;);</span>
  39 |     | <span class='neutral'>        }</span>
  40 |     | <span class='unexecuted'>        if (cache.position.claimPriceLast &gt; 0</span>
  41 |     | <span class='unexecuted'>            || params.claim != (params.zeroForOne ? cache.position.upper : cache.position.lower) </span>
  42 |     | <span class='unexecuted'>            || params.claim == cache.state.latestTick)</span>
  43 |     | <span class='neutral'>        {</span>
  44 |     | <span class='neutral'>            // if position has been crossed into</span>
  45 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
  46 |     | <span class='unexecuted'>                (</span>
  47 |     | <span class='unexecuted'>                    cache.state,</span>
  48 |     | <span class='unexecuted'>                    cache.pool0,</span>
  49 |     | <span class='unexecuted'>                    params.claim</span>
  50 |     | <span class='unexecuted'>                ) = Positions.update(</span>
  51 |     | <span class='unexecuted'>                    positions,</span>
  52 |     | <span class='unexecuted'>                    ticks,</span>
  53 |     | <span class='unexecuted'>                    tickMap,</span>
  54 |     | <span class='unexecuted'>                    cache.state,</span>
  55 |     | <span class='unexecuted'>                    cache.pool0,</span>
  56 |     | <span class='unexecuted'>                    CoverPoolStructs.UpdateParams(</span>
  57 |     | <span class='unexecuted'>                        msg.sender,</span>
  58 |     | <span class='unexecuted'>                        params.to,</span>
  59 |     | <span class='unexecuted'>                        params.burnPercent,</span>
  60 |     | <span class='unexecuted'>                        params.positionId,</span>
  61 |     | <span class='unexecuted'>                        cache.position.lower,</span>
  62 |     | <span class='unexecuted'>                        cache.position.upper,</span>
  63 |     | <span class='unexecuted'>                        params.claim,</span>
  64 |     | <span class='unexecuted'>                        params.zeroForOne</span>
  65 |     | <span class='neutral'>                    ),</span>
  66 |     | <span class='unexecuted'>                    cache.constants</span>
  67 |     | <span class='neutral'>                );</span>
  68 |     | <span class='neutral'>            } else {</span>
  69 |     | <span class='unexecuted'>                (</span>
  70 |     | <span class='unexecuted'>                    cache.state,</span>
  71 |     | <span class='unexecuted'>                    cache.pool1,</span>
  72 |     | <span class='unexecuted'>                    params.claim</span>
  73 |     | <span class='unexecuted'>                ) = Positions.update(</span>
  74 |     | <span class='unexecuted'>                    positions,</span>
  75 |     | <span class='unexecuted'>                    ticks,</span>
  76 |     | <span class='unexecuted'>                    tickMap,</span>
  77 |     | <span class='unexecuted'>                    cache.state,</span>
  78 |     | <span class='unexecuted'>                    cache.pool1,</span>
  79 |     | <span class='unexecuted'>                    CoverPoolStructs.UpdateParams(</span>
  80 |     | <span class='unexecuted'>                        msg.sender,</span>
  81 |     | <span class='unexecuted'>                        params.to,</span>
  82 |     | <span class='unexecuted'>                        params.burnPercent,</span>
  83 |     | <span class='unexecuted'>                        params.positionId,</span>
  84 |     | <span class='unexecuted'>                        cache.position.lower,</span>
  85 |     | <span class='unexecuted'>                        cache.position.upper,</span>
  86 |     | <span class='unexecuted'>                        params.claim,</span>
  87 |     | <span class='unexecuted'>                        params.zeroForOne</span>
  88 |     | <span class='neutral'>                    ),</span>
  89 |     | <span class='unexecuted'>                    cache.constants</span>
  90 |     | <span class='neutral'>                );</span>
  91 |     | <span class='neutral'>            }</span>
  92 |     | <span class='neutral'>        } else {</span>
  93 |     | <span class='neutral'>            // if position hasn&#39;t been crossed into</span>
  94 |     | <span class='unexecuted'>            (, cache.state) = Positions.remove(</span>
  95 |     | <span class='unexecuted'>                positions,</span>
  96 |     | <span class='unexecuted'>                ticks,</span>
  97 |     | <span class='unexecuted'>                tickMap,</span>
  98 |     | <span class='unexecuted'>                cache.state,</span>
  99 |     | <span class='unexecuted'>                CoverPoolStructs.RemoveParams(</span>
 100 |     | <span class='unexecuted'>                    msg.sender,</span>
 101 |     | <span class='unexecuted'>                    params.to,</span>
 102 |     | <span class='unexecuted'>                    params.burnPercent,</span>
 103 |     | <span class='unexecuted'>                    params.positionId,</span>
 104 |     | <span class='unexecuted'>                    cache.position.lower,</span>
 105 |     | <span class='unexecuted'>                    cache.position.upper,</span>
 106 |     | <span class='unexecuted'>                    params.zeroForOne</span>
 107 |     | <span class='neutral'>                ),</span>
 108 |     | <span class='unexecuted'>                cache.constants</span>
 109 |     | <span class='neutral'>            );</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='unexecuted'>        Collect.burn(</span>
 112 |     | <span class='unexecuted'>            cache,</span>
 113 |     | <span class='unexecuted'>            positions,</span>
 114 |     | <span class='unexecuted'>            CoverPoolStructs.CollectParams(</span>
 115 |     | <span class='unexecuted'>                cache.syncFees,</span>
 116 |     | <span class='unexecuted'>                params.to, //address(0) goes to msg.sender</span>
 117 |     | <span class='unexecuted'>                params.positionId,</span>
 118 |     | <span class='unexecuted'>                cache.position.lower,</span>
 119 |     | <span class='unexecuted'>                params.claim,</span>
 120 |     | <span class='unexecuted'>                cache.position.upper,</span>
 121 |     | <span class='unexecuted'>                params.zeroForOne</span>
 122 |     | <span class='neutral'>            )</span>
 123 |     | <span class='neutral'>        );</span>
 124 |     | <span class='unexecuted'>        return cache;</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    // Echidna funcs</span>
 128 | *   | <span class='executed'>    function getResizedTicks(</span>
 129 |     | <span class='neutral'>        ICoverPool.BurnParams memory params,</span>
 130 |     | <span class='neutral'>        CoverPoolStructs.BurnCache memory cache,</span>
 131 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
 132 |     | <span class='neutral'>        mapping(int24 =&gt; CoverPoolStructs.Tick) storage ticks,</span>
 133 |     | <span class='neutral'>        mapping(uint256 =&gt; CoverPoolStructs.CoverPosition)</span>
 134 |     | <span class='neutral'>            storage positions</span>
 135 |     | <span class='neutral'>    ) external {</span>
 136 |     | <span class='neutral'>        // check for invalid receiver</span>
 137 | *   | <span class='executed'>        if (params.to == address(0))</span>
 138 |     | <span class='unexecuted'>            require(false, &#39;CollectToZeroAddress()&#39;);</span>
 139 | *   | <span class='executed'>        cache.position = positions[params.positionId];</span>
 140 |     | <span class='unexecuted'>        if (cache.position.owner != msg.sender) {</span>
 141 |     | <span class='unexecuted'>            require(false, &#39;PositionNotFound()&#39;);</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='unexecuted'>        if (cache.position.claimPriceLast &gt; 0</span>
 144 |     | <span class='unexecuted'>            || params.claim != (params.zeroForOne ? cache.position.upper : cache.position.lower) </span>
 145 |     | <span class='unexecuted'>            || params.claim == cache.state.latestTick)</span>
 146 |     | <span class='neutral'>        {</span>
 147 |     | <span class='neutral'>            // if position has been crossed into</span>
 148 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 149 |     | <span class='unexecuted'>                (</span>
 150 |     | <span class='unexecuted'>                    cache.state,</span>
 151 |     | <span class='unexecuted'>                    cache.pool0,</span>
 152 |     | <span class='unexecuted'>                    params.claim</span>
 153 |     | <span class='unexecuted'>                ) = Positions.update(</span>
 154 |     | <span class='unexecuted'>                    positions,</span>
 155 |     | <span class='unexecuted'>                    ticks,</span>
 156 |     | <span class='unexecuted'>                    tickMap,</span>
 157 |     | <span class='unexecuted'>                    cache.state,</span>
 158 |     | <span class='unexecuted'>                    cache.pool0,</span>
 159 |     | <span class='unexecuted'>                    CoverPoolStructs.UpdateParams(</span>
 160 |     | <span class='unexecuted'>                        msg.sender,</span>
 161 |     | <span class='unexecuted'>                        params.to,</span>
 162 |     | <span class='unexecuted'>                        params.burnPercent,</span>
 163 |     | <span class='unexecuted'>                        params.positionId,</span>
 164 |     | <span class='unexecuted'>                        cache.position.lower,</span>
 165 |     | <span class='unexecuted'>                        cache.position.upper,</span>
 166 |     | <span class='unexecuted'>                        params.claim,</span>
 167 |     | <span class='unexecuted'>                        params.zeroForOne</span>
 168 |     | <span class='neutral'>                    ),</span>
 169 |     | <span class='unexecuted'>                    cache.constants</span>
 170 |     | <span class='neutral'>                );</span>
 171 |     | <span class='neutral'>            } else {</span>
 172 |     | <span class='unexecuted'>                (</span>
 173 |     | <span class='unexecuted'>                    cache.state,</span>
 174 |     | <span class='unexecuted'>                    cache.pool1,</span>
 175 |     | <span class='unexecuted'>                    params.claim</span>
 176 |     | <span class='unexecuted'>                ) = Positions.update(</span>
 177 |     | <span class='unexecuted'>                    positions,</span>
 178 |     | <span class='unexecuted'>                    ticks,</span>
 179 |     | <span class='unexecuted'>                    tickMap,</span>
 180 |     | <span class='unexecuted'>                    cache.state,</span>
 181 |     | <span class='unexecuted'>                    cache.pool1,</span>
 182 |     | <span class='unexecuted'>                    CoverPoolStructs.UpdateParams(</span>
 183 |     | <span class='unexecuted'>                        msg.sender,</span>
 184 |     | <span class='unexecuted'>                        params.to,</span>
 185 |     | <span class='unexecuted'>                        params.burnPercent,</span>
 186 |     | <span class='unexecuted'>                        params.positionId,</span>
 187 |     | <span class='unexecuted'>                        cache.position.lower,</span>
 188 |     | <span class='unexecuted'>                        cache.position.upper,</span>
 189 |     | <span class='unexecuted'>                        params.claim,</span>
 190 |     | <span class='unexecuted'>                        params.zeroForOne</span>
 191 |     | <span class='neutral'>                    ),</span>
 192 |     | <span class='unexecuted'>                    cache.constants</span>
 193 |     | <span class='neutral'>                );</span>
 194 |     | <span class='neutral'>            }</span>
 195 |     | <span class='neutral'>        } else {</span>
 196 |     | <span class='neutral'>            // if position hasn&#39;t been crossed into</span>
 197 |     | <span class='unexecuted'>            (, cache.state) = Positions.remove(</span>
 198 |     | <span class='unexecuted'>                positions,</span>
 199 |     | <span class='unexecuted'>                ticks,</span>
 200 |     | <span class='unexecuted'>                tickMap,</span>
 201 |     | <span class='unexecuted'>                cache.state,</span>
 202 |     | <span class='unexecuted'>                CoverPoolStructs.RemoveParams(</span>
 203 |     | <span class='unexecuted'>                    msg.sender,</span>
 204 |     | <span class='unexecuted'>                    params.to,</span>
 205 |     | <span class='unexecuted'>                    params.burnPercent,</span>
 206 |     | <span class='unexecuted'>                    params.positionId,</span>
 207 |     | <span class='unexecuted'>                    cache.position.lower,</span>
 208 |     | <span class='unexecuted'>                    cache.position.upper,</span>
 209 |     | <span class='unexecuted'>                    params.zeroForOne</span>
 210 |     | <span class='neutral'>                ),</span>
 211 |     | <span class='unexecuted'>                cache.constants</span>
 212 |     | <span class='neutral'>            );</span>
 213 |     | <span class='neutral'>        }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='unexecuted'>        int24 lower = cache.position.lower;</span>
 216 |     | <span class='unexecuted'>        int24 upper = cache.position.upper;</span>
 217 |     | <span class='unexecuted'>        bool positionExists = cache.position.liquidity != 0;</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='unexecuted'>        Collect.burn(</span>
 220 |     | <span class='unexecuted'>            cache,</span>
 221 |     | <span class='unexecuted'>            positions,</span>
 222 |     | <span class='unexecuted'>            CoverPoolStructs.CollectParams(</span>
 223 |     | <span class='unexecuted'>                cache.syncFees,</span>
 224 |     | <span class='unexecuted'>                params.to, //address(0) goes to msg.sender</span>
 225 |     | <span class='unexecuted'>                params.positionId,</span>
 226 |     | <span class='unexecuted'>                cache.position.lower,</span>
 227 |     | <span class='unexecuted'>                params.claim,</span>
 228 |     | <span class='unexecuted'>                cache.position.upper,</span>
 229 |     | <span class='unexecuted'>                params.zeroForOne</span>
 230 |     | <span class='neutral'>            )</span>
 231 |     | <span class='neutral'>        );</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='unexecuted'>        revert SimulateBurn(lower, upper, positionExists);</span>
 234 |     | <span class='neutral'>    }</span>
 235 |     | <span class='neutral'>}</span>
 236 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/libraries/pool/MintCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/structs/CoverPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../Positions.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../utils/Collect.sol&#39;;</span>
   7 |     | <span class='neutral'></span>
   8 | *   | <span class='executed'>library MintCall {</span>
   9 |     | <span class='neutral'>    event Mint(</span>
  10 |     | <span class='neutral'>        address indexed to,</span>
  11 |     | <span class='neutral'>        int24 lower,</span>
  12 |     | <span class='neutral'>        int24 upper,</span>
  13 |     | <span class='neutral'>        bool zeroForOne,</span>
  14 |     | <span class='neutral'>        uint32 positionId,</span>
  15 |     | <span class='neutral'>        uint32 epochLast,</span>
  16 |     | <span class='neutral'>        uint128 amountIn,</span>
  17 |     | <span class='neutral'>        uint128 liquidityMinted,</span>
  18 |     | <span class='neutral'>        uint128 amountInDeltaMaxMinted,</span>
  19 |     | <span class='neutral'>        uint128 amountOutDeltaMaxMinted</span>
  20 |     | <span class='neutral'>    );</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    error SimulateMint(int24 lower, int24 upper, bool positionCreated);</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>    function perform(</span>
  25 |     | <span class='neutral'>        ICoverPool.MintParams memory params,</span>
  26 |     | <span class='neutral'>        CoverPoolStructs.MintCache memory cache,</span>
  27 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
  28 |     | <span class='neutral'>        mapping(int24 =&gt; CoverPoolStructs.Tick) storage ticks,</span>
  29 |     | <span class='neutral'>        mapping(uint256 =&gt; CoverPoolStructs.CoverPosition)</span>
  30 |     | <span class='neutral'>            storage positions</span>
  31 |     | <span class='unexecuted'>    ) internal returns (CoverPoolStructs.MintCache memory) {</span>
  32 |     | <span class='unexecuted'>        if (params.positionId &gt; 0) {</span>
  33 |     | <span class='neutral'>            // load existing position</span>
  34 |     | <span class='unexecuted'>            cache.position = positions[params.positionId];</span>
  35 |     | <span class='unexecuted'>            if (cache.position.owner != msg.sender)</span>
  36 |     | <span class='unexecuted'>                require(false, &#39;PositionNotFound()&#39;);</span>
  37 |     | <span class='neutral'>        }</span>
  38 |     | <span class='neutral'>        // resize position</span>
  39 |     | <span class='unexecuted'>        (params, cache.liquidityMinted) = Positions.resize(</span>
  40 |     | <span class='unexecuted'>            cache.position,</span>
  41 |     | <span class='unexecuted'>            params, </span>
  42 |     | <span class='unexecuted'>            cache.state,</span>
  43 |     | <span class='unexecuted'>            cache.constants</span>
  44 |     | <span class='neutral'>        );</span>
  45 |     | <span class='unexecuted'>        if (params.positionId == 0 ||                       // new position</span>
  46 |     | <span class='unexecuted'>                params.lower != cache.position.lower ||     // lower mismatch</span>
  47 |     | <span class='unexecuted'>                params.upper != cache.position.upper) {     // upper mismatch</span>
  48 |     | <span class='unexecuted'>            CoverPoolStructs.CoverPosition memory newPosition;</span>
  49 |     | <span class='unexecuted'>            newPosition.owner = params.to;</span>
  50 |     | <span class='unexecuted'>            newPosition.lower = params.lower;</span>
  51 |     | <span class='unexecuted'>            newPosition.upper = params.upper;</span>
  52 |     | <span class='neutral'>            // use new position in cache</span>
  53 |     | <span class='unexecuted'>            cache.position = newPosition;</span>
  54 |     | <span class='unexecuted'>            params.positionId = cache.state.positionIdNext;</span>
  55 |     | <span class='unexecuted'>            cache.state.positionIdNext += 1;</span>
  56 |     | <span class='neutral'>        }</span>
  57 |     | <span class='neutral'>        // params.amount must be &gt; 0 here</span>
  58 |     | <span class='unexecuted'>        SafeTransfers.transferIn(params.zeroForOne ? cache.constants.token0 </span>
  59 |     | <span class='unexecuted'>                                                   : cache.constants.token1,</span>
  60 |     | <span class='unexecuted'>                                 params.amount</span>
  61 |     | <span class='neutral'>                                );</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>        (cache.state, cache.position) = Positions.add(</span>
  64 |     | <span class='unexecuted'>            cache.position,</span>
  65 |     | <span class='unexecuted'>            ticks,</span>
  66 |     | <span class='unexecuted'>            tickMap,</span>
  67 |     | <span class='unexecuted'>            cache.state,</span>
  68 |     | <span class='unexecuted'>            CoverPoolStructs.AddParams(</span>
  69 |     | <span class='unexecuted'>                params.to,</span>
  70 |     | <span class='unexecuted'>                uint128(cache.liquidityMinted),</span>
  71 |     | <span class='unexecuted'>                params.amount,</span>
  72 |     | <span class='unexecuted'>                params.positionId,</span>
  73 |     | <span class='unexecuted'>                params.lower,</span>
  74 |     | <span class='unexecuted'>                params.upper,</span>
  75 |     | <span class='unexecuted'>                params.zeroForOne</span>
  76 |     | <span class='neutral'>            ),</span>
  77 |     | <span class='unexecuted'>            cache.constants</span>
  78 |     | <span class='neutral'>        );</span>
  79 |     | <span class='unexecuted'>        Collect.mint(</span>
  80 |     | <span class='unexecuted'>            cache,</span>
  81 |     | <span class='unexecuted'>            CoverPoolStructs.CollectParams(</span>
  82 |     | <span class='unexecuted'>                cache.syncFees,</span>
  83 |     | <span class='unexecuted'>                params.to,</span>
  84 |     | <span class='unexecuted'>                params.positionId,</span>
  85 |     | <span class='unexecuted'>                params.lower,</span>
  86 |     | <span class='unexecuted'>                0, // not needed for mint collect</span>
  87 |     | <span class='unexecuted'>                params.upper,</span>
  88 |     | <span class='unexecuted'>                params.zeroForOne</span>
  89 |     | <span class='neutral'>            )</span>
  90 |     | <span class='neutral'>        );</span>
  91 |     | <span class='unexecuted'>        positions[params.positionId] = cache.position;</span>
  92 |     | <span class='unexecuted'>        return cache;</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    // Echidna funcs</span>
  96 | *   | <span class='executed'>    function getResizedTicks(</span>
  97 |     | <span class='neutral'>        ICoverPool.MintParams memory params,</span>
  98 |     | <span class='neutral'>        CoverPoolStructs.MintCache memory cache,</span>
  99 |     | <span class='neutral'>        CoverPoolStructs.TickMap storage tickMap,</span>
 100 |     | <span class='neutral'>        mapping(int24 =&gt; CoverPoolStructs.Tick) storage ticks,</span>
 101 |     | <span class='neutral'>        mapping(uint256 =&gt; CoverPoolStructs.CoverPosition)</span>
 102 |     | <span class='neutral'>            storage positions</span>
 103 |     | <span class='neutral'>    ) external {</span>
 104 | *   | <span class='executed'>        bool positionCreated = false;</span>
 105 | *   | <span class='executed'>        if (params.positionId &gt; 0) {</span>
 106 |     | <span class='neutral'>            // load existing position</span>
 107 |     | <span class='unexecuted'>            cache.position = positions[params.positionId];</span>
 108 |     | <span class='unexecuted'>            if (cache.position.owner != msg.sender)</span>
 109 |     | <span class='unexecuted'>                require(false, &#39;PositionNotFound()&#39;);</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'>        // assume cache.state is already set</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        // resize position</span>
 114 |     | <span class='unexecuted'>        (params, cache.liquidityMinted) = Positions.resize(</span>
 115 |     | <span class='unexecuted'>            cache.position,</span>
 116 |     | <span class='unexecuted'>            params, </span>
 117 |     | <span class='unexecuted'>            cache.state,</span>
 118 |     | <span class='unexecuted'>            cache.constants</span>
 119 |     | <span class='neutral'>        );</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>        if (params.positionId == 0 ||                       // new position</span>
 122 |     | <span class='unexecuted'>                params.lower != cache.position.lower ||     // lower mismatch</span>
 123 |     | <span class='unexecuted'>                params.upper != cache.position.upper) {     // upper mismatch</span>
 124 |     | <span class='unexecuted'>            CoverPoolStructs.CoverPosition memory newPosition;</span>
 125 |     | <span class='unexecuted'>            newPosition.owner = params.to;</span>
 126 |     | <span class='unexecuted'>            newPosition.lower = params.lower;</span>
 127 |     | <span class='unexecuted'>            newPosition.upper = params.upper;</span>
 128 |     | <span class='neutral'>            // use new position in cache</span>
 129 |     | <span class='unexecuted'>            cache.position = newPosition;</span>
 130 |     | <span class='unexecuted'>            params.positionId = cache.state.positionIdNext;</span>
 131 |     | <span class='unexecuted'>            cache.state.positionIdNext += 1;</span>
 132 |     | <span class='neutral'>        }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>        // transfer in token amount</span>
 135 |     | <span class='unexecuted'>        SafeTransfers.transferIn(params.zeroForOne ? cache.constants.token0 </span>
 136 |     | <span class='unexecuted'>                                                   : cache.constants.token1,</span>
 137 |     | <span class='unexecuted'>                                 params.amount</span>
 138 |     | <span class='neutral'>                                );</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>        (cache.state, cache.position) = Positions.add(</span>
 141 |     | <span class='unexecuted'>            cache.position,</span>
 142 |     | <span class='unexecuted'>            ticks,</span>
 143 |     | <span class='unexecuted'>            tickMap,</span>
 144 |     | <span class='unexecuted'>            cache.state,</span>
 145 |     | <span class='unexecuted'>            CoverPoolStructs.AddParams(</span>
 146 |     | <span class='unexecuted'>                params.to,</span>
 147 |     | <span class='unexecuted'>                uint128(cache.liquidityMinted),</span>
 148 |     | <span class='unexecuted'>                params.amount,</span>
 149 |     | <span class='unexecuted'>                params.positionId,</span>
 150 |     | <span class='unexecuted'>                params.lower,</span>
 151 |     | <span class='unexecuted'>                params.upper,</span>
 152 |     | <span class='unexecuted'>                params.zeroForOne</span>
 153 |     | <span class='neutral'>            ),</span>
 154 |     | <span class='unexecuted'>            cache.constants</span>
 155 |     | <span class='neutral'>        );</span>
 156 |     | <span class='unexecuted'>        positionCreated = true;</span>
 157 |     | <span class='unexecuted'>        Collect.mint(</span>
 158 |     | <span class='unexecuted'>            cache,</span>
 159 |     | <span class='unexecuted'>            CoverPoolStructs.CollectParams(</span>
 160 |     | <span class='unexecuted'>                cache.syncFees,</span>
 161 |     | <span class='unexecuted'>                params.to,</span>
 162 |     | <span class='unexecuted'>                params.positionId,</span>
 163 |     | <span class='unexecuted'>                params.lower,</span>
 164 |     | <span class='unexecuted'>                0, // not needed for mint collect</span>
 165 |     | <span class='unexecuted'>                params.upper,</span>
 166 |     | <span class='unexecuted'>                params.zeroForOne</span>
 167 |     | <span class='neutral'>            )</span>
 168 |     | <span class='neutral'>        );</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>        revert SimulateMint(params.lower, params.upper, positionCreated);</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'>}</span>
 173 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/libraries/pool/QuoteCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/structs/CoverPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../interfaces/ICoverPool.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../Ticks.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>library QuoteCall {</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    function perform(</span>
 11 |     | <span class='neutral'>        ICoverPool.QuoteParams memory params,</span>
 12 |     | <span class='neutral'>        CoverPoolStructs.SwapCache memory cache</span>
 13 |     | <span class='neutral'>    ) internal view returns (</span>
 14 |     | <span class='unexecuted'>        int256,</span>
 15 |     | <span class='unexecuted'>        int256,</span>
 16 |     | <span class='unexecuted'>        uint256</span>
 17 |     | <span class='neutral'>    ) {</span>
 18 |     | <span class='unexecuted'>        {</span>
 19 |     | <span class='unexecuted'>            CoverPoolStructs.PoolState memory pool = params.zeroForOne ? cache.pool1 : cache.pool0;</span>
 20 |     | <span class='unexecuted'>            cache = CoverPoolStructs.SwapCache({</span>
 21 |     | <span class='unexecuted'>                state: cache.state,</span>
 22 |     | <span class='unexecuted'>                syncFees: cache.syncFees,</span>
 23 |     | <span class='unexecuted'>                constants: cache.constants,</span>
 24 |     | <span class='unexecuted'>                pool0: cache.pool0,</span>
 25 |     | <span class='unexecuted'>                pool1: cache.pool1,</span>
 26 |     | <span class='unexecuted'>                price: pool.price,</span>
 27 |     | <span class='unexecuted'>                liquidity: pool.liquidity,</span>
 28 |     | <span class='unexecuted'>                amountLeft: params.amount,</span>
 29 |     | <span class='unexecuted'>                auctionDepth: block.timestamp - cache.constants.genesisTime - cache.state.auctionStart,</span>
 30 |     | <span class='unexecuted'>                auctionBoost: 0,</span>
 31 |     | <span class='unexecuted'>                input: 0,</span>
 32 |     | <span class='unexecuted'>                output: 0,</span>
 33 |     | <span class='unexecuted'>                amountBoosted: 0,</span>
 34 |     | <span class='unexecuted'>                amountInDelta: 0,</span>
 35 |     | <span class='unexecuted'>                amount0Delta: 0,</span>
 36 |     | <span class='unexecuted'>                amount1Delta: 0,</span>
 37 |     | <span class='unexecuted'>                exactIn: true</span>
 38 |     | <span class='neutral'>            });</span>
 39 |     | <span class='neutral'>        }</span>
 40 |     | <span class='neutral'>        // call quote</span>
 41 |     | <span class='unexecuted'>        cache = Ticks.quote(</span>
 42 |     | <span class='unexecuted'>            params.zeroForOne,</span>
 43 |     | <span class='unexecuted'>            params.priceLimit,</span>
 44 |     | <span class='unexecuted'>            cache.state,</span>
 45 |     | <span class='unexecuted'>            cache,</span>
 46 |     | <span class='unexecuted'>            cache.constants</span>
 47 |     | <span class='neutral'>        );</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>        // calculate deltas</span>
 50 |     | <span class='unexecuted'>        cache = calculateDeltas(params, cache);</span>
 51 |     | <span class='neutral'>        </span>
 52 |     | <span class='unexecuted'>        return (</span>
 53 |     | <span class='unexecuted'>            params.zeroForOne ? -cache.amount0Delta : -cache.amount1Delta,</span>
 54 |     | <span class='unexecuted'>            params.zeroForOne ? cache.amount1Delta : cache.amount0Delta,</span>
 55 |     | <span class='unexecuted'>            cache.price</span>
 56 |     | <span class='neutral'>        );</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>    function calculateDeltas(</span>
 60 |     | <span class='neutral'>        ICoverPool.QuoteParams memory params,</span>
 61 |     | <span class='neutral'>        CoverPoolStructs.SwapCache memory cache</span>
 62 |     | <span class='neutral'>    ) internal pure returns (</span>
 63 |     | <span class='unexecuted'>        CoverPoolStructs.SwapCache memory</span>
 64 |     | <span class='neutral'>    ) {</span>
 65 |     | <span class='neutral'>        // calculate amount deltas</span>
 66 |     | <span class='unexecuted'>        cache.amount0Delta = params.zeroForOne ? -int256(cache.input) </span>
 67 |     | <span class='unexecuted'>                                               : int256(cache.output);</span>
 68 |     | <span class='unexecuted'>        cache.amount1Delta = params.zeroForOne ? int256(cache.output) </span>
 69 |     | <span class='unexecuted'>                                               : -int256(cache.input);</span>
 70 |     | <span class='neutral'>        </span>
 71 |     | <span class='neutral'>        // factor in sync fees</span>
 72 |     | <span class='unexecuted'>        cache.amount0Delta += int128(cache.syncFees.token0);</span>
 73 |     | <span class='unexecuted'>        cache.amount1Delta += int128(cache.syncFees.token1);</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='unexecuted'>        return cache;</span>
 76 |     | <span class='neutral'>    }</span>
 77 |     | <span class='neutral'>}</span>
 78 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/libraries/pool/SwapCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/structs/CoverPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/IERC20Minimal.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/callbacks/ICoverPoolSwapCallback.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../Epochs.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../Positions.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../utils/Collect.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../utils/SafeCast.sol&#39;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='unexecuted'>library SwapCall {</span>
  13 |     | <span class='neutral'>    using SafeCast for int256;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    event SwapPool0(</span>
  16 |     | <span class='neutral'>        address indexed recipient,</span>
  17 |     | <span class='neutral'>        uint128 amountIn,</span>
  18 |     | <span class='neutral'>        uint128 amountOut,</span>
  19 |     | <span class='neutral'>        uint160 priceLimit,</span>
  20 |     | <span class='neutral'>        uint160 newPrice</span>
  21 |     | <span class='neutral'>    );</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    event SwapPool1(</span>
  24 |     | <span class='neutral'>        address indexed recipient,</span>
  25 |     | <span class='neutral'>        uint128 amountIn,</span>
  26 |     | <span class='neutral'>        uint128 amountOut,</span>
  27 |     | <span class='neutral'>        uint160 priceLimit,</span>
  28 |     | <span class='neutral'>        uint160 newPrice</span>
  29 |     | <span class='neutral'>    );</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>    function perform(</span>
  32 |     | <span class='neutral'>        ICoverPool.SwapParams memory params,</span>
  33 |     | <span class='neutral'>        CoverPoolStructs.SwapCache memory cache,</span>
  34 |     | <span class='neutral'>        CoverPoolStructs.GlobalState storage globalState,</span>
  35 |     | <span class='neutral'>        CoverPoolStructs.PoolState storage pool0,</span>
  36 |     | <span class='neutral'>        CoverPoolStructs.PoolState storage pool1</span>
  37 |     | <span class='neutral'>    ) internal returns (</span>
  38 |     | <span class='unexecuted'>        int256,</span>
  39 |     | <span class='unexecuted'>        int256</span>
  40 |     | <span class='neutral'>    ) {</span>
  41 |     | <span class='unexecuted'>        {</span>
  42 |     | <span class='unexecuted'>            CoverPoolStructs.PoolState memory pool = params.zeroForOne ? cache.pool1 : cache.pool0;</span>
  43 |     | <span class='unexecuted'>            cache = CoverPoolStructs.SwapCache({</span>
  44 |     | <span class='unexecuted'>                state: cache.state,</span>
  45 |     | <span class='unexecuted'>                syncFees: cache.syncFees,</span>
  46 |     | <span class='unexecuted'>                constants: cache.constants,</span>
  47 |     | <span class='unexecuted'>                pool0: cache.pool0,</span>
  48 |     | <span class='unexecuted'>                pool1: cache.pool1,</span>
  49 |     | <span class='unexecuted'>                price: pool.price,</span>
  50 |     | <span class='unexecuted'>                liquidity: pool.liquidity,</span>
  51 |     | <span class='unexecuted'>                amountLeft: params.amount,</span>
  52 |     | <span class='unexecuted'>                auctionDepth: block.timestamp - cache.constants.genesisTime - cache.state.auctionStart,</span>
  53 |     | <span class='unexecuted'>                auctionBoost: 0,</span>
  54 |     | <span class='unexecuted'>                input: 0,</span>
  55 |     | <span class='unexecuted'>                output: 0,</span>
  56 |     | <span class='unexecuted'>                amountBoosted: 0,</span>
  57 |     | <span class='unexecuted'>                amountInDelta: 0,</span>
  58 |     | <span class='unexecuted'>                amount0Delta: 0,</span>
  59 |     | <span class='unexecuted'>                amount1Delta: 0,</span>
  60 |     | <span class='unexecuted'>                exactIn: true</span>
  61 |     | <span class='neutral'>            });</span>
  62 |     | <span class='neutral'>        }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>        // call quote</span>
  65 |     | <span class='unexecuted'>        cache = Ticks.quote(params.zeroForOne, params.priceLimit, cache.state, cache, cache.constants);</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>        // save state to storage before callback</span>
  68 |     | <span class='unexecuted'>        save(params, cache, globalState, pool0, pool1);</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>        // calculate amount deltas</span>
  71 |     | <span class='unexecuted'>        cache = calculateDeltas(params, cache);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        EchidnaAssertions.assertPoolBalanceExceeded(</span>
  74 |     | <span class='unexecuted'>            (params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0)),</span>
  75 |     | <span class='unexecuted'>            cache.output</span>
  76 |     | <span class='neutral'>        );</span>
  77 |     | <span class='neutral'>        // transfer swap output</span>
  78 |     | <span class='unexecuted'>        SafeTransfers.transferOut(</span>
  79 |     | <span class='unexecuted'>            params.to,</span>
  80 |     | <span class='unexecuted'>            params.zeroForOne ? cache.constants.token1</span>
  81 |     | <span class='unexecuted'>                              : cache.constants.token0,</span>
  82 |     | <span class='unexecuted'>            params.zeroForOne ? cache.amount1Delta.toUint256()</span>
  83 |     | <span class='unexecuted'>                              : cache.amount0Delta.toUint256()</span>
  84 |     | <span class='neutral'>        );</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>        // check balance and execute callback</span>
  87 |     | <span class='unexecuted'>        uint256 balanceStart = balance(params, cache);</span>
  88 |     | <span class='unexecuted'>        ICoverPoolSwapCallback(msg.sender).coverPoolSwapCallback(</span>
  89 |     | <span class='unexecuted'>            cache.amount0Delta,</span>
  90 |     | <span class='unexecuted'>            cache.amount1Delta,</span>
  91 |     | <span class='unexecuted'>            params.callbackData</span>
  92 |     | <span class='neutral'>        );</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>        // check balance requirements after callback</span>
  95 |     | <span class='unexecuted'>        if (balance(params, cache) &lt; balanceStart + cache.input)</span>
  96 |     | <span class='unexecuted'>            require(false, &#39;SwapInputAmountTooLow()&#39;);</span>
  97 |     | <span class='neutral'>    </span>
  98 |     | <span class='unexecuted'>        if (params.zeroForOne) {</span>
  99 |     | <span class='neutral'>            // transfer out if sync fees &gt; swap input</span>
 100 |     | <span class='unexecuted'>            if (cache.amount0Delta &gt; 0) {</span>
 101 |     | <span class='unexecuted'>                SafeTransfers.transferOut(params.to, cache.constants.token0, cache.amount0Delta.toUint256());</span>
 102 |     | <span class='neutral'>            }</span>
 103 |     | <span class='unexecuted'>            emit SwapPool1(params.to, uint128(cache.input), uint128(cache.output), uint160(cache.price), params.priceLimit);</span>
 104 |     | <span class='neutral'>        } else {</span>
 105 |     | <span class='unexecuted'>            if (cache.amount1Delta &gt; 0) {</span>
 106 |     | <span class='unexecuted'>                SafeTransfers.transferOut(params.to, cache.constants.token1, cache.amount1Delta.toUint256());</span>
 107 |     | <span class='neutral'>            }</span>
 108 |     | <span class='unexecuted'>            emit SwapPool0(params.to, uint128(cache.input), uint128(cache.output), uint160(cache.price), params.priceLimit);</span>
 109 |     | <span class='neutral'>        }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>        return (</span>
 112 |     | <span class='unexecuted'>            cache.amount0Delta,</span>
 113 |     | <span class='unexecuted'>            cache.amount1Delta</span>
 114 |     | <span class='neutral'>        );</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>    function balance(</span>
 118 |     | <span class='neutral'>        address token</span>
 119 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
 120 |     | <span class='unexecuted'>        (</span>
 121 |     | <span class='unexecuted'>            bool success,</span>
 122 |     | <span class='unexecuted'>            bytes memory data</span>
 123 |     | <span class='unexecuted'>        ) = token.staticcall(</span>
 124 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
 125 |     | <span class='unexecuted'>                                        IERC20Minimal.balanceOf.selector,</span>
 126 |     | <span class='unexecuted'>                                        address(this)</span>
 127 |     | <span class='neutral'>                                    )</span>
 128 |     | <span class='neutral'>                                );</span>
 129 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 130 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>    function save(</span>
 134 |     | <span class='neutral'>        ICoverPool.SwapParams memory params,</span>
 135 |     | <span class='neutral'>        CoverPoolStructs.SwapCache memory cache,</span>
 136 |     | <span class='neutral'>        CoverPoolStructs.GlobalState storage globalState,</span>
 137 |     | <span class='neutral'>        CoverPoolStructs.PoolState storage pool0,</span>
 138 |     | <span class='neutral'>        CoverPoolStructs.PoolState storage pool1</span>
 139 |     | <span class='neutral'>    ) internal {</span>
 140 |     | <span class='neutral'>        // save pool changes to cache</span>
 141 |     | <span class='unexecuted'>        if (params.zeroForOne) {</span>
 142 |     | <span class='unexecuted'>            cache.pool1.price = uint160(cache.price);</span>
 143 |     | <span class='unexecuted'>            cache.pool1.amountInDelta += uint128(cache.amountInDelta);</span>
 144 |     | <span class='neutral'>        } else {</span>
 145 |     | <span class='unexecuted'>            cache.pool0.price = uint160(cache.price);</span>
 146 |     | <span class='unexecuted'>            cache.pool0.amountInDelta += uint128(cache.amountInDelta);</span>
 147 |     | <span class='neutral'>        }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>        // save global state changes to storage</span>
 150 |     | <span class='unexecuted'>        globalState.latestPrice = cache.state.latestPrice;</span>
 151 |     | <span class='unexecuted'>        globalState.liquidityGlobal = cache.state.liquidityGlobal;</span>
 152 |     | <span class='unexecuted'>        globalState.lastTime = cache.state.lastTime;</span>
 153 |     | <span class='unexecuted'>        globalState.auctionStart = cache.state.auctionStart;</span>
 154 |     | <span class='unexecuted'>        globalState.accumEpoch = cache.state.accumEpoch;</span>
 155 |     | <span class='unexecuted'>        globalState.latestTick = cache.state.latestTick;</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>        // save pool0 changes to storage</span>
 158 |     | <span class='unexecuted'>        pool0.price = cache.pool0.price;</span>
 159 |     | <span class='unexecuted'>        pool0.liquidity = cache.pool0.liquidity;</span>
 160 |     | <span class='unexecuted'>        pool0.amountInDelta = cache.pool0.amountInDelta;</span>
 161 |     | <span class='unexecuted'>        pool0.amountInDeltaMaxClaimed = cache.pool0.amountInDeltaMaxClaimed;</span>
 162 |     | <span class='unexecuted'>        pool0.amountOutDeltaMaxClaimed = cache.pool0.amountOutDeltaMaxClaimed;</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>        // save pool1 changes to storage</span>
 165 |     | <span class='unexecuted'>        pool1.price = cache.pool1.price;</span>
 166 |     | <span class='unexecuted'>        pool1.liquidity = cache.pool1.liquidity;</span>
 167 |     | <span class='unexecuted'>        pool1.amountInDelta = cache.pool1.amountInDelta;</span>
 168 |     | <span class='unexecuted'>        pool1.amountInDeltaMaxClaimed = cache.pool1.amountInDeltaMaxClaimed;</span>
 169 |     | <span class='unexecuted'>        pool1.amountOutDeltaMaxClaimed = cache.pool1.amountOutDeltaMaxClaimed;</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='unexecuted'>    function balance(</span>
 173 |     | <span class='neutral'>        ICoverPool.SwapParams memory params,</span>
 174 |     | <span class='neutral'>        CoverPoolStructs.SwapCache memory cache</span>
 175 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
 176 |     | <span class='unexecuted'>        (</span>
 177 |     | <span class='unexecuted'>            bool success,</span>
 178 |     | <span class='unexecuted'>            bytes memory data</span>
 179 |     | <span class='unexecuted'>        ) = (params.zeroForOne ? cache.constants.token0</span>
 180 |     | <span class='unexecuted'>                               : cache.constants.token1)</span>
 181 |     | <span class='neutral'>                               .staticcall(</span>
 182 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
 183 |     | <span class='unexecuted'>                                        IERC20Minimal.balanceOf.selector,</span>
 184 |     | <span class='unexecuted'>                                        address(this)</span>
 185 |     | <span class='neutral'>                                    )</span>
 186 |     | <span class='neutral'>                                );</span>
 187 |     | <span class='unexecuted'>        if(!success || data.length &lt; 32) require(false, &#39;InvalidERC20ReturnData()&#39;);</span>
 188 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='unexecuted'>    function calculateDeltas(</span>
 192 |     | <span class='neutral'>        ICoverPool.SwapParams memory params,</span>
 193 |     | <span class='neutral'>        CoverPoolStructs.SwapCache memory cache</span>
 194 |     | <span class='neutral'>    ) internal pure returns (</span>
 195 |     | <span class='unexecuted'>        CoverPoolStructs.SwapCache memory</span>
 196 |     | <span class='neutral'>    ) {</span>
 197 |     | <span class='neutral'>        // calculate amount deltas</span>
 198 |     | <span class='unexecuted'>        cache.amount0Delta = params.zeroForOne ? -int256(cache.input) </span>
 199 |     | <span class='unexecuted'>                                               : int256(cache.output);</span>
 200 |     | <span class='unexecuted'>        cache.amount1Delta = params.zeroForOne ? int256(cache.output) </span>
 201 |     | <span class='unexecuted'>                                               : -int256(cache.input);</span>
 202 |     | <span class='neutral'>        </span>
 203 |     | <span class='neutral'>        // factor in sync fees</span>
 204 |     | <span class='unexecuted'>        cache.amount0Delta += int128(cache.syncFees.token0);</span>
 205 |     | <span class='unexecuted'>        cache.amount1Delta += int128(cache.syncFees.token1);</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='unexecuted'>        return cache;</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'>}</span>
 210 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/libraries/sources/UniswapV3Source.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/external/uniswap/v3/IUniswapV3Factory.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/external/uniswap/v3/IUniswapV3Pool.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/structs/CoverPoolStructs.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../interfaces/modules/sources/ITwapSource.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../math/ConstantProduct.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 | *   | <span class='executed'>contract UniswapV3Source is ITwapSource {</span>
  11 |     | <span class='neutral'>    error WaitUntilBelowMaxTick();</span>
  12 |     | <span class='neutral'>    error WaitUntilAboveMinTick();</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>    address public immutable uniV3Factory;</span>
  15 | *   | <span class='executed'>    uint32 public constant oneSecond = 1000;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>    constructor(</span>
  18 |     | <span class='neutral'>        address _uniV3Factory</span>
  19 |     | <span class='neutral'>    ) {</span>
  20 |     | <span class='unexecuted'>        uniV3Factory = _uniV3Factory;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 | *   | <span class='executed'>    function initialize(</span>
  24 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
  25 |     | <span class='neutral'>    ) external returns (</span>
  26 | *   | <span class='executed'>        uint8 initializable,</span>
  27 | *   | <span class='executed'>        int24 startingTick</span>
  28 |     | <span class='neutral'>    )</span>
  29 | *   | <span class='executed'>    {</span>
  30 |     | <span class='neutral'>        // get the number of blocks covered by the twapLength</span>
  31 | *   | <span class='executed'>        uint32 blockCount = uint32(constants.twapLength) * oneSecond / constants.blockTime;</span>
  32 | *   | <span class='executed'>        (</span>
  33 | *   | <span class='executed'>            bool observationsCountEnough,</span>
  34 | *   | <span class='executed'>            bool observationsLengthEnough</span>
  35 | *   | <span class='executed'>        ) = _isPoolObservationsEnough(</span>
  36 | *   | <span class='executed'>                constants.inputPool,</span>
  37 | *   | <span class='executed'>                blockCount</span>
  38 |     | <span class='neutral'>        );</span>
  39 | *   | <span class='executed'>        if (!observationsLengthEnough) {</span>
  40 |     | <span class='unexecuted'>            _increaseV3Observations(constants.inputPool, blockCount);</span>
  41 |     | <span class='unexecuted'>            return (0, 0);</span>
  42 | *   | <span class='executed'>        } else if (!observationsCountEnough) {</span>
  43 |     | <span class='unexecuted'>            return (0, 0);</span>
  44 |     | <span class='neutral'>        }</span>
  45 |     | <span class='neutral'>        // ready to initialize if we get here</span>
  46 | *   | <span class='executed'>        initializable = 1;</span>
  47 | *   | <span class='executed'>        int24[4] memory averageTicks = _calculateAverageTicks(constants);</span>
  48 |     | <span class='neutral'>        // take the average of the 4 samples as a starting tick</span>
  49 | *   | <span class='executed'>        startingTick = (averageTicks[0] + averageTicks[1] + averageTicks[2] + averageTicks[3]) / 4;</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>    function factory() external view returns (address) {</span>
  53 |     | <span class='unexecuted'>        return uniV3Factory;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>    function feeTierTickSpacing(</span>
  57 |     | <span class='neutral'>        uint16 feeTier</span>
  58 |     | <span class='neutral'>    ) external view returns (</span>
  59 |     | <span class='unexecuted'>        int24</span>
  60 |     | <span class='neutral'>    )</span>
  61 |     | <span class='neutral'>    {</span>
  62 |     | <span class='unexecuted'>        return IUniswapV3Factory(uniV3Factory).feeTierTickSpacing(feeTier);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function getPool(</span>
  66 |     | <span class='neutral'>        address token0,</span>
  67 |     | <span class='neutral'>        address token1,</span>
  68 |     | <span class='neutral'>        uint16 feeTier</span>
  69 |     | <span class='neutral'>    ) external view returns(</span>
  70 |     | <span class='unexecuted'>        address pool</span>
  71 |     | <span class='neutral'>    ) {</span>
  72 |     | <span class='unexecuted'>        return IUniswapV3Factory(uniV3Factory).getPool(token0, token1, feeTier);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 | *   | <span class='executed'>    function calculateAverageTick(</span>
  76 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants,</span>
  77 |     | <span class='neutral'>        int24 latestTick</span>
  78 |     | <span class='neutral'>    ) external view returns (</span>
  79 | *   | <span class='executed'>        int24 averageTick</span>
  80 |     | <span class='neutral'>    )</span>
  81 | *   | <span class='executed'>    {</span>
  82 | *   | <span class='executed'>        int24[4] memory averageTicks = _calculateAverageTicks(constants);</span>
  83 | *   | <span class='executed'>        int24 minTickVariance = ConstantProduct.maxTick(constants.tickSpread) * 2;</span>
  84 | *   | <span class='executed'>        for (uint i; i &lt; 4; i++) {</span>
  85 | *   | <span class='executed'>            int24 absTickVariance = latestTick - averageTicks[i] &gt;= 0 ? latestTick - averageTicks[i]</span>
  86 | *   | <span class='executed'>                                                                      : averageTicks[i] - latestTick;</span>
  87 | *   | <span class='executed'>            if (absTickVariance &lt;= minTickVariance) {</span>
  88 |     | <span class='neutral'>                /// @dev - averageTick has the least possible variance from latestTick</span>
  89 | *   | <span class='executed'>                minTickVariance = absTickVariance;</span>
  90 | *   | <span class='executed'>                averageTick = averageTicks[i];</span>
  91 |     | <span class='neutral'>            }</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 | *   | <span class='executed'>    function _calculateAverageTicks(</span>
  96 |     | <span class='neutral'>        PoolsharkStructs.CoverImmutables memory constants</span>
  97 |     | <span class='neutral'>    ) internal view returns (</span>
  98 | *   | <span class='executed'>        int24[4] memory averageTicks</span>
  99 |     | <span class='neutral'>    )</span>
 100 | *   | <span class='executed'>    {</span>
 101 | *   | <span class='executed'>        uint32[] memory secondsAgos = new uint32[](4);</span>
 102 |     | <span class='neutral'>        /// @dev - take 4 samples</span>
 103 |     | <span class='neutral'>        /// @dev - twapLength must be &gt;= 5 * blockTime</span>
 104 | *   | <span class='executed'>        uint32 timeDelta = (constants.blockTime / oneSecond == 0) ? 2 </span>
 105 | *   | <span class='executed'>                                                                : constants.blockTime * 2 / oneSecond;</span>
 106 | *   | <span class='executed'>        secondsAgos[0] = 0;</span>
 107 | *   | <span class='executed'>        secondsAgos[1] = timeDelta;</span>
 108 | *   | <span class='executed'>        secondsAgos[2] = constants.twapLength - timeDelta;</span>
 109 | *   | <span class='executed'>        secondsAgos[3] = constants.twapLength;</span>
 110 | *   | <span class='executed'>        (int56[] memory tickCumulatives, ) = IUniswapV3Pool(constants.inputPool).observe(secondsAgos);</span>
 111 |     | <span class='neutral'>        </span>
 112 |     | <span class='neutral'>        // take the smallest absolute value of 4 samples</span>
 113 | *   | <span class='executed'>        averageTicks[0] = int24(((tickCumulatives[0] - tickCumulatives[2]) / (int32(secondsAgos[2] - secondsAgos[0]))));</span>
 114 | *   | <span class='executed'>        averageTicks[1] = int24(((tickCumulatives[0] - tickCumulatives[3]) / (int32(secondsAgos[3] - secondsAgos[0]))));</span>
 115 | *   | <span class='executed'>        averageTicks[2] = int24(((tickCumulatives[1] - tickCumulatives[2]) / (int32(secondsAgos[2] - secondsAgos[1]))));</span>
 116 | *   | <span class='executed'>        averageTicks[3] = int24(((tickCumulatives[1] - tickCumulatives[3]) / (int32(secondsAgos[3] - secondsAgos[1]))));</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>        // make sure all samples fit within min/max bounds</span>
 119 | *   | <span class='executed'>        int24 minAverageTick = ConstantProduct.minTick(constants.tickSpread) + constants.tickSpread;</span>
 120 | *   | <span class='executed'>        int24 maxAverageTick = ConstantProduct.maxTick(constants.tickSpread) - constants.tickSpread;</span>
 121 | *   | <span class='executed'>        for (uint i; i &lt; 4; i++) {</span>
 122 | *   | <span class='executed'>            if (averageTicks[i] &lt; minAverageTick)</span>
 123 |     | <span class='unexecuted'>                averageTicks[i] = minAverageTick;</span>
 124 | *   | <span class='executed'>            if (averageTicks[i] &gt; maxAverageTick)</span>
 125 |     | <span class='unexecuted'>                averageTicks[i] = maxAverageTick;</span>
 126 |     | <span class='neutral'>        }</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 | *   | <span class='executed'>    function _isPoolObservationsEnough(</span>
 130 |     | <span class='neutral'>        address pool,</span>
 131 |     | <span class='neutral'>        uint32 blockCount</span>
 132 |     | <span class='neutral'>    ) internal view returns (</span>
 133 | *   | <span class='executed'>        bool,</span>
 134 | *   | <span class='executed'>        bool</span>
 135 |     | <span class='neutral'>    )</span>
 136 |     | <span class='neutral'>    {</span>
 137 |     | <span class='neutral'></span>
 138 | *   | <span class='executed'>        (, , , uint16 observationsCount, uint16 observationsLength, , ) = IUniswapV3Pool(pool).slot0();</span>
 139 | *   | <span class='executed'>        return (observationsCount &gt;= blockCount, observationsLength &gt;= blockCount);</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='unexecuted'>    function _increaseV3Observations(address pool, uint32 blockCount) internal {</span>
 143 |     | <span class='unexecuted'>        IUniswapV3Pool(pool).increaseObservationCardinalityNext(uint16(blockCount));</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'>}</span>
 146 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/libraries/utils/Collect.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/structs/CoverPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/IERC20Minimal.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../Epochs.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../Positions.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../utils/SafeTransfers.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>library Collect {</span>
  11 |     | <span class='unexecuted'>    function mint(</span>
  12 |     | <span class='neutral'>        CoverPoolStructs.MintCache memory cache,</span>
  13 |     | <span class='neutral'>        CoverPoolStructs.CollectParams memory params</span>
  14 |     | <span class='unexecuted'>    ) internal {</span>
  15 |     | <span class='unexecuted'>        if (params.syncFees.token0 == 0 &amp;&amp; params.syncFees.token1 == 0) return;</span>
  16 |     | <span class='neutral'>        // store amounts for transferOut</span>
  17 |     | <span class='unexecuted'>        uint128 amountIn;</span>
  18 |     | <span class='unexecuted'>        uint128 amountOut;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>        // factor in sync fees</span>
  21 |     | <span class='unexecuted'>        if (params.zeroForOne) {</span>
  22 |     | <span class='unexecuted'>            amountIn  += params.syncFees.token1;</span>
  23 |     | <span class='unexecuted'>            amountOut += params.syncFees.token0;</span>
  24 |     | <span class='neutral'>        } else {</span>
  25 |     | <span class='unexecuted'>            amountIn  += params.syncFees.token0;</span>
  26 |     | <span class='unexecuted'>            amountOut += params.syncFees.token1;</span>
  27 |     | <span class='neutral'>        }</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>        /// zero out balances and transfer out</span>
  30 |     | <span class='neutral'>        //TODO: subtract out sync fees from transferred in amounts</span>
  31 |     | <span class='unexecuted'>        if (amountIn &gt; 0) {</span>
  32 |     | <span class='unexecuted'>            EchidnaAssertions.assertPoolBalanceExceeded(</span>
  33 |     | <span class='unexecuted'>                (params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0)),</span>
  34 |     | <span class='unexecuted'>                amountIn</span>
  35 |     | <span class='neutral'>            );</span>
  36 |     | <span class='unexecuted'>            SafeTransfers.transferOut(params.to, params.zeroForOne ? cache.constants.token1 : cache.constants.token0, amountIn);</span>
  37 |     | <span class='neutral'>        } </span>
  38 |     | <span class='unexecuted'>        if (amountOut &gt; 0) {</span>
  39 |     | <span class='unexecuted'>            EchidnaAssertions.assertPoolBalanceExceeded(</span>
  40 |     | <span class='unexecuted'>                (params.zeroForOne ? balance(cache.constants.token0) : balance(cache.constants.token1)),</span>
  41 |     | <span class='unexecuted'>                amountOut</span>
  42 |     | <span class='neutral'>            );</span>
  43 |     | <span class='unexecuted'>            SafeTransfers.transferOut(params.to, params.zeroForOne ? cache.constants.token0 : cache.constants.token1, amountOut);</span>
  44 |     | <span class='neutral'>        }</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>    function balance(</span>
  48 |     | <span class='neutral'>        address token</span>
  49 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
  50 |     | <span class='unexecuted'>        (</span>
  51 |     | <span class='unexecuted'>            bool success,</span>
  52 |     | <span class='unexecuted'>            bytes memory data</span>
  53 |     | <span class='unexecuted'>        ) = token.staticcall(</span>
  54 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
  55 |     | <span class='unexecuted'>                                        IERC20Minimal.balanceOf.selector,</span>
  56 |     | <span class='unexecuted'>                                        address(this)</span>
  57 |     | <span class='neutral'>                                    )</span>
  58 |     | <span class='neutral'>                                );</span>
  59 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
  60 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>    function burn(</span>
  64 |     | <span class='neutral'>        CoverPoolStructs.BurnCache memory cache,</span>
  65 |     | <span class='neutral'>        mapping(uint256 =&gt; CoverPoolStructs.CoverPosition)</span>
  66 |     | <span class='neutral'>            storage positions,</span>
  67 |     | <span class='neutral'>        CoverPoolStructs.CollectParams memory params</span>
  68 |     | <span class='unexecuted'>    ) internal {</span>
  69 |     | <span class='unexecuted'>        params.zeroForOne ? params.upper = params.claim : params.lower = params.claim;</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>        // store amounts for transferOut</span>
  72 |     | <span class='unexecuted'>        uint128 amountIn  = positions[params.positionId].amountIn;</span>
  73 |     | <span class='unexecuted'>        uint128 amountOut = positions[params.positionId].amountOut;</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>        // factor in sync fees</span>
  76 |     | <span class='unexecuted'>        if (params.zeroForOne) {</span>
  77 |     | <span class='unexecuted'>            amountIn  += params.syncFees.token1;</span>
  78 |     | <span class='unexecuted'>            amountOut += params.syncFees.token0;</span>
  79 |     | <span class='neutral'>        } else {</span>
  80 |     | <span class='unexecuted'>            amountIn  += params.syncFees.token0;</span>
  81 |     | <span class='unexecuted'>            amountOut += params.syncFees.token1;</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>        /// zero out balances and transfer out</span>
  85 |     | <span class='unexecuted'>        if (amountIn &gt; 0) {</span>
  86 |     | <span class='unexecuted'>            EchidnaAssertions.assertPoolBalanceExceeded(</span>
  87 |     | <span class='unexecuted'>                (params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0)),</span>
  88 |     | <span class='unexecuted'>                amountIn</span>
  89 |     | <span class='neutral'>            );</span>
  90 |     | <span class='unexecuted'>            positions[params.positionId].amountIn = 0;</span>
  91 |     | <span class='unexecuted'>            SafeTransfers.transferOut(params.to, params.zeroForOne ? cache.constants.token1 : cache.constants.token0, amountIn);</span>
  92 |     | <span class='neutral'>        } </span>
  93 |     | <span class='unexecuted'>        if (amountOut &gt; 0) {</span>
  94 |     | <span class='unexecuted'>            EchidnaAssertions.assertPoolBalanceExceeded(</span>
  95 |     | <span class='unexecuted'>                (params.zeroForOne ? balance(cache.constants.token0) : balance(cache.constants.token1)),</span>
  96 |     | <span class='unexecuted'>                amountOut</span>
  97 |     | <span class='neutral'>            );</span>
  98 |     | <span class='unexecuted'>            positions[params.positionId].amountOut = 0;</span>
  99 |     | <span class='unexecuted'>            SafeTransfers.transferOut(params.to, params.zeroForOne ? cache.constants.token0 : cache.constants.token1, amountOut);</span>
 100 |     | <span class='neutral'>        }</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'>}</span>
 103 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/libraries/utils/SafeCast.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Safe casting methods</span>
  5 |     | <span class='neutral'>/// @notice Contains methods for safely casting between types</span>
  6 |     | <span class='unexecuted'>library SafeCast {</span>
  7 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint128, revert on overflow</span>
  8 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
  9 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint128</span>
 10 |     | <span class='neutral'>    function toUint128(uint256 y) internal pure returns (uint128 z) {</span>
 11 |     | <span class='neutral'>        if((z = uint128(y)) != y) require(false, &#39;Uint256ToUint128:Overflow()&#39;);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint128, revert on overflow</span>
 15 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
 16 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint128</span>
 17 |     | <span class='neutral'>    function toUint128(int128 y) internal pure returns (uint128 z) {</span>
 18 |     | <span class='neutral'>        if(y &lt; 0) require(false, &#39;Int128ToUint128:Underflow()&#39;);</span>
 19 |     | <span class='neutral'>        z = uint128(y);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint160, revert on overflow</span>
 23 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
 24 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint160</span>
 25 |     | <span class='neutral'>    function toUint160(uint256 y) internal pure returns (uint160 z) {</span>
 26 |     | <span class='neutral'>        if((z = uint160(y)) != y) require(false, &#39;Uint256ToUint160:Overflow()&#39;);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint160, revert on overflow</span>
 30 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
 31 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint160</span>
 32 |     | <span class='neutral'>    function toUint32(uint256 y) internal pure returns (uint32 z) {</span>
 33 |     | <span class='neutral'>        if((z = uint32(y)) != y) require(false, &#39;Uint256ToUint32:Overflow()&#39;);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /// @notice Cast a int256 to a int128, revert on overflow or underflow</span>
 37 |     | <span class='neutral'>    /// @param y The int256 to be downcasted</span>
 38 |     | <span class='neutral'>    /// @return z The downcasted integer, now type int128</span>
 39 |     | <span class='neutral'>    function toInt128(int256 y) internal pure returns (int128 z) {</span>
 40 |     | <span class='neutral'>        if ((z = int128(y)) != y) require(false, &#39;Int256ToInt128:Overflow()&#39;);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /// @notice Cast a int256 to a int128, revert on overflow or underflow</span>
 44 |     | <span class='neutral'>    /// @param y The int256 to be downcasted</span>
 45 |     | <span class='neutral'>    /// @return z The downcasted integer, now type int128</span>
 46 |     | <span class='neutral'>    function toInt128(uint128 y) internal pure returns (int128 z) {</span>
 47 |     | <span class='neutral'>        if(y &gt; uint128(type(int128).max)) require(false, &#39;Uint128ToInt128:Overflow()&#39;);</span>
 48 |     | <span class='neutral'>        z = int128(y);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    /// @notice Cast a uint256 to a int256, revert on overflow</span>
 52 |     | <span class='neutral'>    /// @param y The uint256 to be casted</span>
 53 |     | <span class='neutral'>    /// @return z The casted integer, now type int256</span>
 54 |     | <span class='neutral'>    function toInt256(uint256 y) internal pure returns (int256 z) {</span>
 55 |     | <span class='neutral'>        if(y &gt; uint256(type(int256).max)) require(false, &#39;Uint256ToInt256:Overflow()&#39;);</span>
 56 |     | <span class='neutral'>        z = int256(y);</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint128, revert on overflow</span>
 60 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
 61 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint128</span>
 62 |     | <span class='unexecuted'>    function toUint256(int256 y) internal pure returns (uint256 z) {</span>
 63 |     | <span class='unexecuted'>        if(y &lt; 0) require(false, &#39;Int256ToUint256:Underflow()&#39;);</span>
 64 |     | <span class='unexecuted'>        z = uint256(y);</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/libraries/utils/SafeTransfers.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: Unlicense</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../external/openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='unexecuted'>library SafeTransfers {</span>
   7 |     | <span class='neutral'>    /**</span>
   8 |     | <span class='neutral'>     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.</span>
   9 |     | <span class='neutral'>     *      This will revert due to insufficient balance or insufficient allowance.</span>
  10 |     | <span class='neutral'>     *      This function returns the actual amount received,</span>
  11 |     | <span class='neutral'>     *      which may be less than `amount` if there is a fee attached to the transfer.</span>
  12 |     | <span class='neutral'>     *</span>
  13 |     | <span class='neutral'>     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.</span>
  14 |     | <span class='neutral'>     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca</span>
  15 |     | <span class='neutral'>     */</span>
  16 |     | <span class='neutral'>    // slither-disable-next-line assembly</span>
  17 |     | <span class='unexecuted'>    function transferIn(address token, uint256 amount) internal returns (uint256) {</span>
  18 |     | <span class='unexecuted'>        if (token == address(0)) {</span>
  19 |     | <span class='unexecuted'>            if (msg.value &lt; amount) require(false, &#39;TransferFailed(msg.sender, address(this)&#39;);</span>
  20 |     | <span class='unexecuted'>            return amount;</span>
  21 |     | <span class='neutral'>        }</span>
  22 |     | <span class='unexecuted'>        if (amount == 0) return 0;</span>
  23 |     | <span class='unexecuted'>        IERC20 erc20Token = IERC20(token);</span>
  24 |     | <span class='unexecuted'>        uint256 balanceBefore = IERC20(token).balanceOf(address(this));</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>        // ? We are checking the transfer, but since we are doing so in an assembly block</span>
  27 |     | <span class='neutral'>        // ? Slither does not pick up on that and results in a hit</span>
  28 |     | <span class='neutral'>        // slither-disable-next-line unchecked-transfer</span>
  29 |     | <span class='unexecuted'>        erc20Token.transferFrom(msg.sender, address(this), amount);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>        bool success;</span>
  32 |     | <span class='neutral'>        assembly {</span>
  33 |     | <span class='unexecuted'>            switch returndatasize()</span>
  34 |     | <span class='unexecuted'>            case 0 {</span>
  35 |     | <span class='neutral'>                // This is a non-standard ERC-20</span>
  36 |     | <span class='unexecuted'>                success := 1 // set success to true</span>
  37 |     | <span class='neutral'>            }</span>
  38 |     | <span class='unexecuted'>            case 32 {</span>
  39 |     | <span class='neutral'>                // This is a compliant ERC-20</span>
  40 |     | <span class='unexecuted'>                returndatacopy(0, 0, 32)</span>
  41 |     | <span class='unexecuted'>                success := mload(0) // Set `success = returndata` of external call</span>
  42 |     | <span class='neutral'>            }</span>
  43 |     | <span class='neutral'>            default {</span>
  44 |     | <span class='neutral'>                // This is an excessively non-compliant ERC-20, revert.</span>
  45 |     | <span class='unexecuted'>                success := 0</span>
  46 |     | <span class='neutral'>            }</span>
  47 |     | <span class='neutral'>        }</span>
  48 |     | <span class='unexecuted'>        if (!success) require(false, &#39;TransferFailed(msg.sender, address(this)&#39;);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>        // Calculate the amount that was *actually* transferred</span>
  51 |     | <span class='unexecuted'>        uint256 balanceAfter = IERC20(token).balanceOf(address(this));</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>        return balanceAfter - balanceBefore; // underflow already checked above, just subtract</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory</span>
  58 |     | <span class='neutral'>     *      error code rather than reverting. If caller has not called checked protocol&#39;s balance, this may revert due to</span>
  59 |     | <span class='neutral'>     *      insufficient cash held in this contract. If caller has checked protocol&#39;s balance prior to this call, and verified</span>
  60 |     | <span class='neutral'>     *      it is &gt;= amount, this should not revert in normal conditions.</span>
  61 |     | <span class='neutral'>     *</span>
  62 |     | <span class='neutral'>     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.</span>
  63 |     | <span class='neutral'>     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca</span>
  64 |     | <span class='neutral'>     */</span>
  65 |     | <span class='neutral'>    // slither-disable-next-line assembly</span>
  66 |     | <span class='unexecuted'>    function transferOut(</span>
  67 |     | <span class='neutral'>        address to,</span>
  68 |     | <span class='neutral'>        address token,</span>
  69 |     | <span class='neutral'>        uint256 amount</span>
  70 |     | <span class='unexecuted'>    ) internal {</span>
  71 |     | <span class='unexecuted'>        if (token == address(0)) {</span>
  72 |     | <span class='unexecuted'>            if (address(this).balance &lt; amount) require(false, &#39;TransferFailed(address(this), to&#39;);</span>
  73 |     | <span class='unexecuted'>            payable(to).transfer(amount);</span>
  74 |     | <span class='unexecuted'>            return;</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='unexecuted'>        if (amount == 0) return;</span>
  77 |     | <span class='unexecuted'>        IERC20 erc20Token = IERC20(token);</span>
  78 |     | <span class='neutral'>        // ? We are checking the transfer, but since we are doing so in an assembly block</span>
  79 |     | <span class='neutral'>        // ? Slither does not pick up on that and results in a hit</span>
  80 |     | <span class='neutral'>        // slither-disable-next-line unchecked-transfer</span>
  81 |     | <span class='unexecuted'>        erc20Token.transfer(to, amount);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        bool success;</span>
  84 |     | <span class='neutral'>        assembly {</span>
  85 |     | <span class='unexecuted'>            switch returndatasize()</span>
  86 |     | <span class='unexecuted'>            case 0 {</span>
  87 |     | <span class='neutral'>                // This is a non-standard ERC-20</span>
  88 |     | <span class='unexecuted'>                success := 1 // set success to true</span>
  89 |     | <span class='neutral'>            }</span>
  90 |     | <span class='unexecuted'>            case 32 {</span>
  91 |     | <span class='neutral'>                // This is a complaint ERC-20</span>
  92 |     | <span class='unexecuted'>                returndatacopy(0, 0, 32)</span>
  93 |     | <span class='unexecuted'>                success := mload(0) // Set `success = returndata` of external call</span>
  94 |     | <span class='neutral'>            }</span>
  95 |     | <span class='neutral'>            default {</span>
  96 |     | <span class='neutral'>                // This is an excessively non-compliant ERC-20, revert.</span>
  97 |     | <span class='unexecuted'>                success := 0</span>
  98 |     | <span class='neutral'>            }</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='unexecuted'>        if (!success) require(false, &#39;TransferFailed(address(this), msg.sender&#39;);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /**</span>
 104 |     | <span class='neutral'>     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.</span>
 105 |     | <span class='neutral'>     *      This will revert due to insufficient balance or insufficient allowance.</span>
 106 |     | <span class='neutral'>     *      This function returns the actual amount received,</span>
 107 |     | <span class='neutral'>     *      which may be less than `amount` if there is a fee attached to the transfer.</span>
 108 |     | <span class='neutral'>     *</span>
 109 |     | <span class='neutral'>     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.</span>
 110 |     | <span class='neutral'>     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca</span>
 111 |     | <span class='neutral'>     */</span>
 112 |     | <span class='neutral'>    // slither-disable-next-line assembly</span>
 113 | *   | <span class='executed'>    function transferInto(address token, address sender, uint256 amount) internal returns (uint256) {</span>
 114 | *   | <span class='executed'>        if (token == address(0)) {</span>
 115 |     | <span class='unexecuted'>            if (msg.value &lt; amount) require(false, &#39;TransferFailed(msg.sender, address(this)&#39;);</span>
 116 |     | <span class='unexecuted'>            return amount;</span>
 117 |     | <span class='neutral'>        }</span>
 118 | *   | <span class='executed'>        IERC20 erc20Token = IERC20(token);</span>
 119 | *   | <span class='executed'>        uint256 balanceBefore = IERC20(token).balanceOf(address(this));</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>        /// @dev - msg.sender here is the pool</span>
 122 | *r  | <span class='executed'>        erc20Token.transferFrom(sender, msg.sender, amount);</span>
 123 |     | <span class='neutral'></span>
 124 | *   | <span class='executed'>        bool success;</span>
 125 |     | <span class='neutral'>        assembly {</span>
 126 | *   | <span class='executed'>            switch returndatasize()</span>
 127 | *   | <span class='executed'>            case 0 {</span>
 128 |     | <span class='neutral'>                // This is a non-standard ERC-20</span>
 129 |     | <span class='unexecuted'>                success := 1 // set success to true</span>
 130 |     | <span class='neutral'>            }</span>
 131 | *   | <span class='executed'>            case 32 {</span>
 132 |     | <span class='neutral'>                // This is a compliant ERC-20</span>
 133 | *   | <span class='executed'>                returndatacopy(0, 0, 32)</span>
 134 | *   | <span class='executed'>                success := mload(0) // Set `success = returndata` of external call</span>
 135 |     | <span class='neutral'>            }</span>
 136 |     | <span class='neutral'>            default {</span>
 137 |     | <span class='neutral'>                // This is an excessively non-compliant ERC-20, revert.</span>
 138 |     | <span class='unexecuted'>                success := 0</span>
 139 |     | <span class='neutral'>            }</span>
 140 |     | <span class='neutral'>        }</span>
 141 | *   | <span class='executed'>        if (!success) require(false, &#39;TransferFailed(msg.sender, address(this)&#39;);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>        // Calculate the amount that was *actually* transferred</span>
 144 | *   | <span class='executed'>        uint256 balanceAfter = IERC20(token).balanceOf(address(this));</span>
 145 |     | <span class='neutral'></span>
 146 | *   | <span class='executed'>        return balanceAfter - balanceBefore; // underflow already checked above, just subtract</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'>}</span>
 149 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/libraries/utils/String.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>library String {</span>
  5 |     | <span class='neutral'>    bytes16 private constant alphabet = &quot;0123456789abcdef&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function from(bytes32 value) internal pure returns(string memory) {</span>
  8 |     | <span class='neutral'>        return toString(abi.encodePacked(value));</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function from(address account) internal pure returns(string memory) {</span>
 12 |     | <span class='neutral'>        return toString(abi.encodePacked(account));</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function from(uint256 value) internal pure returns(string memory) {</span>
 16 |     | <span class='neutral'>        unchecked {</span>
 17 |     | <span class='unexecuted'>            uint256 length = log10(value) + 1;</span>
 18 |     | <span class='unexecuted'>            string memory buffer = new string(length);</span>
 19 |     | <span class='unexecuted'>            uint256 ptr;</span>
 20 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 21 |     | <span class='neutral'>            assembly {</span>
 22 |     | <span class='unexecuted'>                ptr := add(buffer, add(32, length))</span>
 23 |     | <span class='neutral'>            }</span>
 24 |     | <span class='unexecuted'>            while (true) {</span>
 25 |     | <span class='unexecuted'>                ptr--;</span>
 26 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
 27 |     | <span class='neutral'>                assembly {</span>
 28 |     | <span class='unexecuted'>                    mstore8(ptr, byte(mod(value, 10), alphabet))</span>
 29 |     | <span class='neutral'>                }</span>
 30 |     | <span class='unexecuted'>                value /= 10;</span>
 31 |     | <span class='unexecuted'>                if (value == 0) break;</span>
 32 |     | <span class='neutral'>            }</span>
 33 |     | <span class='unexecuted'>            return buffer;</span>
 34 |     | <span class='neutral'>        }</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    function from(int256 value) internal pure returns (string memory) {</span>
 38 |     | <span class='unexecuted'>        return string(abi.encodePacked(value &lt; 0 ? &quot;-&quot; : &quot;&quot;, from(abs(value))));</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='unexecuted'>    function abs(int256 n) internal pure returns (uint256) {</span>
 42 |     | <span class='neutral'>        unchecked {</span>
 43 |     | <span class='neutral'>            // must be unchecked in order to support `n = type(int256).min`</span>
 44 |     | <span class='unexecuted'>            return uint256(n &gt;= 0 ? n : -n);</span>
 45 |     | <span class='neutral'>        }</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>    function log10(uint256 value) internal pure returns (uint256) {</span>
 49 |     | <span class='unexecuted'>        uint256 result = 0;</span>
 50 |     | <span class='neutral'>        unchecked {</span>
 51 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 64) {</span>
 52 |     | <span class='unexecuted'>                value /= 10 ** 64;</span>
 53 |     | <span class='unexecuted'>                result += 64;</span>
 54 |     | <span class='neutral'>            }</span>
 55 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 32) {</span>
 56 |     | <span class='unexecuted'>                value /= 10 ** 32;</span>
 57 |     | <span class='unexecuted'>                result += 32;</span>
 58 |     | <span class='neutral'>            }</span>
 59 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 16) {</span>
 60 |     | <span class='unexecuted'>                value /= 10 ** 16;</span>
 61 |     | <span class='unexecuted'>                result += 16;</span>
 62 |     | <span class='neutral'>            }</span>
 63 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 8) {</span>
 64 |     | <span class='unexecuted'>                value /= 10 ** 8;</span>
 65 |     | <span class='unexecuted'>                result += 8;</span>
 66 |     | <span class='neutral'>            }</span>
 67 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 4) {</span>
 68 |     | <span class='unexecuted'>                value /= 10 ** 4;</span>
 69 |     | <span class='unexecuted'>                result += 4;</span>
 70 |     | <span class='neutral'>            }</span>
 71 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 2) {</span>
 72 |     | <span class='unexecuted'>                value /= 10 ** 2;</span>
 73 |     | <span class='unexecuted'>                result += 2;</span>
 74 |     | <span class='neutral'>            }</span>
 75 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 1) {</span>
 76 |     | <span class='unexecuted'>                result += 1;</span>
 77 |     | <span class='neutral'>            }</span>
 78 |     | <span class='neutral'>        }</span>
 79 |     | <span class='unexecuted'>        return result;</span>
 80 |     | <span class='neutral'>    }</span>
 81 |     | <span class='neutral'></span>
 82 |     | <span class='neutral'>    function toString(bytes memory data) internal pure returns(string memory) {</span>
 83 |     | <span class='neutral'>        bytes memory str = new bytes(2 + data.length * 2);</span>
 84 |     | <span class='neutral'>        str[0] = &quot;0&quot;;</span>
 85 |     | <span class='neutral'>        str[1] = &quot;x&quot;;</span>
 86 |     | <span class='neutral'>        for (uint i = 0; i &lt; data.length; i++) {</span>
 87 |     | <span class='neutral'>            str[2+i*2] = alphabet[uint(uint8(data[i] &gt;&gt; 4))];</span>
 88 |     | <span class='neutral'>            str[3+i*2] = alphabet[uint(uint8(data[i] &amp; 0x0f))];</span>
 89 |     | <span class='neutral'>        }</span>
 90 |     | <span class='neutral'>        return string(str);</span>
 91 |     | <span class='neutral'>    }</span>
 92 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/test/Token20.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: Unlicense</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../external/openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../external/openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 | *   | <span class='executed'>contract Token20 is ERC20, ERC20Burnable {</span>
  8 |     | <span class='neutral'>    uint8 _decimals;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    constructor(</span>
 11 |     | <span class='neutral'>        string memory tokenName,</span>
 12 |     | <span class='neutral'>        string memory tokenSymbol,</span>
 13 |     | <span class='neutral'>        uint8 decimals_</span>
 14 |     | <span class='unexecuted'>    ) ERC20(tokenName, tokenSymbol) {</span>
 15 |     | <span class='unexecuted'>        _decimals = decimals_;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 | *   | <span class='executed'>    function mint(address to, uint256 amount) external {</span>
 19 | *   | <span class='executed'>        _mint(to, amount);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function decimals() public view override returns (uint8) {</span>
 23 |     | <span class='unexecuted'>        return _decimals;</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    function setDecimals(uint8 decimals_) public {</span>
 27 |     | <span class='unexecuted'>        _decimals = decimals_;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/test/UniswapV3FactoryMock.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: Unlicense</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../interfaces/external/uniswap/v3/IUniswapV3Factory.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;./UniswapV3PoolMock.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract UniswapV3FactoryMock is IUniswapV3Factory {</span>
  8 |     | <span class='neutral'>    address mockPool;</span>
  9 |     | <span class='neutral'>    address mockPool2;</span>
 10 |     | <span class='neutral'>    address owner;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    mapping(uint24 =&gt; int24) public feeTierTickSpacing;</span>
 13 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; mapping(uint24 =&gt; address))) public override getPool;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    constructor(address tokenA, address tokenB) {</span>
 16 |     | <span class='unexecuted'>        owner = msg.sender;</span>
 17 |     | <span class='unexecuted'>        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB)</span>
 18 |     | <span class='unexecuted'>                                                           : (tokenB, tokenA);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>        feeTierTickSpacing[500] = 10;</span>
 21 |     | <span class='unexecuted'>        feeTierTickSpacing[3000] = 60;</span>
 22 |     | <span class='unexecuted'>        feeTierTickSpacing[10000] = 200;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>        // create mock pool 1</span>
 25 |     | <span class='unexecuted'>        mockPool = address(new UniswapV3PoolMock(token0, token1, 500, 10));</span>
 26 |     | <span class='unexecuted'>        getPool[token0][token1][500] = mockPool;</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>        // create mock pool 2</span>
 29 |     | <span class='unexecuted'>        mockPool2 = address(new UniswapV3PoolMock(token0, token1, 3000, 60));</span>
 30 |     | <span class='unexecuted'>        getPool[token0][token1][3000] = mockPool2;</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'>}</span>
 33 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/test/UniswapV3PoolMock.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: Unlicense</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../interfaces/external/uniswap/v3/IUniswapV3Pool.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;./UniswapV3PoolMock.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 | *   | <span class='executed'>contract UniswapV3PoolMock is IUniswapV3Pool {</span>
  8 |     | <span class='neutral'>    address internal admin;</span>
  9 |     | <span class='unexecuted'>    address public token0;</span>
 10 |     | <span class='unexecuted'>    address public token1;</span>
 11 |     | <span class='unexecuted'>    int24 public tickSpacing;</span>
 12 |     | <span class='neutral'>    uint256 swapFee;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    uint16 observationCardinality;</span>
 15 |     | <span class='neutral'>    uint16 observationCardinalityNext;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    int56 tickCumulative0;</span>
 18 |     | <span class='neutral'>    int56 tickCumulative1;</span>
 19 |     | <span class='neutral'>    int56 tickCumulative2;</span>
 20 |     | <span class='neutral'>    int56 tickCumulative3;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    constructor(</span>
 23 |     | <span class='neutral'>        address _token0,</span>
 24 |     | <span class='neutral'>        address _token1,</span>
 25 |     | <span class='neutral'>        uint24 _swapFee,</span>
 26 |     | <span class='neutral'>        int24 _tickSpacing</span>
 27 |     | <span class='neutral'>    ) {</span>
 28 |     | <span class='unexecuted'>        require(_token0 &lt; _token1, &#39;wrong token order&#39;);</span>
 29 |     | <span class='unexecuted'>        admin = msg.sender;</span>
 30 |     | <span class='unexecuted'>        token0 = _token0;</span>
 31 |     | <span class='unexecuted'>        token1 = _token1;</span>
 32 |     | <span class='unexecuted'>        swapFee = _swapFee;</span>
 33 |     | <span class='unexecuted'>        tickSpacing = _tickSpacing;</span>
 34 |     | <span class='unexecuted'>        observationCardinality = 4;</span>
 35 |     | <span class='unexecuted'>        observationCardinalityNext = 4;</span>
 36 |     | <span class='unexecuted'>        tickCumulative0 = 10;</span>
 37 |     | <span class='unexecuted'>        tickCumulative1 = 9;</span>
 38 |     | <span class='unexecuted'>        tickCumulative2 = 6;</span>
 39 |     | <span class='unexecuted'>        tickCumulative3 = 5;</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 | *   | <span class='executed'>    function slot0()</span>
 43 |     | <span class='neutral'>        external</span>
 44 |     | <span class='neutral'>        view</span>
 45 |     | <span class='neutral'>        returns (</span>
 46 | *   | <span class='executed'>            uint160 sqrtPriceX96,</span>
 47 | *   | <span class='executed'>            int24 tick,</span>
 48 | *   | <span class='executed'>            uint16 observationIndex,</span>
 49 | *   | <span class='executed'>            uint16 cardinality,</span>
 50 | *   | <span class='executed'>            uint16 cardinalityNext,</span>
 51 | *   | <span class='executed'>            uint8 feeProtocol,</span>
 52 | *   | <span class='executed'>            bool unlocked</span>
 53 |     | <span class='neutral'>        )</span>
 54 |     | <span class='neutral'>    {</span>
 55 | *   | <span class='executed'>        return (1 &lt;&lt; 96, 0, 4, observationCardinality, observationCardinalityNext, 100, true);</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'></span>
 58 | *   | <span class='executed'>    function observe(uint32[] calldata secondsAgos)</span>
 59 |     | <span class='neutral'>        external</span>
 60 |     | <span class='neutral'>        view</span>
 61 |     | <span class='neutral'>        returns (</span>
 62 | *   | <span class='executed'>            int56[] memory tickCumulatives,</span>
 63 | *   | <span class='executed'>            uint160[] memory secondsPerLiquidityCumulativeX128s</span>
 64 |     | <span class='neutral'>        )</span>
 65 |     | <span class='neutral'>    {</span>
 66 |     | <span class='neutral'>        secondsAgos;</span>
 67 | *   | <span class='executed'>        tickCumulatives = new int56[](secondsAgos.length);</span>
 68 | *   | <span class='executed'>        tickCumulatives[0] = int56(tickCumulative0);</span>
 69 | *   | <span class='executed'>        tickCumulatives[1] = int56(tickCumulative1);</span>
 70 | *   | <span class='executed'>        tickCumulatives[2] = int56(tickCumulative2);</span>
 71 | *   | <span class='executed'>        tickCumulatives[3] = int56(tickCumulative3);</span>
 72 | *   | <span class='executed'>        secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);</span>
 73 | *   | <span class='executed'>        secondsPerLiquidityCumulativeX128s[0] = uint160(949568451203788412348119);</span>
 74 | *   | <span class='executed'>        secondsPerLiquidityCumulativeX128s[1] = uint160(949568451203788412348119);</span>
 75 | *   | <span class='executed'>        secondsPerLiquidityCumulativeX128s[2] = uint160(949568438263103965182699);</span>
 76 | *   | <span class='executed'>        secondsPerLiquidityCumulativeX128s[3] = uint160(949568438263103965182699);</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='unexecuted'>    function increaseObservationCardinalityNext(uint16 cardinalityNext) external {</span>
 80 |     | <span class='unexecuted'>        observationCardinalityNext = cardinalityNext;</span>
 81 |     | <span class='neutral'>    }</span>
 82 |     | <span class='neutral'></span>
 83 | *   | <span class='executed'>    function setTickCumulatives(int56 _tickCumulative0, int56 _tickCumulative1, int56 _tickCumulative2, int56 _tickCumulative3) external {</span>
 84 | *   | <span class='executed'>        tickCumulative0 = _tickCumulative0;</span>
 85 | *   | <span class='executed'>        tickCumulative1 = _tickCumulative1;</span>
 86 | *   | <span class='executed'>        tickCumulative2 = _tickCumulative2;</span>
 87 | *   | <span class='executed'>        tickCumulative3 = _tickCumulative3;</span>
 88 |     | <span class='neutral'>    }</span>
 89 |     | <span class='neutral'></span>
 90 |     | <span class='unexecuted'>    function setObservationCardinality(uint16 _observationCardinality, uint16 _observationCardinalityNext) external {</span>
 91 |     | <span class='unexecuted'>        observationCardinality = _observationCardinality;</span>
 92 |     | <span class='unexecuted'>        observationCardinalityNext = _observationCardinalityNext;</span>
 93 |     | <span class='neutral'>    }</span>
 94 |     | <span class='neutral'>}</span>
 95 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/test/echidna/EchidnaAssertions.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/structs/CoverPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../libraries/math/ConstantProduct.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library EchidnaAssertions {</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    event LiquidityGlobalUnderflow(uint128 liquidityGlobal, uint128 amount, string location);</span>
 10 |     | <span class='neutral'>    event LiquidityUnderflow(uint128 liquidity, uint128 amount, string location);</span>
 11 |     | <span class='neutral'>    event LiquidityOverflow(uint128 liquidity, uint128 amount, string location);</span>
 12 |     | <span class='neutral'>    event LiquidityUnlock(int128 liquidity);</span>
 13 |     | <span class='neutral'>    event PoolBalanceExceeded(uint256 poolBalance, uint256 outputAmount);</span>
 14 |     | <span class='neutral'>    event LiquidityDelta(int128 liquidityDelta);</span>
 15 |     | <span class='neutral'>    event TickDivisibleByTickSpacing(int24 tick, int16 tickSpacing);</span>
 16 |     | <span class='neutral'>    event TickWithinBounds(int24 tick, int24 minTick, int24 maxTick);</span>
 17 |     | <span class='neutral'>    event InfiniteLoop0(int24 accumTick, int24 crossTick);</span>
 18 |     | <span class='neutral'>    event InfiniteLoop1(int24 accumTick, int24 crossTick);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function assertLiquidityGlobalUnderflows(uint128 liquidityGlobal, uint128 amount, string memory location) internal {</span>
 21 |     | <span class='unexecuted'>        emit LiquidityGlobalUnderflow(liquidityGlobal, amount, location);</span>
 22 |     | <span class='unexecuted'>        assert(liquidityGlobal &gt;= amount);</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>    function assertLiquidityUnderflows(uint128 liquidity, uint128 amount, string memory location) internal {</span>
 26 |     | <span class='unexecuted'>        emit LiquidityUnderflow(liquidity, amount, location);</span>
 27 |     | <span class='unexecuted'>        assert(liquidity &gt;= amount);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>    function assertLiquidityOverflows(uint128 liquidity, uint128 amount, string memory location) internal {</span>
 31 |     | <span class='unexecuted'>        emit LiquidityUnderflow(liquidity, amount, location);</span>
 32 |     | <span class='unexecuted'>        assert(uint256(liquidity) + uint256(amount) &lt;= uint128(type(int128).max));</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function assertAmountInDeltaMaxMinusUnderflows(uint128 liquidityAbs, uint128 amount, string memory location) internal {</span>
 36 |     | <span class='neutral'>        emit LiquidityUnderflow(liquidityAbs, amount, location);</span>
 37 |     | <span class='neutral'>        assert(liquidityAbs &gt;= amount);</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    function assertAmountOutDeltaMaxMinusUnderflows(uint128 liquidityAbs, uint128 amount, string memory location) internal {</span>
 41 |     | <span class='neutral'>        emit LiquidityUnderflow(liquidityAbs, amount, location);</span>
 42 |     | <span class='neutral'>        assert(liquidityAbs &gt;= amount);</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    function assertPositiveLiquidityOnUnlock(int128 liquidity) internal {</span>
 46 |     | <span class='neutral'>        emit LiquidityUnlock(liquidity);</span>
 47 |     | <span class='neutral'>        assert(liquidity &gt;= 0);</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='unexecuted'>    function assertPoolBalanceExceeded(uint256 poolBalance, uint256 outputAmount) internal {</span>
 51 |     | <span class='unexecuted'>        emit PoolBalanceExceeded(poolBalance, outputAmount);</span>
 52 |     | <span class='unexecuted'>        assert(poolBalance &gt;= outputAmount);</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='unexecuted'>    function assertTickDivisibleByTickSpacing(int24 tick, int16 tickSpacing) internal {</span>
 56 |     | <span class='unexecuted'>        emit TickDivisibleByTickSpacing(tick, tickSpacing);</span>
 57 |     | <span class='unexecuted'>        assert(tick % tickSpacing == 0);</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='unexecuted'>    function assertTickWithinBounds(int24 tick, int24 minTick, int24 maxTick) internal {</span>
 61 |     | <span class='unexecuted'>        emit TickWithinBounds(tick, minTick, maxTick);</span>
 62 |     | <span class='unexecuted'>        assert(tick &gt;= minTick);</span>
 63 |     | <span class='unexecuted'>        assert(tick &lt;= maxTick);</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='unexecuted'>    function assertInfiniteLoop0(int24 accumTick, int24 crossTick) internal {</span>
 67 |     | <span class='unexecuted'>        emit InfiniteLoop0(accumTick, crossTick);</span>
 68 |     | <span class='unexecuted'>        assert(accumTick != crossTick);</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='neutral'>    function assertInfiniteLoop1(int24 accumTick, int24 crossTick) internal {</span>
 72 |     | <span class='neutral'>        emit InfiniteLoop1(accumTick, crossTick);</span>
 73 |     | <span class='neutral'>        assert(accumTick != crossTick);</span>
 74 |     | <span class='neutral'>    }</span>
 75 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/utils/CoverPoolErrors.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract CoverPoolErrors {</span>
  5 |     | <span class='neutral'>    error Locked();</span>
  6 |     | <span class='neutral'>    error OwnerOnly();</span>
  7 |     | <span class='neutral'>    error InvalidToken();</span>
  8 |     | <span class='neutral'>    error InvalidPosition();</span>
  9 |     | <span class='neutral'>    error InvalidSwapFee();</span>
 10 |     | <span class='neutral'>    error InvalidTokenDecimals();</span>
 11 |     | <span class='neutral'>    error InvalidTickSpread();</span>
 12 |     | <span class='neutral'>    error LiquidityOverflow();</span>
 13 |     | <span class='neutral'>    error Token0Missing();</span>
 14 |     | <span class='neutral'>    error Token1Missing();</span>
 15 |     | <span class='neutral'>    error InvalidTick();</span>
 16 |     | <span class='neutral'>    error FactoryOnly();</span>
 17 |     | <span class='neutral'>    error LowerNotEvenTick();</span>
 18 |     | <span class='neutral'>    error UpperNotOddTick();</span>
 19 |     | <span class='neutral'>    error MaxTickLiquidity();</span>
 20 |     | <span class='neutral'>    error CollectToZeroAddress();</span>
 21 |     | <span class='neutral'>    error Overflow();</span>
 22 |     | <span class='neutral'>    error NotEnoughOutputLiquidity();</span>
 23 |     | <span class='neutral'>    error WaitUntilEnoughObservations();</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>abstract contract CoverTicksErrors {</span>
 27 |     | <span class='neutral'>    error WrongTickLowerRange();</span>
 28 |     | <span class='neutral'>    error WrongTickUpperRange();</span>
 29 |     | <span class='neutral'>    error WrongTickLowerOrder();</span>
 30 |     | <span class='neutral'>    error WrongTickUpperOrder();</span>
 31 |     | <span class='neutral'>    error WrongTickClaimedAt();</span>
 32 |     | <span class='neutral'>}</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>abstract contract CoverMiscErrors {</span>
 35 |     | <span class='neutral'>    // to be removed before production</span>
 36 |     | <span class='neutral'>    error NotImplementedYet();</span>
 37 |     | <span class='neutral'>}</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>abstract contract CoverPositionErrors {</span>
 40 |     | <span class='neutral'>    error NotEnoughPositionLiquidity();</span>
 41 |     | <span class='neutral'>    error InvalidClaimTick();</span>
 42 |     | <span class='neutral'>}</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>abstract contract CoverPoolFactoryErrors {</span>
 45 |     | <span class='neutral'>    error OwnerOnly();</span>
 46 |     | <span class='neutral'>    error InvalidTokenAddress();</span>
 47 |     | <span class='neutral'>    error InvalidTokenDecimals();</span>
 48 |     | <span class='neutral'>    error PoolAlreadyExists();</span>
 49 |     | <span class='neutral'>    error FeeTierNotSupported();</span>
 50 |     | <span class='neutral'>    error VolatilityTierNotSupported();</span>
 51 |     | <span class='neutral'>    error InvalidTickSpread();</span>
 52 |     | <span class='neutral'>    error PoolTypeNotFound();</span>
 53 |     | <span class='neutral'>    error CurveMathNotFound();</span>
 54 |     | <span class='neutral'>    error TickSpreadNotMultipleOfTickSpacing();</span>
 55 |     | <span class='neutral'>    error TickSpreadNotAtLeastDoubleTickSpread();</span>
 56 |     | <span class='neutral'>}</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>abstract contract CoverTransferErrors {</span>
 59 |     | <span class='neutral'>    error TransferFailed(address from, address dest);</span>
 60 |     | <span class='neutral'>}</span>
 61 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/cover/contracts/utils/CoverPoolManager.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &#39;../interfaces/ICoverPool.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../interfaces/ICoverPoolFactory.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../interfaces/ICoverPoolManager.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../base/events/CoverPoolManagerEvents.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Defines the actions which can be executed by the factory admin.</span>
  12 |     | <span class='neutral'> */</span>
  13 |     | <span class='unexecuted'>contract CoverPoolManager is ICoverPoolManager, CoverPoolManagerEvents {</span>
  14 |     | <span class='unexecuted'>    address public owner;</span>
  15 |     | <span class='unexecuted'>    address public feeTo;</span>
  16 |     | <span class='unexecuted'>    address public factory;</span>
  17 |     | <span class='unexecuted'>    uint16  public constant MAX_PROTOCOL_FEE = 1e4; /// @dev - max protocol fee of 1%</span>
  18 |     | <span class='unexecuted'>    uint16  public constant oneSecond = 1000;</span>
  19 |     | <span class='neutral'>    // sourceName =&gt; sourceAddress</span>
  20 |     | <span class='neutral'>    mapping(bytes32 =&gt; address) internal _twapSources;</span>
  21 |     | <span class='neutral'>    mapping(bytes32 =&gt; address) internal _poolTypes;</span>
  22 |     | <span class='neutral'>    // sourceName =&gt; feeTier =&gt; tickSpread =&gt; twapLength =&gt; VolatilityTier</span>
  23 |     | <span class='neutral'>    mapping(bytes32 =&gt; mapping(uint16 =&gt; mapping(int16 =&gt; mapping(uint16 =&gt; VolatilityTier)))) internal _volatilityTiers;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    constructor() {</span>
  26 |     | <span class='unexecuted'>        owner = msg.sender;</span>
  27 |     | <span class='unexecuted'>        feeTo = msg.sender;</span>
  28 |     | <span class='unexecuted'>        emit OwnerTransfer(address(0), msg.sender);</span>
  29 |     | <span class='unexecuted'>        emit FeeToTransfer(address(0), msg.sender);</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /**</span>
  33 |     | <span class='neutral'>     * @dev Throws if called by any account other than the owner.</span>
  34 |     | <span class='neutral'>     */</span>
  35 |     | <span class='neutral'>    modifier onlyOwner() {</span>
  36 |     | <span class='unexecuted'>        _checkOwner();</span>
  37 |     | <span class='neutral'>        _;</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    modifier onlyFeeTo() {</span>
  41 |     | <span class='unexecuted'>        _checkFeeTo();</span>
  42 |     | <span class='neutral'>        _;</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /**</span>
  46 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
  47 |     | <span class='neutral'>     * Can only be called by the current owner.</span>
  48 |     | <span class='neutral'>     */</span>
  49 |     | <span class='unexecuted'>    function transferOwner(address newOwner) public virtual onlyOwner {</span>
  50 |     | <span class='unexecuted'>        if(newOwner == address(0)) require (false, &#39;TransferredToZeroAddress()&#39;);</span>
  51 |     | <span class='unexecuted'>        _transferOwner(newOwner);</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>    function transferFeeTo(address newFeeTo) public virtual onlyFeeTo {</span>
  55 |     | <span class='unexecuted'>        if(newFeeTo == address(0)) require (false, &#39;TransferredToZeroAddress()&#39;);</span>
  56 |     | <span class='unexecuted'>        _transferFeeTo(newFeeTo);</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
  61 |     | <span class='neutral'>     * Internal function without access restriction.</span>
  62 |     | <span class='neutral'>     */</span>
  63 |     | <span class='unexecuted'>    function _transferOwner(address newOwner) internal virtual {</span>
  64 |     | <span class='unexecuted'>        address oldOwner = owner;</span>
  65 |     | <span class='unexecuted'>        owner = newOwner;</span>
  66 |     | <span class='unexecuted'>        emit OwnerTransfer(oldOwner, newOwner);</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @dev Transfers fee collection to a new account (`newFeeTo`).</span>
  71 |     | <span class='neutral'>     * Internal function without access restriction.</span>
  72 |     | <span class='neutral'>     */</span>
  73 |     | <span class='unexecuted'>    function _transferFeeTo(address newFeeTo) internal virtual {</span>
  74 |     | <span class='unexecuted'>        address oldFeeTo = feeTo;</span>
  75 |     | <span class='unexecuted'>        feeTo = newFeeTo;</span>
  76 |     | <span class='unexecuted'>        emit FeeToTransfer(oldFeeTo, newFeeTo);</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>    function enablePoolType(</span>
  80 |     | <span class='neutral'>        bytes32 poolType,</span>
  81 |     | <span class='neutral'>        address implAddress,</span>
  82 |     | <span class='neutral'>        address sourceAddress</span>
  83 |     | <span class='neutral'>    ) external onlyOwner {</span>
  84 |     | <span class='unexecuted'>        if (poolType == bytes32(&quot;&quot;)) require (false, &#39;TwapSourceNameInvalid()&#39;);</span>
  85 |     | <span class='unexecuted'>        if (implAddress == address(0) || sourceAddress == address(0)) require (false, &#39;TwapSourceAddressZero()&#39;);</span>
  86 |     | <span class='unexecuted'>        if (_twapSources[poolType] != address(0)) require (false, &#39;ImplementationAlreadyExists()&#39;);</span>
  87 |     | <span class='unexecuted'>        if (_poolTypes[poolType] != address(0)) require (false, &#39;ImplementationAlreadyExists()&#39;);</span>
  88 |     | <span class='unexecuted'>        _poolTypes[poolType] = implAddress;</span>
  89 |     | <span class='unexecuted'>        _twapSources[poolType] = sourceAddress;</span>
  90 |     | <span class='unexecuted'>        emit PoolTypeEnabled(poolType, implAddress, sourceAddress, ITwapSource(sourceAddress).factory());</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>    function enableVolatilityTier(</span>
  94 |     | <span class='neutral'>        bytes32 poolType,</span>
  95 |     | <span class='neutral'>        uint16  feeTier,</span>
  96 |     | <span class='neutral'>        int16   tickSpread,</span>
  97 |     | <span class='neutral'>        uint16  twapLength,</span>
  98 |     | <span class='neutral'>        VolatilityTier memory volTier</span>
  99 |     | <span class='unexecuted'>    ) external onlyOwner {</span>
 100 |     | <span class='unexecuted'>        if (_volatilityTiers[poolType][feeTier][tickSpread][twapLength].auctionLength != 0) {</span>
 101 |     | <span class='unexecuted'>            require (false, &#39;VolatilityTierAlreadyEnabled()&#39;);</span>
 102 |     | <span class='unexecuted'>        } else if (volTier.auctionLength == 0 ||  volTier.minPositionWidth &lt;= 0) {</span>
 103 |     | <span class='unexecuted'>            require (false, &#39;VolatilityTierCannotBeZero()&#39;);</span>
 104 |     | <span class='unexecuted'>        } else if (twapLength &lt; 5 * volTier.blockTime / oneSecond) {</span>
 105 |     | <span class='unexecuted'>            require (false, &#39;VoltatilityTierTwapTooShort()&#39;);</span>
 106 |     | <span class='unexecuted'>        } else if (volTier.syncFee &gt; 10000 || volTier.fillFee &gt; 10000) {</span>
 107 |     | <span class='unexecuted'>            require (false, &#39;ProtocolFeeCeilingExceeded()&#39;);</span>
 108 |     | <span class='neutral'>        }</span>
 109 |     | <span class='unexecuted'>        address sourceAddress = _twapSources[poolType];</span>
 110 |     | <span class='unexecuted'>        address implAddress = _poolTypes[poolType];</span>
 111 |     | <span class='unexecuted'>        {</span>
 112 |     | <span class='neutral'>            // check fee tier exists</span>
 113 |     | <span class='unexecuted'>            if (sourceAddress == address(0)) require (false, &#39;TwapSourceNotFound()&#39;);</span>
 114 |     | <span class='unexecuted'>            int24 tickSpacing = ITwapSource(sourceAddress).feeTierTickSpacing(feeTier);</span>
 115 |     | <span class='unexecuted'>            if (tickSpacing == 0) {</span>
 116 |     | <span class='unexecuted'>                require (false, &#39;FeeTierNotSupported()&#39;);</span>
 117 |     | <span class='neutral'>            }</span>
 118 |     | <span class='neutral'>            // check tick multiple</span>
 119 |     | <span class='unexecuted'>            int24 tickMultiple = tickSpread / tickSpacing;</span>
 120 |     | <span class='unexecuted'>            if (tickMultiple * tickSpacing != tickSpread) {</span>
 121 |     | <span class='unexecuted'>                require (false, &#39;TickSpreadNotMultipleOfTickSpacing()&#39;);</span>
 122 |     | <span class='unexecuted'>            } else if (tickMultiple &lt; 2) {</span>
 123 |     | <span class='unexecuted'>                require (false, &#39;TickSpreadNotAtLeastDoubleTickSpread()&#39;);</span>
 124 |     | <span class='neutral'>            }</span>
 125 |     | <span class='neutral'>        }</span>
 126 |     | <span class='neutral'>        // twapLength * blockTime should never overflow uint16</span>
 127 |     | <span class='unexecuted'>        _volatilityTiers[poolType][feeTier][tickSpread][twapLength] = volTier;</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>        emit VolatilityTierEnabled(</span>
 130 |     | <span class='unexecuted'>            implAddress,</span>
 131 |     | <span class='unexecuted'>            feeTier,</span>
 132 |     | <span class='unexecuted'>            tickSpread,</span>
 133 |     | <span class='unexecuted'>            twapLength,</span>
 134 |     | <span class='unexecuted'>            volTier.minAmountPerAuction,</span>
 135 |     | <span class='unexecuted'>            volTier.auctionLength,</span>
 136 |     | <span class='unexecuted'>            volTier.blockTime,</span>
 137 |     | <span class='unexecuted'>            volTier.syncFee,</span>
 138 |     | <span class='unexecuted'>            volTier.fillFee,</span>
 139 |     | <span class='unexecuted'>            volTier.minPositionWidth,</span>
 140 |     | <span class='unexecuted'>            volTier.minAmountLowerPriced</span>
 141 |     | <span class='neutral'>        );</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>    function modifyVolatilityTierFees(</span>
 145 |     | <span class='neutral'>        bytes32 implName,</span>
 146 |     | <span class='neutral'>        uint16 feeTier,</span>
 147 |     | <span class='neutral'>        int16 tickSpread,</span>
 148 |     | <span class='neutral'>        uint16 twapLength,</span>
 149 |     | <span class='neutral'>        uint16 syncFee,</span>
 150 |     | <span class='neutral'>        uint16 fillFee</span>
 151 |     | <span class='neutral'>    ) external onlyOwner {</span>
 152 |     | <span class='unexecuted'>        if (syncFee &gt; 10000 || fillFee &gt; 10000) {</span>
 153 |     | <span class='unexecuted'>            require (false, &#39;ProtocolFeeCeilingExceeded()&#39;);</span>
 154 |     | <span class='neutral'>        }</span>
 155 |     | <span class='unexecuted'>        _volatilityTiers[implName][feeTier][tickSpread][twapLength].syncFee = syncFee;</span>
 156 |     | <span class='unexecuted'>        _volatilityTiers[implName][feeTier][tickSpread][twapLength].fillFee = fillFee;</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>    function setFactory(</span>
 160 |     | <span class='neutral'>        address factory_</span>
 161 |     | <span class='neutral'>    ) external onlyOwner {</span>
 162 |     | <span class='unexecuted'>        if (factory != address(0)) require (false, &#39;FactoryAlreadySet()&#39;);</span>
 163 |     | <span class='unexecuted'>        emit FactoryChanged(factory, factory_);</span>
 164 |     | <span class='unexecuted'>        factory = factory_;</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='unexecuted'>    function collectProtocolFees(</span>
 168 |     | <span class='neutral'>        address[] calldata collectPools</span>
 169 |     | <span class='unexecuted'>    ) external {</span>
 170 |     | <span class='unexecuted'>        if (collectPools.length == 0) require (false, &#39;EmptyPoolsArray()&#39;);</span>
 171 |     | <span class='unexecuted'>        uint128[] memory token0Fees = new uint128[](collectPools.length);</span>
 172 |     | <span class='unexecuted'>        uint128[] memory token1Fees = new uint128[](collectPools.length);</span>
 173 |     | <span class='unexecuted'>        for (uint i; i &lt; collectPools.length; i++) {</span>
 174 |     | <span class='unexecuted'>            (token0Fees[i], token1Fees[i]) = ICoverPool(collectPools[i]).fees(0,0,false);</span>
 175 |     | <span class='neutral'>        }</span>
 176 |     | <span class='unexecuted'>        emit ProtocolFeesCollected(collectPools, token0Fees, token1Fees);</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='unexecuted'>    function modifyProtocolFees(</span>
 180 |     | <span class='neutral'>        address[] calldata modifyPools,</span>
 181 |     | <span class='neutral'>        uint16[] calldata syncFees,</span>
 182 |     | <span class='neutral'>        uint16[] calldata fillFees,</span>
 183 |     | <span class='neutral'>        bool[] calldata setFees</span>
 184 |     | <span class='unexecuted'>    ) external onlyOwner {</span>
 185 |     | <span class='unexecuted'>        if (modifyPools.length == 0) require (false, &#39;EmptyPoolsArray()&#39;);</span>
 186 |     | <span class='unexecuted'>        if (modifyPools.length != syncFees.length</span>
 187 |     | <span class='unexecuted'>            || syncFees.length != fillFees.length</span>
 188 |     | <span class='unexecuted'>            || fillFees.length != setFees.length) {</span>
 189 |     | <span class='unexecuted'>            require (false, &#39;MismatchedArrayLengths()&#39;);</span>
 190 |     | <span class='neutral'>        }</span>
 191 |     | <span class='unexecuted'>        uint128[] memory token0Fees = new uint128[](modifyPools.length);</span>
 192 |     | <span class='unexecuted'>        uint128[] memory token1Fees = new uint128[](modifyPools.length);</span>
 193 |     | <span class='unexecuted'>        for (uint i; i &lt; modifyPools.length; i++) {</span>
 194 |     | <span class='unexecuted'>            if (syncFees[i] &gt; MAX_PROTOCOL_FEE) require (false, &#39;ProtocolFeeCeilingExceeded()&#39;);</span>
 195 |     | <span class='unexecuted'>            if (fillFees[i] &gt; MAX_PROTOCOL_FEE) require (false, &#39;ProtocolFeeCeilingExceeded()&#39;);</span>
 196 |     | <span class='unexecuted'>            (</span>
 197 |     | <span class='unexecuted'>                token0Fees[i],</span>
 198 |     | <span class='unexecuted'>                token1Fees[i]</span>
 199 |     | <span class='unexecuted'>            ) =ICoverPool(modifyPools[i]).fees(</span>
 200 |     | <span class='unexecuted'>                syncFees[i],</span>
 201 |     | <span class='unexecuted'>                fillFees[i],</span>
 202 |     | <span class='unexecuted'>                setFees[i]</span>
 203 |     | <span class='neutral'>            );</span>
 204 |     | <span class='neutral'>        }</span>
 205 |     | <span class='unexecuted'>        emit ProtocolFeesModified(modifyPools, syncFees, fillFees, setFees, token0Fees, token1Fees);</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='unexecuted'>    function poolTypes(</span>
 209 |     | <span class='neutral'>        bytes32 poolType</span>
 210 |     | <span class='neutral'>    ) external view returns (</span>
 211 |     | <span class='unexecuted'>        address implAddress,</span>
 212 |     | <span class='unexecuted'>        address sourceAddress</span>
 213 |     | <span class='neutral'>    ) {</span>
 214 |     | <span class='unexecuted'>        return (_poolTypes[poolType], _twapSources[poolType]);</span>
 215 |     | <span class='neutral'>    }</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='unexecuted'>    function volatilityTiers(</span>
 218 |     | <span class='neutral'>        bytes32 implName,</span>
 219 |     | <span class='neutral'>        uint16 feeTier,</span>
 220 |     | <span class='neutral'>        int16 tickSpread,</span>
 221 |     | <span class='neutral'>        uint16 twapLength</span>
 222 |     | <span class='neutral'>    ) external view returns (</span>
 223 |     | <span class='unexecuted'>        VolatilityTier memory config</span>
 224 |     | <span class='neutral'>    ) {</span>
 225 |     | <span class='unexecuted'>        config = _volatilityTiers[implName][feeTier][tickSpread][twapLength];</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'>    </span>
 228 |     | <span class='neutral'>    /**</span>
 229 |     | <span class='neutral'>     * @dev Throws if the sender is not the owner.</span>
 230 |     | <span class='neutral'>     */</span>
 231 |     | <span class='unexecuted'>    function _checkOwner() internal view {</span>
 232 |     | <span class='unexecuted'>        if (owner != msg.sender) require (false, &#39;OwnerOnly()&#39;);</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>    /**</span>
 236 |     | <span class='neutral'>     * @dev Throws if the sender is not the feeTo.</span>
 237 |     | <span class='neutral'>     */</span>
 238 |     | <span class='unexecuted'>    function _checkFeeTo() internal view {</span>
 239 |     | <span class='unexecuted'>        if (feeTo != msg.sender) require (false, &#39;FeeToOnly()&#39;);</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'>}</span>

</code>
<br />

