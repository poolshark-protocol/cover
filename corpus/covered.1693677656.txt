/home/ec2-user/git/cover/contracts/CoverEchidnaPool.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './CoverPoolFactory.sol';
   5 |     | import './utils/CoverPoolManager.sol';
   6 |     | import './test/Token20.sol';
   7 |     | import './interfaces/structs/CoverPoolStructs.sol';
   8 |     | import './libraries/math/ConstantProduct.sol';
   9 |     | import './libraries/pool/MintCall.sol';
  10 |     | import './libraries/pool/BurnCall.sol';
  11 |     | import './test/UniswapV3FactoryMock.sol';
  12 |     | import './libraries/sources/UniswapV3Source.sol';
  13 |     | 
  14 |     | //TODO: make sure no assertions fail
  15 |     | //TODO: add the ability to change the TWAP randomly
  16 |     | 
  17 |     | // Fuzz CoverPool functionality
  18 | *r  | contract CoverEchidnaPool {
  19 |     | 
  20 |     |     event PassedMint();
  21 |     |     event PassedBurn();
  22 |     |     event Prices(uint160 price0, uint160 price1);
  23 |     |     event LiquidityGlobal(uint128 liqBefore, uint128 liqAfter);
  24 |     |     event Liquidity(uint128 liq0Before, uint128 liq1Before, uint128 liq0After, uint128 liq1After);
  25 |     |     event PositionTicks(int24 lower, int24 upper);
  26 |     |     event BurnTicks(int24 lower, int24 upper, bool positionExists);
  27 |     |     event LiquidityMinted(uint256 amount, uint256 tokenAmount, bool zeroForOne);
  28 |     |     event PositionCreated(bool isCreated);
  29 |     |     event AmountInDeltaMaxMinus(uint128 beforeDelta, uint128 afterDelta);
  30 |     |     event AmountOutDeltaMaxMinus(uint128 beforeDelta, uint128 afterDelta);
  31 |     |     event LiquidityDeltaAndDeltaMaxMinus(int128 delta, uint128 abs);
  32 |     |     event Deployed(address contractAddress);
  33 |     | 
  34 |     |     int16 tickSpacing;
  35 |     |     uint16 swapFee;
  36 |     |     address private implementation;
  37 |     |     address private poolMock;
  38 |     |     address private poolFactoryMock;
  39 |     |     address private twapSource;
  40 |     |     CoverPoolFactory private factory;
  41 |     |     CoverPoolManager private manager;
  42 |     |     CoverPool private pool;
  43 |     |     Token20 private token0;
  44 |     |     Token20 private token1;
  45 |     |     Token20 private tokenIn;
  46 |     |     Token20 private tokenOut;
  47 |     |     Position[] private positions;
  48 |     | 
  49 |     |     struct LiquidityDeltaValues {
  50 |     |         int128 liquidityDeltaLowerBefore;
  51 |     |         int128 liquidityDeltaUpperBefore;
  52 |     |         int128 liquidityDeltaLowerAfter;
  53 |     |         int128 liquidityDeltaUpperAfter;
  54 |     |     }
  55 |     | 
  56 |     |     struct PoolValues {
  57 |     |         uint160 price0Before;
  58 |     |         uint128 liquidity0Before;
  59 |     |         uint160 price1Before;
  60 |     |         uint128 liquidity1Before;
  61 |     |         uint160 price0After;
  62 |     |         uint128 liquidity0After;
  63 |     |         uint160 price1After;
  64 |     |         uint128 liquidity1After;
  65 |     | 
  66 |     |         uint128 liquidityGlobalBefore;
  67 |     |         uint128 liquidityGlobalAfter;
  68 |     | 
  69 |     |         // CoverPoolStructs.PoolState pool0Before;
  70 |     |         // CoverPoolStructs.PoolState pool1Before;
  71 |     |         // CoverPoolStructs.GlobalState stateBefore;
  72 |     |         // CoverPoolStructs.GlobalState stateAfter;
  73 |     | 
  74 |     |         // CoverPoolStructs.Tick tickLowerBefore;
  75 |     |         // CoverPoolStructs.Tick tickUpperBefore;
  76 |     |         // CoverPoolStructs.Tick tickLowerAfter;
  77 |     |         // CoverPoolStructs.Tick tickUpperAfter;
  78 |     | 
  79 |     |         uint128 amountInDeltaMaxMinusUpperBefore;
  80 |     |         uint128 amountInDeltaMaxMinusLowerBefore;
  81 |     |         uint128 amountInDeltaMaxMinusUpperAfter;
  82 |     |         uint128 amountInDeltaMaxMinusLowerAfter;
  83 |     | 
  84 |     |         uint128 amountOutDeltaMaxMinusUpperBefore;
  85 |     |         uint128 amountOutDeltaMaxMinusLowerBefore;
  86 |     |         uint128 amountOutDeltaMaxMinusUpperAfter;
  87 |     |         uint128 amountOutDeltaMaxMinusLowerAfter;
  88 |     | 
  89 |     |         uint160 price0;
  90 |     |         uint160 price1;
  91 |     | 
  92 |     |         uint32 positionIdNextBefore;
  93 |     |         uint32 positionIdNextAfter;
  94 |     |     }
  95 |     | 
  96 |     |     struct SwapCallbackData {
  97 |     |         address sender;
  98 |     |     }
  99 |     | 
 100 |     |     struct Position {
 101 |     |         address owner;
 102 |     |         uint32 positionId;
 103 |     |         int24 lower;
 104 |     |         int24 upper;
 105 |     |         bool zeroForOne;
 106 |     |     }
 107 |     | 
 108 |     |     struct PoolStructs {
 109 |     |         CoverPoolStructs.Tick lower;
 110 |     |         CoverPoolStructs.Tick upper;
 111 |     |         CoverPoolStructs.PoolState pool0;
 112 |     |         CoverPoolStructs.PoolState pool1;
 113 |     |         CoverPoolStructs.GlobalState state;
 114 |     |     }
 115 |     | 
 116 |     |     modifier tickPreconditions(int24 lower, int24 upper) {
 117 | *r  |         require(lower < upper);
 118 | *r  |         require(upper < 887272);
 119 | *r  |         require(lower > -887272);
 120 | *r  |         require(lower % tickSpacing == 0);
 121 | *r  |         require(upper % tickSpacing == 0);
 122 |     |         _;
 123 |     |     }
 124 |     | 
 125 |     |     constructor() {
 126 |     |         manager = new CoverPoolManager();
 127 |     |         factory = new CoverPoolFactory(address(manager));
 128 |     |         implementation = address(new CoverPool(address(factory)));
 129 |     |         tokenIn = new Token20("IN", "IN", 18);
 130 |     |         tokenOut = new Token20("OUT", "OUT", 18);
 131 |     |         (token0, token1) = address(tokenIn) < address(tokenOut) ? (tokenIn, tokenOut) 
 132 |     |                                                                 : (tokenOut, tokenIn);
 133 |     | 
 134 |     |         // mock sources
 135 |     |         poolFactoryMock = address(new UniswapV3FactoryMock(address(tokenIn), address(tokenOut)));
 136 |     |         twapSource = address(new UniswapV3Source(poolFactoryMock));
 137 |     | 
 138 |     |         poolMock = UniswapV3FactoryMock(poolFactoryMock).getPool(address(token0), address(token1), 500);
 139 |     |         emit Deployed(UniswapV3FactoryMock(poolFactoryMock).getPool(address(token0), address(token1), 500));
 140 |     |         UniswapV3PoolMock(poolMock).setObservationCardinality(5, 5);
 141 |     | 
 142 |     |         CoverPoolStructs.VolatilityTier memory volTier = CoverPoolStructs.VolatilityTier({
 143 |     |             minAmountPerAuction: 0,
 144 |     |             auctionLength: 5,
 145 |     |             blockTime: 1000,
 146 |     |             syncFee: 0,
 147 |     |             fillFee: 0,
 148 |     |             minPositionWidth: 1,
 149 |     |             minAmountLowerPriced: true
 150 |     |         });
 151 |     |         
 152 |     |         // add pool type
 153 |     |         manager.enablePoolType(bytes32(uint256(0x1)), address(implementation), twapSource);
 154 |     |         manager.enableVolatilityTier(bytes32(uint256(0x1)), 500, 20, 5, volTier);
 155 |     |         tickSpacing = 20;
 156 |     |         ICoverPoolFactory.CoverPoolParams memory params;
 157 |     |         params.poolType = bytes32(uint256(0x1));
 158 |     |         params.tokenIn = address(tokenIn);
 159 |     |         params.tokenOut = address(tokenOut);
 160 |     |         params.feeTier = 500;
 161 |     |         params.tickSpread = 20;
 162 |     |         params.twapLength = 5;
 163 |     | 
 164 |     |         // launch pool
 165 |     |         address poolAddr = factory.createCoverPool(params);
 166 |     |         pool = CoverPool(poolAddr);
 167 |     |     }
 168 |     | 
 169 | *   |     function mint(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {
 170 |     |         // PRE CONDITIONS
 171 | *   |         mintAndApprove();
 172 | *   |         amount = amount + 1;
 173 |     |         // // Ensure the newly created position is using different ticks
 174 | *   |         for(uint i = 0; i < positions.length;) {
 175 | *   |             if(positions[i].owner == msg.sender && positions[i].lower == lower && positions[i].upper == upper && positions[i].zeroForOne == zeroForOne) {
 176 |     |                 revert("Position already exists");
 177 |     |             }
 178 |     |             unchecked {
 179 | *   |                 ++i;
 180 |     |             }
 181 |     |         }
 182 |     | 
 183 | *   |         PoolValues memory poolValues;
 184 | *   |         PoolStructs memory poolStructs;
 185 | *   |         LiquidityDeltaValues memory values;
 186 |     |         
 187 |     |         // storage structs
 188 | *   |         poolStructs.pool0 = getPoolState(true);
 189 | *   |         poolStructs.pool1 = getPoolState(false);
 190 | *   |         poolStructs.state = getGlobalState();
 191 | *   |         poolStructs.lower = getTick(lower);
 192 | *   |         poolStructs.upper = getTick(upper);
 193 |     | 
 194 |     |         // pool price and liquidity
 195 | *   |         poolValues.price0Before = poolStructs.pool0.price;
 196 | *   |         poolValues.liquidity0Before = poolStructs.pool0.liquidity;
 197 | *   |         poolValues.price1Before = poolStructs.pool1.price;
 198 | *   |         poolValues.liquidity1Before = poolStructs.pool1.liquidity;
 199 | *   |         poolValues.liquidityGlobalBefore = poolStructs.state.liquidityGlobal;
 200 |     | 
 201 |     |         // tick values
 202 | *   |         values.liquidityDeltaLowerBefore = poolStructs.lower.liquidityDelta;
 203 | *   |         values.liquidityDeltaUpperBefore = poolStructs.upper.liquidityDelta;
 204 | *   |         poolValues.amountInDeltaMaxMinusLowerBefore = poolStructs.lower.amountInDeltaMaxMinus;
 205 | *   |         poolValues.amountInDeltaMaxMinusUpperBefore = poolStructs.upper.amountInDeltaMaxMinus;
 206 | *   |         poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;
 207 | *   |         poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;
 208 |     | 
 209 | *   |         ICoverPool.MintParams memory params;
 210 | *   |         params.to = msg.sender;
 211 | *   |         params.amount = amount;
 212 | *   |         params.positionId = 0;
 213 | *   |         params.lower = lower;
 214 | *   |         params.upper = upper;
 215 | *   |         params.zeroForOne = zeroForOne;
 216 |     | 
 217 |     |         // Get the ticks the position will be minted with rather than what was passed directly by fuzzer
 218 |     |         // This is so the we can properly compare before and after mint states of particular ticks.
 219 | *   |         bool posCreated;
 220 | *   |         (lower, upper, posCreated) = pool.getResizedTicksForMint(params);
 221 |     |         //TODO: amount can change as well here so we should change this functionality or account for the change
 222 | *   |         emit PositionTicks(lower, upper);
 223 | *   |         emit PositionCreated(posCreated);
 224 |     | 
 225 |     |         // ACTION 
 226 | *r  |         pool.mint(params);
 227 | *   |         if (posCreated) positions.push(Position(msg.sender, poolValues.positionIdNextBefore, lower, upper, zeroForOne));
 228 |     | 
 229 |     |         // storage structs
 230 | *   |         poolStructs.pool0 = getPoolState(true);
 231 | *   |         poolStructs.pool1 = getPoolState(false);
 232 | *   |         poolStructs.state = getGlobalState();
 233 | *   |         poolStructs.lower = getTick(lower);
 234 | *   |         poolStructs.upper = getTick(upper);
 235 |     | 
 236 |     |         // pool price and liquidity
 237 | *   |         poolValues.price0After = poolStructs.pool0.price;
 238 | *   |         poolValues.liquidity0After = poolStructs.pool0.liquidity;
 239 | *   |         poolValues.price1After = poolStructs.pool1.price;
 240 | *   |         poolValues.liquidity1After = poolStructs.pool1.liquidity;
 241 | *   |         poolValues.liquidityGlobalAfter = poolStructs.state.liquidityGlobal;
 242 |     | 
 243 |     |         // tick values
 244 | *   |         values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;
 245 | *   |         values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;
 246 | *   |         poolValues.amountInDeltaMaxMinusLowerAfter = poolStructs.lower.amountInDeltaMaxMinus;
 247 | *   |         poolValues.amountInDeltaMaxMinusUpperAfter = poolStructs.upper.amountInDeltaMaxMinus;
 248 | *   |         poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;
 249 | *   |         poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;
 250 |     |         
 251 |     |         // POST CONDITIONS
 252 | *   |         emit Prices(poolValues.price0, poolValues.price1);
 253 | *   |         assert(poolValues.price0 >= poolValues.price1);
 254 |     | 
 255 |     |         // Ensure prices have not crossed
 256 | *   |         emit Prices(poolValues.price0After, poolValues.price1After);
 257 | *   |         assert(poolValues.price0After >= poolValues.price1After);
 258 |     |         
 259 |     |         // Ensure that amountOutDeltaMaxMinus is incremented when not undercutting
 260 |     |         //NOTE: delta max minus should be strictly greater as both values should be non-zero
 261 |     |         if (posCreated) {
 262 |     |             emit PositionTicks(lower, upper);
 263 |     |             // Ensure positions ticks arent crossed
 264 |     |             assert(lower < upper);
 265 |     |             // Ensure minted ticks on proper tick spacing
 266 |     |             assert((lower % tickSpacing == 0) && (upper % tickSpacing == 0));
 267 |     | 
 268 |     |             // check delta maxes
 269 |     |             if(zeroForOne){
 270 |     |                 emit AmountInDeltaMaxMinus(poolValues.amountInDeltaMaxMinusLowerBefore, poolValues.amountInDeltaMaxMinusLowerAfter);
 271 |     |                 assert(poolValues.amountInDeltaMaxMinusLowerAfter > poolValues.amountInDeltaMaxMinusLowerBefore);
 272 |     |                 emit AmountOutDeltaMaxMinus(poolValues.amountOutDeltaMaxMinusLowerBefore, poolValues.amountOutDeltaMaxMinusLowerAfter);
 273 |     |                 assert(poolValues.amountOutDeltaMaxMinusLowerAfter > poolValues.amountOutDeltaMaxMinusLowerBefore);
 274 |     |             } else {
 275 |     |                 emit AmountInDeltaMaxMinus(poolValues.amountInDeltaMaxMinusUpperBefore, poolValues.amountInDeltaMaxMinusUpperAfter);
 276 |     |                 assert(poolValues.amountInDeltaMaxMinusUpperAfter > poolValues.amountInDeltaMaxMinusUpperBefore);
 277 |     |                 emit AmountOutDeltaMaxMinus(poolValues.amountOutDeltaMaxMinusUpperBefore, poolValues.amountOutDeltaMaxMinusUpperAfter);
 278 |     |                 assert(poolValues.amountOutDeltaMaxMinusUpperAfter > poolValues.amountOutDeltaMaxMinusUpperBefore);
 279 |     |             }
 280 |     |             emit LiquidityGlobal(poolValues.liquidityGlobalBefore, poolValues.liquidityGlobalAfter);
 281 |     |             //emit Liquidity(poolValues.liquidity0Before, poolValues.liquidity1Before, poolValues.liquidity0After, poolValues.liquidity1After);
 282 |     |             // Ensure liquidityGlobal is incremented after mint
 283 |     |             assert(poolValues.liquidityGlobalAfter > poolValues.liquidityGlobalBefore);
 284 |     |         }
 285 |     |         // Ensure pool liquidity is non-zero after mint with no undercuts
 286 |     |         // if (zeroForOne) {
 287 |     |         //     if (poolValues.price0After < poolValues.price0Before) assert(poolValues.liquidity0After > 0);
 288 |     |         // }
 289 |     |         // else {
 290 |     |         //     if (poolValues.price1After > poolValues.price1Before) assert(poolValues.liquidity1After > 0);
 291 |     |         // }
 292 |     |     }
 293 |     | 
 294 | *   |     function mintVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {
 295 |     |         // PRE CONDITIONS
 296 |     |         // check if it's going to sync beforehand
 297 | *   |         mintAndApprove();
 298 | *   |         amount = amount + 1;
 299 |     |         // Ensure the newly created position is using different ticks
 300 | *   |         for(uint i = 0; i < positions.length;) {
 301 | *   |             if(positions[i].owner == msg.sender && positions[i].lower == lower && positions[i].upper == upper && positions[i].zeroForOne == zeroForOne) {
 302 |     |                 revert("Position already exists");
 303 |     |             }
 304 |     |             unchecked {
 305 | *   |                 ++i;
 306 |     |             }
 307 |     |         }
 308 |     | 
 309 | *   |         PoolValues memory poolValues;
 310 | *   |         PoolStructs memory poolStructs;
 311 | *   |         LiquidityDeltaValues memory values;
 312 |     | 
 313 |     |         // storage structs
 314 | *   |         poolStructs.pool0 = getPoolState(true);
 315 | *   |         poolStructs.pool1 = getPoolState(false);
 316 | *   |         poolStructs.state = getGlobalState();
 317 | *   |         poolStructs.lower = getTick(lower);
 318 | *   |         poolStructs.upper = getTick(upper);
 319 |     | 
 320 |     |         // pool price and liquidity
 321 | *   |         poolValues.price0Before = poolStructs.pool0.price;
 322 | *   |         poolValues.liquidity0Before = poolStructs.pool0.liquidity;
 323 | *   |         poolValues.price1Before = poolStructs.pool1.price;
 324 | *   |         poolValues.liquidity1Before = poolStructs.pool1.liquidity;
 325 | *   |         poolValues.liquidityGlobalBefore = poolStructs.state.liquidityGlobal;
 326 |     | 
 327 |     |         // tick values
 328 | *   |         values.liquidityDeltaLowerBefore = poolStructs.lower.liquidityDelta;
 329 | *   |         values.liquidityDeltaUpperBefore = poolStructs.upper.liquidityDelta;
 330 | *   |         poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;
 331 | *   |         poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;
 332 |     | 
 333 | *   |         ICoverPool.MintParams memory params;
 334 | *   |         params.to = msg.sender;
 335 | *   |         params.amount = amount;
 336 | *   |         params.lower = lower;
 337 | *   |         params.upper = upper;
 338 | *   |         params.zeroForOne = zeroForOne;
 339 |     | 
 340 |     |         // Get the ticks the position will be minted with rather than what was passed directly by fuzzer
 341 |     |         // This is so the we can properly compare before and after mint states of particular ticks.
 342 | *   |         bool posCreated;
 343 | *   |         (lower, upper, posCreated) = pool.getResizedTicksForMint(params);
 344 | *   |         emit PositionTicks(lower, upper);
 345 | *   |         emit PositionCreated(posCreated);
 346 |     | 
 347 |     |         // ACTION 
 348 | *r  |         pool.mint(params);
 349 | *   |         if (posCreated) positions.push(Position(msg.sender, poolValues.positionIdNextBefore, lower, upper, zeroForOne));
 350 |     | 
 351 |     |         // pool price and liquidity
 352 | *   |         poolValues.price0After = poolStructs.pool0.price;
 353 | *   |         poolValues.liquidity0After = poolStructs.pool0.liquidity;
 354 | *   |         poolValues.price1After = poolStructs.pool1.price;
 355 | *   |         poolValues.liquidity1After = poolStructs.pool1.liquidity;
 356 | *   |         poolValues.liquidityGlobalAfter = poolStructs.state.liquidityGlobal;
 357 |     | 
 358 |     |         // tick values
 359 | *   |         values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;
 360 | *   |         values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;
 361 | *   |         poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;
 362 | *   |         poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;
 363 |     | 
 364 |     |         // POST CONDITIONS
 365 | *   |         emit Prices(poolValues.price0, poolValues.price1);
 366 | *   |         assert(poolValues.price0 >= poolValues.price1);
 367 | *   |         emit Prices(poolValues.price0After, poolValues.price1After);
 368 |     | 
 369 |     |         // Ensure liquidityDelta is always less or equal to amountOutDeltaMaxMinus
 370 | *   |         if(zeroForOne){
 371 | *   |             emit AmountInDeltaMaxMinus(poolValues.amountOutDeltaMaxMinusLowerBefore, poolValues.amountOutDeltaMaxMinusLowerAfter);
 372 | *   |             assert(poolValues.amountOutDeltaMaxMinusLowerAfter >= poolValues.amountOutDeltaMaxMinusLowerBefore);
 373 | *   |             emit AmountOutDeltaMaxMinus(poolValues.amountOutDeltaMaxMinusLowerBefore, poolValues.amountOutDeltaMaxMinusLowerAfter);
 374 | *   |             assert(poolValues.amountOutDeltaMaxMinusLowerAfter >= poolValues.amountOutDeltaMaxMinusLowerBefore);
 375 |     |         } else {
 376 | *   |             emit AmountInDeltaMaxMinus(poolValues.amountOutDeltaMaxMinusUpperBefore, poolValues.amountOutDeltaMaxMinusUpperAfter);
 377 | *   |             assert(poolValues.amountOutDeltaMaxMinusUpperAfter >= poolValues.amountOutDeltaMaxMinusUpperBefore);
 378 | *   |             emit AmountOutDeltaMaxMinus(poolValues.amountOutDeltaMaxMinusUpperBefore, poolValues.amountOutDeltaMaxMinusUpperAfter);
 379 | *   |             assert(poolValues.amountOutDeltaMaxMinusUpperAfter >= poolValues.amountOutDeltaMaxMinusUpperBefore);
 380 |     |         }
 381 |     | 
 382 |     |         // Ensure prices have not crossed
 383 | *   |         assert(poolValues.price0After >= poolValues.price1After);
 384 | *   |         if (posCreated) {
 385 | *   |             emit PositionTicks(lower, upper);
 386 |     |             // Ensure positions ticks arent crossed
 387 | *   |             assert(lower < upper);
 388 |     |             // Ensure minted ticks on proper tick spacing
 389 | *   |             assert((lower % tickSpacing == 0) && (upper % tickSpacing == 0));
 390 |     |         }
 391 |     |         
 392 | *   |         emit LiquidityGlobal(poolValues.liquidityGlobalBefore, poolValues.liquidityGlobalAfter);
 393 | *   |         emit Liquidity(poolValues.liquidity0Before, poolValues.liquidity1Before, poolValues.liquidity0After, poolValues.liquidity1After);
 394 |     |         
 395 |     |         // Ensure liquidityGlobal is incremented after mint
 396 | *   |         assert(poolValues.liquidityGlobalAfter >= poolValues.liquidityGlobalBefore);
 397 |     | 
 398 |     |         // Ensure pool liquidity is non-zero after mint with no undercuts
 399 | *   |         if (zeroForOne) {
 400 | *   |             if (poolValues.price0After < poolValues.price0Before) assert(poolValues.liquidity0After > 0);
 401 |     |         }
 402 |     |         else {
 403 | *   |             if (poolValues.price1After > poolValues.price1Before) assert(poolValues.liquidity1After > 0);
 404 |     |         }
 405 |     |     }
 406 |     | 
 407 | *   |     function swap(uint160 priceLimit, uint128 amount, bool zeroForOne) public {
 408 |     |         // PRE CONDITIONS
 409 | *   |         mintAndApprove();
 410 |     | 
 411 | *   |         CoverPoolStructs.SwapParams memory params;
 412 | *   |         params.to = msg.sender;
 413 | *   |         params.priceLimit = priceLimit;
 414 | *   |         params.amount = amount;
 415 | *   |         params.exactIn = true; // TODO: exactIn always true for now
 416 | *   |         params.zeroForOne = zeroForOne;
 417 | *   |         params.callbackData = abi.encodePacked(address(this));
 418 |     |         
 419 |     |         // ACTION
 420 | *r  |         pool.swap(params);
 421 |     | 
 422 |     |         // POST CONDITIONS
 423 |     |         CoverPoolStructs.PoolState memory pool0 = getPoolState(true);
 424 |     |         CoverPoolStructs.PoolState memory pool1 = getPoolState(false);
 425 |     |         uint160 price0 = pool0.price;
 426 |     |         uint160 price1 = pool1.price;
 427 |     |         
 428 |     |         // Ensure prices never cross
 429 |     |         emit Prices(price0, price1);
 430 |     |         assert(price0 <= price1);
 431 |     |     }
 432 |     | 
 433 | *   |     function syncTick(int24 newLatestTick, bool autoSync) public  {
 434 | *   |         UniswapV3PoolMock(poolMock).setTickCumulatives(
 435 | *   |             newLatestTick * 10,
 436 | *   |             newLatestTick * 8,
 437 | *   |             newLatestTick * 7,
 438 | *   |             newLatestTick * 5
 439 |     |         );
 440 |     | 
 441 | *   |         if (autoSync) {
 442 |     |             // quote of 0 should start at new tick
 443 |     |             //TODO: find new latest tick based on auction depth
 444 | *   |             CoverPoolStructs.SwapParams memory params;
 445 | *   |             params.to = msg.sender;
 446 | *   |             params.priceLimit = 0;
 447 | *   |             params.amount = 0;
 448 | *   |             params.exactIn = true;
 449 | *   |             params.zeroForOne = true;
 450 | *   |             params.callbackData = abi.encodePacked(address(this));
 451 |     |         
 452 |     |             // ACTION
 453 | *r  |             pool.swap(params);
 454 |     | 
 455 |     |             // POST CONDITIONS
 456 |     |             //TODO: find new latest tick based on auction depth
 457 |     |             //new latestTick should match
 458 |     |             //if there was liquidity delta on that tick it should be unlocked
 459 |     |             //amountInDelta should be zeroed out if tick moved
 460 |     |             PoolStructs memory poolStructs;
 461 |     |             poolStructs.pool0 = getPoolState(true);
 462 |     |             poolStructs.pool1 = getPoolState(false);
 463 |     |             poolStructs.state = getGlobalState();
 464 |     |             emit Prices(poolStructs.pool0.price, poolStructs.pool1.price);
 465 |     |             assert(poolStructs.pool0.price <= poolStructs.pool1.price);
 466 |     |         }
 467 |     |     }
 468 |     | 
 469 | *   |     function burn(int24 claimAt, uint256 positionIndex, uint128 burnPercent) public {
 470 |     |         // PRE CONDITIONS
 471 | *   |         positionIndex = positionIndex % positions.length;
 472 | *   |         Position memory pos = positions[positionIndex];
 473 | *r  |         require(claimAt >= pos.lower && claimAt <= pos.upper);
 474 | *r  |         require(claimAt % tickSpacing == 0);
 475 | *   |         PoolStructs memory poolStructs;
 476 | *   |         PoolValues memory poolValues;
 477 |     | 
 478 | *   |         poolStructs.pool0 = getPoolState(true);
 479 | *   |         poolStructs.pool1 = getPoolState(false);
 480 | *   |         poolStructs.state = getGlobalState();
 481 | *   |         poolStructs.lower = getTick(pos.lower);
 482 | *   |         poolStructs.upper = getTick(pos.upper);
 483 |     | 
 484 | *   |         ICoverPool.BurnParams memory params;
 485 | *   |         params.to = pos.owner;
 486 | *   |         params.burnPercent = burnPercent == 1e38 ? burnPercent : _between(burnPercent, 1e36, 1e38); //1e38;
 487 | *   |         params.positionId = pos.positionId;
 488 | *   |         params.claim = claimAt;
 489 | *   |         params.zeroForOne = pos.zeroForOne;
 490 |     | 
 491 | *   |         poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;
 492 | *   |         poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;
 493 | *   |         poolValues.liquidityGlobalBefore = poolStructs.state.liquidityGlobal;
 494 |     |         
 495 | *   |         emit PositionTicks(pos.lower, pos.upper);
 496 | *   |         (int24 lower, int24 upper, bool positionExists) = pool.getResizedTicksForBurn(params);
 497 | *   |         emit BurnTicks(lower, upper, positionExists);
 498 |     | 
 499 |     |         // ACTION
 500 | *r  |         pool.burn(params);
 501 |     |         if (!positionExists) {
 502 |     |             positions[positionIndex] = positions[positions.length - 1];
 503 |     |             delete positions[positions.length - 1];
 504 |     |         }
 505 |     |         else {
 506 |     |             // Update position data in array if not fully burned
 507 |     |             positions[positionIndex] = Position(pos.owner, pos.positionId, lower, upper, pos.zeroForOne);
 508 |     |             // Ensure positions ticks arent crossed
 509 |     |             assert(lower < upper);
 510 |     |             // Ensure minted ticks on proper tick spacing
 511 |     |             assert((lower % tickSpacing == 0) && (upper % tickSpacing == 0));
 512 |     |         }
 513 |     | 
 514 |     |         poolStructs.pool0 = getPoolState(true);
 515 |     |         poolStructs.pool1 = getPoolState(false);
 516 |     |         poolStructs.state = getGlobalState();
 517 |     |         poolStructs.lower = getTick(pos.lower);
 518 |     |         poolStructs.upper = getTick(pos.upper);
 519 |     | 
 520 |     |         poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;
 521 |     |         poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;
 522 |     |         poolValues.liquidityGlobalAfter = poolStructs.state.liquidityGlobal;
 523 |     | 
 524 |     |         uint160 price0 = poolStructs.pool0.price;
 525 |     |         uint160 price1 = poolStructs.pool1.price;
 526 |     |         
 527 |     |         // POST CONDITIONS
 528 |     | 
 529 |     |         // Ensure prices never cross
 530 |     |         emit Prices(price0, price1);
 531 |     |         assert(price0 <= price1);
 532 |     | 
 533 |     |         // Ensure liquidityGlobal is decremented after burn
 534 |     |         emit LiquidityGlobal(poolValues.liquidityGlobalBefore, poolValues.liquidityGlobalAfter);
 535 |     |         assert((poolValues.liquidityGlobalAfter <= poolValues.liquidityGlobalBefore));
 536 |     |     }
 537 |     | 
 538 | *   |     function claim(int24 claimAt, uint256 positionIndex) public {
 539 |     |         // PRE CONDITIONS
 540 | *   |         positionIndex = positionIndex % positions.length;
 541 | *   |         Position memory pos = positions[positionIndex];
 542 | *   |         claimAt = pos.lower + (claimAt % (pos.upper - pos.lower));
 543 | *r  |         require(claimAt % tickSpacing == 0);
 544 |     | 
 545 |     |         // PoolValues memory poolValues;
 546 | *   |         PoolStructs memory poolStructs;
 547 |     | 
 548 | *   |         poolStructs.pool0 = getPoolState(true);
 549 | *   |         poolStructs.pool1 = getPoolState(false);
 550 | *   |         poolStructs.state = getGlobalState();
 551 | *   |         poolStructs.lower = getTick(pos.lower);
 552 | *   |         poolStructs.upper = getTick(pos.upper);
 553 |     | 
 554 | *   |         ICoverPool.BurnParams memory params;
 555 | *   |         params.to = pos.owner;
 556 | *   |         params.burnPercent = 0;
 557 | *   |         params.positionId = pos.positionId;
 558 | *   |         params.claim = claimAt;
 559 | *   |         params.zeroForOne = pos.zeroForOne;
 560 |     |         
 561 | *   |         emit PositionTicks(pos.lower, pos.upper);
 562 | *   |         (int24 lower, int24 upper, bool positionExists) = pool.getResizedTicksForBurn(params);
 563 | *   |         emit BurnTicks(lower, upper, positionExists);
 564 |     | 
 565 |     |         // ACTION
 566 | *r  |         pool.burn(params);
 567 |     |         if (!positionExists) {
 568 |     |             positions[positionIndex] = positions[positions.length - 1];
 569 |     |             delete positions[positions.length - 1];
 570 |     |         }
 571 |     |         else {
 572 |     |             // Update position data in array if not fully burned
 573 |     |             positions[positionIndex] = Position(pos.owner, pos.positionId, lower, upper, pos.zeroForOne);
 574 |     |             // Ensure positions ticks arent crossed
 575 |     |             assert(lower < upper);
 576 |     |             // Ensure minted ticks on proper tick spacing
 577 |     |             assert((lower % tickSpacing == 0) && (upper % tickSpacing == 0));
 578 |     |         }
 579 |     | 
 580 |     |         // POST CONDITIONS
 581 |     |         poolStructs.pool0 = getPoolState(true);
 582 |     |         poolStructs.pool1 = getPoolState(false);
 583 |     |         poolStructs.state = getGlobalState();
 584 |     |         poolStructs.lower = getTick(pos.lower);
 585 |     |         poolStructs.upper = getTick(pos.upper);
 586 |     | 
 587 |     |         uint160 price0 = poolStructs.pool0.price;
 588 |     |         uint160 price1 = poolStructs.pool1.price;
 589 |     | 
 590 |     |         // Ensure prices never cross
 591 |     |         emit Prices(price0, price1);
 592 |     |         assert(price0 <= price1);
 593 |     |     }
 594 |     | 
 595 | *   |     function mintThenBurnZeroLiquidityChangeVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {
 596 |     |         // PRE CONDITIONS
 597 | *   |         mintAndApprove();
 598 | *   |         PoolValues memory poolValues;
 599 | *   |         PoolStructs memory poolStructs;
 600 | *   |         LiquidityDeltaValues memory values;
 601 |     | 
 602 | *   |         poolStructs.pool0 = getPoolState(true);
 603 | *   |         poolStructs.pool1 = getPoolState(false);
 604 | *   |         poolStructs.state = getGlobalState();
 605 | *   |         poolStructs.lower = getTick(lower);
 606 | *   |         poolStructs.upper = getTick(upper);
 607 |     | 
 608 | *   |         poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;
 609 | *   |         poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;
 610 |     | 
 611 |     |         // ACTION 
 612 | *   |         mintVariable(amount, zeroForOne, lower, upper);
 613 | *   |         emit PassedMint();
 614 | *   |         burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);
 615 |     |         emit PassedBurn();
 616 |     | 
 617 |     |         // POST CONDITIONS
 618 |     |         poolStructs.pool0 = getPoolState(true);
 619 |     |         poolStructs.pool1 = getPoolState(false);
 620 |     |         poolStructs.state = getGlobalState();
 621 |     |         poolStructs.lower = getTick(lower);
 622 |     |         poolStructs.upper = getTick(upper);
 623 |     | 
 624 |     |         values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;
 625 |     |         values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;
 626 |     |         poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;
 627 |     |         poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;
 628 |     | 
 629 |     |         uint160 price0After = poolStructs.pool0.price;
 630 |     |         uint160 price1After = poolStructs.pool1.price;
 631 |     |         poolValues.liquidityGlobalAfter = poolStructs.state.liquidityGlobal;
 632 |     | 
 633 |     |         // POST CONDITIONS
 634 |     | 
 635 |     |         // Ensure prices never cross
 636 |     |         emit Prices(price0After, price1After);
 637 |     |         assert(price0After <= price1After);
 638 |     | 
 639 |     |         // Ensure liquidityGlobal is decremented after burn
 640 |     |         // emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);
 641 |     |         // assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);
 642 |     |     }
 643 |     | 
 644 | *   |     function mintThenBurnZeroLiquidityChange(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {
 645 |     |         // PRE CONDITIONS
 646 | *   |         mintAndApprove();
 647 | *   |         PoolValues memory poolValues;
 648 | *   |         PoolStructs memory poolStructs;
 649 | *   |         LiquidityDeltaValues memory values;
 650 |     | 
 651 | *   |         poolStructs.pool0 = getPoolState(true);
 652 | *   |         poolStructs.pool1 = getPoolState(false);
 653 | *   |         poolStructs.state = getGlobalState();
 654 | *   |         poolStructs.lower = getTick(lower);
 655 | *   |         poolStructs.upper = getTick(upper);
 656 |     | 
 657 | *   |         poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;
 658 | *   |         poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;
 659 |     | 
 660 |     |         // ACTION 
 661 | *   |         mint(amount, zeroForOne, lower, upper);
 662 |     |         emit PassedMint();
 663 |     |         burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);
 664 |     |         emit PassedBurn();
 665 |     | 
 666 |     |         poolStructs.pool0 = getPoolState(true);
 667 |     |         poolStructs.pool1 = getPoolState(false);
 668 |     |         poolStructs.state = getGlobalState();
 669 |     |         poolStructs.lower = getTick(lower);
 670 |     |         poolStructs.upper = getTick(upper);
 671 |     | 
 672 |     |         values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;
 673 |     |         values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;
 674 |     |         poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;
 675 |     |         poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;
 676 |     | 
 677 |     |         uint160 price0After = poolStructs.pool0.price;
 678 |     |         uint160 price1After = poolStructs.pool1.price;
 679 |     |         
 680 |     |         // POST CONDITIONS
 681 |     | 
 682 |     |         // Ensure prices never cross
 683 |     |         emit Prices(price0After, price1After);
 684 |     |         assert(price0After <= price1After);
 685 |     | 
 686 |     |         // Ensure liquidityGlobal is decremented after burn
 687 |     |         // emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);
 688 |     |         // assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);
 689 |     |     }
 690 |     | 
 691 | *   |     function mintThenPartialBurnTwiceLiquidityChange(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint128 percent) public tickPreconditions(lower, upper) {
 692 |     |         // PRE CONDITIONS
 693 | *   |         percent = 1 + (percent % (1e38 - 1));
 694 | *   |         mintAndApprove();
 695 | *   |         PoolValues memory poolValues;
 696 | *   |         PoolStructs memory poolStructs;
 697 | *   |         LiquidityDeltaValues memory values;
 698 |     | 
 699 | *   |         poolStructs.pool0 = getPoolState(true);
 700 | *   |         poolStructs.pool1 = getPoolState(false);
 701 | *   |         poolStructs.state = getGlobalState();
 702 | *   |         poolStructs.lower = getTick(lower);
 703 | *   |         poolStructs.upper = getTick(upper);
 704 |     | 
 705 | *   |         poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;
 706 | *   |         poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;
 707 |     | 
 708 |     |         // ACTION 
 709 | *   |         mint(amount, zeroForOne, lower, upper);
 710 |     |         emit PassedMint();
 711 |     |         burn(zeroForOne ? lower : upper, positions.length - 1, percent);
 712 |     |         emit PassedBurn();
 713 |     |         burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);
 714 |     |         emit PassedBurn();
 715 |     | 
 716 |     |         poolStructs.pool0 = getPoolState(true);
 717 |     |         poolStructs.pool1 = getPoolState(false);
 718 |     |         poolStructs.state = getGlobalState();
 719 |     |         poolStructs.lower = getTick(lower);
 720 |     |         poolStructs.upper = getTick(upper);
 721 |     | 
 722 |     |         values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;
 723 |     |         values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;
 724 |     |         poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;
 725 |     |         poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;
 726 |     | 
 727 |     |         uint160 price0After = poolStructs.pool0.price;
 728 |     |         uint160 price1After = poolStructs.pool1.price;
 729 |     | 
 730 |     |         // POST CONDITIONS
 731 |     | 
 732 |     |         // Ensure prices never cross
 733 |     |         emit Prices(price0After, price1After);
 734 |     |         assert(price0After <= price1After);
 735 |     | 
 736 |     |         // Ensure liquidityGlobal is decremented after burn
 737 |     |         // emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);
 738 |     |         // assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);
 739 |     |     }
 740 |     | 
 741 | *   |     function mintThenPartialBurnTwiceLiquidityChangeVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint128 percent) public tickPreconditions(lower, upper) {
 742 |     |         // PRE CONDITIONS
 743 | *   |         percent = 1 + (percent % (1e38 - 1));
 744 | *   |         mintAndApprove();
 745 | *   |         PoolValues memory poolValues;
 746 | *   |         PoolStructs memory poolStructs;
 747 | *   |         LiquidityDeltaValues memory values;
 748 |     | 
 749 | *   |         poolStructs.pool0 = getPoolState(true);
 750 | *   |         poolStructs.pool1 = getPoolState(false);
 751 | *   |         poolStructs.state = getGlobalState();
 752 | *   |         poolStructs.lower = getTick(lower);
 753 | *   |         poolStructs.upper = getTick(upper);
 754 |     | 
 755 | *   |         poolValues.amountOutDeltaMaxMinusLowerBefore = poolStructs.lower.amountOutDeltaMaxMinus;
 756 | *   |         poolValues.amountOutDeltaMaxMinusUpperBefore = poolStructs.upper.amountOutDeltaMaxMinus;
 757 |     | 
 758 |     |         // ACTION 
 759 | *   |         mintVariable(amount, zeroForOne, lower, upper);
 760 | *   |         emit PassedMint();
 761 | *   |         burn(zeroForOne ? lower : upper, positions.length - 1, percent);
 762 |     |         emit PassedBurn();
 763 |     |         burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);
 764 |     |         emit PassedBurn();
 765 |     | 
 766 |     |         poolStructs.pool0 = getPoolState(true);
 767 |     |         poolStructs.pool1 = getPoolState(false);
 768 |     |         poolStructs.state = getGlobalState();
 769 |     |         poolStructs.lower = getTick(lower);
 770 |     |         poolStructs.upper = getTick(upper);
 771 |     | 
 772 |     |         values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;
 773 |     |         values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;
 774 |     |         poolValues.amountOutDeltaMaxMinusLowerAfter = poolStructs.lower.amountOutDeltaMaxMinus;
 775 |     |         poolValues.amountOutDeltaMaxMinusUpperAfter = poolStructs.upper.amountOutDeltaMaxMinus;
 776 |     | 
 777 |     |         uint160 price0After = poolStructs.pool0.price;
 778 |     |         uint160 price1After = poolStructs.pool1.price;
 779 |     |         
 780 |     |         // POST CONDITIONS
 781 |     | 
 782 |     |         // Ensure prices never cross
 783 |     |         emit Prices(price0After, price1After);
 784 |     |         assert(price0After <= price1After);
 785 |     | 
 786 |     |         // Ensure liquidityGlobal is decremented after burn
 787 |     |         // emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);
 788 |     |         // assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);
 789 |     |     }
 790 |     | 
 791 | *   |     function poolsharkSwapCallback(
 792 |     |         int256 amount0Delta,
 793 |     |         int256 amount1Delta,
 794 |     |         bytes calldata data
 795 | *   |     ) external {
 796 | *   |         address token0 = CoverPool(pool).token0();
 797 | *   |         address token1 = CoverPool(pool).token1();
 798 | *   |         if (amount0Delta < 0) {
 799 | *   |             SafeTransfers.transferInto(token0, address(pool), uint256(-amount0Delta));
 800 |     |         } else {
 801 | *   |             SafeTransfers.transferInto(token1, address(pool), uint256(-amount1Delta));
 802 |     |         }
 803 |     |         data;
 804 |     |     }
 805 |     | 
 806 | *   |     function mintAndApprove() internal {
 807 | *   |         tokenIn.mint(msg.sender, 100000000000 ether);
 808 | *   |         tokenOut.mint(msg.sender, 100000000000 ether);
 809 | *   |         tokenIn.mint(address(this), 100000000000 ether);
 810 | *   |         tokenOut.mint(address(this), 100000000000 ether);
 811 | *   |         tokenIn.approve(address(pool), type(uint256).max);
 812 | *   |         tokenOut.approve(address(pool), type(uint256).max);
 813 |     |     }
 814 |     | 
 815 | *   |     function _between(uint128 val, uint low, uint high) internal pure returns(uint128) {
 816 | *   |         return uint128(low + (val % (high-low +1))); 
 817 |     |     }
 818 |     | 
 819 |     |     function liquidityMintedBackcalculates(uint128 amount, bool zeroForOne, int24 lower, int24 upper) tickPreconditions(lower, upper) internal {
 820 |     |         // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation
 821 |     |         amount = amount + 1e5 + 1;
 822 |     |         PoolsharkStructs.CoverImmutables memory immutables = pool.immutables();
 823 |     |         uint256 priceLower = ConstantProduct.getPriceAtTick(lower, immutables);
 824 |     |         uint256 priceUpper = ConstantProduct.getPriceAtTick(upper, immutables);
 825 |     | 
 826 |     |         uint256 liquidityMinted = ConstantProduct.getLiquidityForAmounts(
 827 |     |             priceLower,
 828 |     |             priceUpper,
 829 |     |             zeroForOne ? priceLower : priceUpper,
 830 |     |             zeroForOne ? 0 : uint256(amount),
 831 |     |             zeroForOne ? uint256(amount) : 0
 832 |     |         );
 833 |     | 
 834 |     |         (uint256 token0Amount, uint256 token1Amount) = ConstantProduct.getAmountsForLiquidity(
 835 |     |             priceLower,
 836 |     |             priceUpper,
 837 |     |             zeroForOne ? priceLower : priceUpper,
 838 |     |             liquidityMinted,
 839 |     |             true
 840 |     |         );
 841 |     | 
 842 |     |         if(zeroForOne) {
 843 |     |             emit LiquidityMinted(amount, token0Amount, zeroForOne);
 844 |     |             assert(token0Amount <= amount);
 845 |     |             
 846 |     |         }
 847 |     |         else {
 848 |     |             emit LiquidityMinted(amount, token1Amount, zeroForOne);
 849 |     |             assert(token1Amount <= amount);
 850 |     |         }
 851 |     |     }
 852 |     | 
 853 | *   |     function getTick(
 854 |     |         int24 tickIdx
 855 |     |     ) internal view returns (
 856 | *   |         CoverPoolStructs.Tick memory tick
 857 |     |     ) {
 858 | *   |         (
 859 | *   |             tick.deltas0,
 860 | *   |             tick.deltas1,
 861 | *   |             tick.liquidityDelta,
 862 | *   |             tick.amountOutDeltaMaxMinus,
 863 | *   |             tick.amountOutDeltaMaxMinus,
 864 | *   |             tick.amountInDeltaMaxStashed,
 865 | *   |             tick.amountOutDeltaMaxStashed,
 866 | *   |             tick.pool0Stash
 867 | *   |         ) = pool.ticks(tickIdx);
 868 |     |     }
 869 |     | 
 870 | *   |     function getPoolState(
 871 |     |         bool isPool0
 872 |     |     ) internal view returns (
 873 | *   |         CoverPoolStructs.PoolState memory poolState
 874 |     |     ) {
 875 | *   |         (
 876 | *   |             poolState.price,
 877 | *   |             poolState.liquidity,
 878 | *   |             poolState.amountInDelta,
 879 | *   |             poolState.amountInDeltaMaxClaimed,
 880 | *   |             poolState.amountOutDeltaMaxClaimed
 881 | *   |         ) = isPool0 ? pool.pool0()
 882 | *   |                     : pool.pool1();
 883 |     |     }
 884 |     | 
 885 |     | 
 886 | *   |     function getGlobalState(
 887 |     |     ) internal view returns (
 888 | *   |         CoverPoolStructs.GlobalState memory state
 889 |     |     ) {
 890 | *   |         state = pool.getGlobalState();
 891 |     |     }
 892 |     | }

/home/ec2-user/git/cover/contracts/CoverPool.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.13;
   3 |     | 
   4 |     | import './interfaces/ICoverPool.sol';
   5 |     | import './interfaces/ICoverPoolManager.sol';
   6 |     | import './base/storage/CoverPoolStorage.sol';
   7 |     | import './base/storage/CoverPoolImmutables.sol';
   8 |     | import './interfaces/structs/PoolsharkStructs.sol';
   9 |     | import './utils/CoverPoolErrors.sol';
  10 |     | import './libraries/Epochs.sol';
  11 |     | import './libraries/pool/SwapCall.sol';
  12 |     | import './libraries/pool/QuoteCall.sol';
  13 |     | import './libraries/pool/MintCall.sol';
  14 |     | import './libraries/pool/BurnCall.sol';
  15 |     | import './libraries/math/ConstantProduct.sol';
  16 |     | 
  17 |     | 
  18 |     | /// @notice Poolshark Cover Pool Implementation
  19 | *   | contract CoverPool is
  20 |     |     ICoverPool,
  21 |     |     CoverPoolStorage,
  22 |     |     CoverPoolImmutables
  23 |     | {
  24 |     |     address public immutable factory;
  25 |     |     address public immutable original;
  26 |     | 
  27 |     |     event SimulateMint(bytes b);
  28 |     |     event SimulateMint(bytes4 b);
  29 |     |     event SimulateMint(bool b);
  30 |     | 
  31 |     |     modifier ownerOnly() {
  32 |     |         _onlyOwner();
  33 |     |         _;
  34 |     |     }
  35 |     | 
  36 |     |     modifier lock() {
  37 |     |         _prelock();
  38 |     |         _;
  39 |     |         _postlock();
  40 |     |     }
  41 |     | 
  42 |     |     constructor(
  43 |     |         address factory_
  44 |     |     ) {
  45 |     |         original = address(this);
  46 |     |         factory = factory_;
  47 |     |     }
  48 |     | 
  49 |     |     function mint(
  50 |     |         MintParams memory params
  51 |     |     ) external override lock {
  52 |     |         MintCache memory cache = MintCache({
  53 |     |             state: globalState,
  54 |     |             position: CoverPosition(address(0),0,0,0,0,0,0,0),
  55 |     |             constants: immutables(),
  56 |     |             syncFees: SyncFees(0,0),
  57 |     |             liquidityMinted: 0,
  58 |     |             pool0: pool0,
  59 |     |             pool1: pool1
  60 |     |         });
  61 |     |         (
  62 |     |             cache.state,
  63 |     |             cache.syncFees,
  64 |     |             cache.pool0, 
  65 |     |             cache.pool1
  66 |     |         ) = Epochs.syncLatest(
  67 |     |             ticks,
  68 |     |             tickMap,
  69 |     |             cache.pool0,
  70 |     |             cache.pool1,
  71 |     |             cache.state,
  72 |     |             cache.constants
  73 |     |         );
  74 |     |         cache = MintCall.perform(
  75 |     |             params,
  76 |     |             cache,
  77 |     |             tickMap,
  78 |     |             ticks,
  79 |     |             params.zeroForOne ? positions0 : positions1
  80 |     |         );
  81 |     |         pool0 = cache.pool0;
  82 |     |         pool1 = cache.pool1;
  83 |     |         globalState = cache.state;
  84 |     |     }
  85 |     | 
  86 |     |     function burn(
  87 |     |         BurnParams memory params
  88 |     |     ) external override lock {
  89 |     |         if (params.to == address(0)) revert CollectToZeroAddress();
  90 |     |         BurnCache memory cache = BurnCache({
  91 |     |             state: globalState,
  92 |     |             position: CoverPosition(address(0),0,0,0,0,0,0,0),
  93 |     |             constants: immutables(),
  94 |     |             syncFees: SyncFees(0,0),
  95 |     |             pool0: pool0,
  96 |     |             pool1: pool1
  97 |     |         });
  98 |     |         if (params.sync)
  99 |     |             (
 100 |     |                 cache.state,
 101 |     |                 cache.syncFees,
 102 |     |                 cache.pool0,
 103 |     |                 cache.pool1
 104 |     |             ) = Epochs.syncLatest(
 105 |     |                 ticks,
 106 |     |                 tickMap,
 107 |     |                 cache.pool0,
 108 |     |                 cache.pool1,
 109 |     |                 cache.state,
 110 |     |                 cache.constants
 111 |     |         );
 112 |     |         cache = BurnCall.perform(
 113 |     |             params, 
 114 |     |             cache, 
 115 |     |             tickMap,
 116 |     |             ticks,
 117 |     |             params.zeroForOne ? positions0 : positions1
 118 |     |         );
 119 |     |         pool0 = cache.pool0;
 120 |     |         pool1 = cache.pool1;
 121 |     |         globalState = cache.state;
 122 |     |     }
 123 |     | 
 124 |     |     function swap(
 125 |     |         SwapParams memory params
 126 |     |     ) external override lock returns (
 127 |     |         int256,
 128 |     |         int256
 129 |     |     ) 
 130 |     |     {
 131 |     |         SwapCache memory cache;
 132 |     |         cache.pool0 = pool0;
 133 |     |         cache.pool1 = pool1;
 134 |     |         cache.state = globalState;
 135 |     |         cache.constants = immutables();
 136 |     |         (
 137 |     |             cache.state,
 138 |     |             cache.syncFees,
 139 |     |             cache.pool0,
 140 |     |             cache.pool1
 141 |     |         ) = Epochs.syncLatest(
 142 |     |             ticks,
 143 |     |             tickMap,
 144 |     |             cache.pool0,
 145 |     |             cache.pool1,
 146 |     |             cache.state,
 147 |     |             immutables()
 148 |     |         );
 149 |     | 
 150 |     |         return SwapCall.perform(
 151 |     |             params,
 152 |     |             cache,
 153 |     |             globalState,
 154 |     |             pool0,
 155 |     |             pool1
 156 |     |         );
 157 |     |     }
 158 |     | 
 159 |     |     function quote(
 160 |     |         QuoteParams memory params
 161 |     |     ) external view override returns (
 162 |     |         int256 inAmount,
 163 |     |         int256 outAmount,
 164 |     |         uint256 priceAfter
 165 |     |     ) {
 166 |     |         SwapCache memory cache;
 167 |     |         cache.pool0 = pool0;
 168 |     |         cache.pool1 = pool1;
 169 |     |         cache.state = globalState;
 170 |     |         cache.constants = immutables();
 171 |     |         (
 172 |     |             cache.state,
 173 |     |             cache.syncFees,
 174 |     |             cache.pool0,
 175 |     |             cache.pool1
 176 |     |         ) = Epochs.simulateSync(
 177 |     |             ticks,
 178 |     |             tickMap,
 179 |     |             cache.pool0,
 180 |     |             cache.pool1,
 181 |     |             cache.state,
 182 |     |             cache.constants
 183 |     |         );
 184 |     |         return QuoteCall.perform(params, cache);
 185 |     |     }
 186 |     | 
 187 |     |     function snapshot(
 188 |     |        SnapshotParams memory params 
 189 |     |     ) external view override returns (
 190 |     |         CoverPosition memory
 191 |     |     ) {
 192 |     |         return Positions.snapshot(
 193 |     |             params.zeroForOne ? positions0 : positions1,
 194 |     |             ticks,
 195 |     |             tickMap,
 196 |     |             globalState,
 197 |     |             params.zeroForOne ? pool0 : pool1,
 198 |     |             UpdateParams(
 199 |     |                 params.owner,
 200 |     |                 params.owner,
 201 |     |                 params.burnPercent,
 202 |     |                 params.positionId,
 203 |     |                 0, 0,
 204 |     |                 params.claim,
 205 |     |                 params.zeroForOne
 206 |     |             ),
 207 |     |             immutables()
 208 |     |         );
 209 |     |     }
 210 |     | 
 211 |     |     function fees(
 212 |     |         uint16 syncFee,
 213 |     |         uint16 fillFee,
 214 |     |         bool setFees
 215 |     |     ) external override ownerOnly returns (
 216 |     |         uint128 token0Fees,
 217 |     |         uint128 token1Fees
 218 |     |     ) {
 219 |     |         if (setFees) {
 220 |     |             globalState.syncFee = syncFee;
 221 |     |             globalState.fillFee = fillFee;
 222 |     |         }
 223 |     |         token0Fees = globalState.protocolFees.token0;
 224 |     |         token1Fees = globalState.protocolFees.token1;
 225 |     |         address feeTo = ICoverPoolManager(owner()).feeTo();
 226 |     |         globalState.protocolFees.token0 = 0;
 227 |     |         globalState.protocolFees.token1 = 0;
 228 |     |         SafeTransfers.transferOut(feeTo, token0(), token0Fees);
 229 |     |         SafeTransfers.transferOut(feeTo, token1(), token1Fees);
 230 |     |     }
 231 |     | 
 232 |     |      function getResizedTicksForMint(
 233 |     |         MintParams memory params
 234 |     |     ) external returns (int24 lower, int24 upper, bool positionCreated){
 235 |     |         MintCache memory cache;
 236 |     |         {
 237 |     |             cache.state = globalState;
 238 |     |             cache.constants = immutables();
 239 |     |         }
 240 |     | 
 241 |     |         try MintCall.getResizedTicks(
 242 |     |             params,
 243 |     |             cache,
 244 |     |             tickMap,
 245 |     |             ticks,
 246 |     |             params.zeroForOne ? positions0 : positions1
 247 |     |         ) {
 248 |     |         } catch (bytes memory data) {
 249 |     |             emit SimulateMint(data);
 250 |     |             bytes4 sig;
 251 |     |             assembly {
 252 |     |                 sig := mload(add(data, 0x20))
 253 |     |             }
 254 |     |             
 255 |     |             // SimulateMint error
 256 |     |             if (sig == hex"5cc1f67b") {
 257 |     |                 (, lower, upper, positionCreated) = abi.decode(abi.encodePacked(bytes28(0), data),(bytes32,int24,int24,bool));
 258 |     |             }
 259 |     |             else {
 260 |     |                 lower = -8388608;
 261 |     |                 upper = -8388608;
 262 |     |                 positionCreated = false;
 263 |     |             }
 264 |     |         }
 265 |     |     }
 266 |     | 
 267 |     |     function getResizedTicksForBurn(
 268 |     |         BurnParams memory params
 269 |     |     ) external returns (int24 lower, int24 upper, bool positionExists){
 270 |     |         if (params.to == address(0)) revert CollectToZeroAddress();
 271 |     |         BurnCache memory cache;
 272 |     |         cache.state = globalState;
 273 |     |         cache.constants = immutables();
 274 |     | 
 275 |     |         try BurnCall.getResizedTicks(
 276 |     |             params,
 277 |     |             cache,
 278 |     |             tickMap,
 279 |     |             ticks,
 280 |     |             params.zeroForOne ? positions0 : positions1
 281 |     |         ) {
 282 |     |         } catch (bytes memory data) {
 283 |     |             bytes4 sig;
 284 |     |             assembly {
 285 |     |                 sig := mload(add(data, 0x20))
 286 |     |             }
 287 |     |             // SimulateBurn error
 288 |     |             if (sig == hex"97dd6e0a") {
 289 |     |                 (, lower, upper, positionExists) = abi.decode(abi.encodePacked(bytes28(0), data),(bytes32,int24,int24,bool));
 290 |     |             }
 291 |     |              else {
 292 |     |                 lower = -8388608;
 293 |     |                 upper = -8388608;
 294 |     |                 positionExists = false;
 295 |     |             }
 296 |     |         }
 297 |     |     }
 298 |     | 
 299 |     |     function getGlobalState() public view returns(
 300 |     |         GlobalState memory
 301 |     |     ) {
 302 |     |         return globalState;
 303 |     |     }
 304 |     | 
 305 |     |     function immutables() public view returns (
 306 |     |         CoverImmutables memory
 307 |     |     ) {
 308 |     |         return CoverImmutables(
 309 |     |             ITwapSource(twapSource()),
 310 |     |             PriceBounds(minPrice(), maxPrice()),
 311 |     |             owner(),
 312 |     |             token0(),
 313 |     |             token1(),
 314 |     |             original,
 315 |     |             inputPool(),
 316 |     |             minAmountPerAuction(),
 317 |     |             genesisTime(),
 318 |     |             minPositionWidth(),
 319 |     |             tickSpread(),
 320 |     |             twapLength(),
 321 |     |             auctionLength(),
 322 |     |             blockTime(),
 323 |     |             token0Decimals(),
 324 |     |             token1Decimals(),
 325 |     |             minAmountLowerPriced()
 326 |     |         );
 327 |     |     }
 328 |     | 
 329 |     |     function priceBounds(
 330 |     |         int16 tickSpacing
 331 |     |     ) external pure returns (uint160, uint160) {
 332 |     |         return ConstantProduct.priceBounds(tickSpacing);
 333 |     |     }
 334 |     | 
 335 |     |     function _prelock() private {
 336 |     |         if (globalState.unlocked == 0) {
 337 |     |             globalState = Ticks.initialize(tickMap, pool0, pool1, globalState, immutables());
 338 |     |         }
 339 |     |         if (globalState.unlocked == 0) revert WaitUntilEnoughObservations();
 340 |     |         if (globalState.unlocked == 2) revert Locked();
 341 |     |         globalState.unlocked = 2;
 342 |     |     }
 343 |     | 
 344 |     |     function _postlock() private {
 345 |     |         globalState.unlocked = 1;
 346 |     |     }
 347 |     | 
 348 |     |     function _onlyOwner() private view {
 349 |     |         if (msg.sender != owner()) revert OwnerOnly();
 350 |     |     }
 351 |     | }
 352 |     | 

/home/ec2-user/git/cover/contracts/CoverPoolFactory.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.13;
   3 |     | 
   4 |     | import './CoverPool.sol';
   5 |     | import './external/solady/LibClone.sol';
   6 |     | import './interfaces/structs/CoverPoolStructs.sol';
   7 |     | import './interfaces/ICoverPoolFactory.sol';
   8 |     | import './base/events/CoverPoolFactoryEvents.sol';
   9 |     | import './utils/CoverPoolErrors.sol';
  10 |     | 
  11 |     | contract CoverPoolFactory is 
  12 |     |     ICoverPoolFactory,
  13 |     |     CoverPoolFactoryEvents,
  14 |     |     CoverPoolFactoryErrors,
  15 |     |     CoverPoolStructs
  16 |     | {
  17 |     |     using LibClone for address;
  18 |     | 
  19 |     |     address immutable public owner;
  20 |     | 
  21 |     |     constructor(
  22 |     |         address _owner
  23 |     |     ) {
  24 |     |         owner = _owner;
  25 |     |     }
  26 |     | 
  27 |     |     function createCoverPool(
  28 |     |         CoverPoolParams memory params
  29 |     |     ) external override returns (address pool) {
  30 |     |         // validate token pair
  31 |     |         if (params.tokenIn == params.tokenOut || params.tokenIn == address(0) || params.tokenOut == address(0)) {
  32 |     |             revert InvalidTokenAddress();
  33 |     |         }
  34 |     |         CoverImmutables memory constants;
  35 |     |         constants.owner = owner;
  36 |     |         // sort tokens by address
  37 |     |         constants.token0 = params.tokenIn < params.tokenOut ? params.tokenIn : params.tokenOut;
  38 |     |         constants.token1 = params.tokenIn < params.tokenOut ? params.tokenOut : params.tokenIn;
  39 |     | 
  40 |     |         // validate erc20 decimals
  41 |     |         {
  42 |     |             uint8 token0Decimals = ERC20(constants.token0).decimals();
  43 |     |             uint8 token1Decimals = ERC20(constants.token1).decimals();
  44 |     |             if (token0Decimals > 18 || token1Decimals > 18
  45 |     |             || token0Decimals < 6 || token1Decimals < 6) {
  46 |     |                 revert InvalidTokenDecimals();
  47 |     |             }
  48 |     |             constants.token0Decimals = token0Decimals;
  49 |     |             constants.token1Decimals = token1Decimals;
  50 |     |         }
  51 |     |     
  52 |     |         // get twap source
  53 |     |         {
  54 |     |             (
  55 |     |                 address poolImpl,
  56 |     |                 address twapSource
  57 |     |             ) = ICoverPoolManager(owner).poolTypes(params.poolType);
  58 |     |             if (poolImpl == address(0) || twapSource == address(0)) revert PoolTypeNotFound();
  59 |     |             constants.poolImpl = poolImpl;
  60 |     |             constants.source = ITwapSource(twapSource);
  61 |     |         }
  62 |     |         // get volatility tier config
  63 |     |         {
  64 |     |             VolatilityTier memory config = ICoverPoolManager(owner).volatilityTiers(
  65 |     |                 params.poolType,
  66 |     |                 params.feeTier,
  67 |     |                 params.tickSpread,
  68 |     |                 params.twapLength
  69 |     |             );
  70 |     |             if (config.auctionLength == 0) revert VolatilityTierNotSupported();
  71 |     |             constants.minAmountPerAuction = config.minAmountPerAuction;
  72 |     |             constants.auctionLength = config.auctionLength;
  73 |     |             constants.blockTime = config.blockTime;
  74 |     |             constants.minPositionWidth = config.minPositionWidth;
  75 |     |             constants.minAmountLowerPriced = config.minAmountLowerPriced;
  76 |     |         }
  77 |     |         // record genesis time
  78 |     |         constants.tickSpread = params.tickSpread;
  79 |     |         constants.twapLength = params.twapLength;
  80 |     |         constants.genesisTime   = uint32(block.timestamp);
  81 |     |         // get reference pool
  82 |     |         constants.inputPool  = ITwapSource(constants.source).getPool(constants.token0, constants.token1, params.feeTier);
  83 |     | 
  84 |     |         // generate key for pool
  85 |     |         bytes32 key = keccak256(abi.encode(
  86 |     |                                     constants.token0,
  87 |     |                                     constants.token1,
  88 |     |                                     constants.source,
  89 |     |                                     constants.inputPool,
  90 |     |                                     constants.tickSpread,
  91 |     |                                     constants.twapLength
  92 |     |                                 ));
  93 |     |         if (coverPools[key] != address(0)) {
  94 |     |             revert PoolAlreadyExists();
  95 |     |         }
  96 |     | 
  97 |     |         (
  98 |     |             constants.bounds.min,
  99 |     |             constants.bounds.max
 100 |     |         ) = ICoverPool(constants.poolImpl).priceBounds(constants.tickSpread);
 101 |     | 
 102 |     |         // launch pool and save address
 103 |     |         pool = constants.poolImpl.cloneDeterministic({
 104 |     |             salt: key,
 105 |     |             data: encodeCover(constants)
 106 |     |         });
 107 |     | 
 108 |     |         coverPools[key] = pool;
 109 |     | 
 110 |     |         emit PoolCreated(
 111 |     |             pool,
 112 |     |             address(constants.source),
 113 |     |             constants.inputPool,
 114 |     |             constants.token0,
 115 |     |             constants.token1,
 116 |     |             constants.poolImpl,
 117 |     |             params.feeTier,
 118 |     |             params.tickSpread,
 119 |     |             params.twapLength
 120 |     |         );
 121 |     |     }
 122 |     | 
 123 |     |     function getCoverPool(
 124 |     |         CoverPoolParams memory params
 125 |     |     ) external view override returns (address) {
 126 |     |         // set lexographical token address ordering
 127 |     |         address token0 = params.tokenIn < params.tokenOut ? params.tokenIn : params.tokenOut;
 128 |     |         address token1 = params.tokenIn < params.tokenOut ? params.tokenOut : params.tokenIn;
 129 |     | 
 130 |     |         (
 131 |     |             ,
 132 |     |             address source
 133 |     |         ) = ICoverPoolManager(owner).poolTypes(params.poolType);
 134 |     |         address inputPool  = ITwapSource(source).getPool(token0, token1, params.feeTier);
 135 |     | 
 136 |     |         // generate key for pool
 137 |     |         bytes32 key = keccak256(abi.encode(
 138 |     |                                     token0,
 139 |     |                                     token1,
 140 |     |                                     source,
 141 |     |                                     inputPool,
 142 |     |                                     params.tickSpread,
 143 |     |                                     params.twapLength
 144 |     |                                 ));
 145 |     | 
 146 |     |         return coverPools[key];
 147 |     |     }
 148 |     | 
 149 |     |     function encodeCover(
 150 |     |         CoverImmutables memory constants
 151 |     |     ) private pure returns (bytes memory) {
 152 |     |         bytes memory value1 = abi.encodePacked(
 153 |     |             constants.owner,
 154 |     |             constants.token0,
 155 |     |             constants.token1,
 156 |     |             constants.source,
 157 |     |             constants.inputPool,
 158 |     |             constants.bounds.min,
 159 |     |             constants.bounds.max
 160 |     |         );
 161 |     |         bytes memory value2 = abi.encodePacked(
 162 |     |             constants.minAmountPerAuction,
 163 |     |             constants.genesisTime,
 164 |     |             constants.minPositionWidth,
 165 |     |             constants.tickSpread,
 166 |     |             constants.twapLength,
 167 |     |             constants.auctionLength
 168 |     |         );
 169 |     |         bytes memory value3 = abi.encodePacked(
 170 |     |             constants.blockTime,
 171 |     |             constants.token0Decimals,
 172 |     |             constants.token1Decimals,
 173 |     |             constants.minAmountLowerPriced
 174 |     |         );
 175 |     |         return abi.encodePacked(value1, value2, value3);
 176 |     |     }
 177 |     | }
 178 |     | 

/home/ec2-user/git/cover/contracts/base/events/CoverPoolFactoryEvents.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | abstract contract CoverPoolFactoryEvents {
  5 |     |     event PoolCreated(
  6 |     |         address pool,
  7 |     |         address indexed twapSource,
  8 |     |         address indexed inputPool,
  9 |     |         address token0,
 10 |     |         address token1,
 11 |     |         address indexed poolImpl,
 12 |     |         uint16 fee,
 13 |     |         int16 tickSpread,
 14 |     |         uint16 twapLength
 15 |     |     );
 16 |     | }
 17 |     | 

/home/ec2-user/git/cover/contracts/base/events/CoverPoolManagerEvents.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | abstract contract CoverPoolManagerEvents {
  5 |     |     event FactoryChanged(address indexed previousFactory, address indexed newFactory);
  6 |     |     event VolatilityTierEnabled(
  7 |     |         address implAddress,
  8 |     |         uint16  feeTier,
  9 |     |         int16   tickSpread,
 10 |     |         uint16  twapLength,
 11 |     |         uint128 minAmountPerAuction,
 12 |     |         uint16  auctionLength,
 13 |     |         uint16  blockTime,
 14 |     |         uint16  syncFee,
 15 |     |         uint16  fillFee,
 16 |     |         int16   minPositionWidth,
 17 |     |         bool    minLowerPriced
 18 |     |     );
 19 |     |     event PoolTypeEnabled(
 20 |     |         bytes32 poolType,
 21 |     |         address implAddress,
 22 |     |         address sourceAddress,
 23 |     |         address factoryAddress
 24 |     |     );
 25 |     |     event FeeToTransfer(address indexed previousFeeTo, address indexed newFeeTo);
 26 |     |     event OwnerTransfer(address indexed previousOwner, address indexed newOwner);
 27 |     |     event ProtocolFeesModified(
 28 |     |         address[] modifyPools,
 29 |     |         uint16[] syncFees,
 30 |     |         uint16[] fillFees,
 31 |     |         bool[] setFees,
 32 |     |         uint128[] token0Fees,
 33 |     |         uint128[] token1Fees
 34 |     |     );
 35 |     |     event ProtocolFeesCollected(
 36 |     |         address[] collectPools,
 37 |     |         uint128[] token0Fees,
 38 |     |         uint128[] token1Fees
 39 |     |     );
 40 |     | }

/home/ec2-user/git/cover/contracts/base/storage/CoverPoolFactoryStorage.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | abstract contract CoverPoolFactoryStorage {
  5 |     |     mapping(bytes32 => address) public coverPools;
  6 |     | }
  7 |     | 
  8 |     | 
  9 |     | 
 10 |     | 
 11 |     | 

/home/ec2-user/git/cover/contracts/base/storage/CoverPoolImmutables.sol
  1 |     | // SPDX-License-Identifier: BSD
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import { Clone } from "../../external/solady/Clone.sol";
  5 |     | 
  6 |     | contract CoverPoolImmutables is Clone {
  7 |     |     function owner() public pure returns (address) {
  8 |     |         return _getArgAddress(0);
  9 |     |     }
 10 |     | 
 11 |     |     function token0() public pure returns (address) {
 12 |     |         return _getArgAddress(20);
 13 |     |     }
 14 |     | 
 15 |     |     function token1() public pure returns (address) {
 16 |     |         return _getArgAddress(40);
 17 |     |     }
 18 |     | 
 19 |     |     function twapSource() public pure returns (address) {
 20 |     |         return _getArgAddress(60);
 21 |     |     }
 22 |     | 
 23 |     |     function inputPool() public pure returns (address) {
 24 |     |         return _getArgAddress(80);
 25 |     |     }
 26 |     | 
 27 |     |     function minPrice() public pure returns (uint160) {
 28 |     |         return _getArgUint160(100);
 29 |     |     }
 30 |     | 
 31 |     |     function maxPrice() public pure returns (uint160) {
 32 |     |         return _getArgUint160(120);
 33 |     |     }
 34 |     | 
 35 |     |     function minAmountPerAuction() public pure returns (uint128) {
 36 |     |         return _getArgUint128(140);
 37 |     |     }
 38 |     | 
 39 |     |     function genesisTime() public pure returns (uint32) {
 40 |     |         return _getArgUint32(156);
 41 |     |     }
 42 |     | 
 43 |     |     function minPositionWidth() public pure returns (int16) {
 44 |     |         return int16(_getArgUint16(160));
 45 |     |     }
 46 |     | 
 47 |     |     function tickSpread() public pure returns (int16) {
 48 |     |         return int16(_getArgUint16(162));
 49 |     |     }
 50 |     | 
 51 |     |     function twapLength() public pure returns (uint16) {
 52 |     |         return _getArgUint16(164);
 53 |     |     }
 54 |     | 
 55 |     |     function auctionLength() public pure returns (uint16) {
 56 |     |         return _getArgUint16(166);
 57 |     |     }
 58 |     | 
 59 |     |     function blockTime() public pure returns (uint16) {
 60 |     |         return _getArgUint16(168);
 61 |     |     }
 62 |     | 
 63 |     |     function token0Decimals() public pure returns (uint8) {
 64 |     |         return _getArgUint8(170);
 65 |     |     }
 66 |     | 
 67 |     |     function token1Decimals() public pure returns (uint8) {
 68 |     |         return _getArgUint8(171);
 69 |     |     }
 70 |     | 
 71 |     |     function minAmountLowerPriced() public pure returns (bool) {
 72 |     |         return _getArgUint8(172) > 0;
 73 |     |     }
 74 |     | }

/home/ec2-user/git/cover/contracts/base/storage/CoverPoolStorage.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/structs/CoverPoolStructs.sol';
  5 |     | import '../../interfaces/ICoverPoolFactory.sol';
  6 |     | import '../../utils/CoverPoolErrors.sol';
  7 |     | 
  8 |     | abstract contract CoverPoolStorage is CoverPoolStructs, CoverPoolErrors {
  9 |     |     GlobalState public globalState;
 10 |     |     PoolState public pool0; /// @dev pool with token0 liquidity
 11 |     |     PoolState public pool1; /// @dev pool with token1 liquidity
 12 |     |     TickMap public tickMap;
 13 |     |     mapping(int24 => Tick) public ticks; /// @dev price ticks with delta values
 14 |     |     mapping(uint256 => CoverPosition) public positions0; //positions with token0 deposited
 15 |     |     mapping(uint256 => CoverPosition) public positions1; //positions with token1 deposited
 16 |     | }
 17 |     | 

/home/ec2-user/git/cover/contracts/external/openzeppelin/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20.sol";
   7 |     | import "./extensions/IERC20Metadata.sol";
   8 |     | import "../../utils/Context.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Implementation of the {IERC20} interface.
  12 |     |  *
  13 |     |  * This implementation is agnostic to the way tokens are created. This means
  14 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  15 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  22 |     |  * instead returning `false` on failure. This behavior is nonetheless
  23 |     |  * conventional and does not conflict with the expectations of ERC20
  24 |     |  * applications.
  25 |     |  *
  26 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  27 |     |  * This allows applications to reconstruct the allowance for all accounts just
  28 |     |  * by listening to said events. Other implementations of the EIP may not emit
  29 |     |  * these events, as it isn't required by the specification.
  30 |     |  *
  31 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  32 |     |  * functions have been added to mitigate the well-known issues around setting
  33 |     |  * allowances. See {IERC20-approve}.
  34 |     |  */
  35 |     | contract ERC20 is Context, IERC20, IERC20Metadata {
  36 |     |     mapping(address => uint256) private _balances;
  37 |     | 
  38 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  39 |     | 
  40 |     |     uint256 private _totalSupply;
  41 |     | 
  42 |     |     string private _name;
  43 |     |     string private _symbol;
  44 |     | 
  45 |     |     /**
  46 |     |      * @dev Sets the values for {name} and {symbol}.
  47 |     |      *
  48 |     |      * The default value of {decimals} is 18. To select a different value for
  49 |     |      * {decimals} you should overload it.
  50 |     |      *
  51 |     |      * All two of these values are immutable: they can only be set once during
  52 |     |      * construction.
  53 |     |      */
  54 |     |     constructor(string memory name_, string memory symbol_) {
  55 |     |         _name = name_;
  56 |     |         _symbol = symbol_;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the name of the token.
  61 |     |      */
  62 |     |     function name() public view virtual override returns (string memory) {
  63 |     |         return _name;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  68 |     |      * name.
  69 |     |      */
  70 |     |     function symbol() public view virtual override returns (string memory) {
  71 |     |         return _symbol;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the number of decimals used to get its user representation.
  76 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  77 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  78 |     |      *
  79 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  80 |     |      * Ether and Wei. This is the value {ERC20} uses, unless this function is
  81 |     |      * overridden;
  82 |     |      *
  83 |     |      * NOTE: This information is only used for _display_ purposes: it in
  84 |     |      * no way affects any of the arithmetic of the contract, including
  85 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  86 |     |      */
  87 |     |     function decimals() public view virtual override returns (uint8) {
  88 |     |         return 18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-totalSupply}.
  93 |     |      */
  94 |     |     function totalSupply() public view virtual override returns (uint256) {
  95 |     |         return _totalSupply;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev See {IERC20-balanceOf}.
 100 |     |      */
 101 | *   |     function balanceOf(address account) public view virtual override returns (uint256) {
 102 | *   |         return _balances[account];
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev See {IERC20-transfer}.
 107 |     |      *
 108 |     |      * Requirements:
 109 |     |      *
 110 |     |      * - `to` cannot be the zero address.
 111 |     |      * - the caller must have a balance of at least `amount`.
 112 |     |      */
 113 |     |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 114 |     |         address owner = _msgSender();
 115 |     |         _transfer(owner, to, amount);
 116 |     |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev See {IERC20-allowance}.
 121 |     |      */
 122 | *   |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 123 | *   |         return _allowances[owner][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-approve}.
 128 |     |      *
 129 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 130 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 131 |     |      *
 132 |     |      * Requirements:
 133 |     |      *
 134 |     |      * - `spender` cannot be the zero address.
 135 |     |      */
 136 | *   |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 137 | *   |         address owner = _msgSender();
 138 | *   |         _approve(owner, spender, amount);
 139 | *   |         return true;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev See {IERC20-transferFrom}.
 144 |     |      *
 145 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 146 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 147 |     |      *
 148 |     |      * NOTE: Does not update the allowance if the current allowance
 149 |     |      * is the maximum `uint256`.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - `from` and `to` cannot be the zero address.
 154 |     |      * - `from` must have a balance of at least `amount`.
 155 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 156 |     |      * `amount`.
 157 |     |      */
 158 | *   |     function transferFrom(
 159 |     |         address from,
 160 |     |         address to,
 161 |     |         uint256 amount
 162 | *   |     ) public virtual override returns (bool) {
 163 | *   |         address spender = _msgSender();
 164 | *   |         _spendAllowance(from, spender, amount);
 165 | *   |         _transfer(from, to, amount);
 166 | *   |         return true;
 167 |     |     }
 168 |     | 
 169 |     |     /**
 170 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 171 |     |      *
 172 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 173 |     |      * problems described in {IERC20-approve}.
 174 |     |      *
 175 |     |      * Emits an {Approval} event indicating the updated allowance.
 176 |     |      *
 177 |     |      * Requirements:
 178 |     |      *
 179 |     |      * - `spender` cannot be the zero address.
 180 |     |      */
 181 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 182 |     |         address owner = _msgSender();
 183 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 184 |     |         return true;
 185 |     |     }
 186 |     | 
 187 |     |     /**
 188 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 189 |     |      *
 190 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 191 |     |      * problems described in {IERC20-approve}.
 192 |     |      *
 193 |     |      * Emits an {Approval} event indicating the updated allowance.
 194 |     |      *
 195 |     |      * Requirements:
 196 |     |      *
 197 |     |      * - `spender` cannot be the zero address.
 198 |     |      * - `spender` must have allowance for the caller of at least
 199 |     |      * `subtractedValue`.
 200 |     |      */
 201 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 202 |     |         address owner = _msgSender();
 203 |     |         uint256 currentAllowance = allowance(owner, spender);
 204 |     |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 205 |     |         unchecked {
 206 |     |             _approve(owner, spender, currentAllowance - subtractedValue);
 207 |     |         }
 208 |     | 
 209 |     |         return true;
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 214 |     |      *
 215 |     |      * This internal function is equivalent to {transfer}, and can be used to
 216 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 217 |     |      *
 218 |     |      * Emits a {Transfer} event.
 219 |     |      *
 220 |     |      * Requirements:
 221 |     |      *
 222 |     |      * - `from` cannot be the zero address.
 223 |     |      * - `to` cannot be the zero address.
 224 |     |      * - `from` must have a balance of at least `amount`.
 225 |     |      */
 226 | *   |     function _transfer(
 227 |     |         address from,
 228 |     |         address to,
 229 |     |         uint256 amount
 230 | *   |     ) internal virtual {
 231 | *   |         require(from != address(0), "ERC20: transfer from the zero address");
 232 | *   |         require(to != address(0), "ERC20: transfer to the zero address");
 233 |     | 
 234 | *   |         _beforeTokenTransfer(from, to, amount);
 235 |     | 
 236 | *   |         uint256 fromBalance = _balances[from];
 237 | *   |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 238 |     |         unchecked {
 239 | *   |             _balances[from] = fromBalance - amount;
 240 |     |         }
 241 | *   |         _balances[to] += amount;
 242 |     | 
 243 | *   |         emit Transfer(from, to, amount);
 244 |     | 
 245 | *   |         _afterTokenTransfer(from, to, amount);
 246 |     |     }
 247 |     | 
 248 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 249 |     |      * the total supply.
 250 |     |      *
 251 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 252 |     |      *
 253 |     |      * Requirements:
 254 |     |      *
 255 |     |      * - `account` cannot be the zero address.
 256 |     |      */
 257 | *   |     function _mint(address account, uint256 amount) internal virtual {
 258 | *   |         require(account != address(0), "ERC20: mint to the zero address");
 259 |     | 
 260 | *   |         _beforeTokenTransfer(address(0), account, amount);
 261 |     | 
 262 | *   |         _totalSupply += amount;
 263 | *   |         _balances[account] += amount;
 264 | *   |         emit Transfer(address(0), account, amount);
 265 |     | 
 266 | *   |         _afterTokenTransfer(address(0), account, amount);
 267 |     |     }
 268 |     | 
 269 |     |     /**
 270 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 271 |     |      * total supply.
 272 |     |      *
 273 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 274 |     |      *
 275 |     |      * Requirements:
 276 |     |      *
 277 |     |      * - `account` cannot be the zero address.
 278 |     |      * - `account` must have at least `amount` tokens.
 279 |     |      */
 280 |     |     function _burn(address account, uint256 amount) internal virtual {
 281 |     |         require(account != address(0), "ERC20: burn from the zero address");
 282 |     | 
 283 |     |         _beforeTokenTransfer(account, address(0), amount);
 284 |     | 
 285 |     |         uint256 accountBalance = _balances[account];
 286 |     |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 287 |     |         unchecked {
 288 |     |             _balances[account] = accountBalance - amount;
 289 |     |         }
 290 |     |         _totalSupply -= amount;
 291 |     | 
 292 |     |         emit Transfer(account, address(0), amount);
 293 |     | 
 294 |     |         _afterTokenTransfer(account, address(0), amount);
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 299 |     |      *
 300 |     |      * This internal function is equivalent to `approve`, and can be used to
 301 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 302 |     |      *
 303 |     |      * Emits an {Approval} event.
 304 |     |      *
 305 |     |      * Requirements:
 306 |     |      *
 307 |     |      * - `owner` cannot be the zero address.
 308 |     |      * - `spender` cannot be the zero address.
 309 |     |      */
 310 | *   |     function _approve(
 311 |     |         address owner,
 312 |     |         address spender,
 313 |     |         uint256 amount
 314 |     |     ) internal virtual {
 315 | *   |         require(owner != address(0), "ERC20: approve from the zero address");
 316 | *   |         require(spender != address(0), "ERC20: approve to the zero address");
 317 |     | 
 318 | *   |         _allowances[owner][spender] = amount;
 319 | *   |         emit Approval(owner, spender, amount);
 320 |     |     }
 321 |     | 
 322 |     |     /**
 323 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 324 |     |      *
 325 |     |      * Does not update the allowance amount in case of infinite allowance.
 326 |     |      * Revert if not enough allowance is available.
 327 |     |      *
 328 |     |      * Might emit an {Approval} event.
 329 |     |      */
 330 | *   |     function _spendAllowance(
 331 |     |         address owner,
 332 |     |         address spender,
 333 |     |         uint256 amount
 334 | *   |     ) internal virtual {
 335 | *   |         uint256 currentAllowance = allowance(owner, spender);
 336 | *   |         if (currentAllowance != type(uint256).max) {
 337 | *   |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 338 |     |             unchecked {
 339 | *   |                 _approve(owner, spender, currentAllowance - amount);
 340 |     |             }
 341 |     |         }
 342 |     |     }
 343 |     | 
 344 |     |     /**
 345 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 346 |     |      * minting and burning.
 347 |     |      *
 348 |     |      * Calling conditions:
 349 |     |      *
 350 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 351 |     |      * will be transferred to `to`.
 352 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 353 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 354 |     |      * - `from` and `to` are never both zero.
 355 |     |      *
 356 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 357 |     |      */
 358 | *   |     function _beforeTokenTransfer(
 359 |     |         address from,
 360 |     |         address to,
 361 |     |         uint256 amount
 362 |     |     ) internal virtual {}
 363 |     | 
 364 |     |     /**
 365 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 366 |     |      * minting and burning.
 367 |     |      *
 368 |     |      * Calling conditions:
 369 |     |      *
 370 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 371 |     |      * has been transferred to `to`.
 372 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 373 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 374 |     |      * - `from` and `to` are never both zero.
 375 |     |      *
 376 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 377 |     |      */
 378 | *   |     function _afterTokenTransfer(
 379 |     |         address from,
 380 |     |         address to,
 381 |     |         uint256 amount
 382 |     |     ) internal virtual {}
 383 |     | }
 384 |     | 

/home/ec2-user/git/cover/contracts/external/openzeppelin/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(
 78 |     |         address from,
 79 |     |         address to,
 80 |     |         uint256 amount
 81 |     |     ) external returns (bool);
 82 |     | }
 83 |     | 

/home/ec2-user/git/cover/contracts/external/openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../ERC20.sol";
  7 |     | import "../../../utils/Context.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev Extension of {ERC20} that allows token holders to destroy both their own
 11 |     |  * tokens and those that they have an allowance for, in a way that can be
 12 |     |  * recognized off-chain (via event analysis).
 13 |     |  */
 14 |     | abstract contract ERC20Burnable is Context, ERC20 {
 15 |     |     /**
 16 |     |      * @dev Destroys `amount` tokens from the caller.
 17 |     |      *
 18 |     |      * See {ERC20-_burn}.
 19 |     |      */
 20 |     |     function burn(uint256 amount) public virtual {
 21 |     |         _burn(_msgSender(), amount);
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Destroys `amount` tokens from `account`, deducting from the caller's
 26 |     |      * allowance.
 27 |     |      *
 28 |     |      * See {ERC20-_burn} and {ERC20-allowance}.
 29 |     |      *
 30 |     |      * Requirements:
 31 |     |      *
 32 |     |      * - the caller must have allowance for ``accounts``'s tokens of at least
 33 |     |      * `amount`.
 34 |     |      */
 35 |     |     function burnFrom(address account, uint256 amount) public virtual {
 36 |     |         _spendAllowance(account, _msgSender(), amount);
 37 |     |         _burn(account, amount);
 38 |     |     }
 39 |     | }
 40 |     | 

/home/ec2-user/git/cover/contracts/external/openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | pragma solidity 0.8.13;
  4 |     | 
  5 |     | import {IERC20} from "../IERC20.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
  9 |     |  */
 10 |     | interface IERC20Metadata is IERC20 {
 11 |     |     /**
 12 |     |      * @dev Returns the name of the token.
 13 |     |      */
 14 |     |     function name() external view returns (string memory);
 15 |     | 
 16 |     |     /**
 17 |     |      * @dev Returns the symbol of the token.
 18 |     |      */
 19 |     |     function symbol() external view returns (string memory);
 20 |     | 
 21 |     |     /**
 22 |     |      * @dev Returns the decimals places of the token.
 23 |     |      */
 24 |     |     function decimals() external view returns (uint8);
 25 |     | }

/home/ec2-user/git/cover/contracts/external/openzeppelin/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 | *   |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | }
 25 |     | 

/home/ec2-user/git/cover/contracts/external/solady/Clone.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /// @notice Class with helper read functions for clone with immutable args.
   5 |     | /// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Clone.sol)
   6 |     | /// @author Adapted from clones with immutable args by zefram.eth, Saw-mon & Natalie
   7 |     | /// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)
   8 |     | abstract contract Clone {
   9 |     |     /// @dev Reads an immutable arg with type bytes.
  10 |     |     function _getArgBytes(uint256 argOffset, uint256 length)
  11 |     |         internal
  12 |     |         pure
  13 |     |         returns (bytes memory arg)
  14 |     |     {
  15 |     |         uint256 offset = _getImmutableArgsOffset();
  16 |     |         /// @solidity memory-safe-assembly
  17 |     |         assembly {
  18 |     |             arg := mload(0x40)
  19 |     |             mstore(arg, length) // Store the length.
  20 |     |             calldatacopy(add(arg, 0x20), add(offset, argOffset), length)
  21 |     |             let o := add(add(arg, 0x20), length)
  22 |     |             mstore(o, 0) // Zeroize the slot after the bytes.
  23 |     |             mstore(0x40, add(o, 0x20)) // Allocate the memory.
  24 |     |         }
  25 |     |     }
  26 |     | 
  27 |     |     /// @dev Reads an immutable arg with type address.
  28 |     |     function _getArgAddress(uint256 argOffset) internal pure returns (address arg) {
  29 |     |         uint256 offset = _getImmutableArgsOffset();
  30 |     |         /// @solidity memory-safe-assembly
  31 |     |         assembly {
  32 |     |             arg := shr(96, calldataload(add(offset, argOffset)))
  33 |     |         }
  34 |     |     }
  35 |     | 
  36 |     |     /// @dev Reads a uint256 array stored in the immutable args.
  37 |     |     function _getArgUint256Array(uint256 argOffset, uint256 length)
  38 |     |         internal
  39 |     |         pure
  40 |     |         returns (uint256[] memory arg)
  41 |     |     {
  42 |     |         uint256 offset = _getImmutableArgsOffset();
  43 |     |         /// @solidity memory-safe-assembly
  44 |     |         assembly {
  45 |     |             arg := mload(0x40)
  46 |     |             mstore(arg, length) // Store the length.
  47 |     |             calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))
  48 |     |             mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 |     |     /// @dev Reads a bytes32 array stored in the immutable args.
  53 |     |     function _getArgBytes32Array(uint256 argOffset, uint256 length)
  54 |     |         internal
  55 |     |         pure
  56 |     |         returns (bytes32[] memory arg)
  57 |     |     {
  58 |     |         uint256 offset = _getImmutableArgsOffset();
  59 |     |         /// @solidity memory-safe-assembly
  60 |     |         assembly {
  61 |     |             arg := mload(0x40)
  62 |     |             mstore(arg, length) // Store the length.
  63 |     |             calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))
  64 |     |             mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.
  65 |     |         }
  66 |     |     }
  67 |     | 
  68 |     |     /// @dev Reads an immutable arg with type bytes32.
  69 |     |     function _getArgBytes32(uint256 argOffset) internal pure returns (bytes32 arg) {
  70 |     |         uint256 offset = _getImmutableArgsOffset();
  71 |     |         /// @solidity memory-safe-assembly
  72 |     |         assembly {
  73 |     |             arg := calldataload(add(offset, argOffset))
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /// @dev Reads an immutable arg with type uint256.
  78 |     |     function _getArgUint256(uint256 argOffset) internal pure returns (uint256 arg) {
  79 |     |         uint256 offset = _getImmutableArgsOffset();
  80 |     |         /// @solidity memory-safe-assembly
  81 |     |         assembly {
  82 |     |             arg := calldataload(add(offset, argOffset))
  83 |     |         }
  84 |     |     }
  85 |     | 
  86 |     |     /// @dev Reads an immutable arg with type uint248.
  87 |     |     function _getArgUint248(uint256 argOffset) internal pure returns (uint248 arg) {
  88 |     |         uint256 offset = _getImmutableArgsOffset();
  89 |     |         /// @solidity memory-safe-assembly
  90 |     |         assembly {
  91 |     |             arg := shr(8, calldataload(add(offset, argOffset)))
  92 |     |         }
  93 |     |     }
  94 |     | 
  95 |     |     /// @dev Reads an immutable arg with type uint240.
  96 |     |     function _getArgUint240(uint256 argOffset) internal pure returns (uint240 arg) {
  97 |     |         uint256 offset = _getImmutableArgsOffset();
  98 |     |         /// @solidity memory-safe-assembly
  99 |     |         assembly {
 100 |     |             arg := shr(16, calldataload(add(offset, argOffset)))
 101 |     |         }
 102 |     |     }
 103 |     | 
 104 |     |     /// @dev Reads an immutable arg with type uint232.
 105 |     |     function _getArgUint232(uint256 argOffset) internal pure returns (uint232 arg) {
 106 |     |         uint256 offset = _getImmutableArgsOffset();
 107 |     |         /// @solidity memory-safe-assembly
 108 |     |         assembly {
 109 |     |             arg := shr(24, calldataload(add(offset, argOffset)))
 110 |     |         }
 111 |     |     }
 112 |     | 
 113 |     |     /// @dev Reads an immutable arg with type uint224.
 114 |     |     function _getArgUint224(uint256 argOffset) internal pure returns (uint224 arg) {
 115 |     |         uint256 offset = _getImmutableArgsOffset();
 116 |     |         /// @solidity memory-safe-assembly
 117 |     |         assembly {
 118 |     |             arg := shr(0x20, calldataload(add(offset, argOffset)))
 119 |     |         }
 120 |     |     }
 121 |     | 
 122 |     |     /// @dev Reads an immutable arg with type uint216.
 123 |     |     function _getArgUint216(uint256 argOffset) internal pure returns (uint216 arg) {
 124 |     |         uint256 offset = _getImmutableArgsOffset();
 125 |     |         /// @solidity memory-safe-assembly
 126 |     |         assembly {
 127 |     |             arg := shr(40, calldataload(add(offset, argOffset)))
 128 |     |         }
 129 |     |     }
 130 |     | 
 131 |     |     /// @dev Reads an immutable arg with type uint208.
 132 |     |     function _getArgUint208(uint256 argOffset) internal pure returns (uint208 arg) {
 133 |     |         uint256 offset = _getImmutableArgsOffset();
 134 |     |         /// @solidity memory-safe-assembly
 135 |     |         assembly {
 136 |     |             arg := shr(48, calldataload(add(offset, argOffset)))
 137 |     |         }
 138 |     |     }
 139 |     | 
 140 |     |     /// @dev Reads an immutable arg with type uint200.
 141 |     |     function _getArgUint200(uint256 argOffset) internal pure returns (uint200 arg) {
 142 |     |         uint256 offset = _getImmutableArgsOffset();
 143 |     |         /// @solidity memory-safe-assembly
 144 |     |         assembly {
 145 |     |             arg := shr(56, calldataload(add(offset, argOffset)))
 146 |     |         }
 147 |     |     }
 148 |     | 
 149 |     |     /// @dev Reads an immutable arg with type uint192.
 150 |     |     function _getArgUint192(uint256 argOffset) internal pure returns (uint192 arg) {
 151 |     |         uint256 offset = _getImmutableArgsOffset();
 152 |     |         /// @solidity memory-safe-assembly
 153 |     |         assembly {
 154 |     |             arg := shr(64, calldataload(add(offset, argOffset)))
 155 |     |         }
 156 |     |     }
 157 |     | 
 158 |     |     /// @dev Reads an immutable arg with type uint184.
 159 |     |     function _getArgUint184(uint256 argOffset) internal pure returns (uint184 arg) {
 160 |     |         uint256 offset = _getImmutableArgsOffset();
 161 |     |         /// @solidity memory-safe-assembly
 162 |     |         assembly {
 163 |     |             arg := shr(72, calldataload(add(offset, argOffset)))
 164 |     |         }
 165 |     |     }
 166 |     | 
 167 |     |     /// @dev Reads an immutable arg with type uint176.
 168 |     |     function _getArgUint176(uint256 argOffset) internal pure returns (uint176 arg) {
 169 |     |         uint256 offset = _getImmutableArgsOffset();
 170 |     |         /// @solidity memory-safe-assembly
 171 |     |         assembly {
 172 |     |             arg := shr(80, calldataload(add(offset, argOffset)))
 173 |     |         }
 174 |     |     }
 175 |     | 
 176 |     |     /// @dev Reads an immutable arg with type uint168.
 177 |     |     function _getArgUint168(uint256 argOffset) internal pure returns (uint168 arg) {
 178 |     |         uint256 offset = _getImmutableArgsOffset();
 179 |     |         /// @solidity memory-safe-assembly
 180 |     |         assembly {
 181 |     |             arg := shr(88, calldataload(add(offset, argOffset)))
 182 |     |         }
 183 |     |     }
 184 |     | 
 185 |     |     /// @dev Reads an immutable arg with type uint160.
 186 |     |     function _getArgUint160(uint256 argOffset) internal pure returns (uint160 arg) {
 187 |     |         uint256 offset = _getImmutableArgsOffset();
 188 |     |         /// @solidity memory-safe-assembly
 189 |     |         assembly {
 190 |     |             arg := shr(96, calldataload(add(offset, argOffset)))
 191 |     |         }
 192 |     |     }
 193 |     | 
 194 |     |     /// @dev Reads an immutable arg with type uint152.
 195 |     |     function _getArgUint152(uint256 argOffset) internal pure returns (uint152 arg) {
 196 |     |         uint256 offset = _getImmutableArgsOffset();
 197 |     |         /// @solidity memory-safe-assembly
 198 |     |         assembly {
 199 |     |             arg := shr(104, calldataload(add(offset, argOffset)))
 200 |     |         }
 201 |     |     }
 202 |     | 
 203 |     |     /// @dev Reads an immutable arg with type uint144.
 204 |     |     function _getArgUint144(uint256 argOffset) internal pure returns (uint144 arg) {
 205 |     |         uint256 offset = _getImmutableArgsOffset();
 206 |     |         /// @solidity memory-safe-assembly
 207 |     |         assembly {
 208 |     |             arg := shr(112, calldataload(add(offset, argOffset)))
 209 |     |         }
 210 |     |     }
 211 |     | 
 212 |     |     /// @dev Reads an immutable arg with type uint136.
 213 |     |     function _getArgUint136(uint256 argOffset) internal pure returns (uint136 arg) {
 214 |     |         uint256 offset = _getImmutableArgsOffset();
 215 |     |         /// @solidity memory-safe-assembly
 216 |     |         assembly {
 217 |     |             arg := shr(120, calldataload(add(offset, argOffset)))
 218 |     |         }
 219 |     |     }
 220 |     | 
 221 |     |     /// @dev Reads an immutable arg with type uint128.
 222 |     |     function _getArgUint128(uint256 argOffset) internal pure returns (uint128 arg) {
 223 |     |         uint256 offset = _getImmutableArgsOffset();
 224 |     |         /// @solidity memory-safe-assembly
 225 |     |         assembly {
 226 |     |             arg := shr(128, calldataload(add(offset, argOffset)))
 227 |     |         }
 228 |     |     }
 229 |     | 
 230 |     |     /// @dev Reads an immutable arg with type uint120.
 231 |     |     function _getArgUint120(uint256 argOffset) internal pure returns (uint120 arg) {
 232 |     |         uint256 offset = _getImmutableArgsOffset();
 233 |     |         /// @solidity memory-safe-assembly
 234 |     |         assembly {
 235 |     |             arg := shr(136, calldataload(add(offset, argOffset)))
 236 |     |         }
 237 |     |     }
 238 |     | 
 239 |     |     /// @dev Reads an immutable arg with type uint112.
 240 |     |     function _getArgUint112(uint256 argOffset) internal pure returns (uint112 arg) {
 241 |     |         uint256 offset = _getImmutableArgsOffset();
 242 |     |         /// @solidity memory-safe-assembly
 243 |     |         assembly {
 244 |     |             arg := shr(144, calldataload(add(offset, argOffset)))
 245 |     |         }
 246 |     |     }
 247 |     | 
 248 |     |     /// @dev Reads an immutable arg with type uint104.
 249 |     |     function _getArgUint104(uint256 argOffset) internal pure returns (uint104 arg) {
 250 |     |         uint256 offset = _getImmutableArgsOffset();
 251 |     |         /// @solidity memory-safe-assembly
 252 |     |         assembly {
 253 |     |             arg := shr(152, calldataload(add(offset, argOffset)))
 254 |     |         }
 255 |     |     }
 256 |     | 
 257 |     |     /// @dev Reads an immutable arg with type uint96.
 258 |     |     function _getArgUint96(uint256 argOffset) internal pure returns (uint96 arg) {
 259 |     |         uint256 offset = _getImmutableArgsOffset();
 260 |     |         /// @solidity memory-safe-assembly
 261 |     |         assembly {
 262 |     |             arg := shr(160, calldataload(add(offset, argOffset)))
 263 |     |         }
 264 |     |     }
 265 |     | 
 266 |     |     /// @dev Reads an immutable arg with type uint88.
 267 |     |     function _getArgUint88(uint256 argOffset) internal pure returns (uint88 arg) {
 268 |     |         uint256 offset = _getImmutableArgsOffset();
 269 |     |         /// @solidity memory-safe-assembly
 270 |     |         assembly {
 271 |     |             arg := shr(168, calldataload(add(offset, argOffset)))
 272 |     |         }
 273 |     |     }
 274 |     | 
 275 |     |     /// @dev Reads an immutable arg with type uint80.
 276 |     |     function _getArgUint80(uint256 argOffset) internal pure returns (uint80 arg) {
 277 |     |         uint256 offset = _getImmutableArgsOffset();
 278 |     |         /// @solidity memory-safe-assembly
 279 |     |         assembly {
 280 |     |             arg := shr(176, calldataload(add(offset, argOffset)))
 281 |     |         }
 282 |     |     }
 283 |     | 
 284 |     |     /// @dev Reads an immutable arg with type uint72.
 285 |     |     function _getArgUint72(uint256 argOffset) internal pure returns (uint72 arg) {
 286 |     |         uint256 offset = _getImmutableArgsOffset();
 287 |     |         /// @solidity memory-safe-assembly
 288 |     |         assembly {
 289 |     |             arg := shr(184, calldataload(add(offset, argOffset)))
 290 |     |         }
 291 |     |     }
 292 |     | 
 293 |     |     /// @dev Reads an immutable arg with type uint64.
 294 |     |     function _getArgUint64(uint256 argOffset) internal pure returns (uint64 arg) {
 295 |     |         uint256 offset = _getImmutableArgsOffset();
 296 |     |         /// @solidity memory-safe-assembly
 297 |     |         assembly {
 298 |     |             arg := shr(192, calldataload(add(offset, argOffset)))
 299 |     |         }
 300 |     |     }
 301 |     | 
 302 |     |     /// @dev Reads an immutable arg with type uint56.
 303 |     |     function _getArgUint56(uint256 argOffset) internal pure returns (uint56 arg) {
 304 |     |         uint256 offset = _getImmutableArgsOffset();
 305 |     |         /// @solidity memory-safe-assembly
 306 |     |         assembly {
 307 |     |             arg := shr(200, calldataload(add(offset, argOffset)))
 308 |     |         }
 309 |     |     }
 310 |     | 
 311 |     |     /// @dev Reads an immutable arg with type uint48.
 312 |     |     function _getArgUint48(uint256 argOffset) internal pure returns (uint48 arg) {
 313 |     |         uint256 offset = _getImmutableArgsOffset();
 314 |     |         /// @solidity memory-safe-assembly
 315 |     |         assembly {
 316 |     |             arg := shr(208, calldataload(add(offset, argOffset)))
 317 |     |         }
 318 |     |     }
 319 |     | 
 320 |     |     /// @dev Reads an immutable arg with type uint40.
 321 |     |     function _getArgUint40(uint256 argOffset) internal pure returns (uint40 arg) {
 322 |     |         uint256 offset = _getImmutableArgsOffset();
 323 |     |         /// @solidity memory-safe-assembly
 324 |     |         assembly {
 325 |     |             arg := shr(216, calldataload(add(offset, argOffset)))
 326 |     |         }
 327 |     |     }
 328 |     | 
 329 |     |     /// @dev Reads an immutable arg with type uint32.
 330 |     |     function _getArgUint32(uint256 argOffset) internal pure returns (uint32 arg) {
 331 |     |         uint256 offset = _getImmutableArgsOffset();
 332 |     |         /// @solidity memory-safe-assembly
 333 |     |         assembly {
 334 |     |             arg := shr(224, calldataload(add(offset, argOffset)))
 335 |     |         }
 336 |     |     }
 337 |     | 
 338 |     |     /// @dev Reads an immutable arg with type uint24.
 339 |     |     function _getArgUint24(uint256 argOffset) internal pure returns (uint24 arg) {
 340 |     |         uint256 offset = _getImmutableArgsOffset();
 341 |     |         /// @solidity memory-safe-assembly
 342 |     |         assembly {
 343 |     |             arg := shr(232, calldataload(add(offset, argOffset)))
 344 |     |         }
 345 |     |     }
 346 |     | 
 347 |     |     /// @dev Reads an immutable arg with type uint16.
 348 |     |     function _getArgUint16(uint256 argOffset) internal pure returns (uint16 arg) {
 349 |     |         uint256 offset = _getImmutableArgsOffset();
 350 |     |         /// @solidity memory-safe-assembly
 351 |     |         assembly {
 352 |     |             arg := shr(240, calldataload(add(offset, argOffset)))
 353 |     |         }
 354 |     |     }
 355 |     | 
 356 |     |     /// @dev Reads an immutable arg with type uint8.
 357 |     |     function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {
 358 |     |         uint256 offset = _getImmutableArgsOffset();
 359 |     |         /// @solidity memory-safe-assembly
 360 |     |         assembly {
 361 |     |             arg := shr(248, calldataload(add(offset, argOffset)))
 362 |     |         }
 363 |     |     }
 364 |     | 
 365 |     |     /// @return offset The offset of the packed immutable args in calldata.
 366 |     |     function _getImmutableArgsOffset() internal pure returns (uint256 offset) {
 367 |     |         /// @solidity memory-safe-assembly
 368 |     |         assembly {
 369 |     |             offset := sub(calldatasize(), shr(240, calldataload(sub(calldatasize(), 2))))
 370 |     |         }
 371 |     |     }
 372 |     | }

/home/ec2-user/git/cover/contracts/external/solady/LibClone.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /// @notice Minimal proxy library.
   5 |     | /// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)
   6 |     | /// @author Minimal proxy by 0age (https://github.com/0age)
   7 |     | /// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie
   8 |     | /// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)
   9 |     | ///
  10 |     | /// @dev Minimal proxy:
  11 |     | /// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,
  12 |     | /// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,
  13 |     | /// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.
  14 |     | ///
  15 |     | /// @dev Clones with immutable args (CWIA):
  16 |     | /// The implementation of CWIA here implements a `receive()` method that emits the
  17 |     | /// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,
  18 |     | /// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards
  19 |     | /// composability. The minimal proxy implementation does not offer this feature.
  20 |     | library LibClone {
  21 |     |     /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/
  22 |     |     /*                       CUSTOM ERRORS                        */
  23 |     |     /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/
  24 |     | 
  25 |     |     /// @dev Unable to deploy the clone.
  26 |     |     error DeploymentFailed();
  27 |     | 
  28 |     |     /// @dev The salt must start with either the zero address or the caller.
  29 |     |     error SaltDoesNotStartWithCaller();
  30 |     | 
  31 |     |     /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/
  32 |     |     /*                  MINIMAL PROXY OPERATIONS                  */
  33 |     |     /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/
  34 |     | 
  35 |     |     /// @dev Deploys a deterministic clone of `implementation`,
  36 |     |     /// using immutable  arguments encoded in `data`, with `salt`.
  37 |     |     function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)
  38 |     |         internal
  39 |     |         returns (address instance)
  40 |     |     {
  41 |     |         assembly {
  42 |     |             // Compute the boundaries of the data and cache the memory slots around it.
  43 |     |             let mBefore3 := mload(sub(data, 0x60))
  44 |     |             let mBefore2 := mload(sub(data, 0x40))
  45 |     |             let mBefore1 := mload(sub(data, 0x20))
  46 |     |             let dataLength := mload(data)
  47 |     |             let dataEnd := add(add(data, 0x20), dataLength)
  48 |     |             let mAfter1 := mload(dataEnd)
  49 |     | 
  50 |     |             // +2 bytes for telling how much data there is appended to the call.
  51 |     |             let extraLength := add(dataLength, 2)
  52 |     | 
  53 |     |             // Write the bytecode before the data.
  54 |     |             mstore(data, 0x5af43d3d93803e606057fd5bf3)
  55 |     |             // Write the address of the implementation.
  56 |     |             mstore(sub(data, 0x0d), implementation)
  57 |     |             // Write the rest of the bytecode.
  58 |     |             mstore(
  59 |     |                 sub(data, 0x21),
  60 |     |                 or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)
  61 |     |             )
  62 |     |             // `keccak256("ReceiveETH(uint256)")`
  63 |     |             mstore(
  64 |     |                 sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff
  65 |     |             )
  66 |     |             mstore(
  67 |     |                 sub(data, 0x5a),
  68 |     |                 or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)
  69 |     |             )
  70 |     |             mstore(dataEnd, shl(0xf0, extraLength))
  71 |     | 
  72 |     |             // Create the instance.
  73 |     |             instance := create2(0, sub(data, 0x4c), add(extraLength, 0x6c), salt)
  74 |     | 
  75 |     |             // If `instance` is zero, revert.
  76 |     |             if iszero(instance) {
  77 |     |                 // Store the function selector of `DeploymentFailed()`.
  78 |     |                 mstore(0x00, 0x30116425)
  79 |     |                 // Revert with (offset, size).
  80 |     |                 revert(0x1c, 0x04)
  81 |     |             }
  82 |     | 
  83 |     |             // Restore the overwritten memory surrounding `data`.
  84 |     |             mstore(dataEnd, mAfter1)
  85 |     |             mstore(data, dataLength)
  86 |     |             mstore(sub(data, 0x20), mBefore1)
  87 |     |             mstore(sub(data, 0x40), mBefore2)
  88 |     |             mstore(sub(data, 0x60), mBefore3)
  89 |     |         }
  90 |     |     }
  91 |     | 
  92 |     |     /// @dev Returns the initialization code hash of the clone of `implementation`
  93 |     |     /// using immutable arguments encoded in `data`.
  94 |     |     /// Used for mining vanity addresses with create2crunch.
  95 |     |     function initCodeHash(address implementation, bytes memory data)
  96 |     |         internal
  97 |     |         pure
  98 |     |         returns (bytes32 hash)
  99 |     |     {
 100 |     |         assembly {
 101 |     |             // Compute the boundaries of the data and cache the memory slots around it.
 102 |     |             let mBefore3 := mload(sub(data, 0x60))
 103 |     |             let mBefore2 := mload(sub(data, 0x40))
 104 |     |             let mBefore1 := mload(sub(data, 0x20))
 105 |     |             let dataLength := mload(data)
 106 |     |             let dataEnd := add(add(data, 0x20), dataLength)
 107 |     |             let mAfter1 := mload(dataEnd)
 108 |     | 
 109 |     |             // +2 bytes for telling how much data there is appended to the call.
 110 |     |             let extraLength := add(dataLength, 2)
 111 |     | 
 112 |     |             // Write the bytecode before the data.
 113 |     |             mstore(data, 0x5af43d3d93803e606057fd5bf3)
 114 |     |             // Write the address of the implementation.
 115 |     |             mstore(sub(data, 0x0d), implementation)
 116 |     |             // Write the rest of the bytecode.
 117 |     |             mstore(
 118 |     |                 sub(data, 0x21),
 119 |     |                 or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)
 120 |     |             )
 121 |     |             // `keccak256("ReceiveETH(uint256)")`
 122 |     |             mstore(
 123 |     |                 sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff
 124 |     |             )
 125 |     |             mstore(
 126 |     |                 sub(data, 0x5a),
 127 |     |                 or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)
 128 |     |             )
 129 |     |             mstore(dataEnd, shl(0xf0, extraLength))
 130 |     | 
 131 |     |             // Compute and store the bytecode hash.
 132 |     |             hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))
 133 |     | 
 134 |     |             // Restore the overwritten memory surrounding `data`.
 135 |     |             mstore(dataEnd, mAfter1)
 136 |     |             mstore(data, dataLength)
 137 |     |             mstore(sub(data, 0x20), mBefore1)
 138 |     |             mstore(sub(data, 0x40), mBefore2)
 139 |     |             mstore(sub(data, 0x60), mBefore3)
 140 |     |         }
 141 |     |     }
 142 |     | 
 143 |     |     /// @dev Returns the address of the deterministic clone of
 144 |     |     /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.
 145 |     |     function predictDeterministicAddress(
 146 |     |         address implementation,
 147 |     |         bytes memory data,
 148 |     |         bytes32 salt,
 149 |     |         address deployer
 150 |     |     ) internal pure returns (address predicted) {
 151 |     |         bytes32 hash = initCodeHash(implementation, data);
 152 |     |         predicted = predictDeterministicAddress(hash, salt, deployer);
 153 |     |     }
 154 |     | 
 155 |     |     /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/
 156 |     |     /*                      OTHER OPERATIONS                      */
 157 |     |     /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/
 158 |     | 
 159 |     |     /// @dev Returns the address when a contract with initialization code hash,
 160 |     |     /// `hash`, is deployed with `salt`, by `deployer`.
 161 |     |     function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)
 162 |     |         internal
 163 |     |         pure
 164 |     |         returns (address predicted)
 165 |     |     {
 166 |     |         /// @solidity memory-safe-assembly
 167 |     |         assembly {
 168 |     |             // Compute and store the bytecode hash.
 169 |     |             mstore8(0x00, 0xff) // Write the prefix.
 170 |     |             mstore(0x35, hash)
 171 |     |             mstore(0x01, shl(96, deployer))
 172 |     |             mstore(0x15, salt)
 173 |     |             predicted := keccak256(0x00, 0x55)
 174 |     |             // Restore the part of the free memory pointer that has been overwritten.
 175 |     |             mstore(0x35, 0)
 176 |     |         }
 177 |     |     }
 178 |     | 
 179 |     |     /// @dev Reverts if `salt` does not start with either the zero address or the caller.
 180 |     |     function checkStartsWithCaller(bytes32 salt) internal view {
 181 |     |         /// @solidity memory-safe-assembly
 182 |     |         assembly {
 183 |     |             // If the salt does not start with the zero address or the caller.
 184 |     |             if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {
 185 |     |                 // Store the function selector of `SaltDoesNotStartWithCaller()`.
 186 |     |                 mstore(0x00, 0x2f634836)
 187 |     |                 // Revert with (offset, size).
 188 |     |                 revert(0x1c, 0x04)
 189 |     |             }
 190 |     |         }
 191 |     |     }
 192 |     | }

/home/ec2-user/git/cover/contracts/interfaces/ICoverPool.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
   2 |     | pragma solidity ^0.8.13;
   3 |     | 
   4 |     | import './structs/CoverPoolStructs.sol';
   5 |     | 
   6 |     | /**
   7 |     |  * @title ICoverPool
   8 |     |  * @author Poolshark
   9 |     |  * @notice Defines the basic interface for a Cover Pool.
  10 |     |  */
  11 |     | interface ICoverPool is CoverPoolStructs {
  12 |     |     /**
  13 |     |      * @custom:struct MintParams
  14 |     |      */
  15 |     |     struct MintParams {
  16 |     |         /**
  17 |     |          * @custom:field to
  18 |     |          * @notice Address for the receiver of the minted position
  19 |     |          */
  20 |     |         address to;
  21 |     | 
  22 |     |         /**
  23 |     |          * @custom:field amount
  24 |     |          * @notice Token amount to be deposited into the minted position
  25 |     |          */
  26 |     |         uint128 amount;
  27 |     | 
  28 |     |         /**
  29 |     |          * @custom:field positionId
  30 |     |          * @notice 0 if creating a new position; id of previous if adding liquidity
  31 |     |          */
  32 |     |         uint32 positionId;
  33 |     | 
  34 |     |         /**
  35 |     |          * @custom:field lower
  36 |     |          * @notice The lower price tick for the position range
  37 |     |          */
  38 |     |         int24 lower;
  39 |     | 
  40 |     |         /**
  41 |     |          * @custom:field upper
  42 |     |          * @notice The upper price tick for the position range
  43 |     |          */
  44 |     |         int24 upper;
  45 |     | 
  46 |     |         /**
  47 |     |          * @custom:field zeroForOne
  48 |     |          * @notice True if depositing token0, the first token address in lexographical order
  49 |     |          * @notice False if depositing token1, the second token address in lexographical order 
  50 |     |          */
  51 |     |         bool zeroForOne;
  52 |     |     }
  53 |     | 
  54 |     |     /**
  55 |     |      * @notice Deposits `amountIn` of asset to be auctioned off each time price range is crossed further into.
  56 |     |      * - E.g. User supplies 1 WETH in the range 1500 USDC per WETH to 1400 USDC per WETH
  57 |     |               As latestTick crosses from 1500 USDC per WETH to 1400 USDC per WETH,
  58 |     |               the user's liquidity within each tick spacing is auctioned off.
  59 |     |      * @dev The position will be shrunk onto the correct side of latestTick.
  60 |     |      * @dev The position will be minted with the `to` address as the owner.
  61 |     |      * @param params The parameters for the function. See MintParams above.
  62 |     |      */
  63 |     |     function mint(
  64 |     |         MintParams memory params
  65 |     |     ) external;
  66 |     | 
  67 |     |     /**
  68 |     |      * @custom:struct BurnParams
  69 |     |      */
  70 |     |     struct BurnParams {
  71 |     |         /**
  72 |     |          * @custom:field to
  73 |     |          * @notice Address for the receiver of the collected position amounts
  74 |     |          */
  75 |     |         address to;
  76 |     | 
  77 |     |         /**
  78 |     |          * @custom:field burnPercent
  79 |     |          * @notice Percent of the remaining liquidity to be removed
  80 |     |          * @notice 1e38 represents 100%
  81 |     |          * @notice 5e37 represents 50%
  82 |     |          * @notice 1e37 represents 10%
  83 |     |          */
  84 |     |         uint128 burnPercent;
  85 |     | 
  86 |     |         /**
  87 |     |          * @custom:field positionId
  88 |     |          * @notice 0 if creating a new position; id of previous if adding liquidity
  89 |     |          */
  90 |     |         uint32 positionId;
  91 |     | 
  92 |     |         /**
  93 |     |          * @custom:field claim
  94 |     |          * @notice The most recent tick crossed in this range
  95 |     |          * @notice if `zeroForOne` is true, claim tick progresses from upper => lower
  96 |     |          * @notice if `zeroForOne` is false, claim tick progresses from lower => upper
  97 |     |          */
  98 |     |         int24 claim;
  99 |     | 
 100 |     |         /**
 101 |     |          * @custom:field zeroForOne
 102 |     |          * @notice True if deposited token0, the first token address in lexographical order
 103 |     |          * @notice False if deposited token1, the second token address in lexographical order 
 104 |     |          */
 105 |     |         bool zeroForOne;
 106 |     | 
 107 |     |         /**
 108 |     |          * @custom:field sync
 109 |     |          * @notice True will sync the pool latestTick
 110 |     |          * @notice False will skip syncing latestTick 
 111 |     |          */
 112 |     |         bool sync;
 113 |     |     }
 114 |     | 
 115 |     |     /**
 116 |     |      * @notice Withdraws the input token and returns any filled and/or unfilled amounts to the 'to' address specified. 
 117 |     |      * - E.g. User supplies 1 WETH in the range 1500 USDC per WETH to 1400 USDC per WETH
 118 |     |               As latestTick crosses from 1500 USDC per WETH to 1400 USDC per WETH,
 119 |     |               the user's liquidity within each tick spacing is auctioned off.
 120 |     |      * @dev The position will be shrunk based on the claim tick passed.
 121 |     |      * @dev The position amounts will be returned to the `to` address specified.
 122 |     |      * @dev The `sync` flag can be set to false so users can exit safely without syncing latestTick.
 123 |     |      * @param params The parameters for the function. See BurnParams above.
 124 |     |      */
 125 |     |     function burn(
 126 |     |         BurnParams memory params
 127 |     |     ) external; 
 128 |     | 
 129 |     |     /**
 130 |     |      * @notice Swaps `tokenIn` for `tokenOut`. 
 131 |     |                `tokenIn` will be `token0` if `zeroForOne` is true.
 132 |     |                `tokenIn` will be `token1` if `zeroForOne` is false.
 133 |     |                The pool price represents token1 per token0.
 134 |     |                The pool price will decrease if `zeroForOne` is true.
 135 |     |                The pool price will increase if `zeroForOne` is false. 
 136 |     |      * @param params The parameters for the function. See SwapParams above.
 137 |     |      * @return amount0Delta The amount of token0 spent (negative) or received (positive) by the user
 138 |     |      * @return amount1Delta The amount of token1 spent (negative) or received (positive) by the user
 139 |     |      */
 140 |     |     function swap(
 141 |     |         SwapParams memory params
 142 |     |     ) external returns (
 143 |     |         int256 amount0Delta,
 144 |     |         int256 amount1Delta
 145 |     |     );
 146 |     | 
 147 |     |     /**
 148 |     |      * @notice Quotes the amount of `tokenIn` for `tokenOut`. 
 149 |     |                `tokenIn` will be `token0` if `zeroForOne` is true.
 150 |     |                `tokenIn` will be `token1` if `zeroForOne` is false.
 151 |     |                The pool price represents token1 per token0.
 152 |     |                The pool price will decrease if `zeroForOne` is true.
 153 |     |                The pool price will increase if `zeroForOne` is false. 
 154 |     |      * @param params The parameters for the function. See SwapParams above.
 155 |     |      * @return inAmount  The amount of tokenIn to be spent
 156 |     |      * @return outAmount The amount of tokenOut to be received
 157 |     |      * @return priceAfter The Q64.96 square root price after the swap
 158 |     |      */
 159 |     |     function quote(
 160 |     |         QuoteParams memory params
 161 |     |     ) external view returns (
 162 |     |         int256 inAmount,
 163 |     |         int256 outAmount,
 164 |     |         uint256 priceAfter
 165 |     |     );
 166 |     | 
 167 |     |     /**
 168 |     |      * @custom:struct SnapshotParams
 169 |     |      */
 170 |     |     struct SnapshotParams {
 171 |     |         /**
 172 |     |          * @custom:field to
 173 |     |          * @notice Address of the position owner
 174 |     |          */
 175 |     |         address owner;
 176 |     | 
 177 |     |         /**
 178 |     |          * @custom:field positionId
 179 |     |          * @notice id of position
 180 |     |          */
 181 |     |         uint32 positionId;
 182 |     | 
 183 |     |         /**
 184 |     |          * @custom:field burnPercent
 185 |     |          * @notice Percent of the remaining liquidity to be removed
 186 |     |          * @notice 1e38 represents 100%
 187 |     |          * @notice 5e37 represents 50%
 188 |     |          * @notice 1e37 represents 10%
 189 |     |          */
 190 |     |         uint128 burnPercent;
 191 |     | 
 192 |     |         /**
 193 |     |          * @custom:field claim
 194 |     |          * @notice The most recent tick crossed in this range
 195 |     |          * @notice if `zeroForOne` is true, claim tick progresses from upper => lower
 196 |     |          * @notice if `zeroForOne` is false, claim tick progresses from lower => upper
 197 |     |          */
 198 |     |         int24 claim;
 199 |     | 
 200 |     |         /**
 201 |     |          * @custom:field zeroForOne
 202 |     |          * @notice True if deposited token0, the first token address in lexographical order
 203 |     |          * @notice False if deposited token1, the second token address in lexographical order 
 204 |     |          */
 205 |     |         bool zeroForOne;
 206 |     |     }
 207 |     | 
 208 |     |     /**
 209 |     |      * @notice Snapshots the current state of an existing position. 
 210 |     |      * @param params The parameters for the function. See SwapParams above.
 211 |     |      * @return position The updated position containing `amountIn` and `amountOut`
 212 |     |      * @dev positions amounts reflected will be collected by the user if `burn` is called
 213 |     |      */
 214 |     |     function snapshot(
 215 |     |         SnapshotParams memory params
 216 |     |     ) external view returns (
 217 |     |         CoverPosition memory position
 218 |     |     );
 219 |     | 
 220 |     |     /**
 221 |     |      * @notice Sets and collect protocol fees from the pool. 
 222 |     |      * @param syncFee The new syncFee to be set if `setFees` is true.
 223 |     |      * @param fillFee The new fillFee to be set if `setFees` is true.
 224 |     |      * @return token0Fees The `token0` fees collected.
 225 |     |      * @return token1Fees The `token1` fees collected.
 226 |     |      * @dev `syncFee` is a basis point fee to be paid to users who sync latestTick
 227 |     |      * @dev `fillFee` is a basis point fee to be paid to the protocol for amounts filled
 228 |     |      * @dev All fees are zero by default unless the protocol decides to enable them.
 229 |     |      */
 230 |     |     function fees(
 231 |     |         uint16 syncFee,
 232 |     |         uint16 fillFee,
 233 |     |         bool setFees
 234 |     |     ) external returns (
 235 |     |         uint128 token0Fees,
 236 |     |         uint128 token1Fees
 237 |     |     );
 238 |     | 
 239 |     |     function immutables(
 240 |     |     ) external view returns (
 241 |     |         CoverImmutables memory constants
 242 |     |     );
 243 |     | 
 244 |     |     function priceBounds(
 245 |     |         int16 tickSpacing
 246 |     |     ) external pure returns (
 247 |     |         uint160 minPrice,
 248 |     |         uint160 maxPrice
 249 |     |     );
 250 |     | }
 251 |     | 

/home/ec2-user/git/cover/contracts/interfaces/ICoverPoolFactory.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.13;
  3 |     | import '../base/storage/CoverPoolFactoryStorage.sol';
  4 |     | 
  5 |     | abstract contract ICoverPoolFactory is CoverPoolFactoryStorage {
  6 |     | 
  7 |     |     struct CoverPoolParams {
  8 |     |         bytes32 poolType;
  9 |     |         address tokenIn;
 10 |     |         address tokenOut;
 11 |     |         uint16 feeTier;
 12 |     |         int16  tickSpread;
 13 |     |         uint16 twapLength;
 14 |     |     }
 15 |     | 
 16 |     |     /**
 17 |     |      * @notice Creates a new CoverPool.
 18 |     |      * @param params The CoverPoolParams struct referenced above.
 19 |     |      */
 20 |     |     function createCoverPool(
 21 |     |         CoverPoolParams memory params
 22 |     |     ) external virtual returns (address pool);
 23 |     | 
 24 |     |     /**
 25 |     |      * @notice Fetches an existing CoverPool.
 26 |     |      * @param params The CoverPoolParams struct referenced above.
 27 |     |      */
 28 |     |     function getCoverPool(
 29 |     |         CoverPoolParams memory params
 30 |     |     ) external view virtual returns (address pool);
 31 |     | }
 32 |     | 

/home/ec2-user/git/cover/contracts/interfaces/ICoverPoolManager.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../interfaces/structs/CoverPoolStructs.sol';
  5 |     | 
  6 |     | /// @notice CoverPoolManager interface
  7 |     | interface ICoverPoolManager is CoverPoolStructs {
  8 |     |     function owner() external view returns (address);
  9 |     |     function feeTo() external view returns (address);
 10 |     |     function poolTypes(
 11 |     |         bytes32 poolType
 12 |     |     ) external view returns (
 13 |     |         address implAddress,
 14 |     |         address sourceAddress
 15 |     |     );
 16 |     |     function volatilityTiers(
 17 |     |         bytes32 implName,
 18 |     |         uint16 feeTier,
 19 |     |         int16  tickSpread,
 20 |     |         uint16 twapLength
 21 |     |     ) external view returns (
 22 |     |         VolatilityTier memory
 23 |     |     );
 24 |     | }
 25 |     | 

/home/ec2-user/git/cover/contracts/interfaces/IERC20Minimal.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | interface IERC20Minimal {
  5 |     |     /// @notice Returns the balance of a token
  6 |     |     /// @param account The address for which to look up the balance for
  7 |     |     /// @return amount of tokens held by the account
  8 |     |     function balanceOf(address account) external view returns (uint256);
  9 |     | }

/home/ec2-user/git/cover/contracts/interfaces/callbacks/ICoverPoolSwapCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | /// @title Callback for swaps
  5 |     | /// @notice Any contract that calls the `swap` function must implement this interface.
  6 |     | interface ICoverPoolSwapCallback {
  7 |     |     /// @notice Called to `msg.sender` after executing a swap.
  8 |     |     /// @dev In the implementation you must pay the pool tokens owed for the swap.
  9 |     |     /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.
 10 |     |     /// @param amount0Delta The amount of token0 either received by (positive) or sent from (negative) the user.
 11 |     |     /// @param amount1Delta The amount of token1 either received by (positive) or sent from (negative) the user.
 12 |     |     function coverPoolSwapCallback(
 13 |     |         int256 amount0Delta,
 14 |     |         int256 amount1Delta,
 15 |     |         bytes calldata data
 16 |     |     ) external;
 17 |     | }

/home/ec2-user/git/cover/contracts/interfaces/external/uniswap/v3/IUniswapV3Factory.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title The interface for the Concentrated Liquidity Pool Factory
  5 |     | interface IUniswapV3Factory {
  6 |     |     /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled
  7 |     |     /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context
  8 |     |     /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee
  9 |     |     /// @return The tick spacing
 10 |     |     function feeTierTickSpacing(uint24 fee) external view returns (int24);
 11 |     | 
 12 |     |     /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist
 13 |     |     /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order
 14 |     |     /// @param tokenA The contract address of either token0 or token1
 15 |     |     /// @param tokenB The contract address of the other token
 16 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 17 |     |     /// @return pool The pool address
 18 |     |     function getPool(
 19 |     |         address tokenA,
 20 |     |         address tokenB,
 21 |     |         uint24 fee
 22 |     |     ) external view returns (address pool);
 23 |     | }
 24 |     | 

/home/ec2-user/git/cover/contracts/interfaces/external/uniswap/v3/IUniswapV3Pool.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | interface IUniswapV3Pool {
  5 |     |     /// @notice This is to be used at hedge pool initialization in case the cardinality is too low for the hedge pool.
  6 |     |     /// @notice Increase the maximum number of price and liquidity observations that this pool will store
  7 |     |     /// @param observationCardinalityNext The desired minimum number of observations for the pool to store
  8 |     |     function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
  9 |     | 
 10 |     |     function token0() external view returns (address);
 11 |     | 
 12 |     |     function token1() external view returns (address);
 13 |     | 
 14 |     |     function tickSpacing() external view returns (int24);
 15 |     | 
 16 |     |     /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
 17 |     |     /// when accessed externally.
 18 |     |     /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
 19 |     |     /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
 20 |     |     /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
 21 |     |     /// boundary.
 22 |     |     /// observationIndex The index of the last oracle observation that was written,
 23 |     |     /// observationCardinality The current maximum number of observations stored in the pool,
 24 |     |     /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
 25 |     |     /// feeProtocol The protocol fee for both tokens of the pool.
 26 |     |     /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
 27 |     |     /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
 28 |     |     /// unlocked Whether the pool is currently locked to reentrancy
 29 |     |     function slot0()
 30 |     |         external
 31 |     |         view
 32 |     |         returns (
 33 |     |             uint160 sqrtPriceX96,
 34 |     |             int24 tick,
 35 |     |             uint16 observationIndex,
 36 |     |             uint16 observationCardinality,
 37 |     |             uint16 observationCardinalityNext,
 38 |     |             uint8 feeProtocol,
 39 |     |             bool unlocked
 40 |     |         );
 41 |     | 
 42 |     |     /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
 43 |     |     /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
 44 |     |     /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned
 45 |     |     /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp
 46 |     |     /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block
 47 |     |     /// timestamp
 48 |     |     function observe(uint32[] calldata secondsAgos)
 49 |     |         external
 50 |     |         view
 51 |     |         returns (
 52 |     |             int56[] memory tickCumulatives,
 53 |     |             uint160[] memory secondsPerLiquidityCumulativeX128s
 54 |     |         );
 55 |     | }
 56 |     | 

/home/ec2-user/git/cover/contracts/interfaces/modules/sources/ITwapSource.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import '../../structs/PoolsharkStructs.sol';
  5 |     | 
  6 |     | interface ITwapSource {
  7 |     |     function initialize(
  8 |     |         PoolsharkStructs.CoverImmutables memory constants
  9 |     |     ) external returns (
 10 |     |         uint8 initializable,
 11 |     |         int24 startingTick
 12 |     |     );
 13 |     | 
 14 |     |     function calculateAverageTick(
 15 |     |         PoolsharkStructs.CoverImmutables memory constants,
 16 |     |         int24 latestTick
 17 |     |     ) external view returns (
 18 |     |         int24 averageTick
 19 |     |     );
 20 |     | 
 21 |     |     function getPool(
 22 |     |         address tokenA,
 23 |     |         address tokenB,
 24 |     |         uint16 feeTier
 25 |     |     ) external view returns (
 26 |     |         address pool
 27 |     |     );
 28 |     | 
 29 |     |     function feeTierTickSpacing(
 30 |     |         uint16 feeTier
 31 |     |     ) external view returns (
 32 |     |         int24 tickSpacing
 33 |     |     );
 34 |     | 
 35 |     |     function factory()
 36 |     |     external view returns (address);
 37 |     | }
 38 |     | 

/home/ec2-user/git/cover/contracts/interfaces/structs/CoverPoolStructs.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.13;
   3 |     | 
   4 |     | import './PoolsharkStructs.sol';
   5 |     | import '../modules/sources/ITwapSource.sol';
   6 |     | 
   7 |     | interface CoverPoolStructs is PoolsharkStructs {
   8 |     |     struct GlobalState {
   9 |     |         ProtocolFees protocolFees;
  10 |     |         uint160  latestPrice;      /// @dev price of latestTick
  11 |     |         uint128  liquidityGlobal;
  12 |     |         uint32   lastTime;         /// @dev last block checked
  13 |     |         uint32   auctionStart;     /// @dev last block price reference was updated
  14 |     |         uint32   accumEpoch;       /// @dev number of times this pool has been synced
  15 |     |         uint32   positionIdNext;
  16 |     |         int24    latestTick;       /// @dev latest updated inputPool price tick
  17 |     |         uint16   syncFee;
  18 |     |         uint16   fillFee;
  19 |     |         uint8    unlocked;
  20 |     |     }
  21 |     | 
  22 |     |     struct PoolState {
  23 |     |         uint160 price; /// @dev Starting price current
  24 |     |         uint128 liquidity; /// @dev Liquidity currently active
  25 |     |         uint128 amountInDelta; /// @dev Delta for the current tick auction
  26 |     |         uint128 amountInDeltaMaxClaimed;  /// @dev - needed when users claim and don't burn; should be cleared when users burn liquidity
  27 |     |         uint128 amountOutDeltaMaxClaimed; /// @dev - needed when users claim and don't burn; should be cleared when users burn liquidity
  28 |     |     }
  29 |     | 
  30 |     |     struct TickMap {
  31 |     |         uint256 blocks;                     /// @dev - sets of words
  32 |     |         mapping(uint256 => uint256) words;  /// @dev - sets to words
  33 |     |         mapping(uint256 => uint256) ticks;  /// @dev - words to ticks
  34 |     |         mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) epochs0; /// @dev - ticks to pool0 epochs
  35 |     |         mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) epochs1; /// @dev - ticks to pool1 epochs
  36 |     |     }
  37 |     | 
  38 |     |     struct Tick {
  39 |     |         Deltas deltas0;
  40 |     |         Deltas deltas1;                    
  41 |     |         int128 liquidityDelta;
  42 |     |         uint128 amountInDeltaMaxMinus;
  43 |     |         uint128 amountOutDeltaMaxMinus;
  44 |     |         uint128 amountInDeltaMaxStashed;
  45 |     |         uint128 amountOutDeltaMaxStashed;
  46 |     |         bool pool0Stash;
  47 |     |     }
  48 |     | 
  49 |     |     struct Deltas {
  50 |     |         uint128 amountInDelta;     /// @dev - amount filled
  51 |     |         uint128 amountOutDelta;    /// @dev - amount unfilled
  52 |     |         uint128 amountInDeltaMax;  /// @dev - max filled 
  53 |     |         uint128 amountOutDeltaMax; /// @dev - max unfilled
  54 |     |     }
  55 |     | 
  56 |     |     struct CoverPosition {
  57 |     |         address owner;
  58 |     |         uint160 claimPriceLast;    /// @dev - highest price claimed at
  59 |     |         uint128 liquidity;         /// @dev - expected amount to be used not actual
  60 |     |         uint128 amountIn;          /// @dev - token amount already claimed; balance
  61 |     |         uint128 amountOut;         /// @dev - necessary for non-custodial positions
  62 |     |         uint32  accumEpochLast;    /// @dev - last epoch this position was updated at
  63 |     |         int24 lower;
  64 |     |         int24 upper;
  65 |     |     }
  66 |     | 
  67 |     |     struct VolatilityTier {
  68 |     |         uint128 minAmountPerAuction; // based on 18 decimals and then converted based on token decimals
  69 |     |         uint16  auctionLength;
  70 |     |         uint16  blockTime; // average block time where 1e3 is 1 second
  71 |     |         uint16  syncFee;
  72 |     |         uint16  fillFee;
  73 |     |         int16   minPositionWidth;
  74 |     |         bool    minAmountLowerPriced;
  75 |     |     }
  76 |     | 
  77 |     |     struct ProtocolFees {
  78 |     |         uint128 token0;
  79 |     |         uint128 token1;
  80 |     |     }
  81 |     | 
  82 |     |     struct SyncFees {
  83 |     |         uint128 token0;
  84 |     |         uint128 token1;
  85 |     |     }
  86 |     | 
  87 |     |     struct CollectParams {
  88 |     |         SyncFees syncFees;
  89 |     |         address to;
  90 |     |         uint32 positionId;
  91 |     |         int24 lower;
  92 |     |         int24 claim;
  93 |     |         int24 upper;
  94 |     |         bool zeroForOne;
  95 |     |     }
  96 |     | 
  97 |     |     struct SizeParams {
  98 |     |         uint256 priceLower;
  99 |     |         uint256 priceUpper;
 100 |     |         uint128 liquidityAmount;
 101 |     |         bool zeroForOne;
 102 |     |         int24 latestTick;
 103 |     |         uint24 auctionCount;
 104 |     |     }
 105 |     | 
 106 |     |     struct AddParams {
 107 |     |         address to;
 108 |     |         uint128 amount;
 109 |     |         uint128 amountIn;
 110 |     |         uint32 positionId;
 111 |     |         int24 lower;
 112 |     |         int24 upper;
 113 |     |         bool zeroForOne;
 114 |     |     }
 115 |     | 
 116 |     |     struct RemoveParams {
 117 |     |         address owner;
 118 |     |         address to;
 119 |     |         uint128 amount;
 120 |     |         uint32 positionId;
 121 |     |         int24 lower;
 122 |     |         int24 upper;
 123 |     |         bool zeroForOne;
 124 |     |     }
 125 |     | 
 126 |     |     struct UpdateParams {
 127 |     |         address owner;
 128 |     |         address to;
 129 |     |         uint128 amount;
 130 |     |         uint32 positionId;
 131 |     |         int24 lower;
 132 |     |         int24 upper;
 133 |     |         int24 claim;
 134 |     |         bool zeroForOne;
 135 |     |     }
 136 |     | 
 137 |     |     struct MintCache {
 138 |     |         GlobalState state;
 139 |     |         CoverPosition position;
 140 |     |         CoverImmutables constants;
 141 |     |         SyncFees syncFees;
 142 |     |         PoolState pool0;
 143 |     |         PoolState pool1;
 144 |     |         uint256 liquidityMinted;
 145 |     |     }
 146 |     | 
 147 |     |     struct BurnCache {
 148 |     |         GlobalState state;
 149 |     |         CoverPosition position;
 150 |     |         CoverImmutables constants;
 151 |     |         SyncFees syncFees;
 152 |     |         PoolState pool0;
 153 |     |         PoolState pool1;
 154 |     |     }
 155 |     | 
 156 |     |     struct SwapCache {
 157 |     |         GlobalState state;
 158 |     |         SyncFees syncFees;
 159 |     |         CoverImmutables constants;
 160 |     |         PoolState pool0;
 161 |     |         PoolState pool1;
 162 |     |         uint256 price;
 163 |     |         uint256 liquidity;
 164 |     |         uint256 amountLeft;
 165 |     |         uint256 input;
 166 |     |         uint256 output;
 167 |     |         uint256 amountBoosted;
 168 |     |         uint256 auctionDepth;
 169 |     |         uint256 auctionBoost;
 170 |     |         uint256 amountInDelta;
 171 |     |         int256 amount0Delta;
 172 |     |         int256 amount1Delta;
 173 |     |         bool exactIn;
 174 |     |     }
 175 |     | 
 176 |     |     struct CoverPositionCache {
 177 |     |         CoverPosition position;
 178 |     |         Deltas deltas;
 179 |     |         uint160 priceLower;
 180 |     |         uint160 priceUpper;
 181 |     |         uint256 priceAverage;
 182 |     |         uint256 liquidityMinted;
 183 |     |         int24 requiredStart;
 184 |     |         uint24 auctionCount;
 185 |     |         bool denomTokenIn;
 186 |     |     }
 187 |     | 
 188 |     |     struct UpdatePositionCache {
 189 |     |         Deltas deltas;
 190 |     |         Deltas finalDeltas;
 191 |     |         PoolState pool;
 192 |     |         uint256 amountInFilledMax;    // considers the range covered by each update
 193 |     |         uint256 amountOutUnfilledMax; // considers the range covered by each update
 194 |     |         Tick claimTick;
 195 |     |         Tick finalTick;
 196 |     |         CoverPosition position;
 197 |     |         uint160 priceLower;
 198 |     |         uint160 priceClaim;
 199 |     |         uint160 priceUpper;
 200 |     |         uint160 priceSpread;
 201 |     |         bool earlyReturn;
 202 |     |         bool removeLower;
 203 |     |         bool removeUpper;
 204 |     |     }
 205 |     | 
 206 |     |     struct AccumulateCache {
 207 |     |         Deltas deltas0;
 208 |     |         Deltas deltas1;
 209 |     |         SyncFees syncFees;
 210 |     |         int24 newLatestTick;
 211 |     |         int24 nextTickToCross0;
 212 |     |         int24 nextTickToCross1;
 213 |     |         int24 nextTickToAccum0;
 214 |     |         int24 nextTickToAccum1;
 215 |     |         int24 stopTick0;
 216 |     |         int24 stopTick1;
 217 |     |     }
 218 |     | 
 219 |     |     struct AccumulateParams {
 220 |     |         Deltas deltas;
 221 |     |         Tick crossTick;
 222 |     |         Tick accumTick;
 223 |     |         bool updateAccumDeltas;
 224 |     |         bool isPool0;
 225 |     |     }
 226 |     | }
 227 |     | 

/home/ec2-user/git/cover/contracts/interfaces/structs/PoolsharkStructs.sol
   1 |     | // SPDX-License-Identifier: GPLv3
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../modules/sources/ITwapSource.sol';
   5 |     | 
   6 |     | interface PoolsharkStructs {
   7 |     |     struct LimitImmutables {
   8 |     |         address owner;
   9 |     |         address poolImpl;
  10 |     |         address factory;
  11 |     |         PriceBounds bounds;
  12 |     |         address token0;
  13 |     |         address token1;
  14 |     |         address poolToken;
  15 |     |         uint32 genesisTime;
  16 |     |         int16 tickSpacing;
  17 |     |         uint16 swapFee;
  18 |     |     }
  19 |     | 
  20 |     |     struct CoverImmutables {
  21 |     |         ITwapSource source;
  22 |     |         PriceBounds bounds;
  23 |     |         address owner;
  24 |     |         address token0;
  25 |     |         address token1;
  26 |     |         address poolImpl;
  27 |     |         address inputPool;
  28 |     |         uint128 minAmountPerAuction;
  29 |     |         uint32 genesisTime;
  30 |     |         int16  minPositionWidth;
  31 |     |         int16  tickSpread;
  32 |     |         uint16 twapLength;
  33 |     |         uint16 auctionLength;
  34 |     |         uint16 blockTime;
  35 |     |         uint8 token0Decimals;
  36 |     |         uint8 token1Decimals;
  37 |     |         bool minAmountLowerPriced;
  38 |     |     }
  39 |     | 
  40 |     |     struct PriceBounds {
  41 |     |         uint160 min;
  42 |     |         uint160 max;
  43 |     |     }
  44 |     | 
  45 |     |     struct QuoteResults {
  46 |     |         address pool;
  47 |     |         int256 amountIn;
  48 |     |         int256 amountOut;
  49 |     |         uint160 priceAfter;
  50 |     |     }
  51 |     | 
  52 |     |     /**
  53 |     |      * @custom:struct QuoteParams
  54 |     |      */
  55 |     |     struct QuoteParams {
  56 |     |         /**
  57 |     |          * @custom:field priceLimit
  58 |     |          * @dev The Q64.96 square root price at which to stop swapping.
  59 |     |          */
  60 |     |         uint160 priceLimit;
  61 |     | 
  62 |     |         /**
  63 |     |          * @custom:field amount
  64 |     |          * @dev The exact input amount if exactIn = true
  65 |     |          * @dev The exact output amount if exactIn = false.
  66 |     |          */
  67 |     |         uint128 amount;
  68 |     | 
  69 |     |         /**
  70 |     |          * @custom:field zeroForOne
  71 |     |          * @notice True if amount is an input amount.
  72 |     |          * @notice False if amount is an output amount. 
  73 |     |          */
  74 |     |         bool exactIn;
  75 |     | 
  76 |     |         /**
  77 |     |          * @custom:field zeroForOne
  78 |     |          * @notice True if swapping token0 for token1.
  79 |     |          * @notice False if swapping in token1 for token0. 
  80 |     |          */
  81 |     |         bool zeroForOne;
  82 |     |     }
  83 |     | 
  84 |     |     /**
  85 |     |      * @custom:struct SwapParams
  86 |     |      */
  87 |     |     struct SwapParams {
  88 |     |         /**
  89 |     |          * @custom:field to
  90 |     |          * @notice Address for the receiver of the swap output
  91 |     |          */
  92 |     |         address to;
  93 |     | 
  94 |     |         /**
  95 |     |          * @custom:field priceLimit
  96 |     |          * @dev The Q64.96 square root price at which to stop swapping.
  97 |     |          */
  98 |     |         uint160 priceLimit;
  99 |     | 
 100 |     |         /**
 101 |     |          * @custom:field amount
 102 |     |          * @dev The exact input amount if exactIn = true
 103 |     |          * @dev The exact output amount if exactIn = false.
 104 |     |          */
 105 |     |         uint128 amount;
 106 |     | 
 107 |     |         /**
 108 |     |          * @custom:field zeroForOne
 109 |     |          * @notice True if amount is an input amount.
 110 |     |          * @notice False if amount is an output amount. 
 111 |     |          */
 112 |     |         bool exactIn;
 113 |     | 
 114 |     |         /**
 115 |     |          * @custom:field zeroForOne
 116 |     |          * @notice True if swapping token0 for token1.
 117 |     |          * @notice False if swapping in token1 for token0. 
 118 |     |          */
 119 |     |         bool zeroForOne;
 120 |     |         
 121 |     |         /**
 122 |     |          * @custom:field callbackData
 123 |     |          * @notice Data to be passed through to the swap callback. 
 124 |     |          */
 125 |     |          bytes callbackData;
 126 |     |     }
 127 |     | }

/home/ec2-user/git/cover/contracts/libraries/Claims.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.13;
   3 |     | 
   4 |     | import './Deltas.sol';
   5 |     | import '../interfaces/structs/CoverPoolStructs.sol';
   6 |     | import './EpochMap.sol';
   7 |     | import './TickMap.sol';
   8 |     | import './utils/String.sol';
   9 |     | 
  10 |     | library Claims {
  11 |     |     function validate(
  12 |     |         CoverPoolStructs.TickMap storage tickMap,
  13 |     |         CoverPoolStructs.GlobalState memory state,
  14 |     |         CoverPoolStructs.PoolState memory pool,
  15 |     |         CoverPoolStructs.UpdateParams memory params,
  16 |     |         CoverPoolStructs.UpdatePositionCache memory cache,
  17 |     |         PoolsharkStructs.CoverImmutables memory constants
  18 |     |     ) internal view returns (
  19 |     |         CoverPoolStructs.UpdateParams memory,
  20 |     |         CoverPoolStructs.UpdatePositionCache memory
  21 |     |     ) {
  22 |     |         // validate position liquidity
  23 |     |         if (cache.position.liquidity == 0) {
  24 |     |             cache.earlyReturn = true;
  25 |     |             return (params, cache);
  26 |     |         }
  27 |     |         if (params.amount > cache.position.liquidity) require (false, 'NotEnoughPositionLiquidity()');
  28 |     |         // if the position has not been crossed into at all
  29 |     |         else if (params.zeroForOne ? params.claim == params.upper 
  30 |     |                                         && EpochMap.get(params.upper, params.zeroForOne, tickMap, constants) <= cache.position.accumEpochLast
  31 |     |                                      : params.claim == params.lower 
  32 |     |                                         && EpochMap.get(params.lower, params.zeroForOne, tickMap, constants) <= cache.position.accumEpochLast
  33 |     |         ) {
  34 |     |             cache.earlyReturn = true;
  35 |     |             return (params, cache);
  36 |     |         }
  37 |     |         // early return if no update and amount burned is 0
  38 |     |         if (
  39 |     |             (
  40 |     |                 params.zeroForOne
  41 |     |                     ? params.claim == params.upper && cache.priceUpper != pool.price
  42 |     |                     : params.claim == params.lower && cache.priceLower != pool.price /// @dev - if pool price is start tick, set claimPriceLast to next tick crossed
  43 |     |             ) && params.claim == state.latestTick
  44 |     |         ) { if (params.amount == 0 && cache.position.claimPriceLast == pool.price) {
  45 |     |                 cache.earlyReturn = true;
  46 |     |                 return (params, cache);
  47 |     |             } 
  48 |     |         } /// @dev - nothing to update if pool price hasn't moved
  49 |     |         
  50 |     |         // claim tick sanity checks
  51 |     |         else if (
  52 |     |             // claim tick is on a prior tick
  53 |     |             cache.position.claimPriceLast > 0 &&
  54 |     |             (params.zeroForOne
  55 |     |                     ? cache.position.claimPriceLast < cache.priceClaim
  56 |     |                     : cache.position.claimPriceLast > cache.priceClaim
  57 |     |             ) && params.claim != state.latestTick
  58 |     |         ) require (false, 'InvalidClaimTick()'); /// @dev - wrong claim tick
  59 |     |         if (params.claim < params.lower || params.claim > params.upper) require (false, 'InvalidClaimTick()');
  60 |     | 
  61 |     |         uint32 claimTickEpoch = EpochMap.get(params.claim, params.zeroForOne, tickMap, constants);
  62 |     | 
  63 |     |         // validate claim tick
  64 |     |         if (params.claim == (params.zeroForOne ? params.lower : params.upper)) {
  65 |     |              if (claimTickEpoch <= cache.position.accumEpochLast)
  66 |     |                 require (false, 'WrongTickClaimedAt()');
  67 |     |         } else {
  68 |     |             // check end tick 
  69 |     |             if (params.zeroForOne) {
  70 |     |                 uint32 endTickAccumEpoch = EpochMap.get(cache.position.lower, params.zeroForOne, tickMap, constants);
  71 |     |                 if (endTickAccumEpoch > cache.position.accumEpochLast) {
  72 |     |                     // set claim to final tick
  73 |     |                     params.claim = cache.position.lower;
  74 |     |                     cache.priceClaim = cache.priceLower;
  75 |     |                     cache.claimTick = cache.finalTick;
  76 |     |                     // force user to remove all liquidity
  77 |     |                     params.amount = cache.position.liquidity;
  78 |     |                 } else {
  79 |     |                     int24 claimTickNext = TickMap.previous(params.claim, tickMap, constants);
  80 |     |                     uint32 claimTickNextEpoch = EpochMap.get(claimTickNext, params.zeroForOne, tickMap, constants);
  81 |     |                     ///@dev - next accumEpoch should not be greater
  82 |     |                     if (claimTickNextEpoch > cache.position.accumEpochLast) {
  83 |     |                         require (false, 'WrongTickClaimedAt()');
  84 |     |                     }
  85 |     |                 }
  86 |     |             } else {
  87 |     |                 uint32 endTickAccumEpoch = EpochMap.get(cache.position.upper, params.zeroForOne, tickMap, constants);
  88 |     |                 if (endTickAccumEpoch > cache.position.accumEpochLast) {
  89 |     |                     // set claim to final tick
  90 |     |                     params.claim = cache.position.upper;
  91 |     |                     cache.priceClaim = cache.priceUpper;
  92 |     |                     cache.claimTick = cache.finalTick;
  93 |     |                     // force user to remove all liquidity
  94 |     |                     params.amount = cache.position.liquidity;
  95 |     |                 } else {
  96 |     |                     int24 claimTickNext = TickMap.next(params.claim, tickMap, constants);
  97 |     |                     uint32 claimTickNextEpoch = EpochMap.get(claimTickNext, params.zeroForOne, tickMap, constants);
  98 |     |                     ///@dev - next accumEpoch should not be greater
  99 |     |                     if (claimTickNextEpoch > cache.position.accumEpochLast) {
 100 |     |                         require (false, 'WrongTickClaimedAt()');
 101 |     |                     }
 102 |     |                 }
 103 |     |             }
 104 |     |         }
 105 |     |         if (params.claim != params.upper && params.claim != params.lower) {
 106 |     |             // check accumEpochLast on claim tick
 107 |     |             if (claimTickEpoch <= cache.position.accumEpochLast)
 108 |     |                 require (false, 'WrongTickClaimedAt()');
 109 |     |             /// @dev - user cannot add liquidity if auction is active; checked for in Positions.validate()
 110 |     |         }
 111 |     |         return (params, cache);
 112 |     |     }
 113 |     | 
 114 |     |     function getDeltas(
 115 |     |         CoverPoolStructs.UpdatePositionCache memory cache,
 116 |     |         CoverPoolStructs.UpdateParams memory params
 117 |     |     ) internal pure returns (
 118 |     |         CoverPoolStructs.UpdatePositionCache memory
 119 |     |     ) {
 120 |     |         // transfer deltas into cache
 121 |     |         if (params.claim == (params.zeroForOne ? params.lower : params.upper)) {
 122 |     |             (cache.claimTick, cache.deltas) = Deltas.from(cache.claimTick, cache.deltas, params.zeroForOne);
 123 |     |         } else {
 124 |     |             /// @dev - deltas are applied once per each tick claimed at
 125 |     |             /// @dev - deltas should never be applied if position is not crossed into
 126 |     |             // check if tick already claimed at
 127 |     |             bool transferDeltas = (cache.position.claimPriceLast == 0
 128 |     |                                && (params.claim != (params.zeroForOne ? params.upper : params.lower)))
 129 |     |                                || (params.zeroForOne ? cache.position.claimPriceLast > cache.priceClaim
 130 |     |                                                      : cache.position.claimPriceLast < cache.priceClaim && cache.position.claimPriceLast != 0);
 131 |     |             if (transferDeltas) {
 132 |     |                 (cache.claimTick, cache.deltas) = Deltas.unstash(cache.claimTick, cache.deltas, params.zeroForOne);
 133 |     |             }
 134 |     |         } /// @dev - deltas transfer from claim tick are replaced after applying changes
 135 |     |         return cache;
 136 |     |     }
 137 |     | 
 138 |     |     function applyDeltas(
 139 |     |         CoverPoolStructs.GlobalState memory state,
 140 |     |         CoverPoolStructs.UpdatePositionCache memory cache,
 141 |     |         CoverPoolStructs.UpdateParams memory params
 142 |     |     ) internal pure returns (
 143 |     |         CoverPoolStructs.UpdatePositionCache memory
 144 |     |     ) {
 145 |     |         uint256 percentInDelta; uint256 percentOutDelta;
 146 |     |         if(cache.deltas.amountInDeltaMax > 0) {
 147 |     |             percentInDelta = uint256(cache.amountInFilledMax) * 1e38 / uint256(cache.deltas.amountInDeltaMax);
 148 |     |             percentInDelta = percentInDelta > 1e38 ? 1e38 : percentInDelta;
 149 |     |             if (cache.deltas.amountOutDeltaMax > 0) {
 150 |     |                 percentOutDelta = uint256(cache.amountOutUnfilledMax) * 1e38 / uint256(cache.deltas.amountOutDeltaMax);
 151 |     |                 percentOutDelta = percentOutDelta > 1e38 ? 1e38 : percentOutDelta;
 152 |     |             }
 153 |     |         }
 154 |     |         (cache.deltas, cache.finalDeltas) = Deltas.transfer(cache.deltas, cache.finalDeltas, percentInDelta, percentOutDelta);
 155 |     |         (cache.deltas, cache.finalDeltas) = Deltas.transferMax(cache.deltas, cache.finalDeltas, percentInDelta, percentOutDelta);
 156 |     | 
 157 |     |         uint128 fillFeeAmount = cache.finalDeltas.amountInDelta * state.fillFee / 1e6;
 158 |     |         if (params.zeroForOne) {
 159 |     |             state.protocolFees.token1 += fillFeeAmount;
 160 |     |         } else {
 161 |     |             state.protocolFees.token0 += fillFeeAmount;
 162 |     |         }
 163 |     |         cache.finalDeltas.amountInDelta -= fillFeeAmount;
 164 |     |         cache.position.amountIn  += cache.finalDeltas.amountInDelta;
 165 |     |         cache.position.amountOut += cache.finalDeltas.amountOutDelta;
 166 |     | 
 167 |     |         if (params.claim != (params.zeroForOne ? params.lower : params.upper)) {
 168 |     |             // burn deltas on final tick of position
 169 |     |             cache.finalTick = Deltas.burnMaxMinus(cache.finalTick, cache.finalDeltas);
 170 |     |             // update deltas on claim tick
 171 |     |             if (params.claim == (params.zeroForOne ? params.upper : params.lower)) {
 172 |     |                 (cache.deltas, cache.claimTick) = Deltas.to(cache.deltas, cache.claimTick, params.zeroForOne);
 173 |     |             } else {
 174 |     |                 (cache.deltas, cache.claimTick) = Deltas.stash(cache.deltas, cache.claimTick, params.zeroForOne);
 175 |     |             }
 176 |     |         } else {
 177 |     |             (cache.deltas, cache.claimTick) = Deltas.to(cache.deltas, cache.claimTick, params.zeroForOne);
 178 |     |         }
 179 |     |         return cache;
 180 |     |     }
 181 |     | 
 182 |     |     /// @dev - calculate claim portion of partially claimed previous auction
 183 |     |     function section1(
 184 |     |         CoverPoolStructs.UpdatePositionCache memory cache,
 185 |     |         CoverPoolStructs.UpdateParams memory params,
 186 |     |         PoolsharkStructs.CoverImmutables memory constants
 187 |     |     ) internal pure returns (
 188 |     |         CoverPoolStructs.UpdatePositionCache memory
 189 |     |     ) {
 190 |     |         // delta check complete - update CPL for new position
 191 |     |         if(cache.position.claimPriceLast == 0) {
 192 |     |             cache.position.claimPriceLast = (params.zeroForOne ? cache.priceUpper 
 193 |     |                                                                : cache.priceLower);
 194 |     |         } else if (params.zeroForOne ? (cache.position.claimPriceLast != cache.priceUpper
 195 |     |                                         && cache.position.claimPriceLast > cache.priceClaim)
 196 |     |                                      : (cache.position.claimPriceLast != cache.priceLower
 197 |     |                                         && cache.position.claimPriceLast < cache.priceClaim))
 198 |     |         {
 199 |     |             // section 1 - complete previous auction claim
 200 |     |             {
 201 |     |                 // amounts claimed on this update
 202 |     |                 uint128 amountInFilledMax; uint128 amountOutUnfilledMax;
 203 |     |                 (
 204 |     |                     amountInFilledMax,
 205 |     |                     amountOutUnfilledMax
 206 |     |                 ) = Deltas.maxAuction(
 207 |     |                     cache.position.liquidity,
 208 |     |                     cache.position.claimPriceLast,
 209 |     |                     params.zeroForOne ? cache.priceUpper
 210 |     |                                       : cache.priceLower,
 211 |     |                     params.zeroForOne
 212 |     |                 );
 213 |     |                 cache.amountInFilledMax    += amountInFilledMax;
 214 |     |                 cache.amountOutUnfilledMax += amountOutUnfilledMax;
 215 |     |             }
 216 |     |             // move price to next tick in sequence for section 2
 217 |     |             cache.position.claimPriceLast  = params.zeroForOne ? ConstantProduct.getPriceAtTick(params.upper - constants.tickSpread, constants)
 218 |     |                                                                : ConstantProduct.getPriceAtTick(params.lower + constants.tickSpread, constants);
 219 |     |         }
 220 |     |         return cache;
 221 |     |     }
 222 |     | 
 223 |     |     /// @dev - calculate claim from position start up to claim tick
 224 |     |     function section2(
 225 |     |         CoverPoolStructs.UpdatePositionCache memory cache,
 226 |     |         CoverPoolStructs.UpdateParams memory params
 227 |     |     ) internal pure returns (
 228 |     |         CoverPoolStructs.UpdatePositionCache memory
 229 |     |     ) {
 230 |     |         // section 2 - position start up to claim tick
 231 |     |         if (params.zeroForOne ? cache.priceClaim < cache.position.claimPriceLast 
 232 |     |                               : cache.priceClaim > cache.position.claimPriceLast) {
 233 |     |             // calculate if we at least cover one full tick
 234 |     |             uint128 amountInFilledMax; uint128 amountOutUnfilledMax;
 235 |     |             (
 236 |     |                 amountInFilledMax,
 237 |     |                 amountOutUnfilledMax
 238 |     |             ) = Deltas.maxRoundUp(
 239 |     |                 cache.position.liquidity,
 240 |     |                 cache.position.claimPriceLast,
 241 |     |                 cache.priceClaim,
 242 |     |                 params.zeroForOne
 243 |     |             );
 244 |     |             cache.amountInFilledMax += amountInFilledMax;
 245 |     |             cache.amountOutUnfilledMax += amountOutUnfilledMax;
 246 |     |         }
 247 |     |         return cache;
 248 |     |     }
 249 |     | 
 250 |     |     /// @dev - calculate claim from current auction unfilled section
 251 |     |     function section3(
 252 |     |         CoverPoolStructs.UpdatePositionCache memory cache,
 253 |     |         CoverPoolStructs.UpdateParams memory params,
 254 |     |         CoverPoolStructs.PoolState memory pool
 255 |     |     ) internal pure returns (
 256 |     |         CoverPoolStructs.UpdatePositionCache memory
 257 |     |     ) {
 258 |     |         // section 3 - current auction unfilled section
 259 |     |         if (params.amount > 0) {
 260 |     |             // remove if burn
 261 |     |             uint128 amountOutRemoved = uint128(
 262 |     |                 params.zeroForOne
 263 |     |                     ? ConstantProduct.getDx(params.amount, pool.price, cache.priceClaim, false)
 264 |     |                     : ConstantProduct.getDy(params.amount, cache.priceClaim, pool.price, false)
 265 |     |             );
 266 |     |             uint128 amountInOmitted = uint128(
 267 |     |                 params.zeroForOne
 268 |     |                     ? ConstantProduct.getDy(params.amount, pool.price, cache.priceClaim, false)
 269 |     |                     : ConstantProduct.getDx(params.amount, cache.priceClaim, pool.price, false)
 270 |     |             );
 271 |     |             // add to position
 272 |     |             cache.position.amountOut += amountOutRemoved;
 273 |     |             // modify max deltas to be burned
 274 |     |             cache.finalDeltas.amountInDeltaMax  += amountInOmitted;
 275 |     |             cache.finalDeltas.amountOutDeltaMax += amountOutRemoved;
 276 |     |         }
 277 |     |         return cache;
 278 |     |     }
 279 |     | 
 280 |     |     /// @dev - calculate claim from position start up to claim tick
 281 |     |     function section4(
 282 |     |         CoverPoolStructs.UpdatePositionCache memory cache,
 283 |     |         CoverPoolStructs.UpdateParams memory params,
 284 |     |         CoverPoolStructs.PoolState memory pool
 285 |     |     ) internal pure returns (
 286 |     |         CoverPoolStructs.UpdatePositionCache memory
 287 |     |     ) {
 288 |     |         // section 4 - current auction filled section
 289 |     |         {
 290 |     |             // amounts claimed on this update
 291 |     |             uint128 amountInFilledMax; uint128 amountOutUnfilledMax;
 292 |     |             (
 293 |     |                 amountInFilledMax,
 294 |     |                 amountOutUnfilledMax
 295 |     |             ) = Deltas.maxAuction(
 296 |     |                 cache.position.liquidity,
 297 |     |                 (params.zeroForOne ? cache.position.claimPriceLast < cache.priceClaim
 298 |     |                                     : cache.position.claimPriceLast > cache.priceClaim) 
 299 |     |                                         ? cache.position.claimPriceLast 
 300 |     |                                         : cache.priceSpread,
 301 |     |                 pool.price,
 302 |     |                 params.zeroForOne
 303 |     |             );
 304 |     |             uint256 poolAmountInDeltaChange = uint256(cache.position.liquidity) * 1e38 
 305 |     |                                                 / uint256(pool.liquidity) * uint256(pool.amountInDelta) / 1e38;   
 306 |     |             
 307 |     |             cache.position.amountIn += uint128(poolAmountInDeltaChange);
 308 |     |             pool.amountInDelta -= uint128(poolAmountInDeltaChange); //CHANGE POOL TO MEMORY
 309 |     |             cache.finalDeltas.amountInDeltaMax += amountInFilledMax;
 310 |     |             cache.finalDeltas.amountOutDeltaMax += amountOutUnfilledMax;
 311 |     |             /// @dev - record how much delta max was claimed
 312 |     |             if (params.amount < cache.position.liquidity) {
 313 |     |                 (
 314 |     |                     amountInFilledMax,
 315 |     |                     amountOutUnfilledMax
 316 |     |                 ) = Deltas.maxAuction(
 317 |     |                     cache.position.liquidity - params.amount,
 318 |     |                     (params.zeroForOne ? cache.position.claimPriceLast < cache.priceClaim
 319 |     |                                     : cache.position.claimPriceLast > cache.priceClaim) 
 320 |     |                                             ? cache.position.claimPriceLast 
 321 |     |                                             : cache.priceSpread,
 322 |     |                     pool.price,
 323 |     |                     params.zeroForOne
 324 |     |                 );
 325 |     |                 pool.amountInDeltaMaxClaimed  += amountInFilledMax;
 326 |     |                 pool.amountOutDeltaMaxClaimed += amountOutUnfilledMax;
 327 |     |             }
 328 |     |         }
 329 |     |         if (params.amount > 0 /// @ dev - if removing L and second claim on same tick
 330 |     |             && (params.zeroForOne ? cache.position.claimPriceLast < cache.priceClaim
 331 |     |                                     : cache.position.claimPriceLast > cache.priceClaim)) {
 332 |     |                 // reduce delta max claimed based on liquidity removed
 333 |     |                 pool = Deltas.burnMaxPool(pool, cache, params);
 334 |     |         }
 335 |     |         // modify claim price for section 5
 336 |     |         cache.priceClaim = cache.priceSpread;
 337 |     |         // save pool changes to cache
 338 |     |         cache.pool = pool;
 339 |     |         return cache;
 340 |     |     }
 341 |     | 
 342 |     |     /// @dev - calculate claim from position start up to claim tick
 343 |     |     function section5(
 344 |     |         CoverPoolStructs.UpdatePositionCache memory cache,
 345 |     |         CoverPoolStructs.UpdateParams memory params
 346 |     |     ) internal pure returns (
 347 |     |         CoverPoolStructs.UpdatePositionCache memory
 348 |     |     ) {
 349 |     |         // section 5 - burned liquidity past claim tick
 350 |     |         {
 351 |     |             uint160 endPrice = params.zeroForOne ? cache.priceLower
 352 |     |                                                  : cache.priceUpper;
 353 |     |             if (params.amount > 0 && cache.priceClaim != endPrice) {
 354 |     |                 // update max deltas based on liquidity removed
 355 |     |                 uint128 amountInOmitted; uint128 amountOutRemoved;
 356 |     |                 (
 357 |     |                     amountInOmitted,
 358 |     |                     amountOutRemoved
 359 |     |                 ) = Deltas.max(
 360 |     |                     params.amount,
 361 |     |                     cache.priceClaim,
 362 |     |                     endPrice,
 363 |     |                     params.zeroForOne
 364 |     |                 );
 365 |     |                 cache.position.amountOut += amountOutRemoved;
 366 |     |                 /// @auditor - we don't add to cache.amountInFilledMax and cache.amountOutUnfilledMax 
 367 |     |                 ///            since this section of the curve is not reflected in the deltas
 368 |     |                 if (params.claim != (params.zeroForOne ? params.lower : params.upper)) {
 369 |     |                     cache.finalDeltas.amountInDeltaMax += amountInOmitted;
 370 |     |                     cache.finalDeltas.amountOutDeltaMax += amountOutRemoved;
 371 |     |                 }      
 372 |     |             }
 373 |     |         }
 374 |     |         return cache;
 375 |     |     }
 376 |     | }

/home/ec2-user/git/cover/contracts/libraries/Deltas.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.13;
   3 |     | 
   4 |     | import '../interfaces/structs/CoverPoolStructs.sol';
   5 |     | import './math/ConstantProduct.sol';
   6 |     | library Deltas {
   7 |     | 
   8 |     |     function max(
   9 |     |         uint128 liquidity,
  10 |     |         uint160 priceStart,
  11 |     |         uint160 priceEnd,
  12 |     |         bool   isPool0
  13 |     |     ) internal pure returns (
  14 |     |         uint128 amountInDeltaMax,
  15 |     |         uint128 amountOutDeltaMax
  16 |     |     ) {
  17 |     |         amountInDeltaMax = uint128(
  18 |     |             isPool0
  19 |     |                 ? ConstantProduct.getDy(
  20 |     |                     liquidity,
  21 |     |                     priceEnd,
  22 |     |                     priceStart,
  23 |     |                     false
  24 |     |                 )
  25 |     |                 : ConstantProduct.getDx(
  26 |     |                     liquidity,
  27 |     |                     priceStart,
  28 |     |                     priceEnd,
  29 |     |                     false
  30 |     |                 )
  31 |     |         );
  32 |     |         amountOutDeltaMax = uint128(
  33 |     |             isPool0
  34 |     |                 ? ConstantProduct.getDx(
  35 |     |                     liquidity,
  36 |     |                     priceEnd,
  37 |     |                     priceStart,
  38 |     |                     false
  39 |     |                 )
  40 |     |                 : ConstantProduct.getDy(
  41 |     |                     liquidity,
  42 |     |                     priceStart,
  43 |     |                     priceEnd,
  44 |     |                     false
  45 |     |                 )
  46 |     |         );
  47 |     |     }
  48 |     | 
  49 |     |     function maxRoundUp(
  50 |     |         uint128 liquidity,
  51 |     |         uint160 priceStart,
  52 |     |         uint160 priceEnd,
  53 |     |         bool   isPool0
  54 |     |     ) internal pure returns (
  55 |     |         uint128 amountInDeltaMax,
  56 |     |         uint128 amountOutDeltaMax
  57 |     |     ) {
  58 |     |         amountInDeltaMax = uint128(
  59 |     |             isPool0
  60 |     |                 ? ConstantProduct.getDy(
  61 |     |                     liquidity,
  62 |     |                     priceEnd,
  63 |     |                     priceStart,
  64 |     |                     true
  65 |     |                 )
  66 |     |                 : ConstantProduct.getDx(
  67 |     |                     liquidity,
  68 |     |                     priceStart,
  69 |     |                     priceEnd,
  70 |     |                     true
  71 |     |                 )
  72 |     |         );
  73 |     |         amountOutDeltaMax = uint128(
  74 |     |             isPool0
  75 |     |                 ? ConstantProduct.getDx(
  76 |     |                     liquidity,
  77 |     |                     priceEnd,
  78 |     |                     priceStart,
  79 |     |                     true
  80 |     |                 )
  81 |     |                 : ConstantProduct.getDy(
  82 |     |                     liquidity,
  83 |     |                     priceStart,
  84 |     |                     priceEnd,
  85 |     |                     true
  86 |     |                 )
  87 |     |         );
  88 |     |     }
  89 |     | 
  90 |     |     function maxAuction(
  91 |     |         uint128 liquidity,
  92 |     |         uint160 priceStart,
  93 |     |         uint160 priceEnd,
  94 |     |         bool isPool0
  95 |     |     ) internal pure returns (
  96 |     |         uint128 amountInDeltaMax,
  97 |     |         uint128 amountOutDeltaMax
  98 |     |     ) {
  99 |     |         amountInDeltaMax = uint128(
 100 |     |             isPool0
 101 |     |                 ? ConstantProduct.getDy(
 102 |     |                     liquidity,
 103 |     |                     priceStart,
 104 |     |                     priceEnd,
 105 |     |                     true
 106 |     |                 )
 107 |     |                 : ConstantProduct.getDx(
 108 |     |                     liquidity,
 109 |     |                     priceEnd,
 110 |     |                     priceStart,
 111 |     |                     true
 112 |     |                 )
 113 |     |         );
 114 |     |         amountOutDeltaMax = uint128(
 115 |     |             isPool0
 116 |     |                 ? ConstantProduct.getDx(
 117 |     |                     liquidity,
 118 |     |                     priceStart,
 119 |     |                     priceEnd,
 120 |     |                     true
 121 |     |                 )
 122 |     |                 : ConstantProduct.getDy(
 123 |     |                     liquidity,
 124 |     |                     priceEnd,
 125 |     |                     priceStart,
 126 |     |                     true
 127 |     |                 )
 128 |     |         );
 129 |     |     }
 130 |     | 
 131 |     |     function transfer(
 132 |     |         CoverPoolStructs.Deltas memory fromDeltas,
 133 |     |         CoverPoolStructs.Deltas memory toDeltas,
 134 |     |         uint256 percentInTransfer,
 135 |     |         uint256 percentOutTransfer
 136 |     |     ) internal pure returns (
 137 |     |         CoverPoolStructs.Deltas memory,
 138 |     |         CoverPoolStructs.Deltas memory
 139 |     |     ) {
 140 |     |         {
 141 |     |             uint128 amountInDeltaChange = uint128(uint256(fromDeltas.amountInDelta) * percentInTransfer / 1e38);
 142 |     |             if (amountInDeltaChange < fromDeltas.amountInDelta ) {
 143 |     |                 fromDeltas.amountInDelta -= amountInDeltaChange;
 144 |     |                 toDeltas.amountInDelta += amountInDeltaChange;
 145 |     |             } else {
 146 |     |                 toDeltas.amountInDelta += fromDeltas.amountInDelta;
 147 |     |                 fromDeltas.amountInDelta = 0;
 148 |     |             }
 149 |     |         }
 150 |     |         {
 151 |     |             uint128 amountOutDeltaChange = uint128(uint256(fromDeltas.amountOutDelta) * percentOutTransfer / 1e38);
 152 |     |             if (amountOutDeltaChange < fromDeltas.amountOutDelta ) {
 153 |     |                 fromDeltas.amountOutDelta -= amountOutDeltaChange;
 154 |     |                 toDeltas.amountOutDelta += amountOutDeltaChange;
 155 |     |             } else {
 156 |     |                 toDeltas.amountOutDelta += fromDeltas.amountOutDelta;
 157 |     |                 fromDeltas.amountOutDelta = 0;
 158 |     |             }
 159 |     |         }
 160 |     |         return (fromDeltas, toDeltas);
 161 |     |     }
 162 |     | 
 163 |     |     function transferMax(
 164 |     |         CoverPoolStructs.Deltas memory fromDeltas,
 165 |     |         CoverPoolStructs.Deltas memory toDeltas,
 166 |     |         uint256 percentInTransfer,
 167 |     |         uint256 percentOutTransfer
 168 |     |     ) internal pure returns (
 169 |     |         CoverPoolStructs.Deltas memory,
 170 |     |         CoverPoolStructs.Deltas memory
 171 |     |     ) {
 172 |     |         {
 173 |     |             uint128 amountInDeltaMaxChange = uint128(uint256(fromDeltas.amountInDeltaMax) * percentInTransfer / 1e38);
 174 |     |             if (fromDeltas.amountInDeltaMax > amountInDeltaMaxChange) {
 175 |     |                 fromDeltas.amountInDeltaMax -= amountInDeltaMaxChange;
 176 |     |                 toDeltas.amountInDeltaMax += amountInDeltaMaxChange;
 177 |     |             } else {
 178 |     |                 toDeltas.amountInDeltaMax += fromDeltas.amountInDeltaMax;
 179 |     |                 fromDeltas.amountInDeltaMax = 0;
 180 |     |             }
 181 |     |         }
 182 |     |         {
 183 |     |             uint128 amountOutDeltaMaxChange = uint128(uint256(fromDeltas.amountOutDeltaMax) * percentOutTransfer / 1e38);
 184 |     |             if (fromDeltas.amountOutDeltaMax > amountOutDeltaMaxChange) {
 185 |     |                 fromDeltas.amountOutDeltaMax -= amountOutDeltaMaxChange;
 186 |     |                 toDeltas.amountOutDeltaMax   += amountOutDeltaMaxChange;
 187 |     |             } else {
 188 |     |                 toDeltas.amountOutDeltaMax += fromDeltas.amountOutDeltaMax;
 189 |     |                 fromDeltas.amountOutDeltaMax = 0;
 190 |     |             }
 191 |     |         }
 192 |     |         return (fromDeltas, toDeltas);
 193 |     |     }
 194 |     | 
 195 |     |     function burnMaxCache(
 196 |     |         CoverPoolStructs.Deltas memory fromDeltas,
 197 |     |         CoverPoolStructs.Tick memory burnTick
 198 |     |     ) internal pure returns (
 199 |     |         CoverPoolStructs.Deltas memory
 200 |     |     ) {
 201 |     |         fromDeltas.amountInDeltaMax -= (fromDeltas.amountInDeltaMax 
 202 |     |                                          < burnTick.amountInDeltaMaxMinus) ? fromDeltas.amountInDeltaMax
 203 |     |                                                                            : burnTick.amountInDeltaMaxMinus;
 204 |     |         if (fromDeltas.amountInDeltaMax == 1) {
 205 |     |             fromDeltas.amountInDeltaMax = 0; // handle rounding issues
 206 |     |         }
 207 |     |         fromDeltas.amountOutDeltaMax -= (fromDeltas.amountOutDeltaMax 
 208 |     |                                           < burnTick.amountOutDeltaMaxMinus) ? fromDeltas.amountOutDeltaMax
 209 |     |                                                                              : burnTick.amountOutDeltaMaxMinus;
 210 |     |         return fromDeltas;
 211 |     |     }
 212 |     | 
 213 |     |     function burnMaxMinus(
 214 |     |         CoverPoolStructs.Tick memory fromTick,
 215 |     |         CoverPoolStructs.Deltas memory burnDeltas
 216 |     |     ) internal pure returns (
 217 |     |         CoverPoolStructs.Tick memory
 218 |     |     ) {
 219 |     |         fromTick.amountInDeltaMaxMinus -= (fromTick.amountInDeltaMaxMinus
 220 |     |                                             < burnDeltas.amountInDeltaMax) ? fromTick.amountInDeltaMaxMinus
 221 |     |                                                                            : burnDeltas.amountInDeltaMax;
 222 |     |         if (fromTick.amountInDeltaMaxMinus == 1) {
 223 |     |             fromTick.amountInDeltaMaxMinus = 0; // handle rounding issues
 224 |     |         }
 225 |     |         fromTick.amountOutDeltaMaxMinus -= (fromTick.amountOutDeltaMaxMinus 
 226 |     |                                              < burnDeltas.amountOutDeltaMax) ? fromTick.amountOutDeltaMaxMinus
 227 |     |                                                                                   : burnDeltas.amountOutDeltaMax;
 228 |     |         return fromTick;
 229 |     |     }
 230 |     | 
 231 |     |     function burnMaxPool(
 232 |     |         CoverPoolStructs.PoolState memory pool,
 233 |     |         CoverPoolStructs.UpdatePositionCache memory cache,
 234 |     |         CoverPoolStructs.UpdateParams memory params
 235 |     |     ) internal pure returns (
 236 |     |         CoverPoolStructs.PoolState memory
 237 |     |     )
 238 |     |     {
 239 |     |         uint128 amountInMaxClaimedBefore; uint128 amountOutMaxClaimedBefore;
 240 |     |         (
 241 |     |             amountInMaxClaimedBefore,
 242 |     |             amountOutMaxClaimedBefore
 243 |     |         ) = maxAuction(
 244 |     |             params.amount,
 245 |     |             cache.priceSpread,
 246 |     |             cache.position.claimPriceLast,
 247 |     |             params.zeroForOne
 248 |     |         );
 249 |     |         pool.amountInDeltaMaxClaimed  -= pool.amountInDeltaMaxClaimed > amountInMaxClaimedBefore ? amountInMaxClaimedBefore
 250 |     |                                                                                                  : pool.amountInDeltaMaxClaimed;
 251 |     |         pool.amountOutDeltaMaxClaimed -= pool.amountOutDeltaMaxClaimed > amountOutMaxClaimedBefore ? amountOutMaxClaimedBefore
 252 |     |                                                                                                    : pool.amountOutDeltaMaxClaimed;
 253 |     |         return pool;
 254 |     |     }
 255 |     | 
 256 |     |     struct FromLocals {
 257 |     |         CoverPoolStructs.Deltas fromDeltas;
 258 |     |         uint256 percentOnTick;
 259 |     |         uint128 amountInDeltaChange;
 260 |     |         uint128 amountOutDeltaChange;
 261 |     |     }
 262 |     | 
 263 |     |     function from(
 264 |     |         CoverPoolStructs.Tick memory fromTick,
 265 |     |         CoverPoolStructs.Deltas memory toDeltas,
 266 |     |         bool isPool0
 267 |     |     ) internal pure returns (
 268 |     |         CoverPoolStructs.Tick memory,
 269 |     |         CoverPoolStructs.Deltas memory
 270 |     |     ) {
 271 |     |         FromLocals memory locals;
 272 |     |         locals.fromDeltas = isPool0 ? fromTick.deltas0 
 273 |     |                                     : fromTick.deltas1;
 274 |     |         locals.percentOnTick = uint256(locals.fromDeltas.amountInDeltaMax) * 1e38 / (uint256(locals.fromDeltas.amountInDeltaMax) + uint256(fromTick.amountInDeltaMaxStashed));
 275 |     |         {
 276 |     |             locals.amountInDeltaChange = uint128(uint256(locals.fromDeltas.amountInDelta) * locals.percentOnTick / 1e38);
 277 |     |             locals.fromDeltas.amountInDelta -= locals.amountInDeltaChange;
 278 |     |             toDeltas.amountInDelta += locals.amountInDeltaChange;
 279 |     |             toDeltas.amountInDeltaMax += locals.fromDeltas.amountInDeltaMax;
 280 |     |             locals.fromDeltas.amountInDeltaMax = 0;
 281 |     |         }
 282 |     |         locals.percentOnTick = uint256(locals.fromDeltas.amountOutDeltaMax) * 1e38 / (uint256(locals.fromDeltas.amountOutDeltaMax) + uint256(fromTick.amountOutDeltaMaxStashed));
 283 |     |         {
 284 |     |             locals.amountOutDeltaChange = uint128(uint256(locals.fromDeltas.amountOutDelta) * locals.percentOnTick / 1e38);
 285 |     |             locals.fromDeltas.amountOutDelta -= locals.amountOutDeltaChange;
 286 |     |             toDeltas.amountOutDelta += locals.amountOutDeltaChange;
 287 |     |             toDeltas.amountOutDeltaMax += locals.fromDeltas.amountOutDeltaMax;
 288 |     |             locals.fromDeltas.amountOutDeltaMax = 0;
 289 |     |         }
 290 |     |         if (isPool0) {
 291 |     |             fromTick.deltas0 = locals.fromDeltas;
 292 |     |         } else {
 293 |     |             fromTick.deltas1 = locals.fromDeltas;
 294 |     |         }
 295 |     |         return (fromTick, toDeltas);
 296 |     |     }
 297 |     | 
 298 |     |     function to(
 299 |     |         CoverPoolStructs.Deltas memory fromDeltas,
 300 |     |         CoverPoolStructs.Tick memory toTick,
 301 |     |         bool isPool0
 302 |     |     ) internal pure returns (
 303 |     |         CoverPoolStructs.Deltas memory,
 304 |     |         CoverPoolStructs.Tick memory
 305 |     |     ) {
 306 |     |         CoverPoolStructs.Deltas memory toDeltas = isPool0 ? toTick.deltas0 
 307 |     |                                                           : toTick.deltas1;
 308 |     |         toDeltas.amountInDelta     += fromDeltas.amountInDelta;
 309 |     |         toDeltas.amountInDeltaMax  += fromDeltas.amountInDeltaMax;
 310 |     |         toDeltas.amountOutDelta    += fromDeltas.amountOutDelta;
 311 |     |         toDeltas.amountOutDeltaMax += fromDeltas.amountOutDeltaMax;
 312 |     |         if (isPool0) {
 313 |     |             toTick.deltas0 = toDeltas;
 314 |     |         } else {
 315 |     |             toTick.deltas1 = toDeltas;
 316 |     |         }
 317 |     |         fromDeltas = CoverPoolStructs.Deltas(0,0,0,0);
 318 |     |         return (fromDeltas, toTick);
 319 |     |     }
 320 |     | 
 321 |     |     function stash(
 322 |     |         CoverPoolStructs.Deltas memory fromDeltas,
 323 |     |         CoverPoolStructs.Tick memory toTick,
 324 |     |         bool isPool0
 325 |     |     ) internal pure returns (
 326 |     |         CoverPoolStructs.Deltas memory,
 327 |     |         CoverPoolStructs.Tick memory
 328 |     |     ) {
 329 |     |         CoverPoolStructs.Deltas memory toDeltas = isPool0 ? toTick.deltas0 
 330 |     |                                                           : toTick.deltas1;
 331 |     |         // store deltas on tick
 332 |     |         toDeltas.amountInDelta     += fromDeltas.amountInDelta;
 333 |     |         toDeltas.amountOutDelta    += fromDeltas.amountOutDelta;
 334 |     |         // store delta maxes on stashed deltas
 335 |     |         toTick.amountInDeltaMaxStashed  += fromDeltas.amountInDeltaMax;
 336 |     |         toTick.amountOutDeltaMaxStashed += fromDeltas.amountOutDeltaMax;
 337 |     |         if (isPool0) {
 338 |     |             toTick.deltas0 = toDeltas;
 339 |     |             toTick.pool0Stash = true;
 340 |     |         } else {
 341 |     |             toTick.deltas1 = toDeltas;
 342 |     |             toTick.pool0Stash = false;
 343 |     |         }
 344 |     |         fromDeltas = CoverPoolStructs.Deltas(0,0,0,0);
 345 |     |         return (fromDeltas, toTick);
 346 |     |     }
 347 |     | 
 348 |     |     struct UnstashLocals {
 349 |     |         CoverPoolStructs.Deltas fromDeltas;
 350 |     |         uint256 totalDeltaMax;
 351 |     |         uint256 percentStashed;
 352 |     |         uint128 amountInDeltaChange;
 353 |     |         uint128 amountOutDeltaChange;
 354 |     |     }
 355 |     | 
 356 |     |     function unstash(
 357 |     |         CoverPoolStructs.Tick memory fromTick,
 358 |     |         CoverPoolStructs.Deltas memory toDeltas,
 359 |     |         bool isPool0
 360 |     |     ) internal pure returns (
 361 |     |         CoverPoolStructs.Tick memory,
 362 |     |         CoverPoolStructs.Deltas memory
 363 |     |     ) {
 364 |     |         toDeltas.amountInDeltaMax  += fromTick.amountInDeltaMaxStashed;
 365 |     |         toDeltas.amountOutDeltaMax += fromTick.amountOutDeltaMaxStashed;
 366 |     | 
 367 |     |         UnstashLocals memory locals;
 368 |     |         locals.fromDeltas = isPool0 ? fromTick.deltas0 : fromTick.deltas1;
 369 |     |         locals.totalDeltaMax = uint256(fromTick.amountInDeltaMaxStashed) + uint256(locals.fromDeltas.amountInDeltaMax);
 370 |     |         
 371 |     |         if (locals.totalDeltaMax > 0) {
 372 |     |             locals.percentStashed = uint256(fromTick.amountInDeltaMaxStashed) * 1e38 / locals.totalDeltaMax;
 373 |     |             locals.amountInDeltaChange = uint128(uint256(locals.fromDeltas.amountInDelta) * locals.percentStashed / 1e38);
 374 |     |             locals.fromDeltas.amountInDelta -= locals.amountInDeltaChange;
 375 |     |             toDeltas.amountInDelta += locals.amountInDeltaChange;
 376 |     |         }
 377 |     |         
 378 |     |         locals.totalDeltaMax = uint256(fromTick.amountOutDeltaMaxStashed) + uint256(locals.fromDeltas.amountOutDeltaMax);
 379 |     |         
 380 |     |         if (locals.totalDeltaMax > 0) {
 381 |     |             locals.percentStashed = uint256(fromTick.amountOutDeltaMaxStashed) * 1e38 / locals.totalDeltaMax;
 382 |     |             locals.amountOutDeltaChange = uint128(uint256(locals.fromDeltas.amountOutDelta) * locals.percentStashed / 1e38);
 383 |     |             locals.fromDeltas.amountOutDelta -= locals.amountOutDeltaChange;
 384 |     |             toDeltas.amountOutDelta += locals.amountOutDeltaChange;
 385 |     |         }
 386 |     |         if (isPool0) {
 387 |     |             fromTick.deltas0 = locals.fromDeltas;
 388 |     |         } else {
 389 |     |             fromTick.deltas1 = locals.fromDeltas;
 390 |     |         }
 391 |     |         fromTick.amountInDeltaMaxStashed = 0;
 392 |     |         fromTick.amountOutDeltaMaxStashed = 0;
 393 |     | 
 394 |     |         return (fromTick, toDeltas);
 395 |     |     }
 396 |     | 
 397 |     |     function update(
 398 |     |         CoverPoolStructs.Tick memory tick,
 399 |     |         uint128 amount,
 400 |     |         uint160 priceLower,
 401 |     |         uint160 priceUpper,
 402 |     |         bool   isPool0,
 403 |     |         bool   isAdded
 404 |     |     ) internal pure returns (
 405 |     |         CoverPoolStructs.Tick memory,
 406 |     |         CoverPoolStructs.Deltas memory
 407 |     |     ) {
 408 |     |         // update max deltas
 409 |     |         uint128 amountInDeltaMax; uint128 amountOutDeltaMax;
 410 |     |         if (isPool0) {
 411 |     |             (
 412 |     |                 amountInDeltaMax,
 413 |     |                 amountOutDeltaMax
 414 |     |             ) = max(amount, priceUpper, priceLower, true);
 415 |     |         } else {
 416 |     |             (
 417 |     |                 amountInDeltaMax,
 418 |     |                 amountOutDeltaMax
 419 |     |             ) = max(amount, priceLower, priceUpper, false);
 420 |     |         }
 421 |     |         if (isAdded) {
 422 |     |             tick.amountInDeltaMaxMinus  += amountInDeltaMax;
 423 |     |             tick.amountOutDeltaMaxMinus += amountOutDeltaMax;
 424 |     |         } else {
 425 |     |             tick.amountInDeltaMaxMinus  -= tick.amountInDeltaMaxMinus  > amountInDeltaMax ? amountInDeltaMax
 426 |     |                                                                                           : tick.amountInDeltaMaxMinus;
 427 |     |             tick.amountOutDeltaMaxMinus -= tick.amountOutDeltaMaxMinus > amountOutDeltaMax ? amountOutDeltaMax                                                                           : tick.amountOutDeltaMaxMinus;
 428 |     |         }
 429 |     |         return (tick, CoverPoolStructs.Deltas(0,0,amountInDeltaMax, amountOutDeltaMax));
 430 |     |     }
 431 |     | }

/home/ec2-user/git/cover/contracts/libraries/EpochMap.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import './math/ConstantProduct.sol';
  5 |     | import '../interfaces/structs/CoverPoolStructs.sol';
  6 |     | 
  7 |     | library EpochMap {
  8 |     |     function set(
  9 |     |         int24  tick,
 10 |     |         uint256 epoch,
 11 |     |         bool zeroForOne,
 12 |     |         CoverPoolStructs.TickMap storage tickMap,
 13 |     |         PoolsharkStructs.CoverImmutables memory constants
 14 |     |     ) internal {
 15 |     |         (
 16 |     |             uint256 tickIndex,
 17 |     |             uint256 wordIndex,
 18 |     |             uint256 blockIndex,
 19 |     |             uint256 volumeIndex
 20 |     |         ) = getIndices(tick, constants);
 21 |     |         // assert epoch isn't bigger than max uint32
 22 |     |         uint256 epochValue = zeroForOne ? tickMap.epochs0[volumeIndex][blockIndex][wordIndex]
 23 |     |                                         : tickMap.epochs1[volumeIndex][blockIndex][wordIndex];
 24 |     |         // clear previous value
 25 |     |         epochValue &=  ~(((1 << 9) - 1) << ((tickIndex & 0x7) * 32));
 26 |     |         // add new value to word
 27 |     |         epochValue |= epoch << ((tickIndex & 0x7) * 32);
 28 |     |         // store word in map
 29 |     |         if (zeroForOne) {
 30 |     |             tickMap.epochs0[volumeIndex][blockIndex][wordIndex] = epochValue;
 31 |     |         } else {
 32 |     |             tickMap.epochs1[volumeIndex][blockIndex][wordIndex] = epochValue;
 33 |     |         }
 34 |     |     }
 35 |     | 
 36 |     |     function get(
 37 |     |         int24 tick,
 38 |     |         bool zeroForOne,
 39 |     |         CoverPoolStructs.TickMap storage tickMap,
 40 |     |         PoolsharkStructs.CoverImmutables memory constants
 41 |     |     ) internal view returns (
 42 |     |         uint32 epoch
 43 |     |     ) {
 44 |     |         (
 45 |     |             uint256 tickIndex,
 46 |     |             uint256 wordIndex,
 47 |     |             uint256 blockIndex,
 48 |     |             uint256 volumeIndex
 49 |     |         ) = getIndices(tick, constants);
 50 |     | 
 51 |     |         uint256 epochValue = zeroForOne ? tickMap.epochs0[volumeIndex][blockIndex][wordIndex]
 52 |     |                                         : tickMap.epochs1[volumeIndex][blockIndex][wordIndex];
 53 |     |         // right shift so first 8 bits are epoch value
 54 |     |         epochValue >>= ((tickIndex & 0x7) * 32);
 55 |     |         // clear other bits
 56 |     |         epochValue &= ((1 << 32) - 1);
 57 |     |         return uint32(epochValue);
 58 |     |     }
 59 |     | 
 60 |     |     function getIndices(
 61 |     |         int24 tick,
 62 |     |         PoolsharkStructs.CoverImmutables memory constants
 63 |     |     ) public pure returns (
 64 |     |             uint256 tickIndex,
 65 |     |             uint256 wordIndex,
 66 |     |             uint256 blockIndex,
 67 |     |             uint256 volumeIndex
 68 |     |         )
 69 |     |     {
 70 |     |         unchecked {
 71 |     |             if (tick > ConstantProduct.maxTick(constants.tickSpread)) require (false, 'TickIndexOverflow()');
 72 |     |             if (tick < ConstantProduct.minTick(constants.tickSpread)) require (false, 'TickIndexUnderflow()');
 73 |     |             if (tick % constants.tickSpread != 0) require (false, 'TickIndexInvalid()');
 74 |     |             tickIndex = uint256(int256((tick - ConstantProduct.minTick(constants.tickSpread))) / constants.tickSpread);
 75 |     |             wordIndex = tickIndex >> 3;        // 2^3 epochs per word
 76 |     |             blockIndex = tickIndex >> 11;      // 2^8 words per block
 77 |     |             volumeIndex = tickIndex >> 19;     // 2^8 blocks per volume
 78 |     |             if (blockIndex > 1023) require (false, 'BlockIndexOverflow()');
 79 |     |         }
 80 |     |     }
 81 |     | 
 82 |     |     function _tick (
 83 |     |         uint256 tickIndex,
 84 |     |         PoolsharkStructs.CoverImmutables memory constants
 85 |     |     ) internal pure returns (
 86 |     |         int24 tick
 87 |     |     ) {
 88 |     |         unchecked {
 89 |     |             if (tickIndex > uint24(ConstantProduct.maxTick(constants.tickSpread) * 2)) require (false, 'TickIndexOverflow()');
 90 |     |             tick = int24(int256(tickIndex) * int256(constants.tickSpread) + ConstantProduct.maxTick(constants.tickSpread));
 91 |     |         }
 92 |     |     }
 93 |     | }
 94 |     | 

/home/ec2-user/git/cover/contracts/libraries/Epochs.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.13;
   3 |     | 
   4 |     | import '../interfaces/modules/sources/ITwapSource.sol';
   5 |     | import '../interfaces/structs/CoverPoolStructs.sol';
   6 |     | import './Deltas.sol';
   7 |     | import './Ticks.sol';
   8 |     | import './TickMap.sol';
   9 |     | import './EpochMap.sol';
  10 |     | 
  11 |     | library Epochs {
  12 |     |     event Sync(
  13 |     |         uint160 pool0Price,
  14 |     |         uint160 pool1Price,
  15 |     |         uint128 pool0Liquidity,
  16 |     |         uint128 pool1Liquidity,
  17 |     |         uint32 auctionStart,
  18 |     |         uint32 accumEpoch,
  19 |     |         int24 oldLatestTick,
  20 |     |         int24 newLatestTick
  21 |     |     );
  22 |     | 
  23 |     |     event FinalDeltasAccumulated(
  24 |     |         uint128 amountInDelta,
  25 |     |         uint128 amountOutDelta,
  26 |     |         uint32 accumEpoch,
  27 |     |         int24 accumTick,
  28 |     |         bool isPool0
  29 |     |     );
  30 |     | 
  31 |     |     event StashDeltasCleared(
  32 |     |         int24 stashTick,
  33 |     |         bool isPool0
  34 |     |     );
  35 |     | 
  36 |     |     event StashDeltasAccumulated(
  37 |     |         uint128 amountInDelta,
  38 |     |         uint128 amountOutDelta,
  39 |     |         uint128 amountInDeltaMaxStashed,
  40 |     |         uint128 amountOutDeltaMaxStashed,
  41 |     |         uint32 accumEpoch,
  42 |     |         int24 stashTick,
  43 |     |         bool isPool0
  44 |     |     );
  45 |     | 
  46 |     |     event SyncFeesCollected(
  47 |     |         address collector,
  48 |     |         uint128 token0Amount,
  49 |     |         uint128 token1Amount
  50 |     |     );
  51 |     | 
  52 |     |     function simulateSync(
  53 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
  54 |     |         CoverPoolStructs.TickMap storage tickMap,
  55 |     |         CoverPoolStructs.PoolState memory pool0,
  56 |     |         CoverPoolStructs.PoolState memory pool1,
  57 |     |         CoverPoolStructs.GlobalState memory state,
  58 |     |         PoolsharkStructs.CoverImmutables memory constants
  59 |     |     ) internal view returns (
  60 |     |         CoverPoolStructs.GlobalState memory,
  61 |     |         CoverPoolStructs.SyncFees memory,
  62 |     |         CoverPoolStructs.PoolState memory,
  63 |     |         CoverPoolStructs.PoolState memory
  64 |     |     ) {
  65 |     |         CoverPoolStructs.AccumulateCache memory cache;
  66 |     |         {
  67 |     |             bool earlyReturn;
  68 |     |             (cache.newLatestTick, earlyReturn) = _syncTick(state, constants);
  69 |     |             if (earlyReturn) {
  70 |     |                 return (state, CoverPoolStructs.SyncFees(0, 0), pool0, pool1);
  71 |     |             }
  72 |     |             // else we have a TWAP update
  73 |     |         }
  74 |     | 
  75 |     |         // setup cache
  76 |     |         cache = CoverPoolStructs.AccumulateCache({
  77 |     |             deltas0: CoverPoolStructs.Deltas(0, 0, 0, 0), // deltas for pool0
  78 |     |             deltas1: CoverPoolStructs.Deltas(0, 0, 0, 0),  // deltas for pool1
  79 |     |             syncFees: CoverPoolStructs.SyncFees(0, 0),
  80 |     |             newLatestTick: cache.newLatestTick,
  81 |     |             nextTickToCross0: state.latestTick, // above
  82 |     |             nextTickToCross1: state.latestTick, // below
  83 |     |             nextTickToAccum0: TickMap.previous(state.latestTick, tickMap, constants), // below
  84 |     |             nextTickToAccum1: TickMap.next(state.latestTick, tickMap, constants),     // above
  85 |     |             stopTick0: (cache.newLatestTick > state.latestTick) // where we do stop for pool0 sync
  86 |     |                 ? state.latestTick - constants.tickSpread
  87 |     |                 : cache.newLatestTick, 
  88 |     |             stopTick1: (cache.newLatestTick > state.latestTick) // where we do stop for pool1 sync
  89 |     |                 ? cache.newLatestTick
  90 |     |                 : state.latestTick + constants.tickSpread
  91 |     |         });
  92 |     | 
  93 |     |         while (true) {
  94 |     |             // rollover and calculate sync fees
  95 |     |             (cache, pool0) = _rollover(state, cache, pool0, constants, true);
  96 |     |             // keep looping until accumulation reaches stopTick0 
  97 |     |             if (cache.nextTickToAccum0 >= cache.stopTick0) {
  98 |     |                 (pool0.liquidity, cache.nextTickToCross0, cache.nextTickToAccum0) = _cross(
  99 |     |                     ticks[cache.nextTickToAccum0].liquidityDelta,
 100 |     |                     tickMap,
 101 |     |                     constants,
 102 |     |                     cache.nextTickToCross0,
 103 |     |                     cache.nextTickToAccum0,
 104 |     |                     pool0.liquidity,
 105 |     |                     true
 106 |     |                 );
 107 |     |             } else break;
 108 |     |         }
 109 |     | 
 110 |     |         while (true) {
 111 |     |             (cache, pool1) = _rollover(state, cache, pool1, constants, false);
 112 |     |             // keep looping until accumulation reaches stopTick1 
 113 |     |             if (cache.nextTickToAccum1 <= cache.stopTick1) {
 114 |     |                 (pool1.liquidity, cache.nextTickToCross1, cache.nextTickToAccum1) = _cross(
 115 |     |                     ticks[cache.nextTickToAccum1].liquidityDelta,
 116 |     |                     tickMap,
 117 |     |                     constants,
 118 |     |                     cache.nextTickToCross1,
 119 |     |                     cache.nextTickToAccum1,
 120 |     |                     pool1.liquidity,
 121 |     |                     false
 122 |     |                 );
 123 |     |             } else break;
 124 |     |         }
 125 |     | 
 126 |     |         // update ending pool price for fully filled auction
 127 |     |         state.latestPrice = ConstantProduct.getPriceAtTick(cache.newLatestTick, constants);
 128 |     |         
 129 |     |         // set pool price and liquidity
 130 |     |         if (cache.newLatestTick > state.latestTick) {
 131 |     |             pool0.liquidity = 0;
 132 |     |             pool0.price = state.latestPrice;
 133 |     |             pool1.price = ConstantProduct.getPriceAtTick(cache.newLatestTick + constants.tickSpread, constants);
 134 |     |         } else {
 135 |     |             pool1.liquidity = 0;
 136 |     |             pool0.price = ConstantProduct.getPriceAtTick(cache.newLatestTick - constants.tickSpread, constants);
 137 |     |             pool1.price = state.latestPrice;
 138 |     |         }
 139 |     |         
 140 |     |         // set auction start as an offset of the pool genesis block
 141 |     |         state.auctionStart = uint32(block.timestamp) - constants.genesisTime;
 142 |     |         state.latestTick = cache.newLatestTick;
 143 |     |     
 144 |     |         return (state, cache.syncFees, pool0, pool1);
 145 |     |     }
 146 |     | 
 147 |     |     function syncLatest(
 148 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 149 |     |         CoverPoolStructs.TickMap storage tickMap,
 150 |     |         CoverPoolStructs.PoolState memory pool0,
 151 |     |         CoverPoolStructs.PoolState memory pool1,
 152 |     |         CoverPoolStructs.GlobalState memory state,
 153 |     |         PoolsharkStructs.CoverImmutables memory constants
 154 |     |     ) internal returns (
 155 |     |         CoverPoolStructs.GlobalState memory,
 156 |     |         CoverPoolStructs.SyncFees memory,
 157 |     |         CoverPoolStructs.PoolState memory,
 158 |     |         CoverPoolStructs.PoolState memory
 159 |     |     )
 160 |     |     {
 161 |     |         CoverPoolStructs.AccumulateCache memory cache;
 162 |     |         {
 163 |     |             bool earlyReturn;
 164 |     |             (cache.newLatestTick, earlyReturn) = _syncTick(state, constants);
 165 |     |             if (earlyReturn) {
 166 |     |                 return (state, CoverPoolStructs.SyncFees(0,0), pool0, pool1);
 167 |     |             }
 168 |     |             // else we have a TWAP update
 169 |     |         }
 170 |     | 
 171 |     |         // increase epoch counter
 172 |     |         state.accumEpoch += 1;
 173 |     | 
 174 |     |         // setup cache
 175 |     |         cache = CoverPoolStructs.AccumulateCache({
 176 |     |             deltas0: CoverPoolStructs.Deltas(0, 0, 0, 0), // deltas for pool0
 177 |     |             deltas1: CoverPoolStructs.Deltas(0, 0, 0, 0),  // deltas for pool1
 178 |     |             syncFees: CoverPoolStructs.SyncFees(0,0),
 179 |     |             newLatestTick: cache.newLatestTick,
 180 |     |             nextTickToCross0: state.latestTick, // above
 181 |     |             nextTickToCross1: state.latestTick, // below
 182 |     |             nextTickToAccum0: TickMap.previous(state.latestTick, tickMap, constants), // below
 183 |     |             nextTickToAccum1: TickMap.next(state.latestTick, tickMap, constants),     // above
 184 |     |             stopTick0: (cache.newLatestTick > state.latestTick) // where we do stop for pool0 sync
 185 |     |                 ? state.latestTick - constants.tickSpread
 186 |     |                 : cache.newLatestTick, 
 187 |     |             stopTick1: (cache.newLatestTick > state.latestTick) // where we do stop for pool1 sync
 188 |     |                 ? cache.newLatestTick
 189 |     |                 : state.latestTick + constants.tickSpread
 190 |     |         });
 191 |     | 
 192 |     |         while (true) {
 193 |     |             // get values from current auction
 194 |     |             (cache, pool0) = _rollover(state, cache, pool0, constants, true);
 195 |     |             if (cache.nextTickToAccum0 > cache.stopTick0 
 196 |     |                  && ticks[cache.nextTickToAccum0].amountInDeltaMaxMinus > 0) {
 197 |     |                 EpochMap.set(cache.nextTickToAccum0, state.accumEpoch, true, tickMap, constants);
 198 |     |             }
 199 |     |             // accumulate to next tick
 200 |     |             CoverPoolStructs.AccumulateParams memory params = CoverPoolStructs.AccumulateParams({
 201 |     |                 deltas: cache.deltas0,
 202 |     |                 crossTick: ticks[cache.nextTickToCross0],
 203 |     |                 accumTick: ticks[cache.nextTickToAccum0],
 204 |     |                 updateAccumDeltas: cache.newLatestTick > state.latestTick                // check twap move up or down
 205 |     |                                             ? cache.nextTickToAccum0 == cache.stopTick0  // move up - true at stop tick
 206 |     |                                             : cache.nextTickToAccum0 >= cache.stopTick0, // move down - at or above stop tick
 207 |     |                 isPool0: true
 208 |     |             });
 209 |     |             params = _accumulate(
 210 |     |                 cache,
 211 |     |                 params,
 212 |     |                 state
 213 |     |             );
 214 |     |             /// @dev - deltas in cache updated after _accumulate
 215 |     |             cache.deltas0 = params.deltas;
 216 |     |             ticks[cache.nextTickToAccum0] = params.accumTick;
 217 |     |             Ticks.cleanup(
 218 |     |                ticks,
 219 |     |                tickMap,
 220 |     |                constants,
 221 |     |                params.crossTick,
 222 |     |                cache.nextTickToCross0
 223 |     |             );
 224 |     |     
 225 |     |             // keep looping until accumulation reaches stopTick0 
 226 |     |             if (cache.nextTickToAccum0 >= cache.stopTick0) {
 227 |     |                 (pool0.liquidity, cache.nextTickToCross0, cache.nextTickToAccum0) = _cross(
 228 |     |                     ticks[cache.nextTickToAccum0].liquidityDelta,
 229 |     |                     tickMap,
 230 |     |                     constants,
 231 |     |                     cache.nextTickToCross0,
 232 |     |                     cache.nextTickToAccum0,
 233 |     |                     pool0.liquidity,
 234 |     |                     true
 235 |     |                 );
 236 |     |             } else break;
 237 |     |         }
 238 |     |         // pool0 checkpoint
 239 |     |         {
 240 |     |             // create stopTick0 if necessary
 241 |     |             if (cache.nextTickToAccum0 != cache.stopTick0) {
 242 |     |                 TickMap.set(cache.stopTick0, tickMap, constants);
 243 |     |             }
 244 |     |             CoverPoolStructs.Tick memory stopTick0 = ticks[cache.stopTick0];
 245 |     |             // checkpoint at stopTick0
 246 |     |             (stopTick0) = _stash(
 247 |     |                 stopTick0,
 248 |     |                 cache,
 249 |     |                 state,
 250 |     |                 pool0.liquidity,
 251 |     |                 true
 252 |     |             );
 253 |     |             EpochMap.set(cache.stopTick0, state.accumEpoch, true, tickMap, constants);
 254 |     |             ticks[cache.stopTick0] = stopTick0;
 255 |     |         }
 256 |     | 
 257 |     |         while (true) {
 258 |     |             // rollover deltas pool1
 259 |     |             (cache, pool1) = _rollover(state, cache, pool1, constants, false);
 260 |     |             // accumulate deltas pool1
 261 |     |             if (cache.nextTickToAccum1 < cache.stopTick1 
 262 |     |                  && ticks[cache.nextTickToAccum1].amountInDeltaMaxMinus > 0) {
 263 |     |                 EpochMap.set(cache.nextTickToAccum1, state.accumEpoch, false, tickMap, constants);
 264 |     |             }
 265 |     |             {
 266 |     |                 CoverPoolStructs.AccumulateParams memory params = CoverPoolStructs.AccumulateParams({
 267 |     |                     deltas: cache.deltas1,
 268 |     |                     crossTick: ticks[cache.nextTickToCross1],
 269 |     |                     accumTick: ticks[cache.nextTickToAccum1],
 270 |     |                     updateAccumDeltas: cache.newLatestTick > state.latestTick                   // check twap move up or down
 271 |     |                                                 ? cache.nextTickToAccum1 <= cache.stopTick1     // move up - below or at
 272 |     |                                                 : cache.nextTickToAccum1 == cache.stopTick1,    // move down - at
 273 |     |                     isPool0: false
 274 |     |                 });
 275 |     |                 params = _accumulate(
 276 |     |                     cache,
 277 |     |                     params,
 278 |     |                     state
 279 |     |                 );
 280 |     |                 /// @dev - deltas in cache updated after _accumulate
 281 |     |                 cache.deltas1 = params.deltas;
 282 |     |                 ticks[cache.nextTickToAccum1] = params.accumTick;
 283 |     |                 Ticks.cleanup(
 284 |     |                     ticks,
 285 |     |                     tickMap,
 286 |     |                     constants,
 287 |     |                     params.crossTick,
 288 |     |                     cache.nextTickToCross1
 289 |     |                 );
 290 |     |             }
 291 |     |             // keep looping until accumulation reaches stopTick1 
 292 |     |             if (cache.nextTickToAccum1 <= cache.stopTick1) {
 293 |     |                 (pool1.liquidity, cache.nextTickToCross1, cache.nextTickToAccum1) = _cross(
 294 |     |                     ticks[cache.nextTickToAccum1].liquidityDelta,
 295 |     |                     tickMap,
 296 |     |                     constants,
 297 |     |                     cache.nextTickToCross1,
 298 |     |                     cache.nextTickToAccum1,
 299 |     |                     pool1.liquidity,
 300 |     |                     false
 301 |     |                 );
 302 |     |             } else break;
 303 |     |         }
 304 |     |         // pool1 checkpoint
 305 |     |         {
 306 |     |             // create stopTick1 if necessary
 307 |     |             if (cache.nextTickToAccum1 != cache.stopTick1) {
 308 |     |                 TickMap.set(cache.stopTick1, tickMap, constants);
 309 |     |             }
 310 |     |             CoverPoolStructs.Tick memory stopTick1 = ticks[cache.stopTick1];
 311 |     |             // update deltas on stopTick
 312 |     |             (stopTick1) = _stash(
 313 |     |                 stopTick1,
 314 |     |                 cache,
 315 |     |                 state,
 316 |     |                 pool1.liquidity,
 317 |     |                 false
 318 |     |             );
 319 |     |             ticks[cache.stopTick1] = stopTick1;
 320 |     |             EpochMap.set(cache.stopTick1, state.accumEpoch, false, tickMap, constants);
 321 |     |         }
 322 |     |         // update ending pool price for fully filled auction
 323 |     |         state.latestPrice = ConstantProduct.getPriceAtTick(cache.newLatestTick, constants);
 324 |     |         
 325 |     |         // set pool price and liquidity
 326 |     |         if (cache.newLatestTick > state.latestTick) {
 327 |     |             pool0.liquidity = 0;
 328 |     |             pool0.price = state.latestPrice;
 329 |     |             pool1.price = ConstantProduct.getPriceAtTick(cache.newLatestTick + constants.tickSpread, constants);
 330 |     |         } else {
 331 |     |             pool1.liquidity = 0;
 332 |     |             pool0.price = ConstantProduct.getPriceAtTick(cache.newLatestTick - constants.tickSpread, constants);
 333 |     |             pool1.price = state.latestPrice;
 334 |     |         }
 335 |     |         
 336 |     |         // set auction start as an offset of the pool genesis block
 337 |     |         state.auctionStart = uint32(block.timestamp) - constants.genesisTime;
 338 |     | 
 339 |     |         // emit sync event
 340 |     |         emit Sync(pool0.price, pool1.price, pool0.liquidity, pool1.liquidity, state.auctionStart, state.accumEpoch, state.latestTick, cache.newLatestTick);
 341 |     |         
 342 |     |         // update latestTick
 343 |     |         state.latestTick = cache.newLatestTick;
 344 |     | 
 345 |     |         if (cache.syncFees.token0 > 0 || cache.syncFees.token1 > 0) {
 346 |     |             emit SyncFeesCollected(msg.sender, cache.syncFees.token0, cache.syncFees.token1);
 347 |     |         }
 348 |     |     
 349 |     |         return (state, cache.syncFees, pool0, pool1);
 350 |     |     }
 351 |     | 
 352 |     |     function _syncTick(
 353 |     |         CoverPoolStructs.GlobalState memory state,
 354 |     |         PoolsharkStructs.CoverImmutables memory constants
 355 |     |     ) internal view returns(
 356 |     |         int24 newLatestTick,
 357 |     |         bool
 358 |     |     ) {
 359 |     |         // update last block checked
 360 |     |         if(state.lastTime == uint32(block.timestamp) - constants.genesisTime) {
 361 |     |             return (state.latestTick, true);
 362 |     |         }
 363 |     |         state.lastTime = uint32(block.timestamp) - constants.genesisTime;
 364 |     |         // check auctions elapsed
 365 |     |         uint32 timeElapsed = state.lastTime - state.auctionStart;
 366 |     |         int32 auctionsElapsed = int32(timeElapsed / constants.auctionLength) - 1; /// @dev - subtract 1 for 3/4 twapLength check
 367 |     |         // if 3/4 of twapLength or auctionLength has passed allow for latestTick move
 368 |     |         if (timeElapsed > 3 * constants.twapLength / 4 ||
 369 |     |             timeElapsed > constants.auctionLength) auctionsElapsed += 1;
 370 |     | 
 371 |     |         if (auctionsElapsed < 1) {
 372 |     |             return (state.latestTick, true);
 373 |     |         }
 374 |     |         newLatestTick = constants.source.calculateAverageTick(constants, state.latestTick);
 375 |     |         /// @dev - shift up/down one quartile to put pool ahead of TWAP
 376 |     |         if (newLatestTick > state.latestTick)
 377 |     |              newLatestTick += constants.tickSpread / 4;
 378 |     |         else if (newLatestTick <= state.latestTick - 3 * constants.tickSpread / 4)
 379 |     |              newLatestTick -= constants.tickSpread / 4;
 380 |     |         newLatestTick = newLatestTick / constants.tickSpread * constants.tickSpread; // even multiple of tickSpread
 381 |     |         if (newLatestTick == state.latestTick) {
 382 |     |             return (state.latestTick, true);
 383 |     |         }
 384 |     | 
 385 |     |         // rate-limiting tick move
 386 |     |         int24 maxLatestTickMove = int24(constants.tickSpread * auctionsElapsed);
 387 |     | 
 388 |     |         /// @dev - latestTick can only move based on auctionsElapsed 
 389 |     |         if (newLatestTick > state.latestTick) {
 390 |     |             if (newLatestTick - state.latestTick > maxLatestTickMove)
 391 |     |                 newLatestTick = state.latestTick + maxLatestTickMove;
 392 |     |         } else {
 393 |     |             if (state.latestTick - newLatestTick > maxLatestTickMove)
 394 |     |                 newLatestTick = state.latestTick - maxLatestTickMove;
 395 |     |         }
 396 |     | 
 397 |     |         return (newLatestTick, false);
 398 |     |     }
 399 |     | 
 400 |     |     function _rollover(
 401 |     |         CoverPoolStructs.GlobalState memory state,
 402 |     |         CoverPoolStructs.AccumulateCache memory cache,
 403 |     |         CoverPoolStructs.PoolState memory pool,
 404 |     |         PoolsharkStructs.CoverImmutables memory constants,
 405 |     |         bool isPool0
 406 |     |     ) internal pure returns (
 407 |     |         CoverPoolStructs.AccumulateCache memory,
 408 |     |         CoverPoolStructs.PoolState memory
 409 |     |     ) {
 410 |     |         if (pool.liquidity == 0) {
 411 |     |             return (cache, pool);
 412 |     |         }
 413 |     |         uint160 crossPrice; uint160 accumPrice; uint160 currentPrice;
 414 |     |         if (isPool0) {
 415 |     |             crossPrice = ConstantProduct.getPriceAtTick(cache.nextTickToCross0, constants);
 416 |     |             int24 nextTickToAccum = (cache.nextTickToAccum0 < cache.stopTick0)
 417 |     |                                         ? cache.stopTick0
 418 |     |                                         : cache.nextTickToAccum0;
 419 |     |             accumPrice = ConstantProduct.getPriceAtTick(nextTickToAccum, constants);
 420 |     |             // check for multiple auction skips
 421 |     |             if (cache.nextTickToCross0 == state.latestTick && cache.nextTickToCross0 - nextTickToAccum > constants.tickSpread) {
 422 |     |                 uint160 spreadPrice = ConstantProduct.getPriceAtTick(cache.nextTickToCross0 - constants.tickSpread, constants);
 423 |     |                 /// @dev - amountOutDeltaMax accounted for down below
 424 |     |                 cache.deltas0.amountOutDelta += uint128(ConstantProduct.getDx(pool.liquidity, accumPrice, spreadPrice, false));
 425 |     |             }
 426 |     |             currentPrice = pool.price;
 427 |     |             // if pool.price the bounds set currentPrice to start of auction
 428 |     |             if (!(pool.price > accumPrice && pool.price < crossPrice)) currentPrice = accumPrice;
 429 |     |             // if auction is current and fully filled => set currentPrice to crossPrice
 430 |     |             if (state.latestTick == cache.nextTickToCross0 && crossPrice == pool.price) currentPrice = crossPrice;
 431 |     |         } else {
 432 |     |             crossPrice = ConstantProduct.getPriceAtTick(cache.nextTickToCross1, constants);
 433 |     |             int24 nextTickToAccum = (cache.nextTickToAccum1 > cache.stopTick1)
 434 |     |                                         ? cache.stopTick1
 435 |     |                                         : cache.nextTickToAccum1;
 436 |     |             accumPrice = ConstantProduct.getPriceAtTick(nextTickToAccum, constants);
 437 |     |             // check for multiple auction skips
 438 |     |             if (cache.nextTickToCross1 == state.latestTick && nextTickToAccum - cache.nextTickToCross1 > constants.tickSpread) {
 439 |     |                 uint160 spreadPrice = ConstantProduct.getPriceAtTick(cache.nextTickToCross1 + constants.tickSpread, constants);
 440 |     |                 /// @dev - DeltaMax values accounted for down below
 441 |     |                 cache.deltas1.amountOutDelta += uint128(ConstantProduct.getDy(pool.liquidity, spreadPrice, accumPrice, false));
 442 |     |             }
 443 |     |             currentPrice = pool.price;
 444 |     |             if (!(pool.price < accumPrice && pool.price > crossPrice)) currentPrice = accumPrice;
 445 |     |             if (state.latestTick == cache.nextTickToCross1 && crossPrice == pool.price) currentPrice = crossPrice;
 446 |     |         }
 447 |     | 
 448 |     |         //handle liquidity rollover
 449 |     |         if (isPool0) {
 450 |     |             {
 451 |     |                 // amountIn pool did not receive
 452 |     |                 uint128 amountInDelta;
 453 |     |                 uint128 amountInDeltaMax  = uint128(ConstantProduct.getDy(pool.liquidity, accumPrice, crossPrice, false));
 454 |     |                 amountInDelta       = pool.amountInDelta;
 455 |     |                 amountInDeltaMax   -= (amountInDeltaMax < pool.amountInDeltaMaxClaimed) ? amountInDeltaMax 
 456 |     |                                                                                         : pool.amountInDeltaMaxClaimed;
 457 |     |                 pool.amountInDelta  = 0;
 458 |     |                 pool.amountInDeltaMaxClaimed = 0;
 459 |     | 
 460 |     |                 // update cache in deltas
 461 |     |                 cache.deltas0.amountInDelta     += amountInDelta;
 462 |     |                 cache.deltas0.amountInDeltaMax  += amountInDeltaMax;
 463 |     |             }
 464 |     |             {
 465 |     |                 // amountOut pool has leftover
 466 |     |                 uint128 amountOutDelta    = uint128(ConstantProduct.getDx(pool.liquidity, currentPrice, crossPrice, false));
 467 |     |                 uint128 amountOutDeltaMax = uint128(ConstantProduct.getDx(pool.liquidity, accumPrice, crossPrice, false));
 468 |     |                 amountOutDeltaMax -= (amountOutDeltaMax < pool.amountOutDeltaMaxClaimed) ? amountOutDeltaMax
 469 |     |                                                                                         : pool.amountOutDeltaMaxClaimed;
 470 |     |                 pool.amountOutDeltaMaxClaimed = 0;
 471 |     | 
 472 |     |                 // calculate sync fee
 473 |     |                 uint128 syncFeeAmount = state.syncFee * amountOutDelta / 1e6;
 474 |     |                 cache.syncFees.token0 += syncFeeAmount;
 475 |     |                 amountOutDelta -= syncFeeAmount;
 476 |     | 
 477 |     |                 // update cache out deltas
 478 |     |                 cache.deltas0.amountOutDelta    += amountOutDelta;
 479 |     |                 cache.deltas0.amountOutDeltaMax += amountOutDeltaMax;
 480 |     |             }
 481 |     |         } else {
 482 |     |             {
 483 |     |                 // amountIn pool did not receive
 484 |     |                 uint128 amountInDelta;
 485 |     |                 uint128 amountInDeltaMax = uint128(ConstantProduct.getDx(pool.liquidity, crossPrice, accumPrice, false));
 486 |     |                 amountInDelta       = pool.amountInDelta;
 487 |     |                 amountInDeltaMax   -= (amountInDeltaMax < pool.amountInDeltaMaxClaimed) ? amountInDeltaMax 
 488 |     |                                                                                         : pool.amountInDeltaMaxClaimed;
 489 |     |                 pool.amountInDelta  = 0;
 490 |     |                 pool.amountInDeltaMaxClaimed = 0;
 491 |     | 
 492 |     |                 // update cache in deltas
 493 |     |                 cache.deltas1.amountInDelta     += amountInDelta;
 494 |     |                 cache.deltas1.amountInDeltaMax  += amountInDeltaMax;
 495 |     |             }
 496 |     |             {
 497 |     |                 // amountOut pool has leftover
 498 |     |                 uint128 amountOutDelta    = uint128(ConstantProduct.getDy(pool.liquidity, crossPrice, currentPrice, false));
 499 |     |                 uint128 amountOutDeltaMax = uint128(ConstantProduct.getDy(pool.liquidity, crossPrice, accumPrice, false));
 500 |     |                 amountOutDeltaMax -= (amountOutDeltaMax < pool.amountOutDeltaMaxClaimed) ? amountOutDeltaMax
 501 |     |                                                                                         : pool.amountOutDeltaMaxClaimed;
 502 |     |                 pool.amountOutDeltaMaxClaimed = 0;
 503 |     | 
 504 |     |                 // calculate sync fee
 505 |     |                 uint128 syncFeeAmount = state.syncFee * amountOutDelta / 1e6;
 506 |     |                 cache.syncFees.token1 += syncFeeAmount;
 507 |     |                 amountOutDelta -= syncFeeAmount;    
 508 |     | 
 509 |     |                 // update cache out deltas
 510 |     |                 cache.deltas1.amountOutDelta    += amountOutDelta;
 511 |     |                 cache.deltas1.amountOutDeltaMax += amountOutDeltaMax;
 512 |     |             }
 513 |     |         }
 514 |     |         return (cache, pool);
 515 |     |     }
 516 |     | 
 517 |     |     function _accumulate(
 518 |     |         CoverPoolStructs.AccumulateCache memory cache,
 519 |     |         CoverPoolStructs.AccumulateParams memory params,
 520 |     |         CoverPoolStructs.GlobalState memory state
 521 |     |     ) internal returns (
 522 |     |         CoverPoolStructs.AccumulateParams memory
 523 |     |     ) {
 524 |     |         if (params.isPool0 == params.crossTick.pool0Stash &&
 525 |     |                 params.crossTick.amountInDeltaMaxStashed > 0) {
 526 |     |             /// @dev - else we migrate carry deltas onto cache
 527 |     |             // add carry amounts to cache
 528 |     |             (params.crossTick, params.deltas) = Deltas.unstash(params.crossTick, params.deltas, params.isPool0);
 529 |     |             // clear out stash
 530 |     |             params.crossTick.amountInDeltaMaxStashed  = 0;
 531 |     |             params.crossTick.amountOutDeltaMaxStashed = 0;
 532 |     |             emit StashDeltasCleared(
 533 |     |                 params.isPool0 ? cache.nextTickToCross0 : cache.nextTickToCross1,
 534 |     |                 params.isPool0
 535 |     |             );
 536 |     |         }
 537 |     |         if (params.updateAccumDeltas) {
 538 |     |             // migrate carry deltas from cache to accum tick
 539 |     |             CoverPoolStructs.Deltas memory accumDeltas = params.isPool0 ? params.accumTick.deltas0
 540 |     |                                                                         : params.accumTick.deltas1;
 541 |     |             if (params.accumTick.amountInDeltaMaxMinus > 0) {
 542 |     |                 // calculate percent of deltas left on tick
 543 |     |                 if (params.deltas.amountInDeltaMax > 0 && params.deltas.amountOutDeltaMax > 0) {
 544 |     |                     uint256 percentInOnTick  = uint256(params.accumTick.amountInDeltaMaxMinus)  * 1e38 / (params.deltas.amountInDeltaMax);
 545 |     |                     uint256 percentOutOnTick = uint256(params.accumTick.amountOutDeltaMaxMinus) * 1e38 / (params.deltas.amountOutDeltaMax);
 546 |     |                     // transfer deltas to the accum tick
 547 |     |                     (params.deltas, accumDeltas) = Deltas.transfer(params.deltas, accumDeltas, percentInOnTick, percentOutOnTick);
 548 |     |                     
 549 |     |                     // burn tick deltas maxes from cache
 550 |     |                     params.deltas = Deltas.burnMaxCache(params.deltas, params.accumTick);
 551 |     |                     
 552 |     |                     // empty delta max minuses into delta max
 553 |     |                     accumDeltas.amountInDeltaMax  += params.accumTick.amountInDeltaMaxMinus;
 554 |     |                     accumDeltas.amountOutDeltaMax += params.accumTick.amountOutDeltaMaxMinus;
 555 |     | 
 556 |     |                     emit FinalDeltasAccumulated(
 557 |     |                         accumDeltas.amountInDelta,
 558 |     |                         accumDeltas.amountOutDelta,
 559 |     |                         state.accumEpoch,
 560 |     |                         params.isPool0 ? cache.nextTickToAccum0 : cache.nextTickToAccum1,
 561 |     |                         params.isPool0
 562 |     |                     );
 563 |     |                 } else {
 564 |     |                     emit FinalDeltasAccumulated(
 565 |     |                         0,0,0,
 566 |     |                         params.isPool0 ? cache.nextTickToAccum0 : cache.nextTickToAccum1,
 567 |     |                         params.isPool0
 568 |     |                     );
 569 |     |                 }
 570 |     | 
 571 |     |                 // clear out delta max minus and save on tick
 572 |     |                 params.accumTick.amountInDeltaMaxMinus  = 0;
 573 |     |                 if (params.isPool0) {
 574 |     |                     params.accumTick.deltas0 = accumDeltas;
 575 |     |                 } else {
 576 |     |                     params.accumTick.deltas1 = accumDeltas;
 577 |     |                 }
 578 |     | 
 579 |     |                 emit FinalDeltasAccumulated(
 580 |     |                     accumDeltas.amountInDelta,
 581 |     |                     accumDeltas.amountOutDelta,
 582 |     |                     state.accumEpoch,
 583 |     |                     params.isPool0 ? cache.nextTickToAccum0 : cache.nextTickToAccum1,
 584 |     |                     params.isPool0
 585 |     |                 );
 586 |     |             }
 587 |     |             // clear out delta max in either case
 588 |     |             params.accumTick.amountOutDeltaMaxMinus = 0;
 589 |     |         }
 590 |     |         // remove all liquidity
 591 |     |         params.crossTick.liquidityDelta = 0;
 592 |     | 
 593 |     |         return params;
 594 |     |     }
 595 |     | 
 596 |     |     //maybe call ticks on msg.sender to get tick
 597 |     |     function _cross(
 598 |     |         int128 liquidityDelta,
 599 |     |         CoverPoolStructs.TickMap storage tickMap,
 600 |     |         PoolsharkStructs.CoverImmutables memory constants,
 601 |     |         int24 nextTickToCross,
 602 |     |         int24 nextTickToAccum,
 603 |     |         uint128 currentLiquidity,
 604 |     |         bool zeroForOne
 605 |     |     ) internal view returns (
 606 |     |         uint128,
 607 |     |         int24,
 608 |     |         int24
 609 |     |     )
 610 |     |     {
 611 |     |         nextTickToCross = nextTickToAccum;
 612 |     | 
 613 |     |         if (liquidityDelta > 0) {
 614 |     |             currentLiquidity += uint128(liquidityDelta);
 615 |     |         } else {
 616 |     |             currentLiquidity -= uint128(-liquidityDelta);
 617 |     |         }
 618 |     |         if (zeroForOne) {
 619 |     |             nextTickToAccum = TickMap.previous(nextTickToAccum, tickMap, constants);
 620 |     |         } else {
 621 |     |             nextTickToAccum = TickMap.next(nextTickToAccum, tickMap, constants);
 622 |     |         }
 623 |     |         return (currentLiquidity, nextTickToCross, nextTickToAccum);
 624 |     |     }
 625 |     | 
 626 |     |     function _stash(
 627 |     |         CoverPoolStructs.Tick memory stashTick,
 628 |     |         CoverPoolStructs.AccumulateCache memory cache,
 629 |     |         CoverPoolStructs.GlobalState memory state,
 630 |     |         uint128 currentLiquidity,
 631 |     |         bool isPool0
 632 |     |     ) internal returns (CoverPoolStructs.Tick memory) {
 633 |     |         // return since there is nothing to update
 634 |     |         if (currentLiquidity == 0) return (stashTick);
 635 |     |         // handle deltas
 636 |     |         CoverPoolStructs.Deltas memory deltas = isPool0 ? cache.deltas0 : cache.deltas1;
 637 |     |         emit StashDeltasAccumulated(
 638 |     |             deltas.amountInDelta,
 639 |     |             deltas.amountOutDelta,
 640 |     |             deltas.amountInDeltaMax,
 641 |     |             deltas.amountOutDeltaMax,
 642 |     |             state.accumEpoch,
 643 |     |             isPool0 ? cache.stopTick0 : cache.stopTick1,
 644 |     |             isPool0
 645 |     |         );
 646 |     |         if (deltas.amountInDeltaMax > 0) {
 647 |     |             (deltas, stashTick) = Deltas.stash(deltas, stashTick, isPool0);
 648 |     |         }
 649 |     |         stashTick.liquidityDelta += int128(currentLiquidity);
 650 |     |         return (stashTick);
 651 |     |     }
 652 |     | }
 653 |     | 

/home/ec2-user/git/cover/contracts/libraries/Positions.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.13;
   3 |     | 
   4 |     | import './Ticks.sol';
   5 |     | import './Deltas.sol';
   6 |     | import '../interfaces/structs/CoverPoolStructs.sol';
   7 |     | import '../interfaces/ICoverPool.sol';
   8 |     | import './math/OverflowMath.sol';
   9 |     | import './Claims.sol';
  10 |     | import './EpochMap.sol';
  11 |     | 
  12 |     | /// @notice Position management library for ranged liquidity.
  13 |     | library Positions {
  14 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
  15 |     | 
  16 |     |     event Mint(
  17 |     |         address indexed to,
  18 |     |         int24 lower,
  19 |     |         int24 upper,
  20 |     |         bool zeroForOne,
  21 |     |         uint32 positionId,
  22 |     |         uint32 epochLast,
  23 |     |         uint128 amountIn,
  24 |     |         uint128 liquidityMinted,
  25 |     |         uint128 amountInDeltaMaxMinted,
  26 |     |         uint128 amountOutDeltaMaxMinted
  27 |     |     );
  28 |     | 
  29 |     |     event Burn(
  30 |     |         address indexed to,
  31 |     |         uint32 positionId,
  32 |     |         int24 claim,
  33 |     |         bool zeroForOne,
  34 |     |         uint128 liquidityBurned,
  35 |     |         uint128 tokenInClaimed,
  36 |     |         uint128 tokenOutClaimed,
  37 |     |         uint128 tokenOutBurned,
  38 |     |         uint128 amountInDeltaMaxStashedBurned,
  39 |     |         uint128 amountOutDeltaMaxStashedBurned,
  40 |     |         uint128 amountInDeltaMaxBurned,
  41 |     |         uint128 amountOutDeltaMaxBurned,
  42 |     |         uint160 claimPriceLast
  43 |     |     );
  44 |     | 
  45 |     |     function resize(
  46 |     |         CoverPoolStructs.CoverPosition memory position,
  47 |     |         ICoverPool.MintParams memory params,
  48 |     |         CoverPoolStructs.GlobalState memory state,
  49 |     |         PoolsharkStructs.CoverImmutables memory constants
  50 |     |     ) internal pure returns (
  51 |     |         ICoverPool.MintParams memory,
  52 |     |         uint256
  53 |     |     )
  54 |     |     {
  55 |     |         ConstantProduct.checkTicks(params.lower, params.upper, constants.tickSpread);
  56 |     | 
  57 |     |         CoverPoolStructs.CoverPositionCache memory cache = CoverPoolStructs.CoverPositionCache({
  58 |     |             position: position,
  59 |     |             deltas: CoverPoolStructs.Deltas(0,0,0,0),
  60 |     |             requiredStart: params.zeroForOne ? state.latestTick - int24(constants.tickSpread) * constants.minPositionWidth
  61 |     |                                              : state.latestTick + int24(constants.tickSpread) * constants.minPositionWidth,
  62 |     |             auctionCount: uint24((params.upper - params.lower) / constants.tickSpread),
  63 |     |             priceLower: ConstantProduct.getPriceAtTick(params.lower, constants),
  64 |     |             priceUpper: ConstantProduct.getPriceAtTick(params.upper, constants),
  65 |     |             priceAverage: 0,
  66 |     |             liquidityMinted: 0,
  67 |     |             denomTokenIn: true
  68 |     |         });
  69 |     | 
  70 |     |         // cannot mint empty position
  71 |     |         if (params.amount == 0) require (false, 'PositionAmountZero()');
  72 |     | 
  73 |     |         // enforce safety window
  74 |     |         if (params.zeroForOne) {    
  75 |     |             if (params.lower >= cache.requiredStart) require (false, 'PositionInsideSafetyWindow()'); 
  76 |     |         } else {
  77 |     |             if (params.upper <= cache.requiredStart) require (false, 'PositionInsideSafetyWindow()');
  78 |     |         }
  79 |     | 
  80 |     |         cache.liquidityMinted = ConstantProduct.getLiquidityForAmounts(
  81 |     |             cache.priceLower,
  82 |     |             cache.priceUpper,
  83 |     |             params.zeroForOne ? cache.priceLower : cache.priceUpper,
  84 |     |             params.zeroForOne ? 0 : uint256(params.amount),
  85 |     |             params.zeroForOne ? uint256(params.amount) : 0
  86 |     |         );
  87 |     | 
  88 |     |         // handle partial mints
  89 |     |         if (params.zeroForOne) {
  90 |     |             if (params.upper > cache.requiredStart) {
  91 |     |                 params.upper = cache.requiredStart;
  92 |     |                 uint256 priceNewUpper = ConstantProduct.getPriceAtTick(params.upper, constants);
  93 |     |                 params.amount -= uint128(
  94 |     |                     ConstantProduct.getDx(cache.liquidityMinted, priceNewUpper, cache.priceUpper, false)
  95 |     |                 );
  96 |     |                 cache.priceUpper = uint160(priceNewUpper);
  97 |     |             }
  98 |     |             // update auction count
  99 |     |             cache.auctionCount = uint24((params.upper - params.lower) / constants.tickSpread);
 100 |     |             if (cache.auctionCount == 0) require (false, 'InvalidPositionWidth()');
 101 |     |         } else {
 102 |     |             if (params.lower < cache.requiredStart) {
 103 |     |                 params.lower = cache.requiredStart;
 104 |     |                 uint256 priceNewLower = ConstantProduct.getPriceAtTick(params.lower, constants);
 105 |     |                 params.amount -= uint128(
 106 |     |                     ConstantProduct.getDy(cache.liquidityMinted, cache.priceLower, priceNewLower, false)
 107 |     |                 );
 108 |     |                 cache.priceLower = uint160(priceNewLower);
 109 |     |             }
 110 |     |             // update auction count
 111 |     |             cache.auctionCount = uint24((params.upper - params.lower) / constants.tickSpread);
 112 |     |             if (cache.auctionCount == 0) require (false, 'InvalidPositionWidth()');
 113 |     |         }
 114 |     |         // enforce minimum position width
 115 |     |         if (cache.auctionCount < uint16(constants.minPositionWidth)) require (false, 'InvalidPositionWidth()');
 116 |     |         if (cache.liquidityMinted > uint128(type(int128).max)) require (false, 'LiquidityOverflow()');
 117 |     | 
 118 |     |         // enforce minimum amount per auction
 119 |     |         _size(
 120 |     |             CoverPoolStructs.SizeParams(
 121 |     |                 cache.priceLower,
 122 |     |                 cache.priceUpper,
 123 |     |                 uint128(position.liquidity + cache.liquidityMinted),
 124 |     |                 params.zeroForOne,
 125 |     |                 state.latestTick,
 126 |     |                 cache.auctionCount
 127 |     |             ),
 128 |     |             constants
 129 |     |         );
 130 |     |  
 131 |     |         return (
 132 |     |             params,
 133 |     |             cache.liquidityMinted
 134 |     |         );
 135 |     |     }
 136 |     | 
 137 |     |     function add(
 138 |     |        CoverPoolStructs.CoverPosition memory position,
 139 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 140 |     |         CoverPoolStructs.TickMap storage tickMap,
 141 |     |         CoverPoolStructs.GlobalState memory state,
 142 |     |         CoverPoolStructs.AddParams memory params,
 143 |     |         PoolsharkStructs.CoverImmutables memory constants
 144 |     |     ) internal returns (
 145 |     |         CoverPoolStructs.GlobalState memory,
 146 |     |         CoverPoolStructs.CoverPosition memory
 147 |     |     ) {
 148 |     |         if (params.amount == 0) return (state, position);
 149 |     |         // initialize cache
 150 |     |         CoverPoolStructs.CoverPositionCache memory cache = CoverPoolStructs.CoverPositionCache({
 151 |     |             position: position,
 152 |     |             deltas: CoverPoolStructs.Deltas(0,0,0,0),
 153 |     |             requiredStart: 0,
 154 |     |             auctionCount: 0,
 155 |     |             priceLower: ConstantProduct.getPriceAtTick(params.lower, constants),
 156 |     |             priceUpper: ConstantProduct.getPriceAtTick(params.upper, constants),
 157 |     |             priceAverage: 0,
 158 |     |             liquidityMinted: 0,
 159 |     |             denomTokenIn: true
 160 |     |         });
 161 |     |         /// call if claim != lower and liquidity being added
 162 |     |         /// initialize new position
 163 |     | 
 164 |     |         if (cache.position.liquidity == 0) {
 165 |     |             cache.position.accumEpochLast = state.accumEpoch;
 166 |     |         } else {
 167 |     |             // safety check in case we somehow get here
 168 |     |             if (
 169 |     |                 params.zeroForOne
 170 |     |                     ? state.latestTick < params.upper ||
 171 |     |                         EpochMap.get(TickMap.previous(params.upper, tickMap, constants), params.zeroForOne, tickMap, constants)
 172 |     |                             > cache.position.accumEpochLast
 173 |     |                     : state.latestTick > params.lower ||
 174 |     |                         EpochMap.get(TickMap.next(params.lower, tickMap, constants), params.zeroForOne, tickMap, constants)
 175 |     |                             > cache.position.accumEpochLast
 176 |     |             ) {
 177 |     |                 require (false, string.concat('UpdatePositionFirstAt(', String.from(params.lower), ', ', String.from(params.upper), ')'));
 178 |     |             }
 179 |     |         }
 180 |     |         
 181 |     |         // add liquidity to ticks
 182 |     |         Ticks.insert(
 183 |     |             ticks,
 184 |     |             tickMap,
 185 |     |             state,
 186 |     |             constants,
 187 |     |             params.lower,
 188 |     |             params.upper,
 189 |     |             uint128(params.amount),
 190 |     |             params.zeroForOne
 191 |     |         );
 192 |     | 
 193 |     |         // update liquidity global
 194 |     |         state.liquidityGlobal += params.amount;
 195 |     | 
 196 |     |         {
 197 |     |             // update max deltas
 198 |     |             CoverPoolStructs.Tick memory finalTick = ticks[params.zeroForOne ? params.lower : params.upper];
 199 |     |             (finalTick, cache.deltas) = Deltas.update(finalTick, params.amount, cache.priceLower, cache.priceUpper, params.zeroForOne, true);
 200 |     |             ticks[params.zeroForOne ? params.lower : params.upper] = finalTick;
 201 |     |             // revert if either max delta is zero
 202 |     |             if (cache.deltas.amountInDeltaMax == 0) {
 203 |     |                 require(false, 'AmountInDeltaIsZero()');
 204 |     |             } else if (cache.deltas.amountOutDeltaMax == 0)
 205 |     |                 require(false, 'AmountOutDeltaIsZero()');
 206 |     |         }
 207 |     |         cache.position.liquidity += uint128(params.amount);
 208 |     |         emit Mint(
 209 |     |             params.to,
 210 |     |             params.lower,
 211 |     |             params.upper,
 212 |     |             params.zeroForOne,
 213 |     |             params.positionId,
 214 |     |             state.accumEpoch,
 215 |     |             params.amountIn,
 216 |     |             params.amount,
 217 |     |             cache.deltas.amountInDeltaMax,
 218 |     |             cache.deltas.amountOutDeltaMax
 219 |     |         );
 220 |     | 
 221 |     |         return (state, cache.position);
 222 |     |     }
 223 |     | 
 224 |     |     function remove(
 225 |     |         mapping(uint256 => CoverPoolStructs.CoverPosition)
 226 |     |             storage positions,
 227 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 228 |     |         CoverPoolStructs.TickMap storage tickMap,
 229 |     |         CoverPoolStructs.GlobalState memory state,
 230 |     |         CoverPoolStructs.RemoveParams memory params,
 231 |     |         PoolsharkStructs.CoverImmutables memory constants
 232 |     |     ) internal returns (uint128, CoverPoolStructs.GlobalState memory) {
 233 |     |         // validate burn percentage
 234 |     |         if (params.amount > 1e38) require (false, 'InvalidBurnPercentage()');
 235 |     |         // initialize cache
 236 |     |         CoverPoolStructs.CoverPositionCache memory cache = CoverPoolStructs.CoverPositionCache({
 237 |     |             position: positions[params.positionId],
 238 |     |             deltas: CoverPoolStructs.Deltas(0,0,0,0),
 239 |     |             requiredStart: params.zeroForOne ? state.latestTick - int24(constants.tickSpread) * constants.minPositionWidth
 240 |     |                                              : state.latestTick + int24(constants.tickSpread) * constants.minPositionWidth,
 241 |     |             auctionCount: uint24((params.upper - params.lower) / constants.tickSpread),
 242 |     |             priceLower: ConstantProduct.getPriceAtTick(params.lower, constants),
 243 |     |             priceUpper: ConstantProduct.getPriceAtTick(params.upper, constants),
 244 |     |             priceAverage: 0,
 245 |     |             liquidityMinted: 0,
 246 |     |             denomTokenIn: true
 247 |     |         });
 248 |     |         // convert percentage to liquidity amount
 249 |     |         params.amount = _convert(cache.position.liquidity, params.amount);
 250 |     |         // early return if no liquidity to remove
 251 |     |         if (params.amount == 0) return (0, state);
 252 |     |         if (params.amount > cache.position.liquidity) {
 253 |     |             require (false, 'NotEnoughPositionLiquidity()');
 254 |     |         } else {
 255 |     |             _size(
 256 |     |                 CoverPoolStructs.SizeParams(
 257 |     |                     cache.priceLower,
 258 |     |                     cache.priceUpper,
 259 |     |                     cache.position.liquidity - params.amount,
 260 |     |                     params.zeroForOne,
 261 |     |                     state.latestTick,
 262 |     |                     cache.auctionCount
 263 |     |                 ),
 264 |     |                 constants
 265 |     |             );
 266 |     |             /// @dev - validate needed in case user passes in wrong tick
 267 |     |             if (
 268 |     |                 params.zeroForOne
 269 |     |                     ? state.latestTick < params.upper ||
 270 |     |                         EpochMap.get(TickMap.previous(params.upper, tickMap, constants), params.zeroForOne, tickMap, constants)
 271 |     |                             > cache.position.accumEpochLast
 272 |     |                     : state.latestTick > params.lower ||
 273 |     |                         EpochMap.get(TickMap.next(params.lower, tickMap, constants), params.zeroForOne, tickMap, constants)
 274 |     |                             > cache.position.accumEpochLast
 275 |     |             ) {
 276 |     |                 require (false, 'WrongTickClaimedAt()');
 277 |     |             }
 278 |     |         }
 279 |     | 
 280 |     |         Ticks.remove(
 281 |     |             ticks,
 282 |     |             tickMap,
 283 |     |             constants,
 284 |     |             params.lower,
 285 |     |             params.upper,
 286 |     |             params.amount,
 287 |     |             params.zeroForOne,
 288 |     |             true,
 289 |     |             true
 290 |     |         );
 291 |     | 
 292 |     |         // update liquidity global
 293 |     |         state.liquidityGlobal -= params.amount;
 294 |     | 
 295 |     |         {
 296 |     |             // update max deltas
 297 |     |             CoverPoolStructs.Tick memory finalTick = ticks[params.zeroForOne ? params.lower : params.upper];
 298 |     |             (finalTick, cache.deltas) = Deltas.update(finalTick, params.amount, cache.priceLower, cache.priceUpper, params.zeroForOne, false);
 299 |     |             ticks[params.zeroForOne ? params.lower : params.upper] = finalTick;
 300 |     |         }
 301 |     | 
 302 |     |         cache.position.amountOut += uint128(
 303 |     |             params.zeroForOne
 304 |     |                 ? ConstantProduct.getDx(params.amount, cache.priceLower, cache.priceUpper, false)
 305 |     |                 : ConstantProduct.getDy(params.amount, cache.priceLower, cache.priceUpper, false)
 306 |     |         );
 307 |     | 
 308 |     |         cache.position.liquidity -= uint128(params.amount);
 309 |     |         if (cache.position.liquidity == 0) {
 310 |     |             cache.position.owner = address(0);
 311 |     |             cache.position.lower = 0;
 312 |     |             cache.position.upper = 0;
 313 |     |         }
 314 |     |         positions[params.positionId] = cache.position;
 315 |     | 
 316 |     |         if (params.amount > 0) {
 317 |     |             emit Burn(
 318 |     |                     params.to,
 319 |     |                     params.positionId,
 320 |     |                     params.zeroForOne ? params.upper : params.lower,
 321 |     |                     params.zeroForOne,
 322 |     |                     params.amount,
 323 |     |                     0, 0,
 324 |     |                     cache.position.amountOut,
 325 |     |                     0, 0,
 326 |     |                     cache.deltas.amountInDeltaMax,
 327 |     |                     cache.deltas.amountOutDeltaMax,
 328 |     |                     cache.position.claimPriceLast
 329 |     |             );
 330 |     |         }
 331 |     |         return (params.amount, state);
 332 |     |     }
 333 |     | 
 334 |     |     function update(
 335 |     |         mapping(uint256 => CoverPoolStructs.CoverPosition)
 336 |     |             storage positions,
 337 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 338 |     |         CoverPoolStructs.TickMap storage tickMap,
 339 |     |         CoverPoolStructs.GlobalState memory state,
 340 |     |         CoverPoolStructs.PoolState memory pool,
 341 |     |         CoverPoolStructs.UpdateParams memory params,
 342 |     |         PoolsharkStructs.CoverImmutables memory constants
 343 |     |     ) internal returns (
 344 |     |             CoverPoolStructs.GlobalState memory,
 345 |     |             CoverPoolStructs.PoolState memory,
 346 |     |             int24
 347 |     |         )
 348 |     |     {
 349 |     |         CoverPoolStructs.UpdatePositionCache memory cache;
 350 |     |         (
 351 |     |             params,
 352 |     |             cache,
 353 |     |             state
 354 |     |         ) = _deltas(
 355 |     |             positions,
 356 |     |             ticks,
 357 |     |             tickMap,
 358 |     |             state,
 359 |     |             pool,
 360 |     |             params,
 361 |     |             constants
 362 |     |         );
 363 |     | 
 364 |     |         if (cache.earlyReturn)
 365 |     |             return (state, pool, params.claim);
 366 |     | 
 367 |     |         pool.amountInDelta = cache.pool.amountInDelta;
 368 |     |         pool.amountInDeltaMaxClaimed  = cache.pool.amountInDeltaMaxClaimed;
 369 |     |         pool.amountOutDeltaMaxClaimed = cache.pool.amountOutDeltaMaxClaimed;
 370 |     | 
 371 |     |         // save claim tick
 372 |     |         ticks[params.claim] = cache.claimTick;
 373 |     |         if (params.claim != (params.zeroForOne ? params.lower : params.upper))
 374 |     |             ticks[params.zeroForOne ? params.lower : params.upper] = cache.finalTick;
 375 |     |         
 376 |     |         // update pool liquidity
 377 |     |         if (state.latestTick == params.claim
 378 |     |             && params.claim != (params.zeroForOne ? params.lower : params.upper)
 379 |     |         ) pool.liquidity -= params.amount;
 380 |     |         
 381 |     |         if (params.amount > 0) {
 382 |     |             if (params.claim == (params.zeroForOne ? params.lower : params.upper)) {
 383 |     |                 // only remove once if final tick of position
 384 |     |                 cache.removeLower = false;
 385 |     |                 cache.removeUpper = false;
 386 |     |             } else {
 387 |     |                 params.zeroForOne ? cache.removeUpper = true 
 388 |     |                                   : cache.removeLower = true;
 389 |     |             }
 390 |     |             Ticks.remove(
 391 |     |                 ticks,
 392 |     |                 tickMap,
 393 |     |                 constants,
 394 |     |                 params.zeroForOne ? params.lower : params.claim,
 395 |     |                 params.zeroForOne ? params.claim : params.upper,
 396 |     |                 params.amount,
 397 |     |                 params.zeroForOne,
 398 |     |                 cache.removeLower,
 399 |     |                 cache.removeUpper
 400 |     |             );
 401 |     |             // update position liquidity
 402 |     |             cache.position.liquidity -= uint128(params.amount);
 403 |     |             // update global liquidity
 404 |     |             state.liquidityGlobal -= params.amount;
 405 |     |         }
 406 |     | 
 407 |     |         (
 408 |     |             cache,
 409 |     |             params
 410 |     |         ) = _checkpoint(state, pool, params, constants, cache);
 411 |     | 
 412 |     |         // clear out old position
 413 |     |         if (params.zeroForOne ? params.claim != params.upper 
 414 |     |                               : params.claim != params.lower) {
 415 |     |             /// @dev - this also clears out position end claims
 416 |     |             if (params.zeroForOne ? params.claim == params.lower 
 417 |     |                                   : params.claim == params.upper) {
 418 |     |                 // subtract remaining position liquidity out from global
 419 |     |                 state.liquidityGlobal -= cache.position.liquidity;
 420 |     |                 cache.position.liquidity = 0;
 421 |     |             }
 422 |     |             delete positions[params.positionId];
 423 |     |         }
 424 |     |         // clear position values
 425 |     |         if (cache.position.liquidity == 0) {
 426 |     |             cache.position.owner = address(0);
 427 |     |             cache.position.lower = 0;
 428 |     |             cache.position.upper = 0;
 429 |     |             cache.position.accumEpochLast = 0;
 430 |     |             cache.position.claimPriceLast = 0;
 431 |     |         }
 432 |     |         // update position bounds
 433 |     |         if (params.zeroForOne) {
 434 |     |             cache.position.upper = params.claim;
 435 |     |         } else {
 436 |     |             cache.position.lower = params.claim;
 437 |     |         }
 438 |     |         positions[params.positionId] = cache.position;
 439 |     |         
 440 |     |         emit Burn(
 441 |     |             params.to,
 442 |     |             params.positionId,
 443 |     |             params.claim,
 444 |     |             params.zeroForOne,
 445 |     |             params.amount,
 446 |     |             cache.position.amountIn,
 447 |     |             cache.finalDeltas.amountOutDelta,
 448 |     |             cache.position.amountOut - cache.finalDeltas.amountOutDelta,
 449 |     |             uint128(cache.amountInFilledMax),
 450 |     |             uint128(cache.amountOutUnfilledMax),
 451 |     |             cache.finalDeltas.amountInDeltaMax,
 452 |     |             cache.finalDeltas.amountOutDeltaMax,
 453 |     |             cache.position.claimPriceLast
 454 |     |         );
 455 |     |         // return cached position in memory and transfer out
 456 |     |         return (state, pool, params.claim);
 457 |     |     }
 458 |     | 
 459 |     |     function snapshot(
 460 |     |         mapping(uint256 => CoverPoolStructs.CoverPosition)
 461 |     |             storage positions,
 462 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 463 |     |         CoverPoolStructs.TickMap storage tickMap,
 464 |     |         CoverPoolStructs.GlobalState memory state,
 465 |     |         CoverPoolStructs.PoolState memory pool,
 466 |     |         CoverPoolStructs.UpdateParams memory params,
 467 |     |         PoolsharkStructs.CoverImmutables memory constants
 468 |     |     ) internal view returns (
 469 |     |         CoverPoolStructs.CoverPosition memory
 470 |     |     ) {
 471 |     |         CoverPoolStructs.UpdatePositionCache memory cache;
 472 |     |         (
 473 |     |             params,
 474 |     |             cache,
 475 |     |             state
 476 |     |         ) = _deltas(
 477 |     |             positions,
 478 |     |             ticks,
 479 |     |             tickMap,
 480 |     |             state,
 481 |     |             pool,
 482 |     |             params,
 483 |     |             constants
 484 |     |         );
 485 |     | 
 486 |     |         if (cache.earlyReturn) {
 487 |     |             if (params.amount > 0)
 488 |     |                 cache.position.amountOut += uint128(
 489 |     |                     params.zeroForOne
 490 |     |                         ? ConstantProduct.getDx(params.amount, cache.priceLower, cache.priceUpper, false)
 491 |     |                         : ConstantProduct.getDy(params.amount, cache.priceLower, cache.priceUpper, false)
 492 |     |                 );
 493 |     |             return cache.position;
 494 |     |         }
 495 |     | 
 496 |     |         if (params.amount > 0) {
 497 |     |             cache.position.liquidity -= uint128(params.amount);
 498 |     |         }
 499 |     |         // checkpoint claimPriceLast
 500 |     |         (
 501 |     |             cache,
 502 |     |             params
 503 |     |         ) = _checkpoint(state, pool, params, constants, cache);
 504 |     |         
 505 |     |         // clear position values if empty
 506 |     |         if (cache.position.liquidity == 0) {
 507 |     |             cache.position.accumEpochLast = 0;
 508 |     |             cache.position.claimPriceLast = 0;
 509 |     |         }    
 510 |     |         return cache.position;
 511 |     |     }
 512 |     | 
 513 |     |     function _convert(
 514 |     |         uint128 liquidity,
 515 |     |         uint128 percent
 516 |     |     ) internal pure returns (
 517 |     |         uint128
 518 |     |     ) {
 519 |     |         // convert percentage to liquidity amount
 520 |     |         if (percent > 1e38) require (false, 'InvalidBurnPercentage()');
 521 |     |         if (liquidity == 0 && percent > 0) require (false, 'NotEnoughPositionLiquidity()');
 522 |     |         return uint128(uint256(liquidity) * uint256(percent) / 1e38);
 523 |     |     }
 524 |     | 
 525 |     |     function _deltas(
 526 |     |         mapping(uint256 => CoverPoolStructs.CoverPosition)
 527 |     |             storage positions,
 528 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 529 |     |         CoverPoolStructs.TickMap storage tickMap,
 530 |     |         CoverPoolStructs.GlobalState memory state,
 531 |     |         CoverPoolStructs.PoolState memory pool,
 532 |     |         CoverPoolStructs.UpdateParams memory params,
 533 |     |         PoolsharkStructs.CoverImmutables memory constants
 534 |     |     ) internal view returns (
 535 |     |         CoverPoolStructs.UpdateParams memory,
 536 |     |         CoverPoolStructs.UpdatePositionCache memory,
 537 |     |         CoverPoolStructs.GlobalState memory
 538 |     |     ) {
 539 |     |         CoverPoolStructs.UpdatePositionCache memory cache;
 540 |     |         cache.position = positions[params.positionId];
 541 |     |         params.lower = cache.position.lower;
 542 |     |         params.upper = cache.position.upper;
 543 |     |         cache = CoverPoolStructs.UpdatePositionCache({
 544 |     |             position: cache.position,
 545 |     |             pool: pool,
 546 |     |             priceLower: ConstantProduct.getPriceAtTick(params.lower, constants),
 547 |     |             priceClaim: ConstantProduct.getPriceAtTick(params.claim, constants),
 548 |     |             priceUpper: ConstantProduct.getPriceAtTick(params.upper, constants),
 549 |     |             priceSpread: 0,
 550 |     |             amountInFilledMax: 0,
 551 |     |             amountOutUnfilledMax: 0,
 552 |     |             claimTick: ticks[params.claim],
 553 |     |             finalTick: ticks[params.zeroForOne ? params.lower : params.upper],
 554 |     |             earlyReturn: false,
 555 |     |             removeLower: true,
 556 |     |             removeUpper: true,
 557 |     |             deltas: CoverPoolStructs.Deltas(0,0,0,0),
 558 |     |             finalDeltas: CoverPoolStructs.Deltas(0,0,0,0)
 559 |     |         });
 560 |     |         if (params.claim == (params.zeroForOne ? params.lower : params.upper)) {
 561 |     |             params.amount = 1e38;
 562 |     |         }
 563 |     |         params.amount = _convert(cache.position.liquidity, params.amount);
 564 |     | 
 565 |     |         // check claim is valid
 566 |     |         (params, cache) = Claims.validate(
 567 |     |             tickMap,
 568 |     |             state,
 569 |     |             cache.pool,
 570 |     |             params,
 571 |     |             cache,
 572 |     |             constants
 573 |     |         );
 574 |     |         if (cache.earlyReturn) {
 575 |     |             return (params, cache, state);
 576 |     |         }
 577 |     |         cache.priceSpread = ConstantProduct.getPriceAtTick(params.zeroForOne ? params.claim - constants.tickSpread 
 578 |     |                                                                              : params.claim + constants.tickSpread,
 579 |     |                                                            constants);
 580 |     |         if (params.amount > 0)
 581 |     |             _size(
 582 |     |                 CoverPoolStructs.SizeParams(
 583 |     |                     cache.priceLower,
 584 |     |                     cache.priceUpper,
 585 |     |                     cache.position.liquidity - params.amount,
 586 |     |                     params.zeroForOne,
 587 |     |                     state.latestTick,
 588 |     |                     uint24((params.upper - params.lower) / constants.tickSpread)
 589 |     |                 ),
 590 |     |                 constants
 591 |     |             );
 592 |     |         // get deltas from claim tick
 593 |     |         cache = Claims.getDeltas(cache, params);
 594 |     |         /// @dev - section 1 => position start - previous auction
 595 |     |         cache = Claims.section1(cache, params, constants);
 596 |     |         /// @dev - section 2 => position start -> claim tick
 597 |     |         cache = Claims.section2(cache, params);
 598 |     |         // check if auction in progress 
 599 |     |         if (params.claim == state.latestTick 
 600 |     |             && params.claim != (params.zeroForOne ? params.lower : params.upper)) {
 601 |     |             /// @dev - section 3 => claim tick - unfilled section
 602 |     |             cache = Claims.section3(cache, params, cache.pool);
 603 |     |             /// @dev - section 4 => claim tick - filled section
 604 |     |             cache = Claims.section4(cache, params, cache.pool);
 605 |     |         }
 606 |     |         /// @dev - section 5 => claim tick -> position end
 607 |     |         cache = Claims.section5(cache, params);
 608 |     |         // adjust position amounts based on deltas
 609 |     |         cache = Claims.applyDeltas(state, cache, params);
 610 |     | 
 611 |     |         return (params, cache, state);
 612 |     |     }
 613 |     | 
 614 |     |     function _size(
 615 |     |         CoverPoolStructs.SizeParams memory params,
 616 |     |         PoolsharkStructs.CoverImmutables memory constants
 617 |     |     ) internal pure  
 618 |     |     {
 619 |     |         // early return if 100% of position burned
 620 |     |         if (constants.minAmountPerAuction == 0) return;
 621 |     |         if (params.liquidityAmount == 0 || params.auctionCount == 0) return;
 622 |     |         // set minAmountPerAuction based on token decimals
 623 |     |         uint256 minAmountPerAuction; bool denomTokenIn;
 624 |     |         if (params.latestTick > 0) {
 625 |     |             if (constants.minAmountLowerPriced) {
 626 |     |                 // token1 is the lower priced token
 627 |     |                 denomTokenIn = !params.zeroForOne;
 628 |     |                 minAmountPerAuction = constants.minAmountPerAuction / 10**(18 - constants.token1Decimals);
 629 |     |             } else {
 630 |     |                 // token0 is the higher priced token
 631 |     |                 denomTokenIn = params.zeroForOne;
 632 |     |                 minAmountPerAuction = constants.minAmountPerAuction / 10**(18 - constants.token0Decimals);
 633 |     |             }
 634 |     |         } else {
 635 |     |             if (constants.minAmountLowerPriced) {
 636 |     |                 // token0 is the lower priced token
 637 |     |                 denomTokenIn = params.zeroForOne;
 638 |     |                 minAmountPerAuction = constants.minAmountPerAuction / 10**(18 - constants.token0Decimals);
 639 |     |             } else {
 640 |     |                 // token1 is the higher priced token
 641 |     |                 denomTokenIn = !params.zeroForOne;
 642 |     |                 minAmountPerAuction = constants.minAmountPerAuction / 10**(18 - constants.token1Decimals);
 643 |     |             }
 644 |     |         }
 645 |     |         if (params.zeroForOne) {
 646 |     |             //calculate amount in the position currently
 647 |     |             uint128 amount = uint128(ConstantProduct.getDx(
 648 |     |                 params.liquidityAmount,
 649 |     |                 params.priceLower,
 650 |     |                 params.priceUpper,
 651 |     |                 false
 652 |     |             ));
 653 |     |             if (denomTokenIn) {
 654 |     |                 if (amount / params.auctionCount < minAmountPerAuction)
 655 |     |                     require (false, 'PositionAuctionAmountTooSmall()');
 656 |     |             } else {
 657 |     |                 // denominate in incoming token
 658 |     |                 uint256 priceAverage = (params.priceUpper + params.priceLower) / 2;
 659 |     |                 uint256 convertedAmount = amount * priceAverage / Q96 
 660 |     |                                                  * priceAverage / Q96; // convert by squaring price
 661 |     |                 if (convertedAmount / params.auctionCount < minAmountPerAuction) 
 662 |     |                     require (false, 'PositionAuctionAmountTooSmall()');
 663 |     |             }
 664 |     |         } else {
 665 |     |             uint128 amount = uint128(ConstantProduct.getDy(
 666 |     |                 params.liquidityAmount,
 667 |     |                 params.priceLower,
 668 |     |                 params.priceUpper,
 669 |     |                 false
 670 |     |             ));
 671 |     |             if (denomTokenIn) {
 672 |     |                 // denominate in token1
 673 |     |                 // calculate amount in position currently
 674 |     |                 if (amount / params.auctionCount < minAmountPerAuction) 
 675 |     |                     require (false, 'PositionAuctionAmountTooSmall()');
 676 |     |             } else {
 677 |     |                 // denominate in token0
 678 |     |                 uint256 priceAverage = (params.priceUpper + params.priceLower) / 2;
 679 |     |                 uint256 convertedAmount = amount * Q96 / priceAverage 
 680 |     |                                                  * Q96 / priceAverage; // convert by squaring price
 681 |     |                 if (convertedAmount / params.auctionCount < minAmountPerAuction) 
 682 |     |                     require (false, 'PositionAuctionAmountTooSmall()');
 683 |     |             }
 684 |     |         }
 685 |     |     }
 686 |     | 
 687 |     |     function _checkpoint(
 688 |     |         CoverPoolStructs.GlobalState memory state,
 689 |     |         CoverPoolStructs.PoolState memory pool,
 690 |     |         CoverPoolStructs.UpdateParams memory params,
 691 |     |         PoolsharkStructs.CoverImmutables memory constants,
 692 |     |         CoverPoolStructs.UpdatePositionCache memory cache
 693 |     |     ) internal pure returns (
 694 |     |         CoverPoolStructs.UpdatePositionCache memory,
 695 |     |         CoverPoolStructs.UpdateParams memory
 696 |     |     ) {
 697 |     |         // update claimPriceLast
 698 |     |         cache.priceClaim = ConstantProduct.getPriceAtTick(params.claim, constants);
 699 |     |         cache.position.claimPriceLast = (params.claim == state.latestTick)
 700 |     |             ? pool.price
 701 |     |             : cache.priceClaim;
 702 |     |         /// @dev - if tick 0% filled, set CPL to latestTick
 703 |     |         if (pool.price == cache.priceSpread) cache.position.claimPriceLast = cache.priceClaim;
 704 |     |         /// @dev - if tick 100% filled, set CPL to next tick to unlock
 705 |     |         if (pool.price == cache.priceClaim && params.claim == state.latestTick){
 706 |     |             cache.position.claimPriceLast = cache.priceSpread;
 707 |     |             // set claim tick to claim + tickSpread
 708 |     |             params.claim = params.zeroForOne ? params.claim - constants.tickSpread
 709 |     |                                              : params.claim + constants.tickSpread;
 710 |     |         }
 711 |     |         return (cache, params);
 712 |     |     }
 713 |     | }
 714 |     | 

/home/ec2-user/git/cover/contracts/libraries/TickMap.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.13;
   3 |     | 
   4 |     | import '../interfaces/structs/CoverPoolStructs.sol';
   5 |     | import './math/ConstantProduct.sol';
   6 |     | 
   7 |     | library TickMap {
   8 |     |     function set(
   9 |     |         int24 tick,
  10 |     |         CoverPoolStructs.TickMap storage tickMap,
  11 |     |         PoolsharkStructs.CoverImmutables memory constants
  12 |     |     ) internal returns (
  13 |     |         bool exists
  14 |     |     )    
  15 |     |     {
  16 |     |         (
  17 |     |             uint256 tickIndex,
  18 |     |             uint256 wordIndex,
  19 |     |             uint256 blockIndex
  20 |     |         ) = getIndices(tick, constants);
  21 |     | 
  22 |     |         // check if bit is already set
  23 |     |         uint256 word = tickMap.ticks[wordIndex] | 1 << (tickIndex & 0xFF);
  24 |     |         if (word == tickMap.ticks[wordIndex]) {
  25 |     |             return true;
  26 |     |         }
  27 |     | 
  28 |     |         tickMap.ticks[wordIndex]     = word; 
  29 |     |         tickMap.words[blockIndex]   |= 1 << (wordIndex & 0xFF); // same as modulus 255
  30 |     |         tickMap.blocks              |= 1 << blockIndex;
  31 |     |         return false;
  32 |     |     }
  33 |     | 
  34 |     |     function unset(
  35 |     |         int24 tick,
  36 |     |         CoverPoolStructs.TickMap storage tickMap,
  37 |     |         PoolsharkStructs.CoverImmutables memory constants
  38 |     |     ) internal {
  39 |     |         (
  40 |     |             uint256 tickIndex,
  41 |     |             uint256 wordIndex,
  42 |     |             uint256 blockIndex
  43 |     |         ) = getIndices(tick, constants);
  44 |     | 
  45 |     |         tickMap.ticks[wordIndex] &= ~(1 << (tickIndex & 0xFF));
  46 |     |         if (tickMap.ticks[wordIndex] == 0) {
  47 |     |             tickMap.words[blockIndex] &= ~(1 << (wordIndex & 0xFF));
  48 |     |             if (tickMap.words[blockIndex] == 0) {
  49 |     |                 tickMap.blocks &= ~(1 << blockIndex);
  50 |     |             }
  51 |     |         }
  52 |     |     }
  53 |     | 
  54 |     |     function previous(
  55 |     |         int24 tick,
  56 |     |         CoverPoolStructs.TickMap storage tickMap,
  57 |     |         PoolsharkStructs.CoverImmutables memory constants
  58 |     |     ) internal view returns (
  59 |     |         int24 previousTick
  60 |     |     ) {
  61 |     |         unchecked {
  62 |     |             (
  63 |     |               uint256 tickIndex,
  64 |     |               uint256 wordIndex,
  65 |     |               uint256 blockIndex
  66 |     |             ) = getIndices(tick, constants);
  67 |     | 
  68 |     |             uint256 word = tickMap.ticks[wordIndex] & ((1 << (tickIndex & 0xFF)) - 1);
  69 |     |             if (word == 0) {
  70 |     |                 uint256 block_ = tickMap.words[blockIndex] & ((1 << (wordIndex & 0xFF)) - 1);
  71 |     |                 if (block_ == 0) {
  72 |     |                     uint256 blockMap = tickMap.blocks & ((1 << blockIndex) - 1);
  73 |     |                     if (blockMap == 0) return tick;
  74 |     |                     blockIndex = _msb(blockMap);
  75 |     |                     block_ = tickMap.words[blockIndex];
  76 |     |                 }
  77 |     |                 wordIndex = (blockIndex << 8) | _msb(block_);
  78 |     |                 word = tickMap.ticks[wordIndex];
  79 |     |             }
  80 |     |             previousTick = _tick((wordIndex << 8) | _msb(word), constants);
  81 |     |         }
  82 |     |     }
  83 |     | 
  84 |     |     function next(
  85 |     |         int24 tick,
  86 |     |         CoverPoolStructs.TickMap storage tickMap,
  87 |     |         PoolsharkStructs.CoverImmutables memory constants
  88 |     |     ) internal view returns (
  89 |     |         int24 nextTick
  90 |     |     ) {
  91 |     |         unchecked {
  92 |     |             (
  93 |     |               uint256 tickIndex,
  94 |     |               uint256 wordIndex,
  95 |     |               uint256 blockIndex
  96 |     |             ) = getIndices(tick, constants);
  97 |     |             uint256 word;
  98 |     |             if ((tickIndex & 0xFF) != 255) {
  99 |     |                 word = tickMap.ticks[wordIndex] & ~((1 << ((tickIndex & 0xFF) + 1)) - 1);
 100 |     |             }
 101 |     |             if (word == 0) {
 102 |     |                 uint256 block_;
 103 |     |                 if ((blockIndex & 0xFF) != 255) {
 104 |     |                     block_ = tickMap.words[blockIndex] & ~((1 << ((wordIndex & 0xFF) + 1)) - 1);
 105 |     |                 }
 106 |     |                 if (block_ == 0) {
 107 |     |                     uint256 blockMap = tickMap.blocks & ~((1 << blockIndex + 1) - 1);
 108 |     |                     if (blockMap == 0) return tick;
 109 |     |                     blockIndex = _lsb(blockMap);
 110 |     |                     block_ = tickMap.words[blockIndex];
 111 |     |                 }
 112 |     |                 wordIndex = (blockIndex << 8) | _lsb(block_);
 113 |     |                 word = tickMap.ticks[wordIndex];
 114 |     |             }
 115 |     |             nextTick = _tick((wordIndex << 8) | _lsb(word), constants);
 116 |     |         }
 117 |     |     }
 118 |     | 
 119 |     |     function getIndices(
 120 |     |         int24 tick,
 121 |     |         PoolsharkStructs.CoverImmutables memory constants
 122 |     |     ) public pure returns (
 123 |     |             uint256 tickIndex,
 124 |     |             uint256 wordIndex,
 125 |     |             uint256 blockIndex
 126 |     |         )
 127 |     |     {
 128 |     |         unchecked {
 129 |     |             if (tick > ConstantProduct.maxTick(constants.tickSpread)) require (false, 'TickIndexOverflow()');
 130 |     |             if (tick < ConstantProduct.minTick(constants.tickSpread)) require (false, 'TickIndexUnderflow()');
 131 |     |             if (tick % constants.tickSpread != 0) require (false, 'TickIndexInvalid()');
 132 |     |             tickIndex = uint256(int256((tick - ConstantProduct.minTick(constants.tickSpread))) / constants.tickSpread);
 133 |     |             wordIndex = tickIndex >> 8;   // 2^8 ticks per word
 134 |     |             blockIndex = tickIndex >> 16; // 2^8 words per block
 135 |     |             if (blockIndex > 255) require (false, 'BlockIndexOverflow()');
 136 |     |         }
 137 |     |     }
 138 |     | 
 139 |     |     function _tick (
 140 |     |         uint256 tickIndex,
 141 |     |         PoolsharkStructs.CoverImmutables memory constants
 142 |     |     ) internal pure returns (
 143 |     |         int24 tick
 144 |     |     ) {
 145 |     |         unchecked {
 146 |     |             if (tickIndex > uint24(ConstantProduct.maxTick(constants.tickSpread) * 2)) require (false, 'TickIndexOverflow()');
 147 |     |             tick = int24(int256(tickIndex) * int256(constants.tickSpread) + ConstantProduct.minTick(constants.tickSpread));
 148 |     |         }
 149 |     |     }
 150 |     | 
 151 |     |     function _msb(
 152 |     |         uint256 x
 153 |     |     ) internal pure returns (
 154 |     |         uint8 r
 155 |     |     ) {
 156 |     |         unchecked {
 157 |     |             assert(x > 0);
 158 |     |             if (x >= 0x100000000000000000000000000000000) {
 159 |     |                 x >>= 128;
 160 |     |                 r += 128;
 161 |     |             }
 162 |     |             if (x >= 0x10000000000000000) {
 163 |     |                 x >>= 64;
 164 |     |                 r += 64;
 165 |     |             }
 166 |     |             if (x >= 0x100000000) {
 167 |     |                 x >>= 32;
 168 |     |                 r += 32;
 169 |     |             }
 170 |     |             if (x >= 0x10000) {
 171 |     |                 x >>= 16;
 172 |     |                 r += 16;
 173 |     |             }
 174 |     |             if (x >= 0x100) {
 175 |     |                 x >>= 8;
 176 |     |                 r += 8;
 177 |     |             }
 178 |     |             if (x >= 0x10) {
 179 |     |                 x >>= 4;
 180 |     |                 r += 4;
 181 |     |             }
 182 |     |             if (x >= 0x4) {
 183 |     |                 x >>= 2;
 184 |     |                 r += 2;
 185 |     |             }
 186 |     |             if (x >= 0x2) r += 1;
 187 |     |         }
 188 |     |     }
 189 |     | 
 190 |     |     function _lsb(
 191 |     |         uint256 x
 192 |     |     ) internal pure returns (
 193 |     |         uint8 r
 194 |     |     ) {
 195 |     |         unchecked {
 196 |     |             assert(x > 0); // if x is 0 return 0
 197 |     |             r = 255;
 198 |     |             if (x & type(uint128).max > 0) {
 199 |     |                 r -= 128;
 200 |     |             } else {
 201 |     |                 x >>= 128;
 202 |     |             }
 203 |     |             if (x & type(uint64).max > 0) {
 204 |     |                 r -= 64;
 205 |     |             } else {
 206 |     |                 x >>= 64;
 207 |     |             }
 208 |     |             if (x & type(uint32).max > 0) {
 209 |     |                 r -= 32;
 210 |     |             } else {
 211 |     |                 x >>= 32;
 212 |     |             }
 213 |     |             if (x & type(uint16).max > 0) {
 214 |     |                 r -= 16;
 215 |     |             } else {
 216 |     |                 x >>= 16;
 217 |     |             }
 218 |     |             if (x & type(uint8).max > 0) {
 219 |     |                 r -= 8;
 220 |     |             } else {
 221 |     |                 x >>= 8;
 222 |     |             }
 223 |     |             if (x & 0xf > 0) {
 224 |     |                 r -= 4;
 225 |     |             } else {
 226 |     |                 x >>= 4;
 227 |     |             }
 228 |     |             if (x & 0x3 > 0) {
 229 |     |                 r -= 2;
 230 |     |             } else {
 231 |     |                 x >>= 2;
 232 |     |             }
 233 |     |             if (x & 0x1 > 0) r -= 1;
 234 |     |         }
 235 |     |     }
 236 |     |     
 237 |     | }

/home/ec2-user/git/cover/contracts/libraries/Ticks.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.13;
   3 |     | 
   4 |     | import '../interfaces/structs/CoverPoolStructs.sol';
   5 |     | import '../utils/CoverPoolErrors.sol';
   6 |     | import './math/OverflowMath.sol';
   7 |     | import '../interfaces/modules/sources/ITwapSource.sol';
   8 |     | import './TickMap.sol';
   9 |     | 
  10 |     | /// @notice Tick management library for ranged liquidity.
  11 |     | library Ticks {
  12 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
  13 |     | 
  14 |     |     event Initialize(
  15 |     |         int24 minTick,
  16 |     |         int24 maxTick,
  17 |     |         int24 latestTick,
  18 |     |         uint32 genesisTime,
  19 |     |         uint32 auctionStart,
  20 |     |         uint160 pool0Price,
  21 |     |         uint160 pool1Price
  22 |     |     );
  23 |     | 
  24 |     |     function quote(
  25 |     |         bool zeroForOne,
  26 |     |         uint160 priceLimit,
  27 |     |         CoverPoolStructs.GlobalState memory state,
  28 |     |         CoverPoolStructs.SwapCache memory cache,
  29 |     |         PoolsharkStructs.CoverImmutables memory constants
  30 |     |     ) internal pure returns (CoverPoolStructs.SwapCache memory) {
  31 |     |         if ((zeroForOne ? priceLimit >= cache.price
  32 |     |                         : priceLimit <= cache.price) ||
  33 |     |             (cache.liquidity == 0))
  34 |     |         {
  35 |     |             return cache;
  36 |     |         }
  37 |     |         uint256 nextPrice = state.latestPrice;
  38 |     |         // determine input boost from tick auction
  39 |     |         cache.auctionBoost = ((cache.auctionDepth <= constants.auctionLength) ? cache.auctionDepth
  40 |     |                                                                               : constants.auctionLength
  41 |     |                              ) * 1e14 / constants.auctionLength * uint16(constants.tickSpread);
  42 |     |         cache.amountBoosted = cache.amountLeft * (1e18 + cache.auctionBoost) / 1e18;
  43 |     |         if (zeroForOne) {
  44 |     |             // trade token 0 (x) for token 1 (y)
  45 |     |             // price decreases
  46 |     |             if (priceLimit > nextPrice) {
  47 |     |                 // stop at price limit
  48 |     |                 nextPrice = priceLimit;
  49 |     |             }
  50 |     |             uint256 amountMax = cache.exactIn ? ConstantProduct.getDx(cache.liquidity, nextPrice, cache.price, true)
  51 |     |                                               : ConstantProduct.getDy(cache.liquidity, nextPrice, cache.price, false);
  52 |     |             // check if all input is used
  53 |     |             if (cache.amountBoosted <= amountMax) {
  54 |     |                 // calculate price after swap
  55 |     |                 if (cache.exactIn) {
  56 |     |                     uint256 newPrice = ConstantProduct.getNewPrice(cache.price, cache.liquidity, cache.amountBoosted, zeroForOne, cache.exactIn);
  57 |     |                     cache.input = cache.amountLeft;
  58 |     |                     cache.output += ConstantProduct.getDy(cache.liquidity, newPrice, cache.price, false);
  59 |     |                     cache.price = newPrice;
  60 |     |                     cache.amountLeft = 0;
  61 |     |                 }
  62 |     |             } else if (amountMax > 0) {
  63 |     |                 if (cache.exactIn) {
  64 |     |                     cache.input = amountMax * (1e18 - cache.auctionBoost) / 1e18; /// @dev - convert back to input amount
  65 |     |                     cache.output = ConstantProduct.getDy(cache.liquidity, nextPrice, cache.price, false);
  66 |     |                     cache.price = nextPrice;
  67 |     |                     cache.amountLeft -= cache.input;
  68 |     |                 }
  69 |     |             }
  70 |     |         } else {
  71 |     |             // price increases
  72 |     |             if (priceLimit < nextPrice) {
  73 |     |                 // stop at price limit
  74 |     |                 nextPrice = priceLimit;
  75 |     |             }
  76 |     |             uint256 amountMax = cache.exactIn ? ConstantProduct.getDy(cache.liquidity, uint256(cache.price), nextPrice, true)
  77 |     |                                               : ConstantProduct.getDx(cache.liquidity, uint256(cache.price), nextPrice, false);
  78 |     |             if (cache.amountBoosted <= amountMax) {
  79 |     |                 // calculate price after swap
  80 |     |                 if (cache.exactIn) {
  81 |     |                     uint256 newPrice = ConstantProduct.getNewPrice(cache.price, cache.liquidity, cache.amountBoosted, zeroForOne, cache.exactIn);
  82 |     |                     cache.input = cache.amountLeft;
  83 |     |                     cache.output += ConstantProduct.getDx(cache.liquidity, cache.price, newPrice, false);
  84 |     |                     cache.price = newPrice;
  85 |     |                     cache.amountLeft = 0;
  86 |     |                 }
  87 |     |             } else if (amountMax > 0) {
  88 |     |                 if (cache.exactIn) {
  89 |     |                     cache.input = amountMax * (1e18 - cache.auctionBoost) / 1e18; 
  90 |     |                     cache.output = ConstantProduct.getDx(cache.liquidity, cache.price, nextPrice, false);
  91 |     |                     cache.price = nextPrice;
  92 |     |                     cache.amountLeft -= cache.input;
  93 |     |                 }
  94 |     |             }
  95 |     |         }
  96 |     |         cache.amountInDelta = cache.input;
  97 |     |         return cache;
  98 |     |     }
  99 |     | 
 100 |     |     function initialize(
 101 |     |         CoverPoolStructs.TickMap storage tickMap,
 102 |     |         CoverPoolStructs.PoolState storage pool0,
 103 |     |         CoverPoolStructs.PoolState storage pool1,
 104 |     |         CoverPoolStructs.GlobalState memory state,
 105 |     |         PoolsharkStructs.CoverImmutables memory constants 
 106 |     |     ) internal returns (CoverPoolStructs.GlobalState memory) {
 107 |     |         if (state.unlocked == 0) {
 108 |     |             (state.unlocked, state.latestTick) = constants.source.initialize(constants);
 109 |     |             if (state.unlocked == 1) {
 110 |     |                 // initialize state
 111 |     |                 state.latestTick = (state.latestTick / int24(constants.tickSpread)) * int24(constants.tickSpread);
 112 |     |                 state.latestPrice = ConstantProduct.getPriceAtTick(state.latestTick, constants);
 113 |     |                 state.auctionStart = uint32(block.timestamp - constants.genesisTime);
 114 |     |                 state.accumEpoch = 1;
 115 |     |                 state.positionIdNext = 1;
 116 |     | 
 117 |     |                 // initialize ticks
 118 |     |                 TickMap.set(ConstantProduct.minTick(constants.tickSpread), tickMap, constants);
 119 |     |                 TickMap.set(ConstantProduct.maxTick(constants.tickSpread), tickMap, constants);
 120 |     |                 TickMap.set(state.latestTick, tickMap, constants);
 121 |     | 
 122 |     |                 // initialize price
 123 |     |                 pool0.price = ConstantProduct.getPriceAtTick(state.latestTick - constants.tickSpread, constants);
 124 |     |                 pool1.price = ConstantProduct.getPriceAtTick(state.latestTick + constants.tickSpread, constants);
 125 |     |             
 126 |     |                 emit Initialize(
 127 |     |                     ConstantProduct.minTick(constants.tickSpread),
 128 |     |                     ConstantProduct.maxTick(constants.tickSpread),
 129 |     |                     state.latestTick,
 130 |     |                     constants.genesisTime,
 131 |     |                     state.auctionStart,
 132 |     |                     pool0.price,
 133 |     |                     pool1.price
 134 |     |                 );
 135 |     |             }
 136 |     |         }
 137 |     |         return state;
 138 |     |     }
 139 |     | 
 140 |     |     function insert(
 141 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 142 |     |         CoverPoolStructs.TickMap storage tickMap,
 143 |     |         CoverPoolStructs.GlobalState memory state,
 144 |     |         PoolsharkStructs.CoverImmutables memory constants,
 145 |     |         int24 lower,
 146 |     |         int24 upper,
 147 |     |         uint128 amount,
 148 |     |         bool isPool0
 149 |     |     ) internal {
 150 |     |         /// @dev - validation of ticks is in Positions.validate
 151 |     |         if (amount > uint128(type(int128).max)) require (false, 'LiquidityOverflow()');
 152 |     |         if ((uint128(type(int128).max) - state.liquidityGlobal) < amount)
 153 |     |             require (false, 'LiquidityOverflow()');
 154 |     | 
 155 |     |         // load ticks into memory to reduce reads/writes
 156 |     |         CoverPoolStructs.Tick memory tickLower = ticks[lower];
 157 |     |         CoverPoolStructs.Tick memory tickUpper = ticks[upper];
 158 |     | 
 159 |     |         // sets bit in map
 160 |     |         TickMap.set(lower, tickMap, constants);
 161 |     | 
 162 |     |         // updates liquidity values
 163 |     |         if (isPool0) {
 164 |     |             tickLower.liquidityDelta -= int128(amount);
 165 |     |         } else {
 166 |     |             tickLower.liquidityDelta += int128(amount);
 167 |     |         }
 168 |     | 
 169 |     |         TickMap.set(upper, tickMap, constants);
 170 |     | 
 171 |     |         if (isPool0) {
 172 |     |             tickUpper.liquidityDelta += int128(amount);
 173 |     |         } else {
 174 |     |             tickUpper.liquidityDelta -= int128(amount);
 175 |     |         }
 176 |     |         ticks[lower] = tickLower;
 177 |     |         ticks[upper] = tickUpper;
 178 |     |     }
 179 |     | 
 180 |     |     function remove(
 181 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 182 |     |         CoverPoolStructs.TickMap storage tickMap,
 183 |     |         PoolsharkStructs.CoverImmutables memory constants,
 184 |     |         int24 lower,
 185 |     |         int24 upper,
 186 |     |         uint128 amount,
 187 |     |         bool isPool0,
 188 |     |         bool removeLower,
 189 |     |         bool removeUpper
 190 |     |     ) internal {
 191 |     |         {
 192 |     |             CoverPoolStructs.Tick memory tickLower = ticks[lower];
 193 |     |             if (removeLower) {
 194 |     |                 if (isPool0) {
 195 |     |                     tickLower.liquidityDelta += int128(amount);
 196 |     |                 } else {
 197 |     |                     tickLower.liquidityDelta -= int128(amount);
 198 |     |                 }
 199 |     |                 ticks[lower] = tickLower;
 200 |     |             }
 201 |     |             if (lower != ConstantProduct.minTick(constants.tickSpread)) {
 202 |     |                 cleanup(ticks, tickMap, constants, tickLower, lower);
 203 |     |             }
 204 |     |         }
 205 |     |         {
 206 |     |             CoverPoolStructs.Tick memory tickUpper = ticks[upper];
 207 |     |             if (removeUpper) {
 208 |     |                 if (isPool0) {
 209 |     |                     tickUpper.liquidityDelta -= int128(amount);
 210 |     |                 } else {
 211 |     |                     tickUpper.liquidityDelta += int128(amount);
 212 |     |                 }
 213 |     |                 ticks[upper] = tickUpper;
 214 |     |             }
 215 |     |             if (upper != ConstantProduct.maxTick(constants.tickSpread)) {
 216 |     |                 cleanup(ticks, tickMap, constants, tickUpper, upper);
 217 |     |             }
 218 |     |         }
 219 |     |     }
 220 |     | 
 221 |     |     function cleanup(
 222 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 223 |     |         CoverPoolStructs.TickMap storage tickMap,
 224 |     |         PoolsharkStructs.CoverImmutables memory constants,
 225 |     |         CoverPoolStructs.Tick memory tick,
 226 |     |         int24 tickIndex
 227 |     |     ) internal {
 228 |     |         if (!_empty(tick)){
 229 |     |             // if one of the values is 0 clear out both
 230 |     |             if (tick.amountInDeltaMaxMinus == 0 || tick.amountOutDeltaMaxMinus == 0) {
 231 |     |                 tick.amountInDeltaMaxMinus = 0;
 232 |     |                 tick.amountOutDeltaMaxMinus = 0;
 233 |     |             }
 234 |     |             if (tick.amountInDeltaMaxStashed == 0 || tick.amountOutDeltaMaxStashed == 0) {
 235 |     |                 tick.amountInDeltaMaxStashed = 0;
 236 |     |                 tick.amountOutDeltaMaxStashed = 0;
 237 |     |             }
 238 |     |             if (_inactive(tick)) {
 239 |     |                 // zero out all values for safety
 240 |     |                 tick.amountInDeltaMaxMinus = 0;
 241 |     |                 tick.amountOutDeltaMaxMinus = 0;
 242 |     |                 tick.amountInDeltaMaxStashed = 0;
 243 |     |                 tick.amountOutDeltaMaxStashed = 0;
 244 |     |                 TickMap.unset(tickIndex, tickMap, constants);
 245 |     |             }
 246 |     |         }
 247 |     |         if (_empty(tick)) {
 248 |     |             TickMap.unset(tickIndex, tickMap, constants);
 249 |     |             delete ticks[tickIndex];
 250 |     |         } else {
 251 |     |             ticks[tickIndex] = tick;
 252 |     |         }
 253 |     |     }
 254 |     | 
 255 |     |     function _inactive(
 256 |     |         CoverPoolStructs.Tick memory tick
 257 |     |     ) internal pure returns (
 258 |     |         bool
 259 |     |     ) {
 260 |     |         if (tick.amountInDeltaMaxStashed > 0 && tick.amountOutDeltaMaxStashed > 0) {
 261 |     |             return false;
 262 |     |         } else if (tick.amountInDeltaMaxMinus > 0 && tick.amountOutDeltaMaxMinus > 0){
 263 |     |             return false;
 264 |     |         } else if (tick.liquidityDelta != 0) {
 265 |     |             return false;
 266 |     |         }
 267 |     |         return true;
 268 |     |     }
 269 |     | 
 270 |     |     function _empty(
 271 |     |         CoverPoolStructs.Tick memory tick
 272 |     |     ) internal pure returns (
 273 |     |         bool
 274 |     |     ) {
 275 |     |         if (tick.amountInDeltaMaxStashed > 0 && tick.amountOutDeltaMaxStashed > 0) {
 276 |     |             return false;
 277 |     |         } else if (tick.amountInDeltaMaxMinus > 0 && tick.amountOutDeltaMaxMinus > 0){
 278 |     |             return false;
 279 |     |         } else if (tick.liquidityDelta != 0) {
 280 |     |             return false;
 281 |     |         } else if (tick.deltas0.amountInDeltaMax > 0 && tick.deltas0.amountOutDeltaMax > 0) {
 282 |     |             return false;
 283 |     |         } else if (tick.deltas1.amountInDeltaMax > 0 && tick.deltas1.amountOutDeltaMax > 0) {
 284 |     |             return false;
 285 |     |         }
 286 |     |         return true;
 287 |     |     }
 288 |     | }
 289 |     | 

/home/ec2-user/git/cover/contracts/libraries/math/ConstantProduct.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './OverflowMath.sol';
   5 |     | import '../../interfaces/structs/CoverPoolStructs.sol';
   6 |     | 
   7 |     | /// @notice Math library that facilitates ranged liquidity calculations.
   8 |     | library ConstantProduct {
   9 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
  10 |     | 
  11 |     |     struct PriceBounds {
  12 |     |         uint160 min;
  13 |     |         uint160 max;
  14 |     |     }
  15 |     | 
  16 |     |     /////////////////////////////////////////////////////////////
  17 |     |     ///////////////////////// DYDX MATH /////////////////////////
  18 |     |     /////////////////////////////////////////////////////////////
  19 |     | 
  20 |     |     function getDy(
  21 |     |         uint256 liquidity,
  22 |     |         uint256 priceLower,
  23 |     |         uint256 priceUpper,
  24 |     |         bool roundUp
  25 |     |     ) internal pure returns (uint256 dy) {
  26 |     |         unchecked {
  27 |     |             if (liquidity == 0) return 0;
  28 |     |             if (roundUp) {
  29 |     |                 dy = OverflowMath.mulDivRoundingUp(liquidity, priceUpper - priceLower, Q96);
  30 |     |             } else {
  31 |     |                 dy = OverflowMath.mulDiv(liquidity, priceUpper - priceLower, Q96);
  32 |     |             }
  33 |     |         }
  34 |     |     }
  35 |     | 
  36 |     |     function getDx(
  37 |     |         uint256 liquidity,
  38 |     |         uint256 priceLower,
  39 |     |         uint256 priceUpper,
  40 |     |         bool roundUp
  41 |     |     ) internal pure returns (uint256 dx) {
  42 |     |         unchecked {
  43 |     |             if (liquidity == 0) return 0;
  44 |     |             if (roundUp) {
  45 |     |                 dx = OverflowMath.divRoundingUp(
  46 |     |                         OverflowMath.mulDivRoundingUp(
  47 |     |                             liquidity << 96, 
  48 |     |                             priceUpper - priceLower,
  49 |     |                             priceUpper
  50 |     |                         ),
  51 |     |                         priceLower
  52 |     |                 );
  53 |     |             } else {
  54 |     |                 dx = OverflowMath.mulDiv(
  55 |     |                         liquidity << 96,
  56 |     |                         priceUpper - priceLower,
  57 |     |                         priceUpper
  58 |     |                 ) / priceLower;
  59 |     |             }
  60 |     |         }
  61 |     |     }
  62 |     | 
  63 |     |     function getLiquidityForAmounts(
  64 |     |         uint256 priceLower,
  65 |     |         uint256 priceUpper,
  66 |     |         uint256 currentPrice,
  67 |     |         uint256 dy,
  68 |     |         uint256 dx
  69 |     |     ) internal pure returns (uint256 liquidity) {
  70 |     |         unchecked {
  71 |     |             if (priceUpper <= currentPrice) {
  72 |     |                 liquidity = OverflowMath.mulDiv(dy, Q96, priceUpper - priceLower);
  73 |     |             } else if (currentPrice <= priceLower) {
  74 |     |                 liquidity = OverflowMath.mulDiv(
  75 |     |                     dx,
  76 |     |                     OverflowMath.mulDiv(priceLower, priceUpper, Q96),
  77 |     |                     priceUpper - priceLower
  78 |     |                 );
  79 |     |             } else {
  80 |     |                 uint256 liquidity0 = OverflowMath.mulDiv(
  81 |     |                     dx,
  82 |     |                     OverflowMath.mulDiv(priceUpper, currentPrice, Q96),
  83 |     |                     priceUpper - currentPrice
  84 |     |                 );
  85 |     |                 uint256 liquidity1 = OverflowMath.mulDiv(dy, Q96, currentPrice - priceLower);
  86 |     |                 liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
  87 |     |             }
  88 |     |         }
  89 |     |     }
  90 |     | 
  91 |     |     function getAmountsForLiquidity(
  92 |     |         uint256 priceLower,
  93 |     |         uint256 priceUpper,
  94 |     |         uint256 currentPrice,
  95 |     |         uint256 liquidityAmount,
  96 |     |         bool roundUp
  97 |     |     ) internal pure returns (uint128 token0amount, uint128 token1amount) {
  98 |     |         if (priceUpper <= currentPrice) {
  99 |     |             token1amount = uint128(getDy(liquidityAmount, priceLower, priceUpper, roundUp));
 100 |     |         } else if (currentPrice <= priceLower) {
 101 |     |             token0amount = uint128(getDx(liquidityAmount, priceLower, priceUpper, roundUp));
 102 |     |         } else {
 103 |     |             token0amount = uint128(getDx(liquidityAmount, currentPrice, priceUpper, roundUp));
 104 |     |             token1amount = uint128(getDy(liquidityAmount, priceLower, currentPrice, roundUp));
 105 |     |         }
 106 |     |         if (token0amount > uint128(type(int128).max)) require(false, 'AmountsOutOfBounds()');
 107 |     |         if (token1amount > uint128(type(int128).max)) require(false, 'AmountsOutOfBounds()');
 108 |     |     }
 109 |     | 
 110 |     |     function getNewPrice(
 111 |     |         uint256 price,
 112 |     |         uint256 liquidity,
 113 |     |         uint256 amount,
 114 |     |         bool zeroForOne,
 115 |     |         bool exactIn
 116 |     |     ) internal pure returns (
 117 |     |         uint256 newPrice
 118 |     |     ) {
 119 |     |         if (exactIn) {
 120 |     |             if (zeroForOne) {
 121 |     |                 uint256 liquidityPadded = liquidity << 96;
 122 |     |                 newPrice = OverflowMath.mulDivRoundingUp(
 123 |     |                         liquidityPadded,
 124 |     |                         price,
 125 |     |                         liquidityPadded + price * amount
 126 |     |                     );
 127 |     |             } else {
 128 |     |                 newPrice = price + (amount << 96) / liquidity;
 129 |     |             }
 130 |     |         } else {
 131 |     |             if (zeroForOne) {
 132 |     |                 newPrice = price - 
 133 |     |                         OverflowMath.divRoundingUp(amount << 96, liquidity);
 134 |     |             } else {
 135 |     |                 uint256 liquidityPadded = uint256(liquidity) << 96;
 136 |     |                 newPrice = OverflowMath.mulDivRoundingUp(
 137 |     |                         liquidityPadded, 
 138 |     |                         price,
 139 |     |                         liquidityPadded - uint256(price) * amount
 140 |     |                 );
 141 |     |             }
 142 |     |         }
 143 |     |     }
 144 |     | 
 145 |     |     function getPrice(
 146 |     |         uint256 sqrtPrice
 147 |     |     ) internal pure returns (uint256 price) {
 148 |     |         if (sqrtPrice >= 2 ** 48)
 149 |     |             price = OverflowMath.mulDiv(sqrtPrice, sqrtPrice, 2 ** 96);
 150 |     |         else
 151 |     |             price = sqrtPrice;
 152 |     |     }
 153 |     | 
 154 |     |     /////////////////////////////////////////////////////////////
 155 |     |     ///////////////////////// TICK MATH /////////////////////////
 156 |     |     /////////////////////////////////////////////////////////////
 157 |     | 
 158 | *   |     int24 internal constant MIN_TICK = -887272;   /// @dev - tick for price of 2^-128
 159 | *   |     int24 internal constant MAX_TICK = -MIN_TICK; /// @dev - tick for price of 2^128
 160 |     | 
 161 | *   |     function minTick(
 162 |     |         int16 tickSpacing
 163 |     |     ) internal pure returns (
 164 | *   |         int24 tick
 165 |     |     ) {
 166 | *   |         return MIN_TICK / tickSpacing * tickSpacing;
 167 |     |     }
 168 |     | 
 169 | *   |     function maxTick(
 170 |     |         int16 tickSpacing
 171 |     |     ) internal pure returns (
 172 | *   |         int24 tick
 173 |     |     ) {
 174 | *   |         return MAX_TICK / tickSpacing * tickSpacing;
 175 |     |     }
 176 |     | 
 177 |     |     function priceBounds(
 178 |     |         int16 tickSpacing
 179 |     |     ) internal pure returns (
 180 |     |         uint160,
 181 |     |         uint160
 182 |     |     ) {
 183 |     |         return (minPrice(tickSpacing), maxPrice(tickSpacing));
 184 |     |     }
 185 |     | 
 186 |     |     function minPrice(
 187 |     |         int16 tickSpacing
 188 |     |     ) internal pure returns (
 189 |     |         uint160 price
 190 |     |     ) {
 191 |     |         PoolsharkStructs.CoverImmutables  memory constants;
 192 |     |         constants.tickSpread = tickSpacing;
 193 |     |         return getPriceAtTick(minTick(tickSpacing), constants);
 194 |     |     }
 195 |     | 
 196 |     |     function maxPrice(
 197 |     |         int16 tickSpacing
 198 |     |     ) internal pure returns (
 199 |     |         uint160 price
 200 |     |     ) {
 201 |     |         PoolsharkStructs.CoverImmutables  memory constants;
 202 |     |         constants.tickSpread = tickSpacing;
 203 |     |         return getPriceAtTick(maxTick(tickSpacing), constants);
 204 |     |     }
 205 |     | 
 206 |     |     function checkTicks(
 207 |     |         int24 lower,
 208 |     |         int24 upper,
 209 |     |         int16 tickSpacing
 210 |     |     ) internal pure
 211 |     |     {
 212 |     |         if (lower < minTick(tickSpacing)) require (false, 'LowerTickOutOfBounds()');
 213 |     |         if (upper > maxTick(tickSpacing)) require (false, 'UpperTickOutOfBounds()');
 214 |     |         if (lower % tickSpacing != 0) require (false, 'LowerTickOutsideTickSpacing()');
 215 |     |         if (upper % tickSpacing != 0) require (false, 'UpperTickOutsideTickSpacing()');
 216 |     |         if (lower >= upper) require (false, 'LowerUpperTickOrderInvalid()');
 217 |     |     }
 218 |     | 
 219 |     |     function checkPrice(
 220 |     |         uint160 price,
 221 |     |         PriceBounds memory bounds
 222 |     |     ) internal pure {
 223 |     |         if (price < bounds.min || price >= bounds.max) require (false, 'PriceOutOfBounds()');
 224 |     |     }
 225 |     | 
 226 |     |     /// @notice Calculates sqrt(1.0001^tick) * 2^96.
 227 |     |     /// @dev Throws if |tick| > max tick.
 228 |     |     /// @param tick The input tick for the above formula.
 229 |     |     /// @return price Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
 230 |     |     /// at the given tick.
 231 |     |     function getPriceAtTick(
 232 |     |         int24 tick,
 233 |     |         PoolsharkStructs.CoverImmutables memory constants
 234 |     |     ) internal pure returns (
 235 |     |         uint160 price
 236 |     |     ) {
 237 |     |         uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
 238 |     |         if (absTick > uint256(uint24(maxTick(constants.tickSpread)))) require (false, 'TickOutOfBounds()');
 239 |     |         unchecked {
 240 |     |             uint256 ratio = absTick & 0x1 != 0
 241 |     |                 ? 0xfffcb933bd6fad37aa2d162d1a594001
 242 |     |                 : 0x100000000000000000000000000000000;
 243 |     |             if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
 244 |     |             if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
 245 |     |             if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
 246 |     |             if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
 247 |     |             if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
 248 |     |             if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
 249 |     |             if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
 250 |     |             if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
 251 |     |             if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
 252 |     |             if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
 253 |     |             if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
 254 |     |             if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
 255 |     |             if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
 256 |     |             if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
 257 |     |             if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
 258 |     |             if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
 259 |     |             if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
 260 |     |             if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
 261 |     |             if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
 262 |     | 
 263 |     |             if (tick > 0) ratio = type(uint256).max / ratio;
 264 |     |             // This divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
 265 |     |             // We then downcast because we know the result always fits within 160 bits due to our tick input constraint.
 266 |     |             // We round up in the division so getTickAtPrice of the output price is always consistent.
 267 |     |             price = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
 268 |     |         }
 269 |     |     }
 270 |     | 
 271 |     |     /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio.
 272 |     |     /// @param price The sqrt ratio for which to compute the tick as a Q64.96.
 273 |     |     /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio.
 274 |     |     function getTickAtPrice(
 275 |     |         uint160 price,
 276 |     |         PoolsharkStructs.CoverImmutables  memory constants
 277 |     |     ) internal pure returns (int24 tick) {
 278 |     |         // Second inequality must be < because the price can never reach the price at the max tick.
 279 |     |         if (price < constants.bounds.min || price > constants.bounds.max)
 280 |     |             require (false, 'PriceOutOfBounds()');
 281 |     |         uint256 ratio = uint256(price) << 32;
 282 |     | 
 283 |     |         uint256 r = ratio;
 284 |     |         uint256 msb = 0;
 285 |     | 
 286 |     |         assembly {
 287 |     |             let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
 288 |     |             msb := or(msb, f)
 289 |     |             r := shr(f, r)
 290 |     |         }
 291 |     |         assembly {
 292 |     |             let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
 293 |     |             msb := or(msb, f)
 294 |     |             r := shr(f, r)
 295 |     |         }
 296 |     |         assembly {
 297 |     |             let f := shl(5, gt(r, 0xFFFFFFFF))
 298 |     |             msb := or(msb, f)
 299 |     |             r := shr(f, r)
 300 |     |         }
 301 |     |         assembly {
 302 |     |             let f := shl(4, gt(r, 0xFFFF))
 303 |     |             msb := or(msb, f)
 304 |     |             r := shr(f, r)
 305 |     |         }
 306 |     |         assembly {
 307 |     |             let f := shl(3, gt(r, 0xFF))
 308 |     |             msb := or(msb, f)
 309 |     |             r := shr(f, r)
 310 |     |         }
 311 |     |         assembly {
 312 |     |             let f := shl(2, gt(r, 0xF))
 313 |     |             msb := or(msb, f)
 314 |     |             r := shr(f, r)
 315 |     |         }
 316 |     |         assembly {
 317 |     |             let f := shl(1, gt(r, 0x3))
 318 |     |             msb := or(msb, f)
 319 |     |             r := shr(f, r)
 320 |     |         }
 321 |     |         assembly {
 322 |     |             let f := gt(r, 0x1)
 323 |     |             msb := or(msb, f)
 324 |     |         }
 325 |     | 
 326 |     |         if (msb >= 128) r = ratio >> (msb - 127);
 327 |     |         else r = ratio << (127 - msb);
 328 |     | 
 329 |     |         int256 log_2 = (int256(msb) - 128) << 64;
 330 |     | 
 331 |     |         assembly {
 332 |     |             r := shr(127, mul(r, r))
 333 |     |             let f := shr(128, r)
 334 |     |             log_2 := or(log_2, shl(63, f))
 335 |     |             r := shr(f, r)
 336 |     |         }
 337 |     |         assembly {
 338 |     |             r := shr(127, mul(r, r))
 339 |     |             let f := shr(128, r)
 340 |     |             log_2 := or(log_2, shl(62, f))
 341 |     |             r := shr(f, r)
 342 |     |         }
 343 |     |         assembly {
 344 |     |             r := shr(127, mul(r, r))
 345 |     |             let f := shr(128, r)
 346 |     |             log_2 := or(log_2, shl(61, f))
 347 |     |             r := shr(f, r)
 348 |     |         }
 349 |     |         assembly {
 350 |     |             r := shr(127, mul(r, r))
 351 |     |             let f := shr(128, r)
 352 |     |             log_2 := or(log_2, shl(60, f))
 353 |     |             r := shr(f, r)
 354 |     |         }
 355 |     |         assembly {
 356 |     |             r := shr(127, mul(r, r))
 357 |     |             let f := shr(128, r)
 358 |     |             log_2 := or(log_2, shl(59, f))
 359 |     |             r := shr(f, r)
 360 |     |         }
 361 |     |         assembly {
 362 |     |             r := shr(127, mul(r, r))
 363 |     |             let f := shr(128, r)
 364 |     |             log_2 := or(log_2, shl(58, f))
 365 |     |             r := shr(f, r)
 366 |     |         }
 367 |     |         assembly {
 368 |     |             r := shr(127, mul(r, r))
 369 |     |             let f := shr(128, r)
 370 |     |             log_2 := or(log_2, shl(57, f))
 371 |     |             r := shr(f, r)
 372 |     |         }
 373 |     |         assembly {
 374 |     |             r := shr(127, mul(r, r))
 375 |     |             let f := shr(128, r)
 376 |     |             log_2 := or(log_2, shl(56, f))
 377 |     |             r := shr(f, r)
 378 |     |         }
 379 |     |         assembly {
 380 |     |             r := shr(127, mul(r, r))
 381 |     |             let f := shr(128, r)
 382 |     |             log_2 := or(log_2, shl(55, f))
 383 |     |             r := shr(f, r)
 384 |     |         }
 385 |     |         assembly {
 386 |     |             r := shr(127, mul(r, r))
 387 |     |             let f := shr(128, r)
 388 |     |             log_2 := or(log_2, shl(54, f))
 389 |     |             r := shr(f, r)
 390 |     |         }
 391 |     |         assembly {
 392 |     |             r := shr(127, mul(r, r))
 393 |     |             let f := shr(128, r)
 394 |     |             log_2 := or(log_2, shl(53, f))
 395 |     |             r := shr(f, r)
 396 |     |         }
 397 |     |         assembly {
 398 |     |             r := shr(127, mul(r, r))
 399 |     |             let f := shr(128, r)
 400 |     |             log_2 := or(log_2, shl(52, f))
 401 |     |             r := shr(f, r)
 402 |     |         }
 403 |     |         assembly {
 404 |     |             r := shr(127, mul(r, r))
 405 |     |             let f := shr(128, r)
 406 |     |             log_2 := or(log_2, shl(51, f))
 407 |     |             r := shr(f, r)
 408 |     |         }
 409 |     |         assembly {
 410 |     |             r := shr(127, mul(r, r))
 411 |     |             let f := shr(128, r)
 412 |     |             log_2 := or(log_2, shl(50, f))
 413 |     |         }
 414 |     | 
 415 |     |         int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number
 416 |     | 
 417 |     |         int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
 418 |     |         int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
 419 |     | 
 420 |     |         tick = tickLow == tickHi ? tickLow : getPriceAtTick(tickHi, constants) <= price
 421 |     |             ? tickHi
 422 |     |             : tickLow;
 423 |     |     }
 424 |     | }

/home/ec2-user/git/cover/contracts/libraries/math/OverflowMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.13;
   3 |     | 
   4 |     | /// @notice Math library that facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision.
   5 |     | library OverflowMath {
   6 |     | 
   7 |     |     // @dev no underflow or overflow checks
   8 |     |     function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
   9 |     |         assembly {
  10 |     |             z := add(div(x, y), gt(mod(x, y), 0))
  11 |     |         }
  12 |     |     }
  13 |     | 
  14 |     |     /// @notice Calculates floor(abdenominator) with full precision - throws if result overflows an uint256 or denominator == 0.
  15 |     |     /// @param a The multiplicand.
  16 |     |     /// @param b The multiplier.
  17 |     |     /// @param denominator The divisor.
  18 |     |     /// @return result The 256-bit result.
  19 |     |     /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.
  20 |     |     function mulDiv(
  21 |     |         uint256 a,
  22 |     |         uint256 b,
  23 |     |         uint256 denominator
  24 |     |     ) internal pure returns (uint256 result) {
  25 |     |         unchecked {
  26 |     |             // 512-bit multiply [prod1 prod0] = a * b.
  27 |     |             // Compute the product mod 2**256 and mod 2**256 - 1,
  28 |     |             // then use the Chinese Remainder Theorem to reconstruct
  29 |     |             // the 512 bit result. The result is stored in two 256
  30 |     |             // variables such that product = prod1 * 2**256 + prod0.
  31 |     |             uint256 prod0; // Least significant 256 bits of the product.
  32 |     |             uint256 prod1; // Most significant 256 bits of the product.
  33 |     |             assembly {
  34 |     |                 let mm := mulmod(a, b, not(0))
  35 |     |                 prod0 := mul(a, b)
  36 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  37 |     |             }
  38 |     |             // Handle non-overflow cases, 256 by 256 division.
  39 |     |             if (prod1 == 0) {
  40 |     |                 require(denominator > 0);
  41 |     |                 assembly {
  42 |     |                     result := div(prod0, denominator)
  43 |     |                 }
  44 |     |                 return result;
  45 |     |             }
  46 |     |             // Make sure the result is less than 2**256 -
  47 |     |             // also prevents denominator == 0.
  48 |     |             require(denominator > prod1);
  49 |     |             ///////////////////////////////////////////////
  50 |     |             // 512 by 256 division.
  51 |     |             ///////////////////////////////////////////////
  52 |     |             // Make division exact by subtracting the remainder from [prod1 prod0] -
  53 |     |             // compute remainder using mulmod.
  54 |     |             uint256 remainder;
  55 |     |             assembly {
  56 |     |                 remainder := mulmod(a, b, denominator)
  57 |     |             }
  58 |     |             // Subtract 256 bit number from 512 bit number.
  59 |     |             assembly {
  60 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
  61 |     |                 prod0 := sub(prod0, remainder)
  62 |     |             }
  63 |     |             // Factor powers of two out of denominator -
  64 |     |             // compute largest power of two divisor of denominator
  65 |     |             // (always >= 1).
  66 |     |             uint256 twos = uint256(-int256(denominator)) & denominator;
  67 |     |             // Divide denominator by power of two.
  68 |     |             assembly {
  69 |     |                 denominator := div(denominator, twos)
  70 |     |             }
  71 |     |             // Divide [prod1 prod0] by the factors of two.
  72 |     |             assembly {
  73 |     |                 prod0 := div(prod0, twos)
  74 |     |             }
  75 |     |             // Shift in bits from prod1 into prod0. For this we need
  76 |     |             // to flip `twos` such that it is 2**256 / twos -
  77 |     |             // if twos is zero, then it becomes one.
  78 |     |             assembly {
  79 |     |                 twos := add(div(sub(0, twos), twos), 1)
  80 |     |             }
  81 |     |             prod0 |= prod1 * twos;
  82 |     |             // Invert denominator mod 2**256 -
  83 |     |             // now that denominator is an odd number, it has an inverse
  84 |     |             // modulo 2**256 such that denominator * inv = 1 mod 2**256.
  85 |     |             // Compute the inverse by starting with a seed that is correct
  86 |     |             // for four bits. That is, denominator * inv = 1 mod 2**4.
  87 |     |             uint256 inv = (3 * denominator) ^ 2;
  88 |     |             // Now use Newton-Raphson iteration to improve the precision.
  89 |     |             // Thanks to Hensel's lifting lemma, this also works in modular
  90 |     |             // arithmetic, doubling the correct bits in each step.
  91 |     |             inv *= 2 - denominator * inv; // Inverse mod 2**8.
  92 |     |             inv *= 2 - denominator * inv; // Inverse mod 2**16.
  93 |     |             inv *= 2 - denominator * inv; // Inverse mod 2**32.
  94 |     |             inv *= 2 - denominator * inv; // Inverse mod 2**64.
  95 |     |             inv *= 2 - denominator * inv; // Inverse mod 2**128.
  96 |     |             inv *= 2 - denominator * inv; // Inverse mod 2**256.
  97 |     |             // Because the division is now exact we can divide by multiplying
  98 |     |             // with the modular inverse of denominator. This will give us the
  99 |     |             // correct result modulo 2**256. Since the precoditions guarantee
 100 |     |             // that the outcome is less than 2**256, this is the final result.
 101 |     |             // We don't need to compute the high bits of the result and prod1
 102 |     |             // is no longer required.
 103 |     |             result = prod0 * inv;
 104 |     |             return result;
 105 |     |         }
 106 |     |     }
 107 |     | 
 108 |     |     /// @notice Calculates ceil(abdenominator) with full precision - throws if result overflows an uint256 or denominator == 0.
 109 |     |     /// @param a The multiplicand.
 110 |     |     /// @param b The multiplier.
 111 |     |     /// @param denominator The divisor.
 112 |     |     /// @return result The 256-bit result.
 113 |     |     function mulDivRoundingUp(
 114 |     |         uint256 a,
 115 |     |         uint256 b,
 116 |     |         uint256 denominator
 117 |     |     ) internal pure returns (uint256 result) {
 118 |     |         result = mulDiv(a, b, denominator);
 119 |     |         unchecked {
 120 |     |             if (mulmod(a, b, denominator) != 0) {
 121 |     |                 if (result >= type(uint256).max) require (false, 'MaxUintExceeded()');
 122 |     |                 result++;
 123 |     |             }
 124 |     |         }
 125 |     |     }
 126 |     | }
 127 |     | 

/home/ec2-user/git/cover/contracts/libraries/pool/BurnCall.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/structs/CoverPoolStructs.sol';
   5 |     | import '../Positions.sol';
   6 |     | import '../utils/Collect.sol';
   7 |     | 
   8 | *   | library BurnCall {
   9 |     |     event Burn(
  10 |     |         address indexed to,
  11 |     |         int24 lower,
  12 |     |         int24 upper,
  13 |     |         int24 claim,
  14 |     |         bool zeroForOne,
  15 |     |         uint128 liquidityBurned,
  16 |     |         uint128 tokenInClaimed,
  17 |     |         uint128 tokenOutClaimed,
  18 |     |         uint128 tokenOutBurned,
  19 |     |         uint128 amountInDeltaMaxStashedBurned,
  20 |     |         uint128 amountOutDeltaMaxStashedBurned,
  21 |     |         uint128 amountInDeltaMaxBurned,
  22 |     |         uint128 amountOutDeltaMaxBurned,
  23 |     |         uint160 claimPriceLast
  24 |     |     );
  25 |     | 
  26 |     |     error SimulateBurn(int24 lower, int24 upper, bool positionExists);
  27 |     | 
  28 |     |     function perform(
  29 |     |         ICoverPool.BurnParams memory params,
  30 |     |         CoverPoolStructs.BurnCache memory cache,
  31 |     |         CoverPoolStructs.TickMap storage tickMap,
  32 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
  33 |     |         mapping(uint256 => CoverPoolStructs.CoverPosition)
  34 |     |             storage positions
  35 |     |     ) internal returns (CoverPoolStructs.BurnCache memory) {
  36 |     |         cache.position = positions[params.positionId];
  37 |     |         if (cache.position.owner != msg.sender) {
  38 |     |             require(false, 'PositionNotFound()');
  39 |     |         }
  40 |     |         if (cache.position.claimPriceLast > 0
  41 |     |             || params.claim != (params.zeroForOne ? cache.position.upper : cache.position.lower) 
  42 |     |             || params.claim == cache.state.latestTick)
  43 |     |         {
  44 |     |             // if position has been crossed into
  45 |     |             if (params.zeroForOne) {
  46 |     |                 (
  47 |     |                     cache.state,
  48 |     |                     cache.pool0,
  49 |     |                     params.claim
  50 |     |                 ) = Positions.update(
  51 |     |                     positions,
  52 |     |                     ticks,
  53 |     |                     tickMap,
  54 |     |                     cache.state,
  55 |     |                     cache.pool0,
  56 |     |                     CoverPoolStructs.UpdateParams(
  57 |     |                         msg.sender,
  58 |     |                         params.to,
  59 |     |                         params.burnPercent,
  60 |     |                         params.positionId,
  61 |     |                         cache.position.lower,
  62 |     |                         cache.position.upper,
  63 |     |                         params.claim,
  64 |     |                         params.zeroForOne
  65 |     |                     ),
  66 |     |                     cache.constants
  67 |     |                 );
  68 |     |             } else {
  69 |     |                 (
  70 |     |                     cache.state,
  71 |     |                     cache.pool1,
  72 |     |                     params.claim
  73 |     |                 ) = Positions.update(
  74 |     |                     positions,
  75 |     |                     ticks,
  76 |     |                     tickMap,
  77 |     |                     cache.state,
  78 |     |                     cache.pool1,
  79 |     |                     CoverPoolStructs.UpdateParams(
  80 |     |                         msg.sender,
  81 |     |                         params.to,
  82 |     |                         params.burnPercent,
  83 |     |                         params.positionId,
  84 |     |                         cache.position.lower,
  85 |     |                         cache.position.upper,
  86 |     |                         params.claim,
  87 |     |                         params.zeroForOne
  88 |     |                     ),
  89 |     |                     cache.constants
  90 |     |                 );
  91 |     |             }
  92 |     |         } else {
  93 |     |             // if position hasn't been crossed into
  94 |     |             (, cache.state) = Positions.remove(
  95 |     |                 positions,
  96 |     |                 ticks,
  97 |     |                 tickMap,
  98 |     |                 cache.state,
  99 |     |                 CoverPoolStructs.RemoveParams(
 100 |     |                     msg.sender,
 101 |     |                     params.to,
 102 |     |                     params.burnPercent,
 103 |     |                     params.positionId,
 104 |     |                     cache.position.lower,
 105 |     |                     cache.position.upper,
 106 |     |                     params.zeroForOne
 107 |     |                 ),
 108 |     |                 cache.constants
 109 |     |             );
 110 |     |         }
 111 |     |         Collect.burn(
 112 |     |             cache,
 113 |     |             positions,
 114 |     |             CoverPoolStructs.CollectParams(
 115 |     |                 cache.syncFees,
 116 |     |                 params.to, //address(0) goes to msg.sender
 117 |     |                 params.positionId,
 118 |     |                 cache.position.lower,
 119 |     |                 params.claim,
 120 |     |                 cache.position.upper,
 121 |     |                 params.zeroForOne
 122 |     |             )
 123 |     |         );
 124 |     |         return cache;
 125 |     |     }
 126 |     | 
 127 |     |     // Echidna funcs
 128 | *   |     function getResizedTicks(
 129 |     |         ICoverPool.BurnParams memory params,
 130 |     |         CoverPoolStructs.BurnCache memory cache,
 131 |     |         CoverPoolStructs.TickMap storage tickMap,
 132 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 133 |     |         mapping(uint256 => CoverPoolStructs.CoverPosition)
 134 |     |             storage positions
 135 |     |     ) external {
 136 |     |         // check for invalid receiver
 137 | *   |         if (params.to == address(0))
 138 |     |             require(false, 'CollectToZeroAddress()');
 139 | *   |         cache.position = positions[params.positionId];
 140 |     |         if (cache.position.owner != msg.sender) {
 141 |     |             require(false, 'PositionNotFound()');
 142 |     |         }
 143 |     |         if (cache.position.claimPriceLast > 0
 144 |     |             || params.claim != (params.zeroForOne ? cache.position.upper : cache.position.lower) 
 145 |     |             || params.claim == cache.state.latestTick)
 146 |     |         {
 147 |     |             // if position has been crossed into
 148 |     |             if (params.zeroForOne) {
 149 |     |                 (
 150 |     |                     cache.state,
 151 |     |                     cache.pool0,
 152 |     |                     params.claim
 153 |     |                 ) = Positions.update(
 154 |     |                     positions,
 155 |     |                     ticks,
 156 |     |                     tickMap,
 157 |     |                     cache.state,
 158 |     |                     cache.pool0,
 159 |     |                     CoverPoolStructs.UpdateParams(
 160 |     |                         msg.sender,
 161 |     |                         params.to,
 162 |     |                         params.burnPercent,
 163 |     |                         params.positionId,
 164 |     |                         cache.position.lower,
 165 |     |                         cache.position.upper,
 166 |     |                         params.claim,
 167 |     |                         params.zeroForOne
 168 |     |                     ),
 169 |     |                     cache.constants
 170 |     |                 );
 171 |     |             } else {
 172 |     |                 // (
 173 |     |                 //     cache.state,
 174 |     |                 //     cache.pool1,
 175 |     |                 //     params.claim
 176 |     |                 // ) = Positions.update(
 177 |     |                 //     positions,
 178 |     |                 //     ticks,
 179 |     |                 //     tickMap,
 180 |     |                 //     cache.state,
 181 |     |                 //     cache.pool1,
 182 |     |                 //     CoverPoolStructs.UpdateParams(
 183 |     |                 //         msg.sender,
 184 |     |                 //         params.to,
 185 |     |                 //         params.burnPercent,
 186 |     |                 //         params.positionId,
 187 |     |                 //         cache.position.lower,
 188 |     |                 //         cache.position.upper,
 189 |     |                 //         params.claim,
 190 |     |                 //         params.zeroForOne
 191 |     |                 //     ),
 192 |     |                 //     cache.constants
 193 |     |                 // );
 194 |     |             }
 195 |     |         } else {
 196 |     |             // if position hasn't been crossed into
 197 |     |             (, cache.state) = Positions.remove(
 198 |     |                 positions,
 199 |     |                 ticks,
 200 |     |                 tickMap,
 201 |     |                 cache.state,
 202 |     |                 CoverPoolStructs.RemoveParams(
 203 |     |                     msg.sender,
 204 |     |                     params.to,
 205 |     |                     params.burnPercent,
 206 |     |                     params.positionId,
 207 |     |                     cache.position.lower,
 208 |     |                     cache.position.upper,
 209 |     |                     params.zeroForOne
 210 |     |                 ),
 211 |     |                 cache.constants
 212 |     |             );
 213 |     |         }
 214 |     | 
 215 |     |         int24 lower = cache.position.lower;
 216 |     |         int24 upper = cache.position.upper;
 217 |     |         bool positionExists = cache.position.liquidity != 0;
 218 |     | 
 219 |     |         Collect.burn(
 220 |     |             cache,
 221 |     |             positions,
 222 |     |             CoverPoolStructs.CollectParams(
 223 |     |                 cache.syncFees,
 224 |     |                 params.to, //address(0) goes to msg.sender
 225 |     |                 params.positionId,
 226 |     |                 cache.position.lower,
 227 |     |                 params.claim,
 228 |     |                 cache.position.upper,
 229 |     |                 params.zeroForOne
 230 |     |             )
 231 |     |         );
 232 |     | 
 233 |     |         revert SimulateBurn(lower, upper, positionExists);
 234 |     |     }
 235 |     | }
 236 |     | 

/home/ec2-user/git/cover/contracts/libraries/pool/MintCall.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/structs/CoverPoolStructs.sol';
   5 |     | import '../Positions.sol';
   6 |     | import '../utils/Collect.sol';
   7 |     | 
   8 | *   | library MintCall {
   9 |     |     event Mint(
  10 |     |         address indexed to,
  11 |     |         int24 lower,
  12 |     |         int24 upper,
  13 |     |         bool zeroForOne,
  14 |     |         uint32 positionId,
  15 |     |         uint32 epochLast,
  16 |     |         uint128 amountIn,
  17 |     |         uint128 liquidityMinted,
  18 |     |         uint128 amountInDeltaMaxMinted,
  19 |     |         uint128 amountOutDeltaMaxMinted
  20 |     |     );
  21 |     | 
  22 |     |     error SimulateMint(int24 lower, int24 upper, bool positionCreated);
  23 |     | 
  24 |     |     function perform(
  25 |     |         ICoverPool.MintParams memory params,
  26 |     |         CoverPoolStructs.MintCache memory cache,
  27 |     |         CoverPoolStructs.TickMap storage tickMap,
  28 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
  29 |     |         mapping(uint256 => CoverPoolStructs.CoverPosition)
  30 |     |             storage positions
  31 |     |     ) internal returns (CoverPoolStructs.MintCache memory) {
  32 |     |         if (params.positionId > 0) {
  33 |     |             // load existing position
  34 |     |             cache.position = positions[params.positionId];
  35 |     |             if (cache.position.owner != msg.sender)
  36 |     |                 require(false, 'PositionNotFound()');
  37 |     |         }
  38 |     |         // resize position
  39 |     |         (params, cache.liquidityMinted) = Positions.resize(
  40 |     |             cache.position,
  41 |     |             params, 
  42 |     |             cache.state,
  43 |     |             cache.constants
  44 |     |         );
  45 |     |         if (params.positionId == 0 ||                       // new position
  46 |     |                 params.lower != cache.position.lower ||     // lower mismatch
  47 |     |                 params.upper != cache.position.upper) {     // upper mismatch
  48 |     |             CoverPoolStructs.CoverPosition memory newPosition;
  49 |     |             newPosition.owner = params.to;
  50 |     |             newPosition.lower = params.lower;
  51 |     |             newPosition.upper = params.upper;
  52 |     |             // use new position in cache
  53 |     |             cache.position = newPosition;
  54 |     |             params.positionId = cache.state.positionIdNext;
  55 |     |             cache.state.positionIdNext += 1;
  56 |     |         }
  57 |     |         // params.amount must be > 0 here
  58 |     |         SafeTransfers.transferIn(params.zeroForOne ? cache.constants.token0 
  59 |     |                                                    : cache.constants.token1,
  60 |     |                                  params.amount
  61 |     |                                 );
  62 |     | 
  63 |     |         (cache.state, cache.position) = Positions.add(
  64 |     |             cache.position,
  65 |     |             ticks,
  66 |     |             tickMap,
  67 |     |             cache.state,
  68 |     |             CoverPoolStructs.AddParams(
  69 |     |                 params.to,
  70 |     |                 uint128(cache.liquidityMinted),
  71 |     |                 params.amount,
  72 |     |                 params.positionId,
  73 |     |                 params.lower,
  74 |     |                 params.upper,
  75 |     |                 params.zeroForOne
  76 |     |             ),
  77 |     |             cache.constants
  78 |     |         );
  79 |     |         Collect.mint(
  80 |     |             cache,
  81 |     |             CoverPoolStructs.CollectParams(
  82 |     |                 cache.syncFees,
  83 |     |                 params.to,
  84 |     |                 params.positionId,
  85 |     |                 params.lower,
  86 |     |                 0, // not needed for mint collect
  87 |     |                 params.upper,
  88 |     |                 params.zeroForOne
  89 |     |             )
  90 |     |         );
  91 |     |         positions[params.positionId] = cache.position;
  92 |     |         return cache;
  93 |     |     }
  94 |     | 
  95 |     |     // Echidna funcs
  96 | *   |     function getResizedTicks(
  97 |     |         ICoverPool.MintParams memory params,
  98 |     |         CoverPoolStructs.MintCache memory cache,
  99 |     |         CoverPoolStructs.TickMap storage tickMap,
 100 |     |         mapping(int24 => CoverPoolStructs.Tick) storage ticks,
 101 |     |         mapping(uint256 => CoverPoolStructs.CoverPosition)
 102 |     |             storage positions
 103 |     |     ) external {
 104 | *   |         bool positionCreated = false;
 105 | *   |         if (params.positionId > 0) {
 106 |     |             // load existing position
 107 |     |             cache.position = positions[params.positionId];
 108 |     |             if (cache.position.owner != msg.sender)
 109 |     |                 require(false, 'PositionNotFound()');
 110 |     |         }
 111 |     |         // assume cache.state is already set
 112 |     | 
 113 |     |         // resize position
 114 |     |         (params, cache.liquidityMinted) = Positions.resize(
 115 |     |             cache.position,
 116 |     |             params, 
 117 |     |             cache.state,
 118 |     |             cache.constants
 119 |     |         );
 120 |     | 
 121 |     |         if (params.positionId == 0 ||                       // new position
 122 |     |                 params.lower != cache.position.lower ||     // lower mismatch
 123 |     |                 params.upper != cache.position.upper) {     // upper mismatch
 124 |     |             CoverPoolStructs.CoverPosition memory newPosition;
 125 |     |             newPosition.owner = params.to;
 126 |     |             newPosition.lower = params.lower;
 127 |     |             newPosition.upper = params.upper;
 128 |     |             // use new position in cache
 129 |     |             cache.position = newPosition;
 130 |     |             params.positionId = cache.state.positionIdNext;
 131 |     |             cache.state.positionIdNext += 1;
 132 |     |         }
 133 |     | 
 134 |     |         // transfer in token amount
 135 |     |         SafeTransfers.transferIn(params.zeroForOne ? cache.constants.token0 
 136 |     |                                                    : cache.constants.token1,
 137 |     |                                  params.amount
 138 |     |                                 );
 139 |     | 
 140 |     |         (cache.state, cache.position) = Positions.add(
 141 |     |             cache.position,
 142 |     |             ticks,
 143 |     |             tickMap,
 144 |     |             cache.state,
 145 |     |             CoverPoolStructs.AddParams(
 146 |     |                 params.to,
 147 |     |                 uint128(cache.liquidityMinted),
 148 |     |                 params.amount,
 149 |     |                 params.positionId,
 150 |     |                 params.lower,
 151 |     |                 params.upper,
 152 |     |                 params.zeroForOne
 153 |     |             ),
 154 |     |             cache.constants
 155 |     |         );
 156 |     |         positionCreated = true;
 157 |     |         Collect.mint(
 158 |     |             cache,
 159 |     |             CoverPoolStructs.CollectParams(
 160 |     |                 cache.syncFees,
 161 |     |                 params.to,
 162 |     |                 params.positionId,
 163 |     |                 params.lower,
 164 |     |                 0, // not needed for mint collect
 165 |     |                 params.upper,
 166 |     |                 params.zeroForOne
 167 |     |             )
 168 |     |         );
 169 |     | 
 170 |     |         revert SimulateMint(params.lower, params.upper, positionCreated);
 171 |     |     }
 172 |     | }
 173 |     | 

/home/ec2-user/git/cover/contracts/libraries/pool/QuoteCall.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/structs/CoverPoolStructs.sol';
  5 |     | import '../../interfaces/ICoverPool.sol';
  6 |     | import '../Ticks.sol';
  7 |     | 
  8 |     | library QuoteCall {
  9 |     | 
 10 |     |     function perform(
 11 |     |         ICoverPool.QuoteParams memory params,
 12 |     |         CoverPoolStructs.SwapCache memory cache
 13 |     |     ) internal view returns (
 14 |     |         int256,
 15 |     |         int256,
 16 |     |         uint256
 17 |     |     ) {
 18 |     |         {
 19 |     |             CoverPoolStructs.PoolState memory pool = params.zeroForOne ? cache.pool1 : cache.pool0;
 20 |     |             cache = CoverPoolStructs.SwapCache({
 21 |     |                 state: cache.state,
 22 |     |                 syncFees: cache.syncFees,
 23 |     |                 constants: cache.constants,
 24 |     |                 pool0: cache.pool0,
 25 |     |                 pool1: cache.pool1,
 26 |     |                 price: pool.price,
 27 |     |                 liquidity: pool.liquidity,
 28 |     |                 amountLeft: params.amount,
 29 |     |                 auctionDepth: block.timestamp - cache.constants.genesisTime - cache.state.auctionStart,
 30 |     |                 auctionBoost: 0,
 31 |     |                 input: 0,
 32 |     |                 output: 0,
 33 |     |                 amountBoosted: 0,
 34 |     |                 amountInDelta: 0,
 35 |     |                 amount0Delta: 0,
 36 |     |                 amount1Delta: 0,
 37 |     |                 exactIn: true
 38 |     |             });
 39 |     |         }
 40 |     |         // call quote
 41 |     |         cache = Ticks.quote(
 42 |     |             params.zeroForOne,
 43 |     |             params.priceLimit,
 44 |     |             cache.state,
 45 |     |             cache,
 46 |     |             cache.constants
 47 |     |         );
 48 |     | 
 49 |     |         // calculate deltas
 50 |     |         cache = calculateDeltas(params, cache);
 51 |     |         
 52 |     |         return (
 53 |     |             params.zeroForOne ? -cache.amount0Delta : -cache.amount1Delta,
 54 |     |             params.zeroForOne ? cache.amount1Delta : cache.amount0Delta,
 55 |     |             cache.price
 56 |     |         );
 57 |     |     }
 58 |     | 
 59 |     |     function calculateDeltas(
 60 |     |         ICoverPool.QuoteParams memory params,
 61 |     |         CoverPoolStructs.SwapCache memory cache
 62 |     |     ) internal pure returns (
 63 |     |         CoverPoolStructs.SwapCache memory
 64 |     |     ) {
 65 |     |         // calculate amount deltas
 66 |     |         cache.amount0Delta = params.zeroForOne ? -int256(cache.input) 
 67 |     |                                                : int256(cache.output);
 68 |     |         cache.amount1Delta = params.zeroForOne ? int256(cache.output) 
 69 |     |                                                : -int256(cache.input);
 70 |     |         
 71 |     |         // factor in sync fees
 72 |     |         cache.amount0Delta += int128(cache.syncFees.token0);
 73 |     |         cache.amount1Delta += int128(cache.syncFees.token1);
 74 |     | 
 75 |     |         return cache;
 76 |     |     }
 77 |     | }
 78 |     | 

/home/ec2-user/git/cover/contracts/libraries/pool/SwapCall.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/structs/CoverPoolStructs.sol';
   5 |     | import '../../interfaces/IERC20Minimal.sol';
   6 |     | import '../../interfaces/callbacks/ICoverPoolSwapCallback.sol';
   7 |     | import '../Epochs.sol';
   8 |     | import '../Positions.sol';
   9 |     | import '../utils/Collect.sol';
  10 |     | import '../utils/SafeCast.sol';
  11 |     | 
  12 |     | library SwapCall {
  13 |     |     using SafeCast for int256;
  14 |     | 
  15 |     |     event SwapPool0(
  16 |     |         address indexed recipient,
  17 |     |         uint128 amountIn,
  18 |     |         uint128 amountOut,
  19 |     |         uint160 priceLimit,
  20 |     |         uint160 newPrice
  21 |     |     );
  22 |     | 
  23 |     |     event SwapPool1(
  24 |     |         address indexed recipient,
  25 |     |         uint128 amountIn,
  26 |     |         uint128 amountOut,
  27 |     |         uint160 priceLimit,
  28 |     |         uint160 newPrice
  29 |     |     );
  30 |     | 
  31 |     |     function perform(
  32 |     |         ICoverPool.SwapParams memory params,
  33 |     |         CoverPoolStructs.SwapCache memory cache,
  34 |     |         CoverPoolStructs.GlobalState storage globalState,
  35 |     |         CoverPoolStructs.PoolState storage pool0,
  36 |     |         CoverPoolStructs.PoolState storage pool1
  37 |     |     ) internal returns (
  38 |     |         int256,
  39 |     |         int256
  40 |     |     ) {
  41 |     |         {
  42 |     |             CoverPoolStructs.PoolState memory pool = params.zeroForOne ? cache.pool1 : cache.pool0;
  43 |     |             cache = CoverPoolStructs.SwapCache({
  44 |     |                 state: cache.state,
  45 |     |                 syncFees: cache.syncFees,
  46 |     |                 constants: cache.constants,
  47 |     |                 pool0: cache.pool0,
  48 |     |                 pool1: cache.pool1,
  49 |     |                 price: pool.price,
  50 |     |                 liquidity: pool.liquidity,
  51 |     |                 amountLeft: params.amount,
  52 |     |                 auctionDepth: block.timestamp - cache.constants.genesisTime - cache.state.auctionStart,
  53 |     |                 auctionBoost: 0,
  54 |     |                 input: 0,
  55 |     |                 output: 0,
  56 |     |                 amountBoosted: 0,
  57 |     |                 amountInDelta: 0,
  58 |     |                 amount0Delta: 0,
  59 |     |                 amount1Delta: 0,
  60 |     |                 exactIn: true
  61 |     |             });
  62 |     |         }
  63 |     | 
  64 |     |         // call quote
  65 |     |         cache = Ticks.quote(params.zeroForOne, params.priceLimit, cache.state, cache, cache.constants);
  66 |     | 
  67 |     |         // save state to storage before callback
  68 |     |         save(params, cache, globalState, pool0, pool1);
  69 |     | 
  70 |     |         // calculate amount deltas
  71 |     |         cache = calculateDeltas(params, cache);
  72 |     | 
  73 |     |         // transfer swap output
  74 |     |         SafeTransfers.transferOut(
  75 |     |             params.to,
  76 |     |             params.zeroForOne ? cache.constants.token1
  77 |     |                               : cache.constants.token0,
  78 |     |             params.zeroForOne ? cache.amount1Delta.toUint256()
  79 |     |                               : cache.amount0Delta.toUint256()
  80 |     |         );
  81 |     | 
  82 |     |         // check balance and execute callback
  83 |     |         uint256 balanceStart = balance(params, cache);
  84 |     |         ICoverPoolSwapCallback(msg.sender).coverPoolSwapCallback(
  85 |     |             cache.amount0Delta,
  86 |     |             cache.amount1Delta,
  87 |     |             params.callbackData
  88 |     |         );
  89 |     | 
  90 |     |         // check balance requirements after callback
  91 |     |         if (balance(params, cache) < balanceStart + cache.input)
  92 |     |             require(false, 'SwapInputAmountTooLow()');
  93 |     |     
  94 |     |         if (params.zeroForOne) {
  95 |     |             // transfer out if sync fees > swap input
  96 |     |             if (cache.amount0Delta > 0) {
  97 |     |                 SafeTransfers.transferOut(params.to, cache.constants.token0, cache.amount0Delta.toUint256());
  98 |     |             }
  99 |     |             emit SwapPool1(params.to, uint128(cache.input), uint128(cache.output), uint160(cache.price), params.priceLimit);
 100 |     |         } else {
 101 |     |             if (cache.amount1Delta > 0) {
 102 |     |                 SafeTransfers.transferOut(params.to, cache.constants.token1, cache.amount1Delta.toUint256());
 103 |     |             }
 104 |     |             emit SwapPool0(params.to, uint128(cache.input), uint128(cache.output), uint160(cache.price), params.priceLimit);
 105 |     |         }
 106 |     | 
 107 |     |         return (
 108 |     |             cache.amount0Delta,
 109 |     |             cache.amount1Delta
 110 |     |         );
 111 |     |     }
 112 |     | 
 113 |     |     function save(
 114 |     |         ICoverPool.SwapParams memory params,
 115 |     |         CoverPoolStructs.SwapCache memory cache,
 116 |     |         CoverPoolStructs.GlobalState storage globalState,
 117 |     |         CoverPoolStructs.PoolState storage pool0,
 118 |     |         CoverPoolStructs.PoolState storage pool1
 119 |     |     ) internal {
 120 |     |         // save pool changes to cache
 121 |     |         if (params.zeroForOne) {
 122 |     |             cache.pool1.price = uint160(cache.price);
 123 |     |             cache.pool1.amountInDelta += uint128(cache.amountInDelta);
 124 |     |         } else {
 125 |     |             cache.pool0.price = uint160(cache.price);
 126 |     |             cache.pool0.amountInDelta += uint128(cache.amountInDelta);
 127 |     |         }
 128 |     | 
 129 |     |         // save global state changes to storage
 130 |     |         globalState.latestPrice = cache.state.latestPrice;
 131 |     |         globalState.liquidityGlobal = cache.state.liquidityGlobal;
 132 |     |         globalState.lastTime = cache.state.lastTime;
 133 |     |         globalState.auctionStart = cache.state.auctionStart;
 134 |     |         globalState.accumEpoch = cache.state.accumEpoch;
 135 |     |         globalState.latestTick = cache.state.latestTick;
 136 |     | 
 137 |     |         // save pool0 changes to storage
 138 |     |         pool0.price = cache.pool0.price;
 139 |     |         pool0.liquidity = cache.pool0.liquidity;
 140 |     |         pool0.amountInDelta = cache.pool0.amountInDelta;
 141 |     |         pool0.amountInDeltaMaxClaimed = cache.pool0.amountInDeltaMaxClaimed;
 142 |     |         pool0.amountOutDeltaMaxClaimed = cache.pool0.amountOutDeltaMaxClaimed;
 143 |     | 
 144 |     |         // save pool1 changes to storage
 145 |     |         pool1.price = cache.pool1.price;
 146 |     |         pool1.liquidity = cache.pool1.liquidity;
 147 |     |         pool1.amountInDelta = cache.pool1.amountInDelta;
 148 |     |         pool1.amountInDeltaMaxClaimed = cache.pool1.amountInDeltaMaxClaimed;
 149 |     |         pool1.amountOutDeltaMaxClaimed = cache.pool1.amountOutDeltaMaxClaimed;
 150 |     |     }
 151 |     | 
 152 |     |     function balance(
 153 |     |         ICoverPool.SwapParams memory params,
 154 |     |         CoverPoolStructs.SwapCache memory cache
 155 |     |     ) private view returns (uint256) {
 156 |     |         (
 157 |     |             bool success,
 158 |     |             bytes memory data
 159 |     |         ) = (params.zeroForOne ? cache.constants.token0
 160 |     |                                : cache.constants.token1)
 161 |     |                                .staticcall(
 162 |     |                                     abi.encodeWithSelector(
 163 |     |                                         IERC20Minimal.balanceOf.selector,
 164 |     |                                         address(this)
 165 |     |                                     )
 166 |     |                                 );
 167 |     |         if(!success || data.length < 32) require(false, 'InvalidERC20ReturnData()');
 168 |     |         return abi.decode(data, (uint256));
 169 |     |     }
 170 |     | 
 171 |     |     function calculateDeltas(
 172 |     |         ICoverPool.SwapParams memory params,
 173 |     |         CoverPoolStructs.SwapCache memory cache
 174 |     |     ) internal pure returns (
 175 |     |         CoverPoolStructs.SwapCache memory
 176 |     |     ) {
 177 |     |         // calculate amount deltas
 178 |     |         cache.amount0Delta = params.zeroForOne ? -int256(cache.input) 
 179 |     |                                                : int256(cache.output);
 180 |     |         cache.amount1Delta = params.zeroForOne ? int256(cache.output) 
 181 |     |                                                : -int256(cache.input);
 182 |     |         
 183 |     |         // factor in sync fees
 184 |     |         cache.amount0Delta += int128(cache.syncFees.token0);
 185 |     |         cache.amount1Delta += int128(cache.syncFees.token1);
 186 |     | 
 187 |     |         return cache;
 188 |     |     }
 189 |     | }
 190 |     | 

/home/ec2-user/git/cover/contracts/libraries/sources/UniswapV3Source.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/external/uniswap/v3/IUniswapV3Factory.sol';
   5 |     | import '../../interfaces/external/uniswap/v3/IUniswapV3Pool.sol';
   6 |     | import '../../interfaces/structs/CoverPoolStructs.sol';
   7 |     | import '../../interfaces/modules/sources/ITwapSource.sol';
   8 |     | import '../math/ConstantProduct.sol';
   9 |     | 
  10 | *   | contract UniswapV3Source is ITwapSource {
  11 |     |     error WaitUntilBelowMaxTick();
  12 |     |     error WaitUntilAboveMinTick();
  13 |     | 
  14 |     |     address public immutable uniV3Factory;
  15 | *   |     uint32 public constant oneSecond = 1000;
  16 |     | 
  17 |     |     constructor(
  18 |     |         address _uniV3Factory
  19 |     |     ) {
  20 |     |         uniV3Factory = _uniV3Factory;
  21 |     |     }
  22 |     | 
  23 | *   |     function initialize(
  24 |     |         PoolsharkStructs.CoverImmutables memory constants
  25 |     |     ) external returns (
  26 | *   |         uint8 initializable,
  27 | *   |         int24 startingTick
  28 |     |     )
  29 | *   |     {
  30 |     |         // get the number of blocks covered by the twapLength
  31 | *   |         uint32 blockCount = uint32(constants.twapLength) * oneSecond / constants.blockTime;
  32 | *   |         (
  33 | *   |             bool observationsCountEnough,
  34 | *   |             bool observationsLengthEnough
  35 | *   |         ) = _isPoolObservationsEnough(
  36 | *   |                 constants.inputPool,
  37 | *   |                 blockCount
  38 |     |         );
  39 | *   |         if (!observationsLengthEnough) {
  40 |     |             _increaseV3Observations(constants.inputPool, blockCount);
  41 |     |             return (0, 0);
  42 | *   |         } else if (!observationsCountEnough) {
  43 |     |             return (0, 0);
  44 |     |         }
  45 |     |         // ready to initialize if we get here
  46 | *   |         initializable = 1;
  47 | *   |         int24[4] memory averageTicks = _calculateAverageTicks(constants);
  48 |     |         // take the average of the 4 samples as a starting tick
  49 | *   |         startingTick = (averageTicks[0] + averageTicks[1] + averageTicks[2] + averageTicks[3]) / 4;
  50 |     |     }
  51 |     | 
  52 |     |     function factory() external view returns (address) {
  53 |     |         return uniV3Factory;
  54 |     |     }
  55 |     | 
  56 |     |     function feeTierTickSpacing(
  57 |     |         uint16 feeTier
  58 |     |     ) external view returns (
  59 |     |         int24
  60 |     |     )
  61 |     |     {
  62 |     |         return IUniswapV3Factory(uniV3Factory).feeTierTickSpacing(feeTier);
  63 |     |     }
  64 |     | 
  65 |     |     function getPool(
  66 |     |         address token0,
  67 |     |         address token1,
  68 |     |         uint16 feeTier
  69 |     |     ) external view returns(
  70 |     |         address pool
  71 |     |     ) {
  72 |     |         return IUniswapV3Factory(uniV3Factory).getPool(token0, token1, feeTier);
  73 |     |     }
  74 |     | 
  75 | *   |     function calculateAverageTick(
  76 |     |         PoolsharkStructs.CoverImmutables memory constants,
  77 |     |         int24 latestTick
  78 |     |     ) external view returns (
  79 | *   |         int24 averageTick
  80 |     |     )
  81 | *   |     {
  82 | *   |         int24[4] memory averageTicks = _calculateAverageTicks(constants);
  83 | *   |         int24 minTickVariance = ConstantProduct.maxTick(constants.tickSpread) * 2;
  84 | *   |         for (uint i; i < 4; i++) {
  85 | *   |             int24 absTickVariance = latestTick - averageTicks[i] >= 0 ? latestTick - averageTicks[i]
  86 | *   |                                                                       : averageTicks[i] - latestTick;
  87 | *   |             if (absTickVariance <= minTickVariance) {
  88 |     |                 /// @dev - averageTick has the least possible variance from latestTick
  89 | *   |                 minTickVariance = absTickVariance;
  90 | *   |                 averageTick = averageTicks[i];
  91 |     |             }
  92 |     |         }
  93 |     |     }
  94 |     | 
  95 | *   |     function _calculateAverageTicks(
  96 |     |         PoolsharkStructs.CoverImmutables memory constants
  97 |     |     ) internal view returns (
  98 | *   |         int24[4] memory averageTicks
  99 |     |     )
 100 | *   |     {
 101 | *   |         uint32[] memory secondsAgos = new uint32[](4);
 102 |     |         /// @dev - take 4 samples
 103 |     |         /// @dev - twapLength must be >= 5 * blockTime
 104 | *   |         uint32 timeDelta = (constants.blockTime / oneSecond == 0) ? 2 
 105 | *   |                                                                 : constants.blockTime * 2 / oneSecond;
 106 | *   |         secondsAgos[0] = 0;
 107 | *   |         secondsAgos[1] = timeDelta;
 108 | *   |         secondsAgos[2] = constants.twapLength - timeDelta;
 109 | *   |         secondsAgos[3] = constants.twapLength;
 110 | *   |         (int56[] memory tickCumulatives, ) = IUniswapV3Pool(constants.inputPool).observe(secondsAgos);
 111 |     |         
 112 |     |         // take the smallest absolute value of 4 samples
 113 | *   |         averageTicks[0] = int24(((tickCumulatives[0] - tickCumulatives[2]) / (int32(secondsAgos[2] - secondsAgos[0]))));
 114 | *   |         averageTicks[1] = int24(((tickCumulatives[0] - tickCumulatives[3]) / (int32(secondsAgos[3] - secondsAgos[0]))));
 115 | *   |         averageTicks[2] = int24(((tickCumulatives[1] - tickCumulatives[2]) / (int32(secondsAgos[2] - secondsAgos[1]))));
 116 | *   |         averageTicks[3] = int24(((tickCumulatives[1] - tickCumulatives[3]) / (int32(secondsAgos[3] - secondsAgos[1]))));
 117 |     | 
 118 |     |         // make sure all samples fit within min/max bounds
 119 | *   |         int24 minAverageTick = ConstantProduct.minTick(constants.tickSpread) + constants.tickSpread;
 120 | *   |         int24 maxAverageTick = ConstantProduct.maxTick(constants.tickSpread) - constants.tickSpread;
 121 | *   |         for (uint i; i < 4; i++) {
 122 | *   |             if (averageTicks[i] < minAverageTick)
 123 |     |                 averageTicks[i] = minAverageTick;
 124 | *   |             if (averageTicks[i] > maxAverageTick)
 125 |     |                 averageTicks[i] = maxAverageTick;
 126 |     |         }
 127 |     |     }
 128 |     | 
 129 | *   |     function _isPoolObservationsEnough(
 130 |     |         address pool,
 131 |     |         uint32 blockCount
 132 |     |     ) internal view returns (
 133 | *   |         bool,
 134 | *   |         bool
 135 |     |     )
 136 |     |     {
 137 |     | 
 138 | *   |         (, , , uint16 observationsCount, uint16 observationsLength, , ) = IUniswapV3Pool(pool).slot0();
 139 | *   |         return (observationsCount >= blockCount, observationsLength >= blockCount);
 140 |     |     }
 141 |     | 
 142 |     |     function _increaseV3Observations(address pool, uint32 blockCount) internal {
 143 |     |         IUniswapV3Pool(pool).increaseObservationCardinalityNext(uint16(blockCount));
 144 |     |     }
 145 |     | }
 146 |     | 

/home/ec2-user/git/cover/contracts/libraries/utils/Collect.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/structs/CoverPoolStructs.sol';
  5 |     | import '../Epochs.sol';
  6 |     | import '../Positions.sol';
  7 |     | import '../utils/SafeTransfers.sol';
  8 |     | 
  9 |     | library Collect {
 10 |     |     function mint(
 11 |     |         CoverPoolStructs.MintCache memory cache,
 12 |     |         CoverPoolStructs.CollectParams memory params
 13 |     |     ) internal {
 14 |     |         if (params.syncFees.token0 == 0 && params.syncFees.token1 == 0) return;
 15 |     |         // store amounts for transferOut
 16 |     |         uint128 amountIn;
 17 |     |         uint128 amountOut;
 18 |     | 
 19 |     |         // factor in sync fees
 20 |     |         if (params.zeroForOne) {
 21 |     |             amountIn  += params.syncFees.token1;
 22 |     |             amountOut += params.syncFees.token0;
 23 |     |         } else {
 24 |     |             amountIn  += params.syncFees.token0;
 25 |     |             amountOut += params.syncFees.token1;
 26 |     |         }
 27 |     | 
 28 |     |         /// zero out balances and transfer out
 29 |     |         if (amountIn > 0) {
 30 |     |             SafeTransfers.transferOut(params.to, params.zeroForOne ? cache.constants.token1 : cache.constants.token0, amountIn);
 31 |     |         } 
 32 |     |         if (amountOut > 0) {
 33 |     |             SafeTransfers.transferOut(params.to, params.zeroForOne ? cache.constants.token0 : cache.constants.token1, amountOut);
 34 |     |         }
 35 |     |     }
 36 |     | 
 37 |     |     function burn(
 38 |     |         CoverPoolStructs.BurnCache memory cache,
 39 |     |         mapping(uint256 => CoverPoolStructs.CoverPosition)
 40 |     |             storage positions,
 41 |     |         CoverPoolStructs.CollectParams memory params
 42 |     |     ) internal {
 43 |     |         params.zeroForOne ? params.upper = params.claim : params.lower = params.claim;
 44 |     | 
 45 |     |         // store amounts for transferOut
 46 |     |         uint128 amountIn  = positions[params.positionId].amountIn;
 47 |     |         uint128 amountOut = positions[params.positionId].amountOut;
 48 |     | 
 49 |     |         // factor in sync fees
 50 |     |         if (params.zeroForOne) {
 51 |     |             amountIn  += params.syncFees.token1;
 52 |     |             amountOut += params.syncFees.token0;
 53 |     |         } else {
 54 |     |             amountIn  += params.syncFees.token0;
 55 |     |             amountOut += params.syncFees.token1;
 56 |     |         }
 57 |     | 
 58 |     |         /// zero out balances and transfer out
 59 |     |         if (amountIn > 0) {
 60 |     |             positions[params.positionId].amountIn = 0;
 61 |     |             SafeTransfers.transferOut(params.to, params.zeroForOne ? cache.constants.token1 : cache.constants.token0, amountIn);
 62 |     |         } 
 63 |     |         if (amountOut > 0) {
 64 |     |             positions[params.positionId].amountOut = 0;
 65 |     |             SafeTransfers.transferOut(params.to, params.zeroForOne ? cache.constants.token0 : cache.constants.token1, amountOut);
 66 |     |         }
 67 |     |     }
 68 |     | }
 69 |     | 

/home/ec2-user/git/cover/contracts/libraries/utils/SafeCast.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | /// @title Safe casting methods
  5 |     | /// @notice Contains methods for safely casting between types
  6 |     | library SafeCast {
  7 |     |     /// @notice Cast a uint256 to a uint128, revert on overflow
  8 |     |     /// @param y The uint256 to be downcasted
  9 |     |     /// @return z The downcasted integer, now type uint128
 10 |     |     function toUint128(uint256 y) internal pure returns (uint128 z) {
 11 |     |         if((z = uint128(y)) != y) require(false, 'Uint256ToUint128:Overflow()');
 12 |     |     }
 13 |     | 
 14 |     |     /// @notice Cast a uint256 to a uint128, revert on overflow
 15 |     |     /// @param y The uint256 to be downcasted
 16 |     |     /// @return z The downcasted integer, now type uint128
 17 |     |     function toUint128(int128 y) internal pure returns (uint128 z) {
 18 |     |         if(y < 0) require(false, 'Int128ToUint128:Underflow()');
 19 |     |         z = uint128(y);
 20 |     |     }
 21 |     | 
 22 |     |     /// @notice Cast a uint256 to a uint160, revert on overflow
 23 |     |     /// @param y The uint256 to be downcasted
 24 |     |     /// @return z The downcasted integer, now type uint160
 25 |     |     function toUint160(uint256 y) internal pure returns (uint160 z) {
 26 |     |         if((z = uint160(y)) != y) require(false, 'Uint256ToUint160:Overflow()');
 27 |     |     }
 28 |     | 
 29 |     |     /// @notice Cast a uint256 to a uint160, revert on overflow
 30 |     |     /// @param y The uint256 to be downcasted
 31 |     |     /// @return z The downcasted integer, now type uint160
 32 |     |     function toUint32(uint256 y) internal pure returns (uint32 z) {
 33 |     |         if((z = uint32(y)) != y) require(false, 'Uint256ToUint32:Overflow()');
 34 |     |     }
 35 |     | 
 36 |     |     /// @notice Cast a int256 to a int128, revert on overflow or underflow
 37 |     |     /// @param y The int256 to be downcasted
 38 |     |     /// @return z The downcasted integer, now type int128
 39 |     |     function toInt128(int256 y) internal pure returns (int128 z) {
 40 |     |         if ((z = int128(y)) != y) require(false, 'Int256ToInt128:Overflow()');
 41 |     |     }
 42 |     | 
 43 |     |     /// @notice Cast a int256 to a int128, revert on overflow or underflow
 44 |     |     /// @param y The int256 to be downcasted
 45 |     |     /// @return z The downcasted integer, now type int128
 46 |     |     function toInt128(uint128 y) internal pure returns (int128 z) {
 47 |     |         if(y > uint128(type(int128).max)) require(false, 'Uint128ToInt128:Overflow()');
 48 |     |         z = int128(y);
 49 |     |     }
 50 |     | 
 51 |     |     /// @notice Cast a uint256 to a int256, revert on overflow
 52 |     |     /// @param y The uint256 to be casted
 53 |     |     /// @return z The casted integer, now type int256
 54 |     |     function toInt256(uint256 y) internal pure returns (int256 z) {
 55 |     |         if(y > uint256(type(int256).max)) require(false, 'Uint256ToInt256:Overflow()');
 56 |     |         z = int256(y);
 57 |     |     }
 58 |     | 
 59 |     |     /// @notice Cast a uint256 to a uint128, revert on overflow
 60 |     |     /// @param y The uint256 to be downcasted
 61 |     |     /// @return z The downcasted integer, now type uint128
 62 |     |     function toUint256(int256 y) internal pure returns (uint256 z) {
 63 |     |         if(y < 0) require(false, 'Int256ToUint256:Underflow()');
 64 |     |         z = uint256(y);
 65 |     |     }
 66 |     | }

/home/ec2-user/git/cover/contracts/libraries/utils/SafeTransfers.sol
   1 |     | //SPDX-License-Identifier: Unlicense
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../external/openzeppelin/contracts/token/ERC20/ERC20.sol';
   5 |     | 
   6 |     | library SafeTransfers {
   7 |     |     /**
   8 |     |      * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
   9 |     |      *      This will revert due to insufficient balance or insufficient allowance.
  10 |     |      *      This function returns the actual amount received,
  11 |     |      *      which may be less than `amount` if there is a fee attached to the transfer.
  12 |     |      *
  13 |     |      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
  14 |     |      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
  15 |     |      */
  16 |     |     // slither-disable-next-line assembly
  17 |     |     function transferIn(address token, uint256 amount) internal returns (uint256) {
  18 |     |         if (token == address(0)) {
  19 |     |             if (msg.value < amount) require(false, 'TransferFailed(msg.sender, address(this)');
  20 |     |             return amount;
  21 |     |         }
  22 |     |         if (amount == 0) return 0;
  23 |     |         IERC20 erc20Token = IERC20(token);
  24 |     |         uint256 balanceBefore = IERC20(token).balanceOf(address(this));
  25 |     | 
  26 |     |         // ? We are checking the transfer, but since we are doing so in an assembly block
  27 |     |         // ? Slither does not pick up on that and results in a hit
  28 |     |         // slither-disable-next-line unchecked-transfer
  29 |     |         erc20Token.transferFrom(msg.sender, address(this), amount);
  30 |     | 
  31 |     |         bool success;
  32 |     |         assembly {
  33 |     |             switch returndatasize()
  34 |     |             case 0 {
  35 |     |                 // This is a non-standard ERC-20
  36 |     |                 success := 1 // set success to true
  37 |     |             }
  38 |     |             case 32 {
  39 |     |                 // This is a compliant ERC-20
  40 |     |                 returndatacopy(0, 0, 32)
  41 |     |                 success := mload(0) // Set `success = returndata` of external call
  42 |     |             }
  43 |     |             default {
  44 |     |                 // This is an excessively non-compliant ERC-20, revert.
  45 |     |                 success := 0
  46 |     |             }
  47 |     |         }
  48 |     |         if (!success) require(false, 'TransferFailed(msg.sender, address(this)');
  49 |     | 
  50 |     |         // Calculate the amount that was *actually* transferred
  51 |     |         uint256 balanceAfter = IERC20(token).balanceOf(address(this));
  52 |     | 
  53 |     |         return balanceAfter - balanceBefore; // underflow already checked above, just subtract
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
  58 |     |      *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
  59 |     |      *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
  60 |     |      *      it is >= amount, this should not revert in normal conditions.
  61 |     |      *
  62 |     |      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
  63 |     |      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
  64 |     |      */
  65 |     |     // slither-disable-next-line assembly
  66 |     |     function transferOut(
  67 |     |         address to,
  68 |     |         address token,
  69 |     |         uint256 amount
  70 |     |     ) internal {
  71 |     |         if (token == address(0)) {
  72 |     |             if (address(this).balance < amount) require(false, 'TransferFailed(address(this), to');
  73 |     |             payable(to).transfer(amount);
  74 |     |             return;
  75 |     |         }
  76 |     |         if (amount == 0) return;
  77 |     |         IERC20 erc20Token = IERC20(token);
  78 |     |         // ? We are checking the transfer, but since we are doing so in an assembly block
  79 |     |         // ? Slither does not pick up on that and results in a hit
  80 |     |         // slither-disable-next-line unchecked-transfer
  81 |     |         erc20Token.transfer(to, amount);
  82 |     | 
  83 |     |         bool success;
  84 |     |         assembly {
  85 |     |             switch returndatasize()
  86 |     |             case 0 {
  87 |     |                 // This is a non-standard ERC-20
  88 |     |                 success := 1 // set success to true
  89 |     |             }
  90 |     |             case 32 {
  91 |     |                 // This is a complaint ERC-20
  92 |     |                 returndatacopy(0, 0, 32)
  93 |     |                 success := mload(0) // Set `success = returndata` of external call
  94 |     |             }
  95 |     |             default {
  96 |     |                 // This is an excessively non-compliant ERC-20, revert.
  97 |     |                 success := 0
  98 |     |             }
  99 |     |         }
 100 |     |         if (!success) require(false, 'TransferFailed(address(this), msg.sender');
 101 |     |     }
 102 |     | 
 103 |     |     /**
 104 |     |      * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
 105 |     |      *      This will revert due to insufficient balance or insufficient allowance.
 106 |     |      *      This function returns the actual amount received,
 107 |     |      *      which may be less than `amount` if there is a fee attached to the transfer.
 108 |     |      *
 109 |     |      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
 110 |     |      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
 111 |     |      */
 112 |     |     // slither-disable-next-line assembly
 113 | *   |     function transferInto(address token, address sender, uint256 amount) internal returns (uint256) {
 114 | *   |         if (token == address(0)) {
 115 |     |             if (msg.value < amount) require(false, 'TransferFailed(msg.sender, address(this)');
 116 |     |             return amount;
 117 |     |         }
 118 | *   |         IERC20 erc20Token = IERC20(token);
 119 | *   |         uint256 balanceBefore = IERC20(token).balanceOf(address(this));
 120 |     | 
 121 |     |         /// @dev - msg.sender here is the pool
 122 | *r  |         erc20Token.transferFrom(sender, msg.sender, amount);
 123 |     | 
 124 | *   |         bool success;
 125 |     |         assembly {
 126 | *   |             switch returndatasize()
 127 | *   |             case 0 {
 128 |     |                 // This is a non-standard ERC-20
 129 |     |                 success := 1 // set success to true
 130 |     |             }
 131 | *   |             case 32 {
 132 |     |                 // This is a compliant ERC-20
 133 | *   |                 returndatacopy(0, 0, 32)
 134 | *   |                 success := mload(0) // Set `success = returndata` of external call
 135 |     |             }
 136 |     |             default {
 137 |     |                 // This is an excessively non-compliant ERC-20, revert.
 138 |     |                 success := 0
 139 |     |             }
 140 |     |         }
 141 | *   |         if (!success) require(false, 'TransferFailed(msg.sender, address(this)');
 142 |     | 
 143 |     |         // Calculate the amount that was *actually* transferred
 144 | *   |         uint256 balanceAfter = IERC20(token).balanceOf(address(this));
 145 |     | 
 146 | *   |         return balanceAfter - balanceBefore; // underflow already checked above, just subtract
 147 |     |     }
 148 |     | }
 149 |     | 

/home/ec2-user/git/cover/contracts/libraries/utils/String.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | library String {
  5 |     |     bytes16 private constant alphabet = "0123456789abcdef";
  6 |     | 
  7 |     |     function from(bytes32 value) internal pure returns(string memory) {
  8 |     |         return toString(abi.encodePacked(value));
  9 |     |     }
 10 |     | 
 11 |     |     function from(address account) internal pure returns(string memory) {
 12 |     |         return toString(abi.encodePacked(account));
 13 |     |     }
 14 |     | 
 15 |     |     function from(uint256 value) internal pure returns(string memory) {
 16 |     |         unchecked {
 17 |     |             uint256 length = log10(value) + 1;
 18 |     |             string memory buffer = new string(length);
 19 |     |             uint256 ptr;
 20 |     |             /// @solidity memory-safe-assembly
 21 |     |             assembly {
 22 |     |                 ptr := add(buffer, add(32, length))
 23 |     |             }
 24 |     |             while (true) {
 25 |     |                 ptr--;
 26 |     |                 /// @solidity memory-safe-assembly
 27 |     |                 assembly {
 28 |     |                     mstore8(ptr, byte(mod(value, 10), alphabet))
 29 |     |                 }
 30 |     |                 value /= 10;
 31 |     |                 if (value == 0) break;
 32 |     |             }
 33 |     |             return buffer;
 34 |     |         }
 35 |     |     }
 36 |     | 
 37 |     |     function from(int256 value) internal pure returns (string memory) {
 38 |     |         return string(abi.encodePacked(value < 0 ? "-" : "", from(abs(value))));
 39 |     |     }
 40 |     | 
 41 |     |     function abs(int256 n) internal pure returns (uint256) {
 42 |     |         unchecked {
 43 |     |             // must be unchecked in order to support `n = type(int256).min`
 44 |     |             return uint256(n >= 0 ? n : -n);
 45 |     |         }
 46 |     |     }
 47 |     | 
 48 |     |     function log10(uint256 value) internal pure returns (uint256) {
 49 |     |         uint256 result = 0;
 50 |     |         unchecked {
 51 |     |             if (value >= 10 ** 64) {
 52 |     |                 value /= 10 ** 64;
 53 |     |                 result += 64;
 54 |     |             }
 55 |     |             if (value >= 10 ** 32) {
 56 |     |                 value /= 10 ** 32;
 57 |     |                 result += 32;
 58 |     |             }
 59 |     |             if (value >= 10 ** 16) {
 60 |     |                 value /= 10 ** 16;
 61 |     |                 result += 16;
 62 |     |             }
 63 |     |             if (value >= 10 ** 8) {
 64 |     |                 value /= 10 ** 8;
 65 |     |                 result += 8;
 66 |     |             }
 67 |     |             if (value >= 10 ** 4) {
 68 |     |                 value /= 10 ** 4;
 69 |     |                 result += 4;
 70 |     |             }
 71 |     |             if (value >= 10 ** 2) {
 72 |     |                 value /= 10 ** 2;
 73 |     |                 result += 2;
 74 |     |             }
 75 |     |             if (value >= 10 ** 1) {
 76 |     |                 result += 1;
 77 |     |             }
 78 |     |         }
 79 |     |         return result;
 80 |     |     }
 81 |     | 
 82 |     |     function toString(bytes memory data) internal pure returns(string memory) {
 83 |     |         bytes memory str = new bytes(2 + data.length * 2);
 84 |     |         str[0] = "0";
 85 |     |         str[1] = "x";
 86 |     |         for (uint i = 0; i < data.length; i++) {
 87 |     |             str[2+i*2] = alphabet[uint(uint8(data[i] >> 4))];
 88 |     |             str[3+i*2] = alphabet[uint(uint8(data[i] & 0x0f))];
 89 |     |         }
 90 |     |         return string(str);
 91 |     |     }
 92 |     | }

/home/ec2-user/git/cover/contracts/test/Token20.sol
  1 |     | //SPDX-License-Identifier: Unlicense
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import '../external/openzeppelin/contracts/token/ERC20/ERC20.sol';
  5 |     | import '../external/openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol';
  6 |     | 
  7 | *   | contract Token20 is ERC20, ERC20Burnable {
  8 |     |     uint8 _decimals;
  9 |     | 
 10 |     |     constructor(
 11 |     |         string memory tokenName,
 12 |     |         string memory tokenSymbol,
 13 |     |         uint8 decimals_
 14 |     |     ) ERC20(tokenName, tokenSymbol) {
 15 |     |         _decimals = decimals_;
 16 |     |     }
 17 |     | 
 18 | *   |     function mint(address to, uint256 amount) external {
 19 | *   |         _mint(to, amount);
 20 |     |     }
 21 |     | 
 22 |     |     function decimals() public view override returns (uint8) {
 23 |     |         return _decimals;
 24 |     |     }
 25 |     | 
 26 |     |     function setDecimals(uint8 decimals_) public {
 27 |     |         _decimals = decimals_;
 28 |     |     }
 29 |     | }
 30 |     | 

/home/ec2-user/git/cover/contracts/test/UniswapV3FactoryMock.sol
  1 |     | //SPDX-License-Identifier: Unlicense
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import '../interfaces/external/uniswap/v3/IUniswapV3Factory.sol';
  5 |     | import './UniswapV3PoolMock.sol';
  6 |     | 
  7 |     | contract UniswapV3FactoryMock is IUniswapV3Factory {
  8 |     |     address mockPool;
  9 |     |     address mockPool2;
 10 |     |     address owner;
 11 |     | 
 12 |     |     mapping(uint24 => int24) public feeTierTickSpacing;
 13 |     |     mapping(address => mapping(address => mapping(uint24 => address))) public override getPool;
 14 |     | 
 15 |     |     constructor(address tokenA, address tokenB) {
 16 |     |         owner = msg.sender;
 17 |     |         (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB)
 18 |     |                                                            : (tokenB, tokenA);
 19 |     | 
 20 |     |         feeTierTickSpacing[500] = 10;
 21 |     |         feeTierTickSpacing[3000] = 60;
 22 |     |         feeTierTickSpacing[10000] = 200;
 23 |     | 
 24 |     |         // create mock pool 1
 25 |     |         mockPool = address(new UniswapV3PoolMock(token0, token1, 500, 10));
 26 |     |         getPool[token0][token1][500] = mockPool;
 27 |     | 
 28 |     |         // create mock pool 2
 29 |     |         mockPool2 = address(new UniswapV3PoolMock(token0, token1, 3000, 60));
 30 |     |         getPool[token0][token1][3000] = mockPool2;
 31 |     |     }
 32 |     | }
 33 |     | 

/home/ec2-user/git/cover/contracts/test/UniswapV3PoolMock.sol
  1 |     | //SPDX-License-Identifier: Unlicense
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import '../interfaces/external/uniswap/v3/IUniswapV3Pool.sol';
  5 |     | import './UniswapV3PoolMock.sol';
  6 |     | 
  7 | *   | contract UniswapV3PoolMock is IUniswapV3Pool {
  8 |     |     address internal admin;
  9 |     |     address public token0;
 10 |     |     address public token1;
 11 |     |     int24 public tickSpacing;
 12 |     |     uint256 swapFee;
 13 |     | 
 14 |     |     uint16 observationCardinality;
 15 |     |     uint16 observationCardinalityNext;
 16 |     | 
 17 |     |     int56 tickCumulative0;
 18 |     |     int56 tickCumulative1;
 19 |     |     int56 tickCumulative2;
 20 |     |     int56 tickCumulative3;
 21 |     | 
 22 |     |     constructor(
 23 |     |         address _token0,
 24 |     |         address _token1,
 25 |     |         uint24 _swapFee,
 26 |     |         int24 _tickSpacing
 27 |     |     ) {
 28 |     |         require(_token0 < _token1, 'wrong token order');
 29 |     |         admin = msg.sender;
 30 |     |         token0 = _token0;
 31 |     |         token1 = _token1;
 32 |     |         swapFee = _swapFee;
 33 |     |         tickSpacing = _tickSpacing;
 34 |     |         observationCardinality = 4;
 35 |     |         observationCardinalityNext = 4;
 36 |     |         tickCumulative0 = 10;
 37 |     |         tickCumulative1 = 9;
 38 |     |         tickCumulative2 = 6;
 39 |     |         tickCumulative3 = 5;
 40 |     |     }
 41 |     | 
 42 | *   |     function slot0()
 43 |     |         external
 44 |     |         view
 45 |     |         returns (
 46 | *   |             uint160 sqrtPriceX96,
 47 | *   |             int24 tick,
 48 | *   |             uint16 observationIndex,
 49 | *   |             uint16 cardinality,
 50 | *   |             uint16 cardinalityNext,
 51 | *   |             uint8 feeProtocol,
 52 | *   |             bool unlocked
 53 |     |         )
 54 |     |     {
 55 | *   |         return (1 << 96, 0, 4, observationCardinality, observationCardinalityNext, 100, true);
 56 |     |     }
 57 |     | 
 58 | *   |     function observe(uint32[] calldata secondsAgos)
 59 |     |         external
 60 |     |         view
 61 |     |         returns (
 62 | *   |             int56[] memory tickCumulatives,
 63 | *   |             uint160[] memory secondsPerLiquidityCumulativeX128s
 64 |     |         )
 65 |     |     {
 66 |     |         secondsAgos;
 67 | *   |         tickCumulatives = new int56[](secondsAgos.length);
 68 | *   |         tickCumulatives[0] = int56(tickCumulative0);
 69 | *   |         tickCumulatives[1] = int56(tickCumulative1);
 70 | *   |         tickCumulatives[2] = int56(tickCumulative2);
 71 | *   |         tickCumulatives[3] = int56(tickCumulative3);
 72 | *   |         secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);
 73 | *   |         secondsPerLiquidityCumulativeX128s[0] = uint160(949568451203788412348119);
 74 | *   |         secondsPerLiquidityCumulativeX128s[1] = uint160(949568451203788412348119);
 75 | *   |         secondsPerLiquidityCumulativeX128s[2] = uint160(949568438263103965182699);
 76 | *   |         secondsPerLiquidityCumulativeX128s[3] = uint160(949568438263103965182699);
 77 |     |     }
 78 |     | 
 79 |     |     function increaseObservationCardinalityNext(uint16 cardinalityNext) external {
 80 |     |         observationCardinalityNext = cardinalityNext;
 81 |     |     }
 82 |     | 
 83 | *   |     function setTickCumulatives(int56 _tickCumulative0, int56 _tickCumulative1, int56 _tickCumulative2, int56 _tickCumulative3) external {
 84 | *   |         tickCumulative0 = _tickCumulative0;
 85 | *   |         tickCumulative1 = _tickCumulative1;
 86 | *   |         tickCumulative2 = _tickCumulative2;
 87 | *   |         tickCumulative3 = _tickCumulative3;
 88 |     |     }
 89 |     | 
 90 |     |     function setObservationCardinality(uint16 _observationCardinality, uint16 _observationCardinalityNext) external {
 91 |     |         observationCardinality = _observationCardinality;
 92 |     |         observationCardinalityNext = _observationCardinalityNext;
 93 |     |     }
 94 |     | }
 95 |     | 

/home/ec2-user/git/cover/contracts/utils/CoverPoolErrors.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | abstract contract CoverPoolErrors {
  5 |     |     error Locked();
  6 |     |     error OwnerOnly();
  7 |     |     error InvalidToken();
  8 |     |     error InvalidPosition();
  9 |     |     error InvalidSwapFee();
 10 |     |     error InvalidTokenDecimals();
 11 |     |     error InvalidTickSpread();
 12 |     |     error LiquidityOverflow();
 13 |     |     error Token0Missing();
 14 |     |     error Token1Missing();
 15 |     |     error InvalidTick();
 16 |     |     error FactoryOnly();
 17 |     |     error LowerNotEvenTick();
 18 |     |     error UpperNotOddTick();
 19 |     |     error MaxTickLiquidity();
 20 |     |     error CollectToZeroAddress();
 21 |     |     error Overflow();
 22 |     |     error NotEnoughOutputLiquidity();
 23 |     |     error WaitUntilEnoughObservations();
 24 |     | }
 25 |     | 
 26 |     | abstract contract CoverTicksErrors {
 27 |     |     error WrongTickLowerRange();
 28 |     |     error WrongTickUpperRange();
 29 |     |     error WrongTickLowerOrder();
 30 |     |     error WrongTickUpperOrder();
 31 |     |     error WrongTickClaimedAt();
 32 |     | }
 33 |     | 
 34 |     | abstract contract CoverMiscErrors {
 35 |     |     // to be removed before production
 36 |     |     error NotImplementedYet();
 37 |     | }
 38 |     | 
 39 |     | abstract contract CoverPositionErrors {
 40 |     |     error NotEnoughPositionLiquidity();
 41 |     |     error InvalidClaimTick();
 42 |     | }
 43 |     | 
 44 |     | abstract contract CoverPoolFactoryErrors {
 45 |     |     error OwnerOnly();
 46 |     |     error InvalidTokenAddress();
 47 |     |     error InvalidTokenDecimals();
 48 |     |     error PoolAlreadyExists();
 49 |     |     error FeeTierNotSupported();
 50 |     |     error VolatilityTierNotSupported();
 51 |     |     error InvalidTickSpread();
 52 |     |     error PoolTypeNotFound();
 53 |     |     error CurveMathNotFound();
 54 |     |     error TickSpreadNotMultipleOfTickSpacing();
 55 |     |     error TickSpreadNotAtLeastDoubleTickSpread();
 56 |     | }
 57 |     | 
 58 |     | abstract contract CoverTransferErrors {
 59 |     |     error TransferFailed(address from, address dest);
 60 |     | }
 61 |     | 

/home/ec2-user/git/cover/contracts/utils/CoverPoolManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | import '../interfaces/ICoverPool.sol';
   6 |     | import '../interfaces/ICoverPoolFactory.sol';
   7 |     | import '../interfaces/ICoverPoolManager.sol';
   8 |     | import '../base/events/CoverPoolManagerEvents.sol';
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Defines the actions which can be executed by the factory admin.
  12 |     |  */
  13 |     | contract CoverPoolManager is ICoverPoolManager, CoverPoolManagerEvents {
  14 |     |     address public owner;
  15 |     |     address public feeTo;
  16 |     |     address public factory;
  17 |     |     uint16  public constant MAX_PROTOCOL_FEE = 1e4; /// @dev - max protocol fee of 1%
  18 |     |     uint16  public constant oneSecond = 1000;
  19 |     |     // sourceName => sourceAddress
  20 |     |     mapping(bytes32 => address) internal _twapSources;
  21 |     |     mapping(bytes32 => address) internal _poolTypes;
  22 |     |     // sourceName => feeTier => tickSpread => twapLength => VolatilityTier
  23 |     |     mapping(bytes32 => mapping(uint16 => mapping(int16 => mapping(uint16 => VolatilityTier)))) internal _volatilityTiers;
  24 |     | 
  25 |     |     constructor() {
  26 |     |         owner = msg.sender;
  27 |     |         feeTo = msg.sender;
  28 |     |         emit OwnerTransfer(address(0), msg.sender);
  29 |     |         emit FeeToTransfer(address(0), msg.sender);
  30 |     |     }
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev Throws if called by any account other than the owner.
  34 |     |      */
  35 |     |     modifier onlyOwner() {
  36 |     |         _checkOwner();
  37 |     |         _;
  38 |     |     }
  39 |     | 
  40 |     |     modifier onlyFeeTo() {
  41 |     |         _checkFeeTo();
  42 |     |         _;
  43 |     |     }
  44 |     | 
  45 |     |     /**
  46 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
  47 |     |      * Can only be called by the current owner.
  48 |     |      */
  49 |     |     function transferOwner(address newOwner) public virtual onlyOwner {
  50 |     |         if(newOwner == address(0)) require (false, 'TransferredToZeroAddress()');
  51 |     |         _transferOwner(newOwner);
  52 |     |     }
  53 |     | 
  54 |     |     function transferFeeTo(address newFeeTo) public virtual onlyFeeTo {
  55 |     |         if(newFeeTo == address(0)) require (false, 'TransferredToZeroAddress()');
  56 |     |         _transferFeeTo(newFeeTo);
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
  61 |     |      * Internal function without access restriction.
  62 |     |      */
  63 |     |     function _transferOwner(address newOwner) internal virtual {
  64 |     |         address oldOwner = owner;
  65 |     |         owner = newOwner;
  66 |     |         emit OwnerTransfer(oldOwner, newOwner);
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Transfers fee collection to a new account (`newFeeTo`).
  71 |     |      * Internal function without access restriction.
  72 |     |      */
  73 |     |     function _transferFeeTo(address newFeeTo) internal virtual {
  74 |     |         address oldFeeTo = feeTo;
  75 |     |         feeTo = newFeeTo;
  76 |     |         emit FeeToTransfer(oldFeeTo, newFeeTo);
  77 |     |     }
  78 |     | 
  79 |     |     function enablePoolType(
  80 |     |         bytes32 poolType,
  81 |     |         address implAddress,
  82 |     |         address sourceAddress
  83 |     |     ) external onlyOwner {
  84 |     |         if (poolType == bytes32("")) require (false, 'TwapSourceNameInvalid()');
  85 |     |         if (implAddress == address(0) || sourceAddress == address(0)) require (false, 'TwapSourceAddressZero()');
  86 |     |         if (_twapSources[poolType] != address(0)) require (false, 'ImplementationAlreadyExists()');
  87 |     |         if (_poolTypes[poolType] != address(0)) require (false, 'ImplementationAlreadyExists()');
  88 |     |         _poolTypes[poolType] = implAddress;
  89 |     |         _twapSources[poolType] = sourceAddress;
  90 |     |         emit PoolTypeEnabled(poolType, implAddress, sourceAddress, ITwapSource(sourceAddress).factory());
  91 |     |     }
  92 |     | 
  93 |     |     function enableVolatilityTier(
  94 |     |         bytes32 poolType,
  95 |     |         uint16  feeTier,
  96 |     |         int16   tickSpread,
  97 |     |         uint16  twapLength,
  98 |     |         VolatilityTier memory volTier
  99 |     |     ) external onlyOwner {
 100 |     |         if (_volatilityTiers[poolType][feeTier][tickSpread][twapLength].auctionLength != 0) {
 101 |     |             require (false, 'VolatilityTierAlreadyEnabled()');
 102 |     |         } else if (volTier.auctionLength == 0 ||  volTier.minPositionWidth <= 0) {
 103 |     |             require (false, 'VolatilityTierCannotBeZero()');
 104 |     |         } else if (twapLength < 5 * volTier.blockTime / oneSecond) {
 105 |     |             require (false, 'VoltatilityTierTwapTooShort()');
 106 |     |         } else if (volTier.syncFee > 10000 || volTier.fillFee > 10000) {
 107 |     |             require (false, 'ProtocolFeeCeilingExceeded()');
 108 |     |         }
 109 |     |         address sourceAddress = _twapSources[poolType];
 110 |     |         address implAddress = _poolTypes[poolType];
 111 |     |         {
 112 |     |             // check fee tier exists
 113 |     |             if (sourceAddress == address(0)) require (false, 'TwapSourceNotFound()');
 114 |     |             int24 tickSpacing = ITwapSource(sourceAddress).feeTierTickSpacing(feeTier);
 115 |     |             if (tickSpacing == 0) {
 116 |     |                 require (false, 'FeeTierNotSupported()');
 117 |     |             }
 118 |     |             // check tick multiple
 119 |     |             int24 tickMultiple = tickSpread / tickSpacing;
 120 |     |             if (tickMultiple * tickSpacing != tickSpread) {
 121 |     |                 require (false, 'TickSpreadNotMultipleOfTickSpacing()');
 122 |     |             } else if (tickMultiple < 2) {
 123 |     |                 require (false, 'TickSpreadNotAtLeastDoubleTickSpread()');
 124 |     |             }
 125 |     |         }
 126 |     |         // twapLength * blockTime should never overflow uint16
 127 |     |         _volatilityTiers[poolType][feeTier][tickSpread][twapLength] = volTier;
 128 |     | 
 129 |     |         emit VolatilityTierEnabled(
 130 |     |             implAddress,
 131 |     |             feeTier,
 132 |     |             tickSpread,
 133 |     |             twapLength,
 134 |     |             volTier.minAmountPerAuction,
 135 |     |             volTier.auctionLength,
 136 |     |             volTier.blockTime,
 137 |     |             volTier.syncFee,
 138 |     |             volTier.fillFee,
 139 |     |             volTier.minPositionWidth,
 140 |     |             volTier.minAmountLowerPriced
 141 |     |         );
 142 |     |     }
 143 |     | 
 144 |     |     function modifyVolatilityTierFees(
 145 |     |         bytes32 implName,
 146 |     |         uint16 feeTier,
 147 |     |         int16 tickSpread,
 148 |     |         uint16 twapLength,
 149 |     |         uint16 syncFee,
 150 |     |         uint16 fillFee
 151 |     |     ) external onlyOwner {
 152 |     |         if (syncFee > 10000 || fillFee > 10000) {
 153 |     |             require (false, 'ProtocolFeeCeilingExceeded()');
 154 |     |         }
 155 |     |         _volatilityTiers[implName][feeTier][tickSpread][twapLength].syncFee = syncFee;
 156 |     |         _volatilityTiers[implName][feeTier][tickSpread][twapLength].fillFee = fillFee;
 157 |     |     }
 158 |     | 
 159 |     |     function setFactory(
 160 |     |         address factory_
 161 |     |     ) external onlyOwner {
 162 |     |         if (factory != address(0)) require (false, 'FactoryAlreadySet()');
 163 |     |         emit FactoryChanged(factory, factory_);
 164 |     |         factory = factory_;
 165 |     |     }
 166 |     | 
 167 |     |     function collectProtocolFees(
 168 |     |         address[] calldata collectPools
 169 |     |     ) external {
 170 |     |         if (collectPools.length == 0) require (false, 'EmptyPoolsArray()');
 171 |     |         uint128[] memory token0Fees = new uint128[](collectPools.length);
 172 |     |         uint128[] memory token1Fees = new uint128[](collectPools.length);
 173 |     |         for (uint i; i < collectPools.length; i++) {
 174 |     |             (token0Fees[i], token1Fees[i]) = ICoverPool(collectPools[i]).fees(0,0,false);
 175 |     |         }
 176 |     |         emit ProtocolFeesCollected(collectPools, token0Fees, token1Fees);
 177 |     |     }
 178 |     | 
 179 |     |     function modifyProtocolFees(
 180 |     |         address[] calldata modifyPools,
 181 |     |         uint16[] calldata syncFees,
 182 |     |         uint16[] calldata fillFees,
 183 |     |         bool[] calldata setFees
 184 |     |     ) external onlyOwner {
 185 |     |         if (modifyPools.length == 0) require (false, 'EmptyPoolsArray()');
 186 |     |         if (modifyPools.length != syncFees.length
 187 |     |             || syncFees.length != fillFees.length
 188 |     |             || fillFees.length != setFees.length) {
 189 |     |             require (false, 'MismatchedArrayLengths()');
 190 |     |         }
 191 |     |         uint128[] memory token0Fees = new uint128[](modifyPools.length);
 192 |     |         uint128[] memory token1Fees = new uint128[](modifyPools.length);
 193 |     |         for (uint i; i < modifyPools.length; i++) {
 194 |     |             if (syncFees[i] > MAX_PROTOCOL_FEE) require (false, 'ProtocolFeeCeilingExceeded()');
 195 |     |             if (fillFees[i] > MAX_PROTOCOL_FEE) require (false, 'ProtocolFeeCeilingExceeded()');
 196 |     |             (
 197 |     |                 token0Fees[i],
 198 |     |                 token1Fees[i]
 199 |     |             ) =ICoverPool(modifyPools[i]).fees(
 200 |     |                 syncFees[i],
 201 |     |                 fillFees[i],
 202 |     |                 setFees[i]
 203 |     |             );
 204 |     |         }
 205 |     |         emit ProtocolFeesModified(modifyPools, syncFees, fillFees, setFees, token0Fees, token1Fees);
 206 |     |     }
 207 |     | 
 208 |     |     function poolTypes(
 209 |     |         bytes32 poolType
 210 |     |     ) external view returns (
 211 |     |         address implAddress,
 212 |     |         address sourceAddress
 213 |     |     ) {
 214 |     |         return (_poolTypes[poolType], _twapSources[poolType]);
 215 |     |     }
 216 |     | 
 217 |     |     function volatilityTiers(
 218 |     |         bytes32 implName,
 219 |     |         uint16 feeTier,
 220 |     |         int16 tickSpread,
 221 |     |         uint16 twapLength
 222 |     |     ) external view returns (
 223 |     |         VolatilityTier memory config
 224 |     |     ) {
 225 |     |         config = _volatilityTiers[implName][feeTier][tickSpread][twapLength];
 226 |     |     }
 227 |     |     
 228 |     |     /**
 229 |     |      * @dev Throws if the sender is not the owner.
 230 |     |      */
 231 |     |     function _checkOwner() internal view {
 232 |     |         if (owner != msg.sender) require (false, 'OwnerOnly()');
 233 |     |     }
 234 |     | 
 235 |     |     /**
 236 |     |      * @dev Throws if the sender is not the feeTo.
 237 |     |      */
 238 |     |     function _checkFeeTo() internal view {
 239 |     |         if (feeTo != msg.sender) require (false, 'FeeToOnly()');
 240 |     |     }
 241 |     | }

